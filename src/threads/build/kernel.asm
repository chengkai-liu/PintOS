
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 67 00 00 00       	call   c00201c4 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <run_task>:
}

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020182:	56                   	push   %esi
c0020183:	53                   	push   %ebx
c0020184:	83 ec 0c             	sub    $0xc,%esp
c0020187:	e8 af d7 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002018c:	81 c3 40 93 01 00    	add    $0x19340,%ebx
  const char *task = argv[1];
c0020192:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020196:	8b 70 04             	mov    0x4(%eax),%esi
  
  printf ("Executing '%s':\n", task);
c0020199:	56                   	push   %esi
c002019a:	8d 83 7d 55 ff ff    	lea    -0xaa83(%ebx),%eax
c00201a0:	50                   	push   %eax
c00201a1:	e8 52 70 00 00       	call   c00271f8 <printf>
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c00201a6:	89 34 24             	mov    %esi,(%esp)
c00201a9:	e8 db ad 00 00       	call   c002af89 <run_test>
#endif
  printf ("Execution of '%s' complete.\n", task);
c00201ae:	83 c4 08             	add    $0x8,%esp
c00201b1:	56                   	push   %esi
c00201b2:	8d 83 8e 55 ff ff    	lea    -0xaa72(%ebx),%eax
c00201b8:	50                   	push   %eax
c00201b9:	e8 3a 70 00 00       	call   c00271f8 <printf>
}
c00201be:	83 c4 14             	add    $0x14,%esp
c00201c1:	5b                   	pop    %ebx
c00201c2:	5e                   	pop    %esi
c00201c3:	c3                   	ret    

c00201c4 <pintos_init>:
{
c00201c4:	55                   	push   %ebp
c00201c5:	57                   	push   %edi
c00201c6:	56                   	push   %esi
c00201c7:	53                   	push   %ebx
c00201c8:	83 ec 40             	sub    $0x40,%esp
c00201cb:	e8 6b d7 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00201d0:	81 c3 fc 92 01 00    	add    $0x192fc,%ebx
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c00201d6:	c7 c2 98 9b 03 c0    	mov    $0xc0039b98,%edx
c00201dc:	c7 c0 e8 b8 03 c0    	mov    $0xc003b8e8,%eax
c00201e2:	29 d0                	sub    %edx,%eax
c00201e4:	50                   	push   %eax
c00201e5:	6a 00                	push   $0x0
c00201e7:	52                   	push   %edx
c00201e8:	e8 21 83 00 00       	call   c002850e <memset>
  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00201ed:	a1 3a 7d 00 c0       	mov    0xc0007d3a,%eax
c00201f2:	89 44 24 14          	mov    %eax,0x14(%esp)
c00201f6:	89 c5                	mov    %eax,%ebp
  for (i = 0; i < argc; i++) 
c00201f8:	83 c4 10             	add    $0x10,%esp
c00201fb:	bf 00 00 00 00       	mov    $0x0,%edi
  p = ptov (LOADER_ARGS);
c0020200:	be 3e 7d 00 c0       	mov    $0xc0007d3e,%esi
  for (i = 0; i < argc; i++) 
c0020205:	85 c0                	test   %eax,%eax
c0020207:	7f 6a                	jg     c0020273 <pintos_init+0xaf>
  argv[argc] = NULL;
c0020209:	8b 44 24 04          	mov    0x4(%esp),%eax
c002020d:	c7 84 83 d4 06 00 00 	movl   $0x0,0x6d4(%ebx,%eax,4)
c0020214:	00 00 00 00 
  printf ("Kernel command line:");
c0020218:	83 ec 0c             	sub    $0xc,%esp
c002021b:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c0020221:	50                   	push   %eax
c0020222:	e8 d1 6f 00 00       	call   c00271f8 <printf>
c0020227:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c002022a:	83 ec 0c             	sub    $0xc,%esp
c002022d:	6a 0a                	push   $0xa
c002022f:	e8 f1 ac 00 00       	call   c002af25 <putchar>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020234:	8b 83 d4 06 00 00    	mov    0x6d4(%ebx),%eax
c002023a:	83 c4 10             	add    $0x10,%esp
c002023d:	85 c0                	test   %eax,%eax
c002023f:	0f 84 3f 02 00 00    	je     c0020484 <pintos_init+0x2c0>
c0020245:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020248:	0f 85 d5 02 00 00    	jne    c0020523 <pintos_init+0x35f>
c002024e:	8d ab d4 06 00 00    	lea    0x6d4(%ebx),%ebp
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020254:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
c0020258:	89 4c 24 08          	mov    %ecx,0x8(%esp)
        thread_mlfqs = true;
c002025c:	c7 c1 e0 b8 03 c0    	mov    $0xc003b8e0,%ecx
c0020262:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0020266:	e9 06 01 00 00       	jmp    c0020371 <pintos_init+0x1ad>
      if (p >= end)
c002026b:	81 fe bd 7d 00 c0    	cmp    $0xc0007dbd,%esi
c0020271:	77 66                	ja     c00202d9 <pintos_init+0x115>
      argv[i] = p;
c0020273:	89 b4 bb d4 06 00 00 	mov    %esi,0x6d4(%ebx,%edi,4)
      p += strnlen (p, end - p) + 1;
c002027a:	83 ec 08             	sub    $0x8,%esp
c002027d:	b8 be 7d 00 c0       	mov    $0xc0007dbe,%eax
c0020282:	29 f0                	sub    %esi,%eax
c0020284:	50                   	push   %eax
c0020285:	56                   	push   %esi
c0020286:	e8 2c 83 00 00       	call   c00285b7 <strnlen>
c002028b:	8d 74 06 01          	lea    0x1(%esi,%eax,1),%esi
  for (i = 0; i < argc; i++) 
c002028f:	83 c7 01             	add    $0x1,%edi
c0020292:	83 c4 10             	add    $0x10,%esp
c0020295:	39 fd                	cmp    %edi,%ebp
c0020297:	75 d2                	jne    c002026b <pintos_init+0xa7>
  argv[argc] = NULL;
c0020299:	8d ab d4 06 00 00    	lea    0x6d4(%ebx),%ebp
c002029f:	c7 44 bd 00 00 00 00 	movl   $0x0,0x0(%ebp,%edi,4)
c00202a6:	00 
  printf ("Kernel command line:");
c00202a7:	83 ec 0c             	sub    $0xc,%esp
c00202aa:	8d 83 53 56 ff ff    	lea    -0xa9ad(%ebx),%eax
c00202b0:	50                   	push   %eax
c00202b1:	e8 42 6f 00 00       	call   c00271f8 <printf>
c00202b6:	89 ee                	mov    %ebp,%esi
c00202b8:	8b 44 24 14          	mov    0x14(%esp),%eax
c00202bc:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
c00202c0:	83 c4 10             	add    $0x10,%esp
      printf (" '%s'", argv[i]);
c00202c3:	8d 83 c0 55 ff ff    	lea    -0xaa40(%ebx),%eax
c00202c9:	89 44 24 04          	mov    %eax,0x4(%esp)
      printf (" %s", argv[i]);
c00202cd:	8d 83 8b 63 ff ff    	lea    -0x9c75(%ebx),%eax
c00202d3:	89 44 24 08          	mov    %eax,0x8(%esp)
c00202d7:	eb 3a                	jmp    c0020313 <pintos_init+0x14f>
        PANIC ("command line arguments overflow");
c00202d9:	8d 83 68 56 ff ff    	lea    -0xa998(%ebx),%eax
c00202df:	50                   	push   %eax
c00202e0:	8d 83 c4 44 ff ff    	lea    -0xbb3c(%ebx),%eax
c00202e6:	50                   	push   %eax
c00202e7:	68 d3 00 00 00       	push   $0xd3
c00202ec:	8d 83 ab 55 ff ff    	lea    -0xaa55(%ebx),%eax
c00202f2:	50                   	push   %eax
c00202f3:	e8 97 8c 00 00       	call   c0028f8f <debug_panic>
      printf (" %s", argv[i]);
c00202f8:	83 ec 08             	sub    $0x8,%esp
c00202fb:	57                   	push   %edi
c00202fc:	ff 74 24 14          	pushl  0x14(%esp)
c0020300:	e8 f3 6e 00 00       	call   c00271f8 <printf>
c0020305:	83 c4 10             	add    $0x10,%esp
c0020308:	83 c6 04             	add    $0x4,%esi
  for (i = 0; i < argc; i++)
c002030b:	39 ee                	cmp    %ebp,%esi
c002030d:	0f 84 17 ff ff ff    	je     c002022a <pintos_init+0x66>
    if (strchr (argv[i], ' ') == NULL)
c0020313:	8b 3e                	mov    (%esi),%edi
c0020315:	83 ec 08             	sub    $0x8,%esp
c0020318:	6a 20                	push   $0x20
c002031a:	57                   	push   %edi
c002031b:	e8 a0 7f 00 00       	call   c00282c0 <strchr>
c0020320:	83 c4 10             	add    $0x10,%esp
c0020323:	85 c0                	test   %eax,%eax
c0020325:	74 d1                	je     c00202f8 <pintos_init+0x134>
      printf (" '%s'", argv[i]);
c0020327:	83 ec 08             	sub    $0x8,%esp
c002032a:	57                   	push   %edi
c002032b:	ff 74 24 10          	pushl  0x10(%esp)
c002032f:	e8 c4 6e 00 00       	call   c00271f8 <printf>
c0020334:	83 c4 10             	add    $0x10,%esp
c0020337:	eb cf                	jmp    c0020308 <pintos_init+0x144>
/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020339:	83 ec 0c             	sub    $0xc,%esp
c002033c:	8d 83 88 56 ff ff    	lea    -0xa978(%ebx),%eax
c0020342:	50                   	push   %eax
c0020343:	e8 6b ab 00 00       	call   c002aeb3 <puts>
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020348:	e8 0f 67 00 00       	call   c0026a5c <shutdown_power_off>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c002034d:	83 ec 0c             	sub    $0xc,%esp
c0020350:	6a 01                	push   $0x1
c0020352:	e8 74 66 00 00       	call   c00269cb <shutdown_configure>
c0020357:	83 c4 10             	add    $0x10,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c002035a:	83 c5 04             	add    $0x4,%ebp
c002035d:	8b 45 00             	mov    0x0(%ebp),%eax
c0020360:	85 c0                	test   %eax,%eax
c0020362:	0f 84 22 01 00 00    	je     c002048a <pintos_init+0x2c6>
c0020368:	80 38 2d             	cmpb   $0x2d,(%eax)
c002036b:	0f 85 19 01 00 00    	jne    c002048a <pintos_init+0x2c6>
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020371:	83 ec 04             	sub    $0x4,%esp
c0020374:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0020378:	57                   	push   %edi
c0020379:	8d 93 1d 62 ff ff    	lea    -0x9de3(%ebx),%edx
c002037f:	52                   	push   %edx
c0020380:	50                   	push   %eax
c0020381:	e8 54 80 00 00       	call   c00283da <strtok_r>
c0020386:	89 c6                	mov    %eax,%esi
c0020388:	89 44 24 14          	mov    %eax,0x14(%esp)
      char *value = strtok_r (NULL, "", &save_ptr);
c002038c:	83 c4 0c             	add    $0xc,%esp
c002038f:	57                   	push   %edi
c0020390:	8d 83 2f 62 ff ff    	lea    -0x9dd1(%ebx),%eax
c0020396:	50                   	push   %eax
c0020397:	6a 00                	push   $0x0
c0020399:	e8 3c 80 00 00       	call   c00283da <strtok_r>
      if (!strcmp (name, "-h"))
c002039e:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203a3:	8d bb c6 55 ff ff    	lea    -0xaa3a(%ebx),%edi
c00203a9:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203ab:	0f 97 c2             	seta   %dl
c00203ae:	80 da 00             	sbb    $0x0,%dl
c00203b1:	83 c4 10             	add    $0x10,%esp
c00203b4:	84 d2                	test   %dl,%dl
c00203b6:	74 81                	je     c0020339 <pintos_init+0x175>
      else if (!strcmp (name, "-q"))
c00203b8:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203bd:	8d bb c9 55 ff ff    	lea    -0xaa37(%ebx),%edi
c00203c3:	8b 74 24 04          	mov    0x4(%esp),%esi
c00203c7:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203c9:	0f 97 c2             	seta   %dl
c00203cc:	80 da 00             	sbb    $0x0,%dl
c00203cf:	84 d2                	test   %dl,%dl
c00203d1:	0f 84 76 ff ff ff    	je     c002034d <pintos_init+0x189>
      else if (!strcmp (name, "-r"))
c00203d7:	b9 03 00 00 00       	mov    $0x3,%ecx
c00203dc:	8d bb cc 55 ff ff    	lea    -0xaa34(%ebx),%edi
c00203e2:	8b 74 24 04          	mov    0x4(%esp),%esi
c00203e6:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00203e8:	0f 97 c2             	seta   %dl
c00203eb:	80 da 00             	sbb    $0x0,%dl
c00203ee:	84 d2                	test   %dl,%dl
c00203f0:	74 41                	je     c0020433 <pintos_init+0x26f>
      else if (!strcmp (name, "-rs"))
c00203f2:	b9 04 00 00 00       	mov    $0x4,%ecx
c00203f7:	8d bb cf 55 ff ff    	lea    -0xaa31(%ebx),%edi
c00203fd:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020401:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020403:	0f 97 c2             	seta   %dl
c0020406:	80 da 00             	sbb    $0x0,%dl
c0020409:	84 d2                	test   %dl,%dl
c002040b:	74 38                	je     c0020445 <pintos_init+0x281>
      else if (!strcmp (name, "-mlfqs"))
c002040d:	b9 07 00 00 00       	mov    $0x7,%ecx
c0020412:	8d bb d3 55 ff ff    	lea    -0xaa2d(%ebx),%edi
c0020418:	8b 74 24 04          	mov    0x4(%esp),%esi
c002041c:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002041e:	0f 97 c0             	seta   %al
c0020421:	1c 00                	sbb    $0x0,%al
c0020423:	84 c0                	test   %al,%al
c0020425:	75 37                	jne    c002045e <pintos_init+0x29a>
        thread_mlfqs = true;
c0020427:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002042b:	c6 00 01             	movb   $0x1,(%eax)
c002042e:	e9 27 ff ff ff       	jmp    c002035a <pintos_init+0x196>
        shutdown_configure (SHUTDOWN_REBOOT);
c0020433:	83 ec 0c             	sub    $0xc,%esp
c0020436:	6a 02                	push   $0x2
c0020438:	e8 8e 65 00 00       	call   c00269cb <shutdown_configure>
c002043d:	83 c4 10             	add    $0x10,%esp
c0020440:	e9 15 ff ff ff       	jmp    c002035a <pintos_init+0x196>
        random_init (atoi (value));
c0020445:	83 ec 0c             	sub    $0xc,%esp
c0020448:	50                   	push   %eax
c0020449:	e8 8b 7a 00 00       	call   c0027ed9 <atoi>
c002044e:	89 04 24             	mov    %eax,(%esp)
c0020451:	e8 1e 68 00 00       	call   c0026c74 <random_init>
c0020456:	83 c4 10             	add    $0x10,%esp
c0020459:	e9 fc fe ff ff       	jmp    c002035a <pintos_init+0x196>
        PANIC ("unknown option `%s' (use -h for help)", name);
c002045e:	83 ec 0c             	sub    $0xc,%esp
c0020461:	ff 74 24 10          	pushl  0x10(%esp)
c0020465:	8d 83 58 58 ff ff    	lea    -0xa7a8(%ebx),%eax
c002046b:	50                   	push   %eax
c002046c:	8d 83 b4 44 ff ff    	lea    -0xbb4c(%ebx),%eax
c0020472:	50                   	push   %eax
c0020473:	68 0c 01 00 00       	push   $0x10c
c0020478:	8d 83 ab 55 ff ff    	lea    -0xaa55(%ebx),%eax
c002047e:	50                   	push   %eax
c002047f:	e8 0b 8b 00 00       	call   c0028f8f <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020484:	8d ab d4 06 00 00    	lea    0x6d4(%ebx),%ebp
  random_init (rtc_get_time ());
c002048a:	e8 c6 63 00 00       	call   c0026855 <rtc_get_time>
c002048f:	83 ec 0c             	sub    $0xc,%esp
c0020492:	50                   	push   %eax
c0020493:	e8 dc 67 00 00       	call   c0026c74 <random_init>
  thread_init ();
c0020498:	e8 12 05 00 00       	call   c00209af <thread_init>
  console_init ();  
c002049d:	e8 69 a9 00 00       	call   c002ae0b <console_init>
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00204a2:	83 c4 08             	add    $0x8,%esp
          init_ram_pages * PGSIZE / 1024);
c00204a5:	c7 c6 7e 01 02 c0    	mov    $0xc002017e,%esi
c00204ab:	8b 06                	mov    (%esi),%eax
c00204ad:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00204b0:	c1 e8 0a             	shr    $0xa,%eax
c00204b3:	50                   	push   %eax
c00204b4:	8d 83 80 58 ff ff    	lea    -0xa780(%ebx),%eax
c00204ba:	50                   	push   %eax
c00204bb:	e8 38 6d 00 00       	call   c00271f8 <printf>
  palloc_init (user_page_limit);
c00204c0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c00204c7:	e8 00 32 00 00       	call   c00236cc <palloc_init>
  malloc_init ();
c00204cc:	e8 7c 36 00 00       	call   c0023b4d <malloc_init>
  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00204d1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c00204d8:	e8 4c 33 00 00       	call   c0023829 <palloc_get_page>
c00204dd:	89 c1                	mov    %eax,%ecx
c00204df:	89 44 24 20          	mov    %eax,0x20(%esp)
c00204e3:	c7 c0 d8 b8 03 c0    	mov    $0xc003b8d8,%eax
c00204e9:	89 08                	mov    %ecx,(%eax)
  for (page = 0; page < init_ram_pages; page++)
c00204eb:	83 c4 10             	add    $0x10,%esp
c00204ee:	83 3e 00             	cmpl   $0x0,(%esi)
c00204f1:	0f 84 6f 01 00 00    	je     c0020666 <pintos_init+0x4a2>
c00204f7:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
  pt = NULL;
c00204fc:	b8 00 00 00 00       	mov    $0x0,%eax
  for (page = 0; page < init_ram_pages; page++)
c0020501:	be 00 00 00 00       	mov    $0x0,%esi
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020506:	c7 c1 00 20 03 c0    	mov    $0xc0032000,%ecx
c002050c:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c0020510:	c7 c1 00 00 02 c0    	mov    $0xc0020000,%ecx
c0020516:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c002051a:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c002051e:	e9 a6 00 00 00       	jmp    c00205c9 <pintos_init+0x405>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020523:	8d ab d4 06 00 00    	lea    0x6d4(%ebx),%ebp
c0020529:	e9 5c ff ff ff       	jmp    c002048a <pintos_init+0x2c6>
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
  ASSERT (pg_ofs (pt) == 0);
c002052e:	83 ec 0c             	sub    $0xc,%esp
c0020531:	8d 83 da 55 ff ff    	lea    -0xaa26(%ebx),%eax
c0020537:	50                   	push   %eax
c0020538:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002053e:	50                   	push   %eax
c002053f:	8d 83 a8 44 ff ff    	lea    -0xbb58(%ebx),%eax
c0020545:	50                   	push   %eax
c0020546:	6a 48                	push   $0x48
c0020548:	8d 83 02 56 ff ff    	lea    -0xa9fe(%ebx),%eax
c002054e:	50                   	push   %eax
c002054f:	e8 3b 8a 00 00       	call   c0028f8f <debug_panic>
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
  ASSERT (is_kernel_vaddr (vaddr));
c0020554:	83 ec 0c             	sub    $0xc,%esp
c0020557:	8d 83 16 56 ff ff    	lea    -0xa9ea(%ebx),%eax
c002055d:	50                   	push   %eax
c002055e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020564:	50                   	push   %eax
c0020565:	8d 83 a0 44 ff ff    	lea    -0xbb60(%ebx),%eax
c002056b:	50                   	push   %eax
c002056c:	6a 54                	push   $0x54
c002056e:	8d 83 2e 56 ff ff    	lea    -0xa9d2(%ebx),%eax
c0020574:	50                   	push   %eax
c0020575:	e8 15 8a 00 00       	call   c0028f8f <debug_panic>
      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c002057a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002057e:	8d 0c 88             	lea    (%eax,%ecx,4),%ecx
c0020581:	81 7c 24 0c ff ff ff 	cmpl   $0xbfffffff,0xc(%esp)
c0020588:	bf 
c0020589:	0f 86 ad 00 00 00    	jbe    c002063c <pintos_init+0x478>
c002058f:	89 f2                	mov    %esi,%edx
c0020591:	c1 e2 0c             	shl    $0xc,%edx
c0020594:	89 54 24 08          	mov    %edx,0x8(%esp)
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
  ASSERT (pg_ofs (page) == 0);
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c0020598:	0f b6 6c 24 04       	movzbl 0x4(%esp),%ebp
c002059d:	83 f5 01             	xor    $0x1,%ebp
c00205a0:	89 ea                	mov    %ebp,%edx
c00205a2:	0f b6 ea             	movzbl %dl,%ebp
c00205a5:	01 ed                	add    %ebp,%ebp
c00205a7:	8b 54 24 08          	mov    0x8(%esp),%edx
c00205ab:	83 ca 01             	or     $0x1,%edx
c00205ae:	09 ea                	or     %ebp,%edx
c00205b0:	89 11                	mov    %edx,(%ecx)
  for (page = 0; page < init_ram_pages; page++)
c00205b2:	83 c6 01             	add    $0x1,%esi
c00205b5:	81 c7 00 10 00 00    	add    $0x1000,%edi
c00205bb:	c7 c2 7e 01 02 c0    	mov    $0xc002017e,%edx
c00205c1:	3b 32                	cmp    (%edx),%esi
c00205c3:	0f 83 99 00 00 00    	jae    c0020662 <pintos_init+0x49e>
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00205c9:	89 fa                	mov    %edi,%edx
c00205cb:	c1 ea 0c             	shr    $0xc,%edx
c00205ce:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c00205d4:	89 54 24 08          	mov    %edx,0x8(%esp)
c00205d8:	89 7c 24 0c          	mov    %edi,0xc(%esp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00205dc:	3b 7c 24 14          	cmp    0x14(%esp),%edi
c00205e0:	0f 92 c1             	setb   %cl
c00205e3:	3b 7c 24 18          	cmp    0x18(%esp),%edi
c00205e7:	0f 93 c2             	setae  %dl
c00205ea:	21 d1                	and    %edx,%ecx
c00205ec:	88 4c 24 04          	mov    %cl,0x4(%esp)
  return (uintptr_t) va >> PDSHIFT;
c00205f0:	89 fa                	mov    %edi,%edx
c00205f2:	c1 ea 16             	shr    $0x16,%edx
      if (pd[pde_idx] == 0)
c00205f5:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00205f9:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c00205fc:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c0020600:	0f 85 74 ff ff ff    	jne    c002057a <pintos_init+0x3b6>
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020606:	83 ec 0c             	sub    $0xc,%esp
c0020609:	6a 03                	push   $0x3
c002060b:	e8 19 32 00 00       	call   c0023829 <palloc_get_page>
  return (uintptr_t) va & PGMASK;
c0020610:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c0020612:	83 c4 10             	add    $0x10,%esp
c0020615:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002061a:	0f 85 0e ff ff ff    	jne    c002052e <pintos_init+0x36a>
  ASSERT (is_kernel_vaddr (vaddr));
c0020620:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020625:	0f 86 29 ff ff ff    	jbe    c0020554 <pintos_init+0x390>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002062b:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020631:	83 ca 07             	or     $0x7,%edx
c0020634:	89 55 00             	mov    %edx,0x0(%ebp)
c0020637:	e9 3e ff ff ff       	jmp    c002057a <pintos_init+0x3b6>
  ASSERT (is_kernel_vaddr (vaddr));
c002063c:	83 ec 0c             	sub    $0xc,%esp
c002063f:	8d 83 16 56 ff ff    	lea    -0xa9ea(%ebx),%eax
c0020645:	50                   	push   %eax
c0020646:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002064c:	50                   	push   %eax
c002064d:	8d 83 a0 44 ff ff    	lea    -0xbb60(%ebx),%eax
c0020653:	50                   	push   %eax
c0020654:	6a 54                	push   $0x54
c0020656:	8d 83 2e 56 ff ff    	lea    -0xa9d2(%ebx),%eax
c002065c:	50                   	push   %eax
c002065d:	e8 2d 89 00 00       	call   c0028f8f <debug_panic>
c0020662:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c0020666:	c7 c0 d8 b8 03 c0    	mov    $0xc003b8d8,%eax
c002066c:	8b 00                	mov    (%eax),%eax
c002066e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020673:	76 5c                	jbe    c00206d1 <pintos_init+0x50d>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020675:	05 00 00 00 40       	add    $0x40000000,%eax
c002067a:	0f 22 d8             	mov    %eax,%cr3
  intr_init ();
c002067d:	e8 e5 14 00 00       	call   c0021b67 <intr_init>
  timer_init ();
c0020682:	e8 b5 3b 00 00       	call   c002423c <timer_init>
  kbd_init ();
c0020687:	e8 2d 41 00 00       	call   c00247b9 <kbd_init>
  input_init ();
c002068c:	e8 57 5c 00 00       	call   c00262e8 <input_init>
  thread_start ();
c0020691:	e8 33 0c 00 00       	call   c00212c9 <thread_start>
  serial_init_queue ();
c0020696:	e8 c8 45 00 00       	call   c0024c63 <serial_init_queue>
  timer_calibrate ();
c002069b:	e8 d3 3b 00 00       	call   c0024273 <timer_calibrate>
  printf ("Boot complete.\n");
c00206a0:	83 ec 0c             	sub    $0xc,%esp
c00206a3:	8d 83 44 56 ff ff    	lea    -0xa9bc(%ebx),%eax
c00206a9:	50                   	push   %eax
c00206aa:	e8 04 a8 00 00       	call   c002aeb3 <puts>
  if (*argv != NULL) {
c00206af:	8b 7d 00             	mov    0x0(%ebp),%edi
c00206b2:	83 c4 10             	add    $0x10,%esp
        if (a->name == NULL)
c00206b5:	8d 83 ba 5b ff ff    	lea    -0xa446(%ebx),%eax
c00206bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  if (*argv != NULL) {
c00206bf:	85 ff                	test   %edi,%edi
c00206c1:	0f 85 94 00 00 00    	jne    c002075b <pintos_init+0x597>
  shutdown ();
c00206c7:	e8 29 64 00 00       	call   c0026af5 <shutdown>
  thread_exit ();
c00206cc:	e8 21 09 00 00       	call   c0020ff2 <thread_exit>
  ASSERT (is_kernel_vaddr (vaddr));
c00206d1:	83 ec 0c             	sub    $0xc,%esp
c00206d4:	8d 83 16 56 ff ff    	lea    -0xa9ea(%ebx),%eax
c00206da:	50                   	push   %eax
c00206db:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00206e1:	50                   	push   %eax
c00206e2:	8d 83 a0 44 ff ff    	lea    -0xbb60(%ebx),%eax
c00206e8:	50                   	push   %eax
c00206e9:	6a 54                	push   $0x54
c00206eb:	8d 83 2e 56 ff ff    	lea    -0xa9d2(%ebx),%eax
c00206f1:	50                   	push   %eax
c00206f2:	e8 98 88 00 00       	call   c0028f8f <debug_panic>
      for (i = 1; i < a->argc; i++)
c00206f7:	8b 56 04             	mov    0x4(%esi),%edx
c00206fa:	83 fa 01             	cmp    $0x1,%edx
c00206fd:	7e 40                	jle    c002073f <pintos_init+0x57b>
        if (argv[i] == NULL)
c00206ff:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0020703:	74 13                	je     c0020718 <pintos_init+0x554>
      for (i = 1; i < a->argc; i++)
c0020705:	b8 01 00 00 00       	mov    $0x1,%eax
c002070a:	83 c0 01             	add    $0x1,%eax
c002070d:	39 c2                	cmp    %eax,%edx
c002070f:	74 2e                	je     c002073f <pintos_init+0x57b>
        if (argv[i] == NULL)
c0020711:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c0020716:	75 f2                	jne    c002070a <pintos_init+0x546>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020718:	83 ec 08             	sub    $0x8,%esp
c002071b:	83 ea 01             	sub    $0x1,%edx
c002071e:	52                   	push   %edx
c002071f:	57                   	push   %edi
c0020720:	8d 83 cc 58 ff ff    	lea    -0xa734(%ebx),%eax
c0020726:	50                   	push   %eax
c0020727:	8d 83 94 44 ff ff    	lea    -0xbb6c(%ebx),%eax
c002072d:	50                   	push   %eax
c002072e:	68 55 01 00 00       	push   $0x155
c0020733:	8d 83 ab 55 ff ff    	lea    -0xaa55(%ebx),%eax
c0020739:	50                   	push   %eax
c002073a:	e8 50 88 00 00       	call   c0028f8f <debug_panic>
      a->function (argv);
c002073f:	83 ec 0c             	sub    $0xc,%esp
c0020742:	55                   	push   %ebp
c0020743:	ff 56 08             	call   *0x8(%esi)
      argv += a->argc;
c0020746:	8b 46 04             	mov    0x4(%esi),%eax
c0020749:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
  while (*argv != NULL)
c002074d:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020750:	83 c4 10             	add    $0x10,%esp
c0020753:	85 ff                	test   %edi,%edi
c0020755:	0f 84 6c ff ff ff    	je     c00206c7 <pintos_init+0x503>
        if (a->name == NULL)
c002075b:	8b 44 24 04          	mov    0x4(%esp),%eax
      for (a = actions; ; a++)
c002075f:	8d b3 14 00 00 00    	lea    0x14(%ebx),%esi
        else if (!strcmp (*argv, a->name))
c0020765:	83 ec 08             	sub    $0x8,%esp
c0020768:	50                   	push   %eax
c0020769:	57                   	push   %edi
c002076a:	e8 e5 7a 00 00       	call   c0028254 <strcmp>
c002076f:	83 c4 10             	add    $0x10,%esp
c0020772:	85 c0                	test   %eax,%eax
c0020774:	74 81                	je     c00206f7 <pintos_init+0x533>
      for (a = actions; ; a++)
c0020776:	83 c6 0c             	add    $0xc,%esi
        if (a->name == NULL)
c0020779:	8b 06                	mov    (%esi),%eax
c002077b:	85 c0                	test   %eax,%eax
c002077d:	75 e6                	jne    c0020765 <pintos_init+0x5a1>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c002077f:	83 ec 0c             	sub    $0xc,%esp
c0020782:	57                   	push   %edi
c0020783:	8d 83 a4 58 ff ff    	lea    -0xa75c(%ebx),%eax
c0020789:	50                   	push   %eax
c002078a:	8d 83 94 44 ff ff    	lea    -0xbb6c(%ebx),%eax
c0020790:	50                   	push   %eax
c0020791:	68 4e 01 00 00       	push   $0x14e
c0020796:	8d 83 ab 55 ff ff    	lea    -0xaa55(%ebx),%eax
c002079c:	50                   	push   %eax
c002079d:	e8 ed 87 00 00       	call   c0028f8f <debug_panic>

c00207a2 <thread_cmp_priority>:
        thread_unblock(t);
  }
}

bool thread_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {
  return list_entry(a, struct thread, elem)->priority > list_entry(b, struct thread, elem)->priority;
c00207a2:	8b 54 24 04          	mov    0x4(%esp),%edx
c00207a6:	8b 44 24 08          	mov    0x8(%esp),%eax
c00207aa:	8b 40 f4             	mov    -0xc(%eax),%eax
c00207ad:	39 42 f4             	cmp    %eax,-0xc(%edx)
c00207b0:	0f 9f c0             	setg   %al
}
c00207b3:	c3                   	ret    

c00207b4 <alloc_frame>:
{
c00207b4:	53                   	push   %ebx
c00207b5:	83 ec 08             	sub    $0x8,%esp
c00207b8:	e8 7e d1 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00207bd:	81 c3 0f 8d 01 00    	add    $0x18d0f,%ebx
  return t != NULL && t->magic == THREAD_MAGIC;
c00207c3:	85 c0                	test   %eax,%eax
c00207c5:	74 09                	je     c00207d0 <alloc_frame+0x1c>
c00207c7:	81 78 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%eax)
c00207ce:	74 52                	je     c0020822 <alloc_frame+0x6e>
  ASSERT (is_thread (t));
c00207d0:	83 ec 0c             	sub    $0xc,%esp
c00207d3:	8d 83 25 59 ff ff    	lea    -0xa6db(%ebx),%eax
c00207d9:	50                   	push   %eax
c00207da:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00207e0:	50                   	push   %eax
c00207e1:	8d 83 fc 45 ff ff    	lea    -0xba04(%ebx),%eax
c00207e7:	50                   	push   %eax
c00207e8:	68 47 02 00 00       	push   $0x247
c00207ed:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c00207f3:	50                   	push   %eax
c00207f4:	e8 96 87 00 00       	call   c0028f8f <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00207f9:	83 ec 0c             	sub    $0xc,%esp
c00207fc:	8d 83 f0 58 ff ff    	lea    -0xa710(%ebx),%eax
c0020802:	50                   	push   %eax
c0020803:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020809:	50                   	push   %eax
c002080a:	8d 83 fc 45 ff ff    	lea    -0xba04(%ebx),%eax
c0020810:	50                   	push   %eax
c0020811:	68 48 02 00 00       	push   $0x248
c0020816:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c002081c:	50                   	push   %eax
c002081d:	e8 6d 87 00 00       	call   c0028f8f <debug_panic>
c0020822:	f6 c2 03             	test   $0x3,%dl
c0020825:	75 d2                	jne    c00207f9 <alloc_frame+0x45>
  t->stack -= size;
c0020827:	8b 48 18             	mov    0x18(%eax),%ecx
c002082a:	29 d1                	sub    %edx,%ecx
c002082c:	89 48 18             	mov    %ecx,0x18(%eax)
}
c002082f:	89 c8                	mov    %ecx,%eax
c0020831:	83 c4 08             	add    $0x8,%esp
c0020834:	5b                   	pop    %ebx
c0020835:	c3                   	ret    

c0020836 <init_thread>:
{
c0020836:	55                   	push   %ebp
c0020837:	57                   	push   %edi
c0020838:	56                   	push   %esi
c0020839:	53                   	push   %ebx
c002083a:	83 ec 0c             	sub    $0xc,%esp
c002083d:	e8 f9 d0 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020842:	81 c3 8a 8c 01 00    	add    $0x18c8a,%ebx
  ASSERT (t != NULL);
c0020848:	85 c0                	test   %eax,%eax
c002084a:	0f 84 e4 00 00 00    	je     c0020934 <init_thread+0xfe>
c0020850:	89 c6                	mov    %eax,%esi
c0020852:	89 cd                	mov    %ecx,%ebp
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020854:	83 f9 3f             	cmp    $0x3f,%ecx
c0020857:	0f 87 00 01 00 00    	ja     c002095d <init_thread+0x127>
  ASSERT (name != NULL);
c002085d:	85 d2                	test   %edx,%edx
c002085f:	0f 84 21 01 00 00    	je     c0020986 <init_thread+0x150>
  memset (t, 0, sizeof *t);
c0020865:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c002086b:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
c0020872:	00 00 00 
c0020875:	8d 78 04             	lea    0x4(%eax),%edi
c0020878:	83 e7 fc             	and    $0xfffffffc,%edi
c002087b:	89 c1                	mov    %eax,%ecx
c002087d:	29 f9                	sub    %edi,%ecx
c002087f:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
c0020885:	c1 e9 02             	shr    $0x2,%ecx
c0020888:	b8 00 00 00 00       	mov    $0x0,%eax
c002088d:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c002088f:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
  strlcpy (t->name, name, sizeof t->name);
c0020896:	83 ec 04             	sub    $0x4,%esp
c0020899:	6a 10                	push   $0x10
c002089b:	52                   	push   %edx
c002089c:	8d 46 08             	lea    0x8(%esi),%eax
c002089f:	50                   	push   %eax
c00208a0:	e8 3f 7d 00 00       	call   c00285e4 <strlcpy>
  t->stack = (uint8_t *) t + PGSIZE;
c00208a5:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
c00208ab:	89 46 18             	mov    %eax,0x18(%esi)
  t->priority = priority;
c00208ae:	89 6e 1c             	mov    %ebp,0x1c(%esi)
  t->base_priority = priority;
c00208b1:	89 6e 3c             	mov    %ebp,0x3c(%esi)
  list_init(&t->locks);
c00208b4:	8d 46 40             	lea    0x40(%esi),%eax
c00208b7:	89 04 24             	mov    %eax,(%esp)
c00208ba:	e8 9d 87 00 00       	call   c002905c <list_init>
  t->lock_waiting = NULL;
c00208bf:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
  t->nice = 0;
c00208c6:	c7 46 54 00 00 00 00 	movl   $0x0,0x54(%esi)
  t->recent_cpu = FP_CONST(0);
c00208cd:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
  t->magic = THREAD_MAGIC;
c00208d4:	c7 46 30 4b bf 6a cd 	movl   $0xcd6abf4b,0x30(%esi)
  t->return_value = 0;
c00208db:	c7 46 5c 00 00 00 00 	movl   $0x0,0x5c(%esi)
  t->grandpa_died = false;
c00208e2:	c6 86 98 00 00 00 00 	movb   $0x0,0x98(%esi)
  list_init (&t->child_list);
c00208e9:	8d 46 60             	lea    0x60(%esi),%eax
c00208ec:	89 04 24             	mov    %eax,(%esp)
c00208ef:	e8 68 87 00 00       	call   c002905c <list_init>
  sema_init (&t->sema_finished, 0);
c00208f4:	83 c4 08             	add    $0x8,%esp
c00208f7:	6a 00                	push   $0x0
c00208f9:	8d 46 70             	lea    0x70(%esi),%eax
c00208fc:	50                   	push   %eax
c00208fd:	e8 b9 23 00 00       	call   c0022cbb <sema_init>
  sema_init (&t->sema_started, 0);
c0020902:	83 c4 08             	add    $0x8,%esp
c0020905:	6a 00                	push   $0x0
c0020907:	8d 86 84 00 00 00    	lea    0x84(%esi),%eax
c002090d:	50                   	push   %eax
c002090e:	e8 a8 23 00 00       	call   c0022cbb <sema_init>
  list_insert_ordered(&all_list, &t->allelem, (list_less_func *) &thread_cmp_priority, NULL);
c0020913:	6a 00                	push   $0x0
c0020915:	8d 83 d6 72 fe ff    	lea    -0x18d2a(%ebx),%eax
c002091b:	50                   	push   %eax
c002091c:	83 c6 20             	add    $0x20,%esi
c002091f:	56                   	push   %esi
c0020920:	8d 83 40 08 00 00    	lea    0x840(%ebx),%eax
c0020926:	50                   	push   %eax
c0020927:	e8 28 92 00 00       	call   c0029b54 <list_insert_ordered>
}
c002092c:	83 c4 2c             	add    $0x2c,%esp
c002092f:	5b                   	pop    %ebx
c0020930:	5e                   	pop    %esi
c0020931:	5f                   	pop    %edi
c0020932:	5d                   	pop    %ebp
c0020933:	c3                   	ret    
  ASSERT (t != NULL);
c0020934:	83 ec 0c             	sub    $0xc,%esp
c0020937:	8d 83 e7 6d ff ff    	lea    -0x9219(%ebx),%eax
c002093d:	50                   	push   %eax
c002093e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020944:	50                   	push   %eax
c0020945:	8d 83 28 46 ff ff    	lea    -0xb9d8(%ebx),%eax
c002094b:	50                   	push   %eax
c002094c:	68 1f 02 00 00       	push   $0x21f
c0020951:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020957:	50                   	push   %eax
c0020958:	e8 32 86 00 00       	call   c0028f8f <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c002095d:	83 ec 0c             	sub    $0xc,%esp
c0020960:	8d 83 0c 5a ff ff    	lea    -0xa5f4(%ebx),%eax
c0020966:	50                   	push   %eax
c0020967:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002096d:	50                   	push   %eax
c002096e:	8d 83 28 46 ff ff    	lea    -0xb9d8(%ebx),%eax
c0020974:	50                   	push   %eax
c0020975:	68 20 02 00 00       	push   $0x220
c002097a:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020980:	50                   	push   %eax
c0020981:	e8 09 86 00 00       	call   c0028f8f <debug_panic>
  ASSERT (name != NULL);
c0020986:	83 ec 0c             	sub    $0xc,%esp
c0020989:	8d 83 33 59 ff ff    	lea    -0xa6cd(%ebx),%eax
c002098f:	50                   	push   %eax
c0020990:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020996:	50                   	push   %eax
c0020997:	8d 83 28 46 ff ff    	lea    -0xb9d8(%ebx),%eax
c002099d:	50                   	push   %eax
c002099e:	68 21 02 00 00       	push   $0x221
c00209a3:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c00209a9:	50                   	push   %eax
c00209aa:	e8 e0 85 00 00       	call   c0028f8f <debug_panic>

c00209af <thread_init>:
{
c00209af:	55                   	push   %ebp
c00209b0:	57                   	push   %edi
c00209b1:	56                   	push   %esi
c00209b2:	53                   	push   %ebx
c00209b3:	83 ec 0c             	sub    $0xc,%esp
c00209b6:	e8 80 cf 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00209bb:	81 c3 11 8b 01 00    	add    $0x18b11,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00209c1:	e8 2e 11 00 00       	call   c0021af4 <intr_get_level>
c00209c6:	85 c0                	test   %eax,%eax
c00209c8:	0f 85 a6 00 00 00    	jne    c0020a74 <thread_init+0xc5>
  lock_init (&tid_lock);
c00209ce:	83 ec 0c             	sub    $0xc,%esp
c00209d1:	8d b3 14 08 00 00    	lea    0x814(%ebx),%esi
c00209d7:	56                   	push   %esi
c00209d8:	e8 b4 25 00 00       	call   c0022f91 <lock_init>
  list_init (&ready_list);
c00209dd:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
c00209e3:	89 04 24             	mov    %eax,(%esp)
c00209e6:	e8 71 86 00 00       	call   c002905c <list_init>
  list_init (&all_list);
c00209eb:	8d 83 40 08 00 00    	lea    0x840(%ebx),%eax
c00209f1:	89 04 24             	mov    %eax,(%esp)
c00209f4:	e8 63 86 00 00       	call   c002905c <list_init>
  list_init(&children);
c00209f9:	8d 83 70 08 00 00    	lea    0x870(%ebx),%eax
c00209ff:	89 04 24             	mov    %eax,(%esp)
c0020a02:	e8 55 86 00 00       	call   c002905c <list_init>
  list_init(&file_list);
c0020a07:	8d 83 60 08 00 00    	lea    0x860(%ebx),%eax
c0020a0d:	89 04 24             	mov    %eax,(%esp)
c0020a10:	e8 47 86 00 00       	call   c002905c <list_init>
  asm ("mov %%esp, %0" : "=g" (esp));
c0020a15:	89 e0                	mov    %esp,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c0020a17:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  initial_thread = running_thread ();
c0020a1c:	89 83 38 08 00 00    	mov    %eax,0x838(%ebx)
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020a22:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020a27:	8d 93 5e 59 ff ff    	lea    -0xa6a2(%ebx),%edx
c0020a2d:	e8 04 fe ff ff       	call   c0020836 <init_thread>
  initial_thread->status = THREAD_RUNNING;
c0020a32:	8b bb 38 08 00 00    	mov    0x838(%ebx),%edi
c0020a38:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
  lock_acquire (&tid_lock);
c0020a3f:	89 34 24             	mov    %esi,(%esp)
c0020a42:	e8 f6 25 00 00       	call   c002303d <lock_acquire>
  tid = next_tid++;
c0020a47:	8b ab e8 fb ff ff    	mov    -0x418(%ebx),%ebp
c0020a4d:	8d 45 01             	lea    0x1(%ebp),%eax
c0020a50:	89 83 e8 fb ff ff    	mov    %eax,-0x418(%ebx)
  lock_release (&tid_lock);
c0020a56:	89 34 24             	mov    %esi,(%esp)
c0020a59:	e8 d7 27 00 00       	call   c0023235 <lock_release>
  initial_thread->tid = allocate_tid ();
c0020a5e:	89 2f                	mov    %ebp,(%edi)
  load_avg = FP_CONST(0);
c0020a60:	c7 c0 dc b8 03 c0    	mov    $0xc003b8dc,%eax
c0020a66:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c0020a6c:	83 c4 1c             	add    $0x1c,%esp
c0020a6f:	5b                   	pop    %ebx
c0020a70:	5e                   	pop    %esi
c0020a71:	5f                   	pop    %edi
c0020a72:	5d                   	pop    %ebp
c0020a73:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020a74:	83 ec 0c             	sub    $0xc,%esp
c0020a77:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0020a7d:	50                   	push   %eax
c0020a7e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020a84:	50                   	push   %eax
c0020a85:	8d 83 34 46 ff ff    	lea    -0xb9cc(%ebx),%eax
c0020a8b:	50                   	push   %eax
c0020a8c:	6a 68                	push   $0x68
c0020a8e:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020a94:	50                   	push   %eax
c0020a95:	e8 f5 84 00 00       	call   c0028f8f <debug_panic>

c0020a9a <thread_print_stats>:
{
c0020a9a:	53                   	push   %ebx
c0020a9b:	83 ec 0c             	sub    $0xc,%esp
c0020a9e:	e8 98 ce 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020aa3:	81 c3 29 8a 01 00    	add    $0x18a29,%ebx
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020aa9:	6a 00                	push   $0x0
c0020aab:	6a 00                	push   $0x0
c0020aad:	ff b3 00 08 00 00    	pushl  0x800(%ebx)
c0020ab3:	ff b3 fc 07 00 00    	pushl  0x7fc(%ebx)
c0020ab9:	ff b3 08 08 00 00    	pushl  0x808(%ebx)
c0020abf:	ff b3 04 08 00 00    	pushl  0x804(%ebx)
c0020ac5:	8d 83 38 5a ff ff    	lea    -0xa5c8(%ebx),%eax
c0020acb:	50                   	push   %eax
c0020acc:	e8 27 67 00 00       	call   c00271f8 <printf>
}
c0020ad1:	83 c4 28             	add    $0x28,%esp
c0020ad4:	5b                   	pop    %ebx
c0020ad5:	c3                   	ret    

c0020ad6 <thread_unblock>:
{
c0020ad6:	57                   	push   %edi
c0020ad7:	56                   	push   %esi
c0020ad8:	53                   	push   %ebx
c0020ad9:	e8 5d ce 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020ade:	81 c3 ee 89 01 00    	add    $0x189ee,%ebx
c0020ae4:	8b 74 24 10          	mov    0x10(%esp),%esi
  return t != NULL && t->magic == THREAD_MAGIC;
c0020ae8:	85 f6                	test   %esi,%esi
c0020aea:	74 09                	je     c0020af5 <thread_unblock+0x1f>
c0020aec:	81 7e 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%esi)
c0020af3:	74 52                	je     c0020b47 <thread_unblock+0x71>
  ASSERT (is_thread (t));
c0020af5:	83 ec 0c             	sub    $0xc,%esp
c0020af8:	8d 83 25 59 ff ff    	lea    -0xa6db(%ebx),%eax
c0020afe:	50                   	push   %eax
c0020aff:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020b05:	50                   	push   %eax
c0020b06:	8d 83 d0 45 ff ff    	lea    -0xba30(%ebx),%eax
c0020b0c:	50                   	push   %eax
c0020b0d:	68 1f 01 00 00       	push   $0x11f
c0020b12:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020b18:	50                   	push   %eax
c0020b19:	e8 71 84 00 00       	call   c0028f8f <debug_panic>
  ASSERT (t->status == THREAD_BLOCKED);
c0020b1e:	83 ec 0c             	sub    $0xc,%esp
c0020b21:	8d 83 63 59 ff ff    	lea    -0xa69d(%ebx),%eax
c0020b27:	50                   	push   %eax
c0020b28:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020b2e:	50                   	push   %eax
c0020b2f:	8d 83 d0 45 ff ff    	lea    -0xba30(%ebx),%eax
c0020b35:	50                   	push   %eax
c0020b36:	68 22 01 00 00       	push   $0x122
c0020b3b:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020b41:	50                   	push   %eax
c0020b42:	e8 48 84 00 00       	call   c0028f8f <debug_panic>
  old_level = intr_disable ();
c0020b47:	e8 fa 0f 00 00       	call   c0021b46 <intr_disable>
c0020b4c:	89 c7                	mov    %eax,%edi
  ASSERT (t->status == THREAD_BLOCKED);
c0020b4e:	83 7e 04 02          	cmpl   $0x2,0x4(%esi)
c0020b52:	75 ca                	jne    c0020b1e <thread_unblock+0x48>
  list_insert_ordered(&ready_list, &t->elem, (list_less_func *) &thread_cmp_priority, NULL);
c0020b54:	6a 00                	push   $0x0
c0020b56:	8d 83 d6 72 fe ff    	lea    -0x18d2a(%ebx),%eax
c0020b5c:	50                   	push   %eax
c0020b5d:	8d 46 28             	lea    0x28(%esi),%eax
c0020b60:	50                   	push   %eax
c0020b61:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
c0020b67:	50                   	push   %eax
c0020b68:	e8 e7 8f 00 00       	call   c0029b54 <list_insert_ordered>
  t->status = THREAD_READY;
c0020b6d:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
  intr_set_level (old_level);
c0020b74:	89 3c 24             	mov    %edi,(%esp)
c0020b77:	e8 d1 0f 00 00       	call   c0021b4d <intr_set_level>
}
c0020b7c:	83 c4 10             	add    $0x10,%esp
c0020b7f:	5b                   	pop    %ebx
c0020b80:	5e                   	pop    %esi
c0020b81:	5f                   	pop    %edi
c0020b82:	c3                   	ret    

c0020b83 <thread_current>:
{
c0020b83:	53                   	push   %ebx
c0020b84:	83 ec 08             	sub    $0x8,%esp
c0020b87:	e8 af cd 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020b8c:	81 c3 40 89 01 00    	add    $0x18940,%ebx
  asm ("mov %%esp, %0" : "=g" (esp));
c0020b92:	89 e0                	mov    %esp,%eax
  return t != NULL && t->magic == THREAD_MAGIC;
c0020b94:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0020b99:	74 09                	je     c0020ba4 <thread_current+0x21>
c0020b9b:	81 78 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%eax)
c0020ba2:	74 52                	je     c0020bf6 <thread_current+0x73>
  ASSERT (is_thread (t));
c0020ba4:	83 ec 0c             	sub    $0xc,%esp
c0020ba7:	8d 83 25 59 ff ff    	lea    -0xa6db(%ebx),%eax
c0020bad:	50                   	push   %eax
c0020bae:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020bb4:	50                   	push   %eax
c0020bb5:	8d 83 c0 45 ff ff    	lea    -0xba40(%ebx),%eax
c0020bbb:	50                   	push   %eax
c0020bbc:	68 3d 01 00 00       	push   $0x13d
c0020bc1:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020bc7:	50                   	push   %eax
c0020bc8:	e8 c2 83 00 00       	call   c0028f8f <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020bcd:	83 ec 0c             	sub    $0xc,%esp
c0020bd0:	8d 83 7f 59 ff ff    	lea    -0xa681(%ebx),%eax
c0020bd6:	50                   	push   %eax
c0020bd7:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020bdd:	50                   	push   %eax
c0020bde:	8d 83 c0 45 ff ff    	lea    -0xba40(%ebx),%eax
c0020be4:	50                   	push   %eax
c0020be5:	68 3e 01 00 00       	push   $0x13e
c0020bea:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020bf0:	50                   	push   %eax
c0020bf1:	e8 99 83 00 00       	call   c0028f8f <debug_panic>
c0020bf6:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0020bfa:	75 d1                	jne    c0020bcd <thread_current+0x4a>
}
c0020bfc:	83 c4 08             	add    $0x8,%esp
c0020bff:	5b                   	pop    %ebx
c0020c00:	c3                   	ret    

c0020c01 <thread_tick>:
{
c0020c01:	53                   	push   %ebx
c0020c02:	83 ec 08             	sub    $0x8,%esp
c0020c05:	e8 31 cd 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020c0a:	81 c3 c2 88 01 00    	add    $0x188c2,%ebx
  struct thread *t = thread_current ();
c0020c10:	e8 6e ff ff ff       	call   c0020b83 <thread_current>
  if (t == idle_thread)
c0020c15:	39 83 3c 08 00 00    	cmp    %eax,0x83c(%ebx)
c0020c1b:	74 27                	je     c0020c44 <thread_tick+0x43>
    kernel_ticks++;
c0020c1d:	83 83 fc 07 00 00 01 	addl   $0x1,0x7fc(%ebx)
c0020c24:	83 93 00 08 00 00 00 	adcl   $0x0,0x800(%ebx)
  if (++thread_ticks >= TIME_SLICE)
c0020c2b:	8b 83 f4 07 00 00    	mov    0x7f4(%ebx),%eax
c0020c31:	83 c0 01             	add    $0x1,%eax
c0020c34:	89 83 f4 07 00 00    	mov    %eax,0x7f4(%ebx)
c0020c3a:	83 f8 03             	cmp    $0x3,%eax
c0020c3d:	77 15                	ja     c0020c54 <thread_tick+0x53>
}
c0020c3f:	83 c4 08             	add    $0x8,%esp
c0020c42:	5b                   	pop    %ebx
c0020c43:	c3                   	ret    
    idle_ticks++;
c0020c44:	83 83 04 08 00 00 01 	addl   $0x1,0x804(%ebx)
c0020c4b:	83 93 08 08 00 00 00 	adcl   $0x0,0x808(%ebx)
c0020c52:	eb d7                	jmp    c0020c2b <thread_tick+0x2a>
    intr_yield_on_return ();
c0020c54:	e8 a3 11 00 00       	call   c0021dfc <intr_yield_on_return>
}
c0020c59:	eb e4                	jmp    c0020c3f <thread_tick+0x3e>

c0020c5b <thread_name>:
{
c0020c5b:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->name;
c0020c5e:	e8 20 ff ff ff       	call   c0020b83 <thread_current>
c0020c63:	83 c0 08             	add    $0x8,%eax
}
c0020c66:	83 c4 0c             	add    $0xc,%esp
c0020c69:	c3                   	ret    

c0020c6a <thread_tid>:
{
c0020c6a:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->tid;
c0020c6d:	e8 11 ff ff ff       	call   c0020b83 <thread_current>
c0020c72:	8b 00                	mov    (%eax),%eax
}
c0020c74:	83 c4 0c             	add    $0xc,%esp
c0020c77:	c3                   	ret    

c0020c78 <thread_foreach>:
{
c0020c78:	55                   	push   %ebp
c0020c79:	57                   	push   %edi
c0020c7a:	56                   	push   %esi
c0020c7b:	53                   	push   %ebx
c0020c7c:	83 ec 0c             	sub    $0xc,%esp
c0020c7f:	e8 b7 cc 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020c84:	81 c3 48 88 01 00    	add    $0x18848,%ebx
c0020c8a:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  ASSERT (intr_get_level () == INTR_OFF);
c0020c8e:	e8 61 0e 00 00       	call   c0021af4 <intr_get_level>
c0020c93:	85 c0                	test   %eax,%eax
c0020c95:	75 1c                	jne    c0020cb3 <thread_foreach+0x3b>
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020c97:	83 ec 0c             	sub    $0xc,%esp
c0020c9a:	8d 83 40 08 00 00    	lea    0x840(%ebx),%eax
c0020ca0:	50                   	push   %eax
c0020ca1:	e8 0e 84 00 00       	call   c00290b4 <list_begin>
c0020ca6:	89 c6                	mov    %eax,%esi
c0020ca8:	83 c4 10             	add    $0x10,%esp
c0020cab:	8d bb 40 08 00 00    	lea    0x840(%ebx),%edi
c0020cb1:	eb 42                	jmp    c0020cf5 <thread_foreach+0x7d>
  ASSERT (intr_get_level () == INTR_OFF);
c0020cb3:	83 ec 0c             	sub    $0xc,%esp
c0020cb6:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0020cbc:	50                   	push   %eax
c0020cbd:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020cc3:	50                   	push   %eax
c0020cc4:	8d 83 94 45 ff ff    	lea    -0xba6c(%ebx),%eax
c0020cca:	50                   	push   %eax
c0020ccb:	68 8e 01 00 00       	push   $0x18e
c0020cd0:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020cd6:	50                   	push   %eax
c0020cd7:	e8 b3 82 00 00       	call   c0028f8f <debug_panic>
      func (t, aux);
c0020cdc:	83 ec 08             	sub    $0x8,%esp
c0020cdf:	55                   	push   %ebp
      struct thread *t = list_entry (e, struct thread, allelem);
c0020ce0:	8d 46 e0             	lea    -0x20(%esi),%eax
      func (t, aux);
c0020ce3:	50                   	push   %eax
c0020ce4:	ff 54 24 30          	call   *0x30(%esp)
       e = list_next (e))
c0020ce8:	89 34 24             	mov    %esi,(%esp)
c0020ceb:	e8 09 84 00 00       	call   c00290f9 <list_next>
c0020cf0:	89 c6                	mov    %eax,%esi
c0020cf2:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020cf5:	83 ec 0c             	sub    $0xc,%esp
c0020cf8:	57                   	push   %edi
c0020cf9:	e8 58 84 00 00       	call   c0029156 <list_end>
c0020cfe:	83 c4 10             	add    $0x10,%esp
c0020d01:	39 f0                	cmp    %esi,%eax
c0020d03:	75 d7                	jne    c0020cdc <thread_foreach+0x64>
}
c0020d05:	83 c4 0c             	add    $0xc,%esp
c0020d08:	5b                   	pop    %ebx
c0020d09:	5e                   	pop    %esi
c0020d0a:	5f                   	pop    %edi
c0020d0b:	5d                   	pop    %ebp
c0020d0c:	c3                   	ret    

c0020d0d <thread_get_priority>:
{
c0020d0d:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->priority;
c0020d10:	e8 6e fe ff ff       	call   c0020b83 <thread_current>
c0020d15:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020d18:	83 c4 0c             	add    $0xc,%esp
c0020d1b:	c3                   	ret    

c0020d1c <thread_get_nice>:
{
c0020d1c:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->nice;
c0020d1f:	e8 5f fe ff ff       	call   c0020b83 <thread_current>
c0020d24:	8b 40 54             	mov    0x54(%eax),%eax
}
c0020d27:	83 c4 0c             	add    $0xc,%esp
c0020d2a:	c3                   	ret    

c0020d2b <thread_get_load_avg>:
{
c0020d2b:	e8 0f cc 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0020d30:	05 9c 87 01 00       	add    $0x1879c,%eax
  return FP_ROUND(FP_MULT_MIX(load_avg, 100));
c0020d35:	c7 c0 dc b8 03 c0    	mov    $0xc003b8dc,%eax
c0020d3b:	6b 00 64             	imul   $0x64,(%eax),%eax
c0020d3e:	85 c0                	test   %eax,%eax
c0020d40:	78 09                	js     c0020d4b <thread_get_load_avg+0x20>
c0020d42:	05 00 80 00 00       	add    $0x8000,%eax
c0020d47:	c1 f8 10             	sar    $0x10,%eax
c0020d4a:	c3                   	ret    
c0020d4b:	2d 00 80 00 00       	sub    $0x8000,%eax
c0020d50:	c1 f8 10             	sar    $0x10,%eax
}
c0020d53:	c3                   	ret    

c0020d54 <thread_get_recent_cpu>:
{
c0020d54:	83 ec 0c             	sub    $0xc,%esp
  return FP_ROUND(FP_MULT_MIX(thread_current()->recent_cpu, 100));
c0020d57:	e8 27 fe ff ff       	call   c0020b83 <thread_current>
c0020d5c:	6b 40 58 64          	imul   $0x64,0x58(%eax),%eax
c0020d60:	85 c0                	test   %eax,%eax
c0020d62:	78 0c                	js     c0020d70 <thread_get_recent_cpu+0x1c>
c0020d64:	05 00 80 00 00       	add    $0x8000,%eax
c0020d69:	c1 f8 10             	sar    $0x10,%eax
}
c0020d6c:	83 c4 0c             	add    $0xc,%esp
c0020d6f:	c3                   	ret    
  return FP_ROUND(FP_MULT_MIX(thread_current()->recent_cpu, 100));
c0020d70:	2d 00 80 00 00       	sub    $0x8000,%eax
c0020d75:	c1 f8 10             	sar    $0x10,%eax
c0020d78:	eb f2                	jmp    c0020d6c <thread_get_recent_cpu+0x18>

c0020d7a <thread_schedule_tail>:
{
c0020d7a:	57                   	push   %edi
c0020d7b:	56                   	push   %esi
c0020d7c:	53                   	push   %ebx
c0020d7d:	e8 b9 cb 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020d82:	81 c3 4a 87 01 00    	add    $0x1874a,%ebx
c0020d88:	8b 7c 24 10          	mov    0x10(%esp),%edi
  asm ("mov %%esp, %0" : "=g" (esp));
c0020d8c:	89 e6                	mov    %esp,%esi
c0020d8e:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0020d94:	e8 5b 0d 00 00       	call   c0021af4 <intr_get_level>
c0020d99:	85 c0                	test   %eax,%eax
c0020d9b:	75 1f                	jne    c0020dbc <thread_schedule_tail+0x42>
  cur->status = THREAD_RUNNING;
c0020d9d:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
  thread_ticks = 0;
c0020da4:	c7 83 f4 07 00 00 00 	movl   $0x0,0x7f4(%ebx)
c0020dab:	00 00 00 
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0020dae:	85 ff                	test   %edi,%edi
c0020db0:	74 06                	je     c0020db8 <thread_schedule_tail+0x3e>
c0020db2:	83 7f 04 03          	cmpl   $0x3,0x4(%edi)
c0020db6:	74 2d                	je     c0020de5 <thread_schedule_tail+0x6b>
}
c0020db8:	5b                   	pop    %ebx
c0020db9:	5e                   	pop    %esi
c0020dba:	5f                   	pop    %edi
c0020dbb:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020dbc:	83 ec 0c             	sub    $0xc,%esp
c0020dbf:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0020dc5:	50                   	push   %eax
c0020dc6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020dcc:	50                   	push   %eax
c0020dcd:	8d 83 7c 45 ff ff    	lea    -0xba84(%ebx),%eax
c0020dd3:	50                   	push   %eax
c0020dd4:	68 71 02 00 00       	push   $0x271
c0020dd9:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020ddf:	50                   	push   %eax
c0020de0:	e8 aa 81 00 00       	call   c0028f8f <debug_panic>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0020de5:	39 bb 38 08 00 00    	cmp    %edi,0x838(%ebx)
c0020deb:	74 cb                	je     c0020db8 <thread_schedule_tail+0x3e>
      ASSERT (prev != cur);
c0020ded:	39 f7                	cmp    %esi,%edi
c0020def:	74 0e                	je     c0020dff <thread_schedule_tail+0x85>
      palloc_free_page (prev);
c0020df1:	83 ec 0c             	sub    $0xc,%esp
c0020df4:	57                   	push   %edi
c0020df5:	e8 9d 2b 00 00       	call   c0023997 <palloc_free_page>
c0020dfa:	83 c4 10             	add    $0x10,%esp
}
c0020dfd:	eb b9                	jmp    c0020db8 <thread_schedule_tail+0x3e>
      ASSERT (prev != cur);
c0020dff:	83 ec 0c             	sub    $0xc,%esp
c0020e02:	8d 83 9b 59 ff ff    	lea    -0xa665(%ebx),%eax
c0020e08:	50                   	push   %eax
c0020e09:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020e0f:	50                   	push   %eax
c0020e10:	8d 83 7c 45 ff ff    	lea    -0xba84(%ebx),%eax
c0020e16:	50                   	push   %eax
c0020e17:	68 85 02 00 00       	push   $0x285
c0020e1c:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020e22:	50                   	push   %eax
c0020e23:	e8 67 81 00 00       	call   c0028f8f <debug_panic>

c0020e28 <schedule>:
{
c0020e28:	57                   	push   %edi
c0020e29:	56                   	push   %esi
c0020e2a:	53                   	push   %ebx
c0020e2b:	e8 0b cb 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020e30:	81 c3 9c 86 01 00    	add    $0x1869c,%ebx
  asm ("mov %%esp, %0" : "=g" (esp));
c0020e36:	89 e6                	mov    %esp,%esi
c0020e38:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  if (list_empty (&ready_list))
c0020e3e:	83 ec 0c             	sub    $0xc,%esp
c0020e41:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
c0020e47:	50                   	push   %eax
c0020e48:	e8 b4 88 00 00       	call   c0029701 <list_empty>
c0020e4d:	83 c4 10             	add    $0x10,%esp
c0020e50:	84 c0                	test   %al,%al
c0020e52:	74 4f                	je     c0020ea3 <schedule+0x7b>
    return idle_thread;
c0020e54:	8b bb 3c 08 00 00    	mov    0x83c(%ebx),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c0020e5a:	e8 95 0c 00 00       	call   c0021af4 <intr_get_level>
c0020e5f:	85 c0                	test   %eax,%eax
c0020e61:	75 57                	jne    c0020eba <schedule+0x92>
  ASSERT (cur->status != THREAD_RUNNING);
c0020e63:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0020e67:	74 7a                	je     c0020ee3 <schedule+0xbb>
  return t != NULL && t->magic == THREAD_MAGIC;
c0020e69:	85 ff                	test   %edi,%edi
c0020e6b:	74 0d                	je     c0020e7a <schedule+0x52>
c0020e6d:	81 7f 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%edi)
c0020e74:	0f 84 92 00 00 00    	je     c0020f0c <schedule+0xe4>
  ASSERT (is_thread (next));
c0020e7a:	83 ec 0c             	sub    $0xc,%esp
c0020e7d:	8d 83 c5 59 ff ff    	lea    -0xa63b(%ebx),%eax
c0020e83:	50                   	push   %eax
c0020e84:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020e8a:	50                   	push   %eax
c0020e8b:	8d 83 e0 45 ff ff    	lea    -0xba20(%ebx),%eax
c0020e91:	50                   	push   %eax
c0020e92:	68 9a 02 00 00       	push   $0x29a
c0020e97:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020e9d:	50                   	push   %eax
c0020e9e:	e8 ec 80 00 00       	call   c0028f8f <debug_panic>
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0020ea3:	83 ec 0c             	sub    $0xc,%esp
c0020ea6:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
c0020eac:	50                   	push   %eax
c0020ead:	e8 c6 88 00 00       	call   c0029778 <list_pop_front>
c0020eb2:	8d 78 d8             	lea    -0x28(%eax),%edi
c0020eb5:	83 c4 10             	add    $0x10,%esp
c0020eb8:	eb a0                	jmp    c0020e5a <schedule+0x32>
  ASSERT (intr_get_level () == INTR_OFF);
c0020eba:	83 ec 0c             	sub    $0xc,%esp
c0020ebd:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0020ec3:	50                   	push   %eax
c0020ec4:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020eca:	50                   	push   %eax
c0020ecb:	8d 83 e0 45 ff ff    	lea    -0xba20(%ebx),%eax
c0020ed1:	50                   	push   %eax
c0020ed2:	68 98 02 00 00       	push   $0x298
c0020ed7:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020edd:	50                   	push   %eax
c0020ede:	e8 ac 80 00 00       	call   c0028f8f <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0020ee3:	83 ec 0c             	sub    $0xc,%esp
c0020ee6:	8d 83 a7 59 ff ff    	lea    -0xa659(%ebx),%eax
c0020eec:	50                   	push   %eax
c0020eed:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020ef3:	50                   	push   %eax
c0020ef4:	8d 83 e0 45 ff ff    	lea    -0xba20(%ebx),%eax
c0020efa:	50                   	push   %eax
c0020efb:	68 99 02 00 00       	push   $0x299
c0020f00:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020f06:	50                   	push   %eax
c0020f07:	e8 83 80 00 00       	call   c0028f8f <debug_panic>
  struct thread *prev = NULL;
c0020f0c:	b8 00 00 00 00       	mov    $0x0,%eax
  if (cur != next)
c0020f11:	39 f7                	cmp    %esi,%edi
c0020f13:	74 0d                	je     c0020f22 <schedule+0xfa>
    prev = switch_threads (cur, next);
c0020f15:	83 ec 08             	sub    $0x8,%esp
c0020f18:	57                   	push   %edi
c0020f19:	56                   	push   %esi
c0020f1a:	e8 48 0a 00 00       	call   c0021967 <switch_threads>
c0020f1f:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail (prev);
c0020f22:	83 ec 0c             	sub    $0xc,%esp
c0020f25:	50                   	push   %eax
c0020f26:	e8 4f fe ff ff       	call   c0020d7a <thread_schedule_tail>
}
c0020f2b:	83 c4 10             	add    $0x10,%esp
c0020f2e:	5b                   	pop    %ebx
c0020f2f:	5e                   	pop    %esi
c0020f30:	5f                   	pop    %edi
c0020f31:	c3                   	ret    

c0020f32 <thread_block>:
{
c0020f32:	53                   	push   %ebx
c0020f33:	83 ec 08             	sub    $0x8,%esp
c0020f36:	e8 00 ca 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020f3b:	81 c3 91 85 01 00    	add    $0x18591,%ebx
  ASSERT (!intr_context ());
c0020f41:	e8 a4 0e 00 00       	call   c0021dea <intr_context>
c0020f46:	84 c0                	test   %al,%al
c0020f48:	75 1f                	jne    c0020f69 <thread_block+0x37>
  ASSERT (intr_get_level () == INTR_OFF);
c0020f4a:	e8 a5 0b 00 00       	call   c0021af4 <intr_get_level>
c0020f4f:	85 c0                	test   %eax,%eax
c0020f51:	75 3f                	jne    c0020f92 <thread_block+0x60>
  thread_current ()->status = THREAD_BLOCKED;
c0020f53:	e8 2b fc ff ff       	call   c0020b83 <thread_current>
c0020f58:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020f5f:	e8 c4 fe ff ff       	call   c0020e28 <schedule>
}
c0020f64:	83 c4 08             	add    $0x8,%esp
c0020f67:	5b                   	pop    %ebx
c0020f68:	c3                   	ret    
  ASSERT (!intr_context ());
c0020f69:	83 ec 0c             	sub    $0xc,%esp
c0020f6c:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0020f72:	50                   	push   %eax
c0020f73:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020f79:	50                   	push   %eax
c0020f7a:	8d 83 ec 45 ff ff    	lea    -0xba14(%ebx),%eax
c0020f80:	50                   	push   %eax
c0020f81:	68 0b 01 00 00       	push   $0x10b
c0020f86:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020f8c:	50                   	push   %eax
c0020f8d:	e8 fd 7f 00 00       	call   c0028f8f <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020f92:	83 ec 0c             	sub    $0xc,%esp
c0020f95:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0020f9b:	50                   	push   %eax
c0020f9c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0020fa2:	50                   	push   %eax
c0020fa3:	8d 83 ec 45 ff ff    	lea    -0xba14(%ebx),%eax
c0020fa9:	50                   	push   %eax
c0020faa:	68 0c 01 00 00       	push   $0x10c
c0020faf:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0020fb5:	50                   	push   %eax
c0020fb6:	e8 d4 7f 00 00       	call   c0028f8f <debug_panic>

c0020fbb <idle>:
{
c0020fbb:	53                   	push   %ebx
c0020fbc:	83 ec 08             	sub    $0x8,%esp
c0020fbf:	e8 77 c9 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020fc4:	81 c3 08 85 01 00    	add    $0x18508,%ebx
  idle_thread = thread_current ();
c0020fca:	e8 b4 fb ff ff       	call   c0020b83 <thread_current>
c0020fcf:	89 83 3c 08 00 00    	mov    %eax,0x83c(%ebx)
  sema_up (idle_started);
c0020fd5:	83 ec 0c             	sub    $0xc,%esp
c0020fd8:	ff 74 24 1c          	pushl  0x1c(%esp)
c0020fdc:	e8 56 1e 00 00       	call   c0022e37 <sema_up>
c0020fe1:	83 c4 10             	add    $0x10,%esp
      intr_disable ();
c0020fe4:	e8 5d 0b 00 00       	call   c0021b46 <intr_disable>
      thread_block ();
c0020fe9:	e8 44 ff ff ff       	call   c0020f32 <thread_block>
      asm volatile ("sti; hlt" : : : "memory");
c0020fee:	fb                   	sti    
c0020fef:	f4                   	hlt    
c0020ff0:	eb f2                	jmp    c0020fe4 <idle+0x29>

c0020ff2 <thread_exit>:
{
c0020ff2:	53                   	push   %ebx
c0020ff3:	83 ec 08             	sub    $0x8,%esp
c0020ff6:	e8 40 c9 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0020ffb:	81 c3 d1 84 01 00    	add    $0x184d1,%ebx
  ASSERT (!intr_context ());
c0021001:	e8 e4 0d 00 00       	call   c0021dea <intr_context>
c0021006:	84 c0                	test   %al,%al
c0021008:	74 29                	je     c0021033 <thread_exit+0x41>
c002100a:	83 ec 0c             	sub    $0xc,%esp
c002100d:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0021013:	50                   	push   %eax
c0021014:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002101a:	50                   	push   %eax
c002101b:	8d 83 b4 45 ff ff    	lea    -0xba4c(%ebx),%eax
c0021021:	50                   	push   %eax
c0021022:	68 4f 01 00 00       	push   $0x14f
c0021027:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c002102d:	50                   	push   %eax
c002102e:	e8 5c 7f 00 00       	call   c0028f8f <debug_panic>
  intr_disable ();
c0021033:	e8 0e 0b 00 00       	call   c0021b46 <intr_disable>
  list_remove (&thread_current()->allelem);
c0021038:	e8 46 fb ff ff       	call   c0020b83 <thread_current>
c002103d:	83 ec 0c             	sub    $0xc,%esp
c0021040:	83 c0 20             	add    $0x20,%eax
c0021043:	50                   	push   %eax
c0021044:	e8 16 86 00 00       	call   c002965f <list_remove>
  thread_current ()->status = THREAD_DYING;
c0021049:	e8 35 fb ff ff       	call   c0020b83 <thread_current>
c002104e:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0021055:	e8 ce fd ff ff       	call   c0020e28 <schedule>
  NOT_REACHED ();
c002105a:	8d 83 78 5a ff ff    	lea    -0xa588(%ebx),%eax
c0021060:	50                   	push   %eax
c0021061:	8d 83 b4 45 ff ff    	lea    -0xba4c(%ebx),%eax
c0021067:	50                   	push   %eax
c0021068:	68 70 01 00 00       	push   $0x170
c002106d:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0021073:	50                   	push   %eax
c0021074:	e8 16 7f 00 00       	call   c0028f8f <debug_panic>

c0021079 <kernel_thread>:
{
c0021079:	56                   	push   %esi
c002107a:	53                   	push   %ebx
c002107b:	83 ec 04             	sub    $0x4,%esp
c002107e:	e8 b8 c8 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021083:	81 c3 49 84 01 00    	add    $0x18449,%ebx
c0021089:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (function != NULL);
c002108d:	85 f6                	test   %esi,%esi
c002108f:	74 13                	je     c00210a4 <kernel_thread+0x2b>
  intr_enable ();       /* The scheduler runs with interrupts off. */
c0021091:	e8 67 0a 00 00       	call   c0021afd <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021096:	83 ec 0c             	sub    $0xc,%esp
c0021099:	ff 74 24 20          	pushl  0x20(%esp)
c002109d:	ff d6                	call   *%esi
  thread_exit ();       /* If function() returns, kill the thread. */
c002109f:	e8 4e ff ff ff       	call   c0020ff2 <thread_exit>
  ASSERT (function != NULL);
c00210a4:	83 ec 0c             	sub    $0xc,%esp
c00210a7:	8d 83 e7 59 ff ff    	lea    -0xa619(%ebx),%eax
c00210ad:	50                   	push   %eax
c00210ae:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00210b4:	50                   	push   %eax
c00210b5:	8d 83 08 46 ff ff    	lea    -0xb9f8(%ebx),%eax
c00210bb:	50                   	push   %eax
c00210bc:	68 fc 01 00 00       	push   $0x1fc
c00210c1:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c00210c7:	50                   	push   %eax
c00210c8:	e8 c2 7e 00 00       	call   c0028f8f <debug_panic>

c00210cd <thread_yield>:
{
c00210cd:	57                   	push   %edi
c00210ce:	56                   	push   %esi
c00210cf:	53                   	push   %ebx
c00210d0:	e8 66 c8 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00210d5:	81 c3 f7 83 01 00    	add    $0x183f7,%ebx
  struct thread *cur = thread_current ();
c00210db:	e8 a3 fa ff ff       	call   c0020b83 <thread_current>
c00210e0:	89 c6                	mov    %eax,%esi
  ASSERT (!intr_context ());
c00210e2:	e8 03 0d 00 00       	call   c0021dea <intr_context>
c00210e7:	84 c0                	test   %al,%al
c00210e9:	75 47                	jne    c0021132 <thread_yield+0x65>
  old_level = intr_disable ();
c00210eb:	e8 56 0a 00 00       	call   c0021b46 <intr_disable>
c00210f0:	89 c7                	mov    %eax,%edi
  if (cur != idle_thread) 
c00210f2:	39 b3 3c 08 00 00    	cmp    %esi,0x83c(%ebx)
c00210f8:	74 1c                	je     c0021116 <thread_yield+0x49>
    list_insert_ordered(&ready_list, &cur->elem, (list_less_func *) &thread_cmp_priority, NULL);
c00210fa:	6a 00                	push   $0x0
c00210fc:	8d 83 d6 72 fe ff    	lea    -0x18d2a(%ebx),%eax
c0021102:	50                   	push   %eax
c0021103:	8d 46 28             	lea    0x28(%esi),%eax
c0021106:	50                   	push   %eax
c0021107:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
c002110d:	50                   	push   %eax
c002110e:	e8 41 8a 00 00       	call   c0029b54 <list_insert_ordered>
c0021113:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0021116:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
  schedule ();
c002111d:	e8 06 fd ff ff       	call   c0020e28 <schedule>
  intr_set_level (old_level);
c0021122:	83 ec 0c             	sub    $0xc,%esp
c0021125:	57                   	push   %edi
c0021126:	e8 22 0a 00 00       	call   c0021b4d <intr_set_level>
}
c002112b:	83 c4 10             	add    $0x10,%esp
c002112e:	5b                   	pop    %ebx
c002112f:	5e                   	pop    %esi
c0021130:	5f                   	pop    %edi
c0021131:	c3                   	ret    
  ASSERT (!intr_context ());
c0021132:	83 ec 0c             	sub    $0xc,%esp
c0021135:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c002113b:	50                   	push   %eax
c002113c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021142:	50                   	push   %eax
c0021143:	8d 83 a4 45 ff ff    	lea    -0xba5c(%ebx),%eax
c0021149:	50                   	push   %eax
c002114a:	68 7b 01 00 00       	push   $0x17b
c002114f:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c0021155:	50                   	push   %eax
c0021156:	e8 34 7e 00 00       	call   c0028f8f <debug_panic>

c002115b <thread_create>:
{
c002115b:	55                   	push   %ebp
c002115c:	57                   	push   %edi
c002115d:	56                   	push   %esi
c002115e:	53                   	push   %ebx
c002115f:	83 ec 0c             	sub    $0xc,%esp
c0021162:	e8 d4 c7 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021167:	81 c3 65 83 01 00    	add    $0x18365,%ebx
  ASSERT (function != NULL);
c002116d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0021172:	0f 84 21 01 00 00    	je     c0021299 <thread_create+0x13e>
  t = palloc_get_page (PAL_ZERO);
c0021178:	83 ec 0c             	sub    $0xc,%esp
c002117b:	6a 02                	push   $0x2
c002117d:	e8 a7 26 00 00       	call   c0023829 <palloc_get_page>
c0021182:	89 c6                	mov    %eax,%esi
  if (t == NULL)
c0021184:	83 c4 10             	add    $0x10,%esp
c0021187:	85 c0                	test   %eax,%eax
c0021189:	0f 84 33 01 00 00    	je     c00212c2 <thread_create+0x167>
  init_thread (t, name, priority);
c002118f:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021193:	8b 54 24 20          	mov    0x20(%esp),%edx
c0021197:	e8 9a f6 ff ff       	call   c0020836 <init_thread>
  lock_acquire (&tid_lock);
c002119c:	83 ec 0c             	sub    $0xc,%esp
c002119f:	8d bb 14 08 00 00    	lea    0x814(%ebx),%edi
c00211a5:	57                   	push   %edi
c00211a6:	e8 92 1e 00 00       	call   c002303d <lock_acquire>
  tid = next_tid++;
c00211ab:	8b ab e8 fb ff ff    	mov    -0x418(%ebx),%ebp
c00211b1:	8d 45 01             	lea    0x1(%ebp),%eax
c00211b4:	89 83 e8 fb ff ff    	mov    %eax,-0x418(%ebx)
  lock_release (&tid_lock);
c00211ba:	89 3c 24             	mov    %edi,(%esp)
c00211bd:	e8 73 20 00 00       	call   c0023235 <lock_release>
  tid = t->tid = allocate_tid ();
c00211c2:	89 2e                	mov    %ebp,(%esi)
  struct child_message *own = palloc_get_page(PAL_ZERO);
c00211c4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c00211cb:	e8 59 26 00 00       	call   c0023829 <palloc_get_page>
c00211d0:	89 c7                	mov    %eax,%edi
  own->tid = tid;
c00211d2:	89 68 04             	mov    %ebp,0x4(%eax)
  own->tchild = t;
c00211d5:	89 30                	mov    %esi,(%eax)
  own->exited = false;
c00211d7:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  own->terminated = false;
c00211db:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  own->load_failed = false;
c00211df:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
  own->return_value = 0;
c00211e3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  own->sema_finished = &t->sema_finished;
c00211ea:	8d 46 70             	lea    0x70(%esi),%eax
c00211ed:	89 47 10             	mov    %eax,0x10(%edi)
  own->sema_started = &t->sema_started;
c00211f0:	8d 86 84 00 00 00    	lea    0x84(%esi),%eax
c00211f6:	89 47 14             	mov    %eax,0x14(%edi)
  list_push_back(&children, &own->allelem);
c00211f9:	83 c4 08             	add    $0x8,%esp
c00211fc:	8d 47 20             	lea    0x20(%edi),%eax
c00211ff:	50                   	push   %eax
c0021200:	8d 83 70 08 00 00    	lea    0x870(%ebx),%eax
c0021206:	50                   	push   %eax
c0021207:	e8 36 84 00 00       	call   c0029642 <list_push_back>
  t->message_to_grandpa = own;
c002120c:	89 be 9c 00 00 00    	mov    %edi,0x9c(%esi)
  old_level = intr_disable();
c0021212:	e8 2f 09 00 00       	call   c0021b46 <intr_disable>
c0021217:	89 c7                	mov    %eax,%edi
  kf = alloc_frame (t, sizeof *kf);
c0021219:	ba 0c 00 00 00       	mov    $0xc,%edx
c002121e:	89 f0                	mov    %esi,%eax
c0021220:	e8 8f f5 ff ff       	call   c00207b4 <alloc_frame>
  kf->eip = NULL;
c0021225:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c002122b:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c002122f:	89 48 04             	mov    %ecx,0x4(%eax)
  kf->aux = aux;
c0021232:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0021236:	89 50 08             	mov    %edx,0x8(%eax)
  ef = alloc_frame (t, sizeof *ef);
c0021239:	ba 04 00 00 00       	mov    $0x4,%edx
c002123e:	89 f0                	mov    %esi,%eax
c0021240:	e8 6f f5 ff ff       	call   c00207b4 <alloc_frame>
  ef->eip = (void (*) (void)) kernel_thread;
c0021245:	8d 93 ad 7b fe ff    	lea    -0x18453(%ebx),%edx
c002124b:	89 10                	mov    %edx,(%eax)
  sf = alloc_frame (t, sizeof *sf);
c002124d:	ba 1c 00 00 00       	mov    $0x1c,%edx
c0021252:	89 f0                	mov    %esi,%eax
c0021254:	e8 5b f5 ff ff       	call   c00207b4 <alloc_frame>
  sf->eip = switch_entry;
c0021259:	c7 c2 84 19 02 c0    	mov    $0xc0021984,%edx
c002125f:	89 50 10             	mov    %edx,0x10(%eax)
  sf->ebp = 0;
c0021262:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  intr_set_level(old_level);
c0021269:	89 3c 24             	mov    %edi,(%esp)
c002126c:	e8 dc 08 00 00       	call   c0021b4d <intr_set_level>
  t->ticks_blocked = 0;
c0021271:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
c0021278:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  thread_unblock (t);
c002127f:	89 34 24             	mov    %esi,(%esp)
c0021282:	e8 4f f8 ff ff       	call   c0020ad6 <thread_unblock>
  thread_yield();
c0021287:	e8 41 fe ff ff       	call   c00210cd <thread_yield>
  return tid;
c002128c:	83 c4 10             	add    $0x10,%esp
}
c002128f:	89 e8                	mov    %ebp,%eax
c0021291:	83 c4 0c             	add    $0xc,%esp
c0021294:	5b                   	pop    %ebx
c0021295:	5e                   	pop    %esi
c0021296:	5f                   	pop    %edi
c0021297:	5d                   	pop    %ebp
c0021298:	c3                   	ret    
  ASSERT (function != NULL);
c0021299:	83 ec 0c             	sub    $0xc,%esp
c002129c:	8d 83 e7 59 ff ff    	lea    -0xa619(%ebx),%eax
c00212a2:	50                   	push   %eax
c00212a3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00212a9:	50                   	push   %eax
c00212aa:	8d 83 18 46 ff ff    	lea    -0xb9e8(%ebx),%eax
c00212b0:	50                   	push   %eax
c00212b1:	68 c7 00 00 00       	push   $0xc7
c00212b6:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c00212bc:	50                   	push   %eax
c00212bd:	e8 cd 7c 00 00       	call   c0028f8f <debug_panic>
    return TID_ERROR;
c00212c2:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c00212c7:	eb c6                	jmp    c002128f <thread_create+0x134>

c00212c9 <thread_start>:
{
c00212c9:	56                   	push   %esi
c00212ca:	53                   	push   %ebx
c00212cb:	83 ec 2c             	sub    $0x2c,%esp
c00212ce:	e8 68 c6 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00212d3:	81 c3 f9 81 01 00    	add    $0x181f9,%ebx
  sema_init (&idle_started, 0);
c00212d9:	6a 00                	push   $0x0
c00212db:	8d 74 24 18          	lea    0x18(%esp),%esi
c00212df:	56                   	push   %esi
c00212e0:	e8 d6 19 00 00       	call   c0022cbb <sema_init>
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c00212e5:	56                   	push   %esi
c00212e6:	8d 83 ef 7a fe ff    	lea    -0x18511(%ebx),%eax
c00212ec:	50                   	push   %eax
c00212ed:	6a 00                	push   $0x0
c00212ef:	8d 83 f8 59 ff ff    	lea    -0xa608(%ebx),%eax
c00212f5:	50                   	push   %eax
c00212f6:	e8 60 fe ff ff       	call   c002115b <thread_create>
  intr_enable ();
c00212fb:	83 c4 20             	add    $0x20,%esp
c00212fe:	e8 fa 07 00 00       	call   c0021afd <intr_enable>
  sema_down (&idle_started);
c0021303:	83 ec 0c             	sub    $0xc,%esp
c0021306:	56                   	push   %esi
c0021307:	e8 03 1a 00 00       	call   c0022d0f <sema_down>
}
c002130c:	83 c4 34             	add    $0x34,%esp
c002130f:	5b                   	pop    %ebx
c0021310:	5e                   	pop    %esi
c0021311:	c3                   	ret    

c0021312 <thread_set_priority>:
{
c0021312:	55                   	push   %ebp
c0021313:	57                   	push   %edi
c0021314:	56                   	push   %esi
c0021315:	53                   	push   %ebx
c0021316:	83 ec 0c             	sub    $0xc,%esp
c0021319:	e8 1d c6 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002131e:	81 c3 ae 81 01 00    	add    $0x181ae,%ebx
  if (thread_mlfqs)
c0021324:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002132a:	80 38 00             	cmpb   $0x0,(%eax)
c002132d:	74 08                	je     c0021337 <thread_set_priority+0x25>
}
c002132f:	83 c4 0c             	add    $0xc,%esp
c0021332:	5b                   	pop    %ebx
c0021333:	5e                   	pop    %esi
c0021334:	5f                   	pop    %edi
c0021335:	5d                   	pop    %ebp
c0021336:	c3                   	ret    
  enum intr_level old_level = intr_disable();
c0021337:	e8 0a 08 00 00       	call   c0021b46 <intr_disable>
c002133c:	89 c7                	mov    %eax,%edi
  struct thread *current_thread = thread_current();
c002133e:	e8 40 f8 ff ff       	call   c0020b83 <thread_current>
c0021343:	89 c6                	mov    %eax,%esi
  int old_priority = current_thread->priority;
c0021345:	8b 68 1c             	mov    0x1c(%eax),%ebp
  current_thread->base_priority = new_priority;
c0021348:	8b 44 24 20          	mov    0x20(%esp),%eax
c002134c:	89 46 3c             	mov    %eax,0x3c(%esi)
  if (list_empty (&current_thread->locks) || new_priority > old_priority) {
c002134f:	83 ec 0c             	sub    $0xc,%esp
c0021352:	8d 46 40             	lea    0x40(%esi),%eax
c0021355:	50                   	push   %eax
c0021356:	e8 a6 83 00 00       	call   c0029701 <list_empty>
c002135b:	83 c4 10             	add    $0x10,%esp
c002135e:	3b 6c 24 20          	cmp    0x20(%esp),%ebp
c0021362:	7c 04                	jl     c0021368 <thread_set_priority+0x56>
c0021364:	84 c0                	test   %al,%al
c0021366:	74 0c                	je     c0021374 <thread_set_priority+0x62>
    current_thread->priority = new_priority;
c0021368:	8b 44 24 20          	mov    0x20(%esp),%eax
c002136c:	89 46 1c             	mov    %eax,0x1c(%esi)
    thread_yield();
c002136f:	e8 59 fd ff ff       	call   c00210cd <thread_yield>
  intr_set_level(old_level);
c0021374:	83 ec 0c             	sub    $0xc,%esp
c0021377:	57                   	push   %edi
c0021378:	e8 d0 07 00 00       	call   c0021b4d <intr_set_level>
c002137d:	83 c4 10             	add    $0x10,%esp
c0021380:	eb ad                	jmp    c002132f <thread_set_priority+0x1d>

c0021382 <blocked_thread_check>:
void blocked_thread_check(struct thread *t, void *aux UNUSED) {
c0021382:	53                   	push   %ebx
c0021383:	83 ec 08             	sub    $0x8,%esp
c0021386:	8b 44 24 10          	mov    0x10(%esp),%eax
  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c002138a:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
c002138e:	74 05                	je     c0021395 <blocked_thread_check+0x13>
}
c0021390:	83 c4 08             	add    $0x8,%esp
c0021393:	5b                   	pop    %ebx
c0021394:	c3                   	ret    
  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c0021395:	8b 48 34             	mov    0x34(%eax),%ecx
c0021398:	8b 58 38             	mov    0x38(%eax),%ebx
c002139b:	85 db                	test   %ebx,%ebx
c002139d:	78 f1                	js     c0021390 <blocked_thread_check+0xe>
c002139f:	85 db                	test   %ebx,%ebx
c00213a1:	7e 22                	jle    c00213c5 <blocked_thread_check+0x43>
      t->ticks_blocked--;
c00213a3:	83 c1 ff             	add    $0xffffffff,%ecx
c00213a6:	83 d3 ff             	adc    $0xffffffff,%ebx
c00213a9:	89 48 34             	mov    %ecx,0x34(%eax)
c00213ac:	89 58 38             	mov    %ebx,0x38(%eax)
      if (t->ticks_blocked == 0)
c00213af:	89 ca                	mov    %ecx,%edx
c00213b1:	89 d9                	mov    %ebx,%ecx
c00213b3:	09 d1                	or     %edx,%ecx
c00213b5:	75 d9                	jne    c0021390 <blocked_thread_check+0xe>
        thread_unblock(t);
c00213b7:	83 ec 0c             	sub    $0xc,%esp
c00213ba:	50                   	push   %eax
c00213bb:	e8 16 f7 ff ff       	call   c0020ad6 <thread_unblock>
c00213c0:	83 c4 10             	add    $0x10,%esp
}
c00213c3:	eb cb                	jmp    c0021390 <blocked_thread_check+0xe>
  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c00213c5:	83 f9 00             	cmp    $0x0,%ecx
c00213c8:	76 c6                	jbe    c0021390 <blocked_thread_check+0xe>
c00213ca:	eb d7                	jmp    c00213a3 <blocked_thread_check+0x21>

c00213cc <thread_hold_the_lock>:

void thread_hold_the_lock(struct lock *lock) {
c00213cc:	57                   	push   %edi
c00213cd:	56                   	push   %esi
c00213ce:	53                   	push   %ebx
c00213cf:	e8 67 c5 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00213d4:	81 c3 f8 80 01 00    	add    $0x180f8,%ebx
c00213da:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable();
c00213de:	e8 63 07 00 00       	call   c0021b46 <intr_disable>
c00213e3:	89 c7                	mov    %eax,%edi
  list_insert_ordered(&thread_current ()->locks, &lock->elem, lock_cmp_priority, NULL);
c00213e5:	e8 99 f7 ff ff       	call   c0020b83 <thread_current>
c00213ea:	6a 00                	push   $0x0
c00213ec:	ff b3 fc ff ff ff    	pushl  -0x4(%ebx)
c00213f2:	8d 56 18             	lea    0x18(%esi),%edx
c00213f5:	52                   	push   %edx
c00213f6:	83 c0 40             	add    $0x40,%eax
c00213f9:	50                   	push   %eax
c00213fa:	e8 55 87 00 00       	call   c0029b54 <list_insert_ordered>

  if (lock->max_priority > thread_current()->priority) {
c00213ff:	8b 76 20             	mov    0x20(%esi),%esi
c0021402:	e8 7c f7 ff ff       	call   c0020b83 <thread_current>
c0021407:	83 c4 10             	add    $0x10,%esp
c002140a:	3b 70 1c             	cmp    0x1c(%eax),%esi
c002140d:	7f 10                	jg     c002141f <thread_hold_the_lock+0x53>
    thread_current()->priority = lock->max_priority;
    thread_yield();
  }

  intr_set_level(old_level);
c002140f:	83 ec 0c             	sub    $0xc,%esp
c0021412:	57                   	push   %edi
c0021413:	e8 35 07 00 00       	call   c0021b4d <intr_set_level>
}
c0021418:	83 c4 10             	add    $0x10,%esp
c002141b:	5b                   	pop    %ebx
c002141c:	5e                   	pop    %esi
c002141d:	5f                   	pop    %edi
c002141e:	c3                   	ret    
    thread_current()->priority = lock->max_priority;
c002141f:	89 70 1c             	mov    %esi,0x1c(%eax)
    thread_yield();
c0021422:	e8 a6 fc ff ff       	call   c00210cd <thread_yield>
c0021427:	eb e6                	jmp    c002140f <thread_hold_the_lock+0x43>

c0021429 <thread_update_priority>:
    list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
  }
  intr_set_level(old_level);
}

void thread_update_priority (struct thread *t) {
c0021429:	55                   	push   %ebp
c002142a:	57                   	push   %edi
c002142b:	56                   	push   %esi
c002142c:	53                   	push   %ebx
c002142d:	83 ec 1c             	sub    $0x1c,%esp
c0021430:	e8 06 c5 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021435:	81 c3 97 80 01 00    	add    $0x18097,%ebx
c002143b:	8b 74 24 30          	mov    0x30(%esp),%esi
  enum intr_level old_level = intr_disable();
c002143f:	e8 02 07 00 00       	call   c0021b46 <intr_disable>
c0021444:	89 44 24 0c          	mov    %eax,0xc(%esp)
  int max_priority = t->base_priority;
c0021448:	8b 7e 3c             	mov    0x3c(%esi),%edi
  int lock_priority;

  if (!list_empty(&t->locks)) {
c002144b:	8d 6e 40             	lea    0x40(%esi),%ebp
c002144e:	83 ec 0c             	sub    $0xc,%esp
c0021451:	55                   	push   %ebp
c0021452:	e8 aa 82 00 00       	call   c0029701 <list_empty>
c0021457:	83 c4 10             	add    $0x10,%esp
c002145a:	84 c0                	test   %al,%al
c002145c:	74 17                	je     c0021475 <thread_update_priority+0x4c>
    lock_priority = list_entry(list_front (&t->locks), struct lock, elem)->max_priority;
    if (lock_priority > max_priority)
      max_priority = lock_priority;
  }

  t->priority = max_priority;
c002145e:	89 7e 1c             	mov    %edi,0x1c(%esi)
  intr_set_level(old_level);
c0021461:	83 ec 0c             	sub    $0xc,%esp
c0021464:	ff 74 24 18          	pushl  0x18(%esp)
c0021468:	e8 e0 06 00 00       	call   c0021b4d <intr_set_level>
}
c002146d:	83 c4 2c             	add    $0x2c,%esp
c0021470:	5b                   	pop    %ebx
c0021471:	5e                   	pop    %esi
c0021472:	5f                   	pop    %edi
c0021473:	5d                   	pop    %ebp
c0021474:	c3                   	ret    
    list_sort(&t->locks, lock_cmp_priority, NULL);
c0021475:	83 ec 04             	sub    $0x4,%esp
c0021478:	6a 00                	push   $0x0
c002147a:	ff b3 fc ff ff ff    	pushl  -0x4(%ebx)
c0021480:	55                   	push   %ebp
c0021481:	e8 e1 83 00 00       	call   c0029867 <list_sort>
    lock_priority = list_entry(list_front (&t->locks), struct lock, elem)->max_priority;
c0021486:	89 2c 24             	mov    %ebp,(%esp)
c0021489:	e8 97 82 00 00       	call   c0029725 <list_front>
c002148e:	8b 40 08             	mov    0x8(%eax),%eax
c0021491:	83 c4 10             	add    $0x10,%esp
c0021494:	39 c7                	cmp    %eax,%edi
c0021496:	0f 4c f8             	cmovl  %eax,%edi
c0021499:	eb c3                	jmp    c002145e <thread_update_priority+0x35>

c002149b <thread_remove_lock>:
void thread_remove_lock(struct lock *lock) {
c002149b:	56                   	push   %esi
c002149c:	53                   	push   %ebx
c002149d:	83 ec 04             	sub    $0x4,%esp
c00214a0:	e8 96 c4 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00214a5:	81 c3 27 80 01 00    	add    $0x18027,%ebx
  enum intr_level old_level = intr_disable();
c00214ab:	e8 96 06 00 00       	call   c0021b46 <intr_disable>
c00214b0:	89 c6                	mov    %eax,%esi
  list_remove(&lock->elem);
c00214b2:	83 ec 0c             	sub    $0xc,%esp
c00214b5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00214b9:	83 c0 18             	add    $0x18,%eax
c00214bc:	50                   	push   %eax
c00214bd:	e8 9d 81 00 00       	call   c002965f <list_remove>
  thread_update_priority(thread_current());
c00214c2:	e8 bc f6 ff ff       	call   c0020b83 <thread_current>
c00214c7:	89 04 24             	mov    %eax,(%esp)
c00214ca:	e8 5a ff ff ff       	call   c0021429 <thread_update_priority>
  intr_set_level(old_level);
c00214cf:	89 34 24             	mov    %esi,(%esp)
c00214d2:	e8 76 06 00 00       	call   c0021b4d <intr_set_level>
}
c00214d7:	83 c4 14             	add    $0x14,%esp
c00214da:	5b                   	pop    %ebx
c00214db:	5e                   	pop    %esi
c00214dc:	c3                   	ret    

c00214dd <thread_donate_priority>:
void thread_donate_priority (struct thread *t) {
c00214dd:	57                   	push   %edi
c00214de:	56                   	push   %esi
c00214df:	53                   	push   %ebx
c00214e0:	e8 56 c4 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00214e5:	81 c3 e7 7f 01 00    	add    $0x17fe7,%ebx
c00214eb:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable();
c00214ef:	e8 52 06 00 00       	call   c0021b46 <intr_disable>
c00214f4:	89 c7                	mov    %eax,%edi
  thread_update_priority(t);
c00214f6:	83 ec 0c             	sub    $0xc,%esp
c00214f9:	56                   	push   %esi
c00214fa:	e8 2a ff ff ff       	call   c0021429 <thread_update_priority>
  if (t->status == THREAD_READY) {
c00214ff:	83 c4 10             	add    $0x10,%esp
c0021502:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
c0021506:	74 10                	je     c0021518 <thread_donate_priority+0x3b>
  intr_set_level(old_level);
c0021508:	83 ec 0c             	sub    $0xc,%esp
c002150b:	57                   	push   %edi
c002150c:	e8 3c 06 00 00       	call   c0021b4d <intr_set_level>
}
c0021511:	83 c4 10             	add    $0x10,%esp
c0021514:	5b                   	pop    %ebx
c0021515:	5e                   	pop    %esi
c0021516:	5f                   	pop    %edi
c0021517:	c3                   	ret    
    list_remove(&t->elem);
c0021518:	83 c6 28             	add    $0x28,%esi
c002151b:	83 ec 0c             	sub    $0xc,%esp
c002151e:	56                   	push   %esi
c002151f:	e8 3b 81 00 00       	call   c002965f <list_remove>
    list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
c0021524:	6a 00                	push   $0x0
c0021526:	8d 83 d6 72 fe ff    	lea    -0x18d2a(%ebx),%eax
c002152c:	50                   	push   %eax
c002152d:	56                   	push   %esi
c002152e:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
c0021534:	50                   	push   %eax
c0021535:	e8 1a 86 00 00       	call   c0029b54 <list_insert_ordered>
c002153a:	83 c4 20             	add    $0x20,%esp
c002153d:	eb c9                	jmp    c0021508 <thread_donate_priority+0x2b>

c002153f <thread_mlfqs_increase_recent_cpu_by_one>:

void thread_mlfqs_increase_recent_cpu_by_one (void) {
c002153f:	53                   	push   %ebx
c0021540:	83 ec 08             	sub    $0x8,%esp
c0021543:	e8 f3 c3 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021548:	81 c3 84 7f 01 00    	add    $0x17f84,%ebx
  ASSERT(thread_mlfqs);
c002154e:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c0021554:	80 38 00             	cmpb   $0x0,(%eax)
c0021557:	74 22                	je     c002157b <thread_mlfqs_increase_recent_cpu_by_one+0x3c>
  ASSERT(intr_context());
c0021559:	e8 8c 08 00 00       	call   c0021dea <intr_context>
c002155e:	84 c0                	test   %al,%al
c0021560:	74 42                	je     c00215a4 <thread_mlfqs_increase_recent_cpu_by_one+0x65>

  struct thread *current_thread = thread_current();
c0021562:	e8 1c f6 ff ff       	call   c0020b83 <thread_current>
  if (current_thread == idle_thread)
c0021567:	39 83 3c 08 00 00    	cmp    %eax,0x83c(%ebx)
c002156d:	74 07                	je     c0021576 <thread_mlfqs_increase_recent_cpu_by_one+0x37>
    return;
  current_thread->recent_cpu = FP_ADD_MIX(current_thread->recent_cpu, 1);
c002156f:	81 40 58 00 00 01 00 	addl   $0x10000,0x58(%eax)
}
c0021576:	83 c4 08             	add    $0x8,%esp
c0021579:	5b                   	pop    %ebx
c002157a:	c3                   	ret    
  ASSERT(thread_mlfqs);
c002157b:	83 ec 0c             	sub    $0xc,%esp
c002157e:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c0021584:	50                   	push   %eax
c0021585:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002158b:	50                   	push   %eax
c002158c:	8d 83 54 45 ff ff    	lea    -0xbaac(%ebx),%eax
c0021592:	50                   	push   %eax
c0021593:	68 f1 02 00 00       	push   $0x2f1
c0021598:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c002159e:	50                   	push   %eax
c002159f:	e8 eb 79 00 00       	call   c0028f8f <debug_panic>
  ASSERT(intr_context());
c00215a4:	83 ec 0c             	sub    $0xc,%esp
c00215a7:	8d 83 fd 59 ff ff    	lea    -0xa603(%ebx),%eax
c00215ad:	50                   	push   %eax
c00215ae:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00215b4:	50                   	push   %eax
c00215b5:	8d 83 54 45 ff ff    	lea    -0xbaac(%ebx),%eax
c00215bb:	50                   	push   %eax
c00215bc:	68 f2 02 00 00       	push   $0x2f2
c00215c1:	8d 83 0e 59 ff ff    	lea    -0xa6f2(%ebx),%eax
c00215c7:	50                   	push   %eax
c00215c8:	e8 c2 79 00 00       	call   c0028f8f <debug_panic>

c00215cd <thread_mlfqs_update_priority>:

void thread_mlfqs_update_priority(struct thread *t) {
c00215cd:	53                   	push   %ebx
c00215ce:	83 ec 08             	sub    $0x8,%esp
c00215d1:	e8 65 c3 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00215d6:	81 c3 f6 7e 01 00    	add    $0x17ef6,%ebx
c00215dc:	8b 54 24 10          	mov    0x10(%esp),%edx
  if (t == idle_thread)
c00215e0:	39 93 3c 08 00 00    	cmp    %edx,0x83c(%ebx)
c00215e6:	74 45                	je     c002162d <thread_mlfqs_update_priority+0x60>
    return;

  ASSERT(thread_mlfqs);
c00215e8:	c7 c1 e0 b8 03 c0    	mov    $0xc003b8e0,%ecx
c00215ee:	80 39 00             	cmpb   $0x0,(%ecx)
c00215f1:	74 3f                	je     c0021632 <thread_mlfqs_update_priority+0x65>
  ASSERT(t != idle_thread);

  t->priority = FP_INT_PART(FP_SUB_MIX(FP_SUB(FP_CONST(PRI_MAX), FP_DIV_MIX(t->recent_cpu, 4)), 2 * t->nice));
c00215f3:	8b 4a 58             	mov    0x58(%edx),%ecx
c00215f6:	8d 41 03             	lea    0x3(%ecx),%eax
c00215f9:	85 c9                	test   %ecx,%ecx
c00215fb:	0f 49 c1             	cmovns %ecx,%eax
c00215fe:	c1 f8 02             	sar    $0x2,%eax
c0021601:	f7 d8                	neg    %eax
c0021603:	05 00 00 3f 00       	add    $0x3f0000,%eax
c0021608:	8b 4a 54             	mov    0x54(%edx),%ecx
c002160b:	c1 e1 11             	shl    $0x11,%ecx
c002160e:	29 c8                	sub    %ecx,%eax
c0021610:	c1 f8 10             	sar    $0x10,%eax
c0021613:	89 c1                	mov    %eax,%ecx
  t->priority = t->priority < PRI_MIN ? PRI_MIN : t->priority;
c0021615:	85 c0                	test   %eax,%eax
c0021617:	b8 00 00 00 00       	mov    $0x0,%eax
c002161c:	0f 49 c1             	cmovns %ecx,%eax
  t->priority = t->priority > PRI_MAX ? PRI_MAX : t->priority;
c002161f:	83 f8 3f             	cmp    $0x3f,%eax
c0021622:	b9 3f 00 00 00       	mov    $0x3f,%ecx
c0021627:	0f 4f c1             	cmovg  %ecx,%eax
c002162a:	89 42 1c             	mov    %eax,0x1c(%edx)
}
c002162d:	83 c4 08             	add    $0x8,%esp
c0021630:	5b                   	pop    %ebx
c0021631:	c3                   	ret    
  ASSERT(thread_mlfqs);
c0021632:	83 ec 0c             	sub    $0xc,%esp
c0021635:	8d 93 b9 74 ff ff    	lea    -0x8b47(%ebx),%edx
c002163b:	52                   	push   %edx
c002163c:	8d 93 eb 55 ff ff    	lea    -0xaa15(%ebx),%edx
c0021642:	52                   	push   %edx
c0021643:	8d 93 20 45 ff ff    	lea    -0xbae0(%ebx),%edx
c0021649:	52                   	push   %edx
c002164a:	68 fe 02 00 00       	push   $0x2fe
c002164f:	8d 93 0e 59 ff ff    	lea    -0xa6f2(%ebx),%edx
c0021655:	52                   	push   %edx
c0021656:	e8 34 79 00 00       	call   c0028f8f <debug_panic>

c002165b <thread_set_nice>:
{
c002165b:	83 ec 0c             	sub    $0xc,%esp
  thread_current()->nice = nice;
c002165e:	e8 20 f5 ff ff       	call   c0020b83 <thread_current>
c0021663:	8b 54 24 10          	mov    0x10(%esp),%edx
c0021667:	89 50 54             	mov    %edx,0x54(%eax)
  thread_mlfqs_update_priority(thread_current());
c002166a:	e8 14 f5 ff ff       	call   c0020b83 <thread_current>
c002166f:	83 ec 0c             	sub    $0xc,%esp
c0021672:	50                   	push   %eax
c0021673:	e8 55 ff ff ff       	call   c00215cd <thread_mlfqs_update_priority>
  thread_yield();
c0021678:	e8 50 fa ff ff       	call   c00210cd <thread_yield>
}
c002167d:	83 c4 1c             	add    $0x1c,%esp
c0021680:	c3                   	ret    

c0021681 <thread_mlfqs_update_load_avg_and_recent_cpu>:

void thread_mlfqs_update_load_avg_and_recent_cpu(void) {
c0021681:	55                   	push   %ebp
c0021682:	57                   	push   %edi
c0021683:	56                   	push   %esi
c0021684:	53                   	push   %ebx
c0021685:	83 ec 2c             	sub    $0x2c,%esp
c0021688:	e8 b6 c2 00 00       	call   c002d943 <__x86.get_pc_thunk.di>
c002168d:	81 c7 3f 7e 01 00    	add    $0x17e3f,%edi
  ASSERT(thread_mlfqs);
c0021693:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c0021699:	80 38 00             	cmpb   $0x0,(%eax)
c002169c:	0f 84 91 00 00 00    	je     c0021733 <thread_mlfqs_update_load_avg_and_recent_cpu+0xb2>
  ASSERT(intr_context());
c00216a2:	89 fb                	mov    %edi,%ebx
c00216a4:	e8 41 07 00 00       	call   c0021dea <intr_context>
c00216a9:	84 c0                	test   %al,%al
c00216ab:	0f 84 ad 00 00 00    	je     c002175e <thread_mlfqs_update_load_avg_and_recent_cpu+0xdd>

  size_t ready_threads = list_size(&ready_list);
c00216b1:	83 ec 0c             	sub    $0xc,%esp
c00216b4:	8d 87 50 08 00 00    	lea    0x850(%edi),%eax
c00216ba:	50                   	push   %eax
c00216bb:	e8 fe 7f 00 00       	call   c00296be <list_size>
c00216c0:	89 c6                	mov    %eax,%esi
  if (thread_current() != idle_thread)
c00216c2:	e8 bc f4 ff ff       	call   c0020b83 <thread_current>
    ready_threads++;
c00216c7:	3b 87 3c 08 00 00    	cmp    0x83c(%edi),%eax
c00216cd:	0f 95 c0             	setne  %al
c00216d0:	0f b6 c0             	movzbl %al,%eax
c00216d3:	01 c6                	add    %eax,%esi
  load_avg = FP_ADD(FP_DIV_MIX(FP_MULT_MIX(load_avg, 59), 60), FP_DIV_MIX(FP_CONST(ready_threads), 60));
c00216d5:	c7 c1 dc b8 03 c0    	mov    $0xc003b8dc,%ecx
c00216db:	6b 29 3b             	imul   $0x3b,(%ecx),%ebp
c00216de:	b8 89 88 88 88       	mov    $0x88888889,%eax
c00216e3:	f7 ed                	imul   %ebp
c00216e5:	8d 1c 2a             	lea    (%edx,%ebp,1),%ebx
c00216e8:	c1 fb 05             	sar    $0x5,%ebx
c00216eb:	c1 fd 1f             	sar    $0x1f,%ebp
c00216ee:	29 eb                	sub    %ebp,%ebx
c00216f0:	c1 e6 10             	shl    $0x10,%esi
c00216f3:	b8 89 88 88 88       	mov    $0x88888889,%eax
c00216f8:	f7 ee                	imul   %esi
c00216fa:	01 f2                	add    %esi,%edx
c00216fc:	c1 fa 05             	sar    $0x5,%edx
c00216ff:	c1 fe 1f             	sar    $0x1f,%esi
c0021702:	29 f2                	sub    %esi,%edx
c0021704:	01 d3                	add    %edx,%ebx
c0021706:	89 19                	mov    %ebx,(%ecx)

  struct thread *t;
  struct list_elem *e = list_begin(&all_list);
c0021708:	8d 87 40 08 00 00    	lea    0x840(%edi),%eax
c002170e:	89 04 24             	mov    %eax,(%esp)
c0021711:	89 fb                	mov    %edi,%ebx
c0021713:	e8 9c 79 00 00       	call   c00290b4 <list_begin>
c0021718:	89 c5                	mov    %eax,%ebp

  for (; e != list_end(&all_list); e = list_next(e)) {
c002171a:	83 c4 10             	add    $0x10,%esp
c002171d:	8d 87 40 08 00 00    	lea    0x840(%edi),%eax
c0021723:	89 44 24 18          	mov    %eax,0x18(%esp)
    t = list_entry(e, struct thread, allelem);
    if (t != idle_thread) {
      t->recent_cpu = FP_ADD_MIX(FP_MULT(FP_DIV(FP_MULT_MIX(load_avg, 2), FP_ADD_MIX(FP_MULT_MIX(load_avg, 2), 1)), t->recent_cpu), t->nice);
c0021727:	c7 c0 dc b8 03 c0    	mov    $0xc003b8dc,%eax
c002172d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  for (; e != list_end(&all_list); e = list_next(e)) {
c0021731:	eb 64                	jmp    c0021797 <thread_mlfqs_update_load_avg_and_recent_cpu+0x116>
  ASSERT(thread_mlfqs);
c0021733:	83 ec 0c             	sub    $0xc,%esp
c0021736:	8d 87 b9 74 ff ff    	lea    -0x8b47(%edi),%eax
c002173c:	50                   	push   %eax
c002173d:	8d 87 eb 55 ff ff    	lea    -0xaa15(%edi),%eax
c0021743:	50                   	push   %eax
c0021744:	8d 87 f4 44 ff ff    	lea    -0xbb0c(%edi),%eax
c002174a:	50                   	push   %eax
c002174b:	68 07 03 00 00       	push   $0x307
c0021750:	8d 87 0e 59 ff ff    	lea    -0xa6f2(%edi),%eax
c0021756:	50                   	push   %eax
c0021757:	89 fb                	mov    %edi,%ebx
c0021759:	e8 31 78 00 00       	call   c0028f8f <debug_panic>
  ASSERT(intr_context());
c002175e:	83 ec 0c             	sub    $0xc,%esp
c0021761:	8d 87 fd 59 ff ff    	lea    -0xa603(%edi),%eax
c0021767:	50                   	push   %eax
c0021768:	8d 87 eb 55 ff ff    	lea    -0xaa15(%edi),%eax
c002176e:	50                   	push   %eax
c002176f:	8d 87 f4 44 ff ff    	lea    -0xbb0c(%edi),%eax
c0021775:	50                   	push   %eax
c0021776:	68 08 03 00 00       	push   $0x308
c002177b:	8d 87 0e 59 ff ff    	lea    -0xa6f2(%edi),%eax
c0021781:	50                   	push   %eax
c0021782:	e8 08 78 00 00       	call   c0028f8f <debug_panic>
  for (; e != list_end(&all_list); e = list_next(e)) {
c0021787:	83 ec 0c             	sub    $0xc,%esp
c002178a:	55                   	push   %ebp
c002178b:	89 fb                	mov    %edi,%ebx
c002178d:	e8 67 79 00 00       	call   c00290f9 <list_next>
c0021792:	89 c5                	mov    %eax,%ebp
c0021794:	83 c4 10             	add    $0x10,%esp
c0021797:	83 ec 0c             	sub    $0xc,%esp
c002179a:	ff 74 24 24          	pushl  0x24(%esp)
c002179e:	89 fb                	mov    %edi,%ebx
c00217a0:	e8 b1 79 00 00       	call   c0029156 <list_end>
c00217a5:	83 c4 10             	add    $0x10,%esp
c00217a8:	39 e8                	cmp    %ebp,%eax
c00217aa:	0f 84 87 00 00 00    	je     c0021837 <thread_mlfqs_update_load_avg_and_recent_cpu+0x1b6>
    t = list_entry(e, struct thread, allelem);
c00217b0:	8d 75 e0             	lea    -0x20(%ebp),%esi
    if (t != idle_thread) {
c00217b3:	39 b7 3c 08 00 00    	cmp    %esi,0x83c(%edi)
c00217b9:	74 cc                	je     c0021787 <thread_mlfqs_update_load_avg_and_recent_cpu+0x106>
      t->recent_cpu = FP_ADD_MIX(FP_MULT(FP_DIV(FP_MULT_MIX(load_avg, 2), FP_ADD_MIX(FP_MULT_MIX(load_avg, 2), 1)), t->recent_cpu), t->nice);
c00217bb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00217bf:	8b 00                	mov    (%eax),%eax
c00217c1:	89 44 24 08          	mov    %eax,0x8(%esp)
c00217c5:	01 c0                	add    %eax,%eax
c00217c7:	89 c1                	mov    %eax,%ecx
c00217c9:	89 c3                	mov    %eax,%ebx
c00217cb:	c1 fb 1f             	sar    $0x1f,%ebx
c00217ce:	0f a4 c3 10          	shld   $0x10,%eax,%ebx
c00217d2:	c1 e1 10             	shl    $0x10,%ecx
c00217d5:	05 00 00 01 00       	add    $0x10000,%eax
c00217da:	99                   	cltd   
c00217db:	52                   	push   %edx
c00217dc:	50                   	push   %eax
c00217dd:	53                   	push   %ebx
c00217de:	51                   	push   %ecx
c00217df:	89 fb                	mov    %edi,%ebx
c00217e1:	e8 6c 71 00 00       	call   c0028952 <__divdi3>
c00217e6:	89 c1                	mov    %eax,%ecx
c00217e8:	c1 f9 1f             	sar    $0x1f,%ecx
c00217eb:	89 44 24 20          	mov    %eax,0x20(%esp)
c00217ef:	89 4c 24 24          	mov    %ecx,0x24(%esp)
c00217f3:	8b 55 38             	mov    0x38(%ebp),%edx
c00217f6:	89 d3                	mov    %edx,%ebx
c00217f8:	c1 fb 1f             	sar    $0x1f,%ebx
c00217fb:	89 54 24 18          	mov    %edx,0x18(%esp)
c00217ff:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
c0021803:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021807:	0f af ca             	imul   %edx,%ecx
c002180a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c002180e:	0f af d8             	imul   %eax,%ebx
c0021811:	01 d9                	add    %ebx,%ecx
c0021813:	f7 e2                	mul    %edx
c0021815:	01 ca                	add    %ecx,%edx
c0021817:	0f ac d0 10          	shrd   $0x10,%edx,%eax
c002181b:	8b 55 34             	mov    0x34(%ebp),%edx
c002181e:	c1 e2 10             	shl    $0x10,%edx
c0021821:	8d 04 10             	lea    (%eax,%edx,1),%eax
c0021824:	89 45 38             	mov    %eax,0x38(%ebp)
      thread_mlfqs_update_priority(t);
c0021827:	89 34 24             	mov    %esi,(%esp)
c002182a:	e8 9e fd ff ff       	call   c00215cd <thread_mlfqs_update_priority>
c002182f:	83 c4 10             	add    $0x10,%esp
c0021832:	e9 50 ff ff ff       	jmp    c0021787 <thread_mlfqs_update_load_avg_and_recent_cpu+0x106>
    }
  }
}
c0021837:	83 c4 2c             	add    $0x2c,%esp
c002183a:	5b                   	pop    %ebx
c002183b:	5e                   	pop    %esi
c002183c:	5f                   	pop    %edi
c002183d:	5d                   	pop    %ebp
c002183e:	c3                   	ret    

c002183f <thread_get_child_message>:

struct child_message *thread_get_child_message(tid_t tid) {
c002183f:	55                   	push   %ebp
c0021840:	57                   	push   %edi
c0021841:	56                   	push   %esi
c0021842:	53                   	push   %ebx
c0021843:	83 ec 18             	sub    $0x18,%esp
c0021846:	e8 f0 c0 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002184b:	81 c3 81 7c 01 00    	add    $0x17c81,%ebx
c0021851:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  struct list_elem *e;
  struct child_message *l;
  for (e = list_rbegin(&children); e != list_rend(&children); e = list_prev(e)) {
c0021855:	8d 83 70 08 00 00    	lea    0x870(%ebx),%eax
c002185b:	50                   	push   %eax
c002185c:	e8 3a 79 00 00       	call   c002919b <list_rbegin>
c0021861:	89 c6                	mov    %eax,%esi
c0021863:	83 c4 10             	add    $0x10,%esp
c0021866:	8d bb 70 08 00 00    	lea    0x870(%ebx),%edi
c002186c:	83 ec 0c             	sub    $0xc,%esp
c002186f:	57                   	push   %edi
c0021870:	e8 41 7b 00 00       	call   c00293b6 <list_rend>
c0021875:	83 c4 10             	add    $0x10,%esp
c0021878:	39 f0                	cmp    %esi,%eax
c002187a:	74 1a                	je     c0021896 <thread_get_child_message+0x57>
    l = list_entry(e, struct child_message, allelem);
    if (l->tid == tid)
c002187c:	39 6e e4             	cmp    %ebp,-0x1c(%esi)
c002187f:	74 10                	je     c0021891 <thread_get_child_message+0x52>
  for (e = list_rbegin(&children); e != list_rend(&children); e = list_prev(e)) {
c0021881:	83 ec 0c             	sub    $0xc,%esp
c0021884:	56                   	push   %esi
c0021885:	e8 56 79 00 00       	call   c00291e0 <list_prev>
c002188a:	89 c6                	mov    %eax,%esi
c002188c:	83 c4 10             	add    $0x10,%esp
c002188f:	eb db                	jmp    c002186c <thread_get_child_message+0x2d>
    l = list_entry(e, struct child_message, allelem);
c0021891:	8d 46 e0             	lea    -0x20(%esi),%eax
c0021894:	eb 05                	jmp    c002189b <thread_get_child_message+0x5c>
      return l;
  }
  return NULL;
c0021896:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002189b:	83 c4 0c             	add    $0xc,%esp
c002189e:	5b                   	pop    %ebx
c002189f:	5e                   	pop    %esi
c00218a0:	5f                   	pop    %edi
c00218a1:	5d                   	pop    %ebp
c00218a2:	c3                   	ret    

c00218a3 <thread_exit_with_return_value>:

void thread_exit_with_return_value(struct intr_frame *f, int return_value) {
c00218a3:	53                   	push   %ebx
c00218a4:	83 ec 08             	sub    $0x8,%esp
c00218a7:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct thread *cur = thread_current();
c00218ab:	e8 d3 f2 ff ff       	call   c0020b83 <thread_current>
  cur->return_value = return_value;
c00218b0:	89 58 5c             	mov    %ebx,0x5c(%eax)
  f->eax = (uint32_t)return_value;
c00218b3:	8b 44 24 10          	mov    0x10(%esp),%eax
c00218b7:	89 58 1c             	mov    %ebx,0x1c(%eax)
  thread_exit();
c00218ba:	e8 33 f7 ff ff       	call   c0020ff2 <thread_exit>

c00218bf <thread_file_list_inster>:
}

void thread_file_list_inster(struct file_handle* fh) {
c00218bf:	53                   	push   %ebx
c00218c0:	83 ec 10             	sub    $0x10,%esp
c00218c3:	e8 73 c0 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00218c8:	81 c3 04 7c 01 00    	add    $0x17c04,%ebx
  list_push_back(&file_list, &(fh->elem));
c00218ce:	8b 44 24 18          	mov    0x18(%esp),%eax
c00218d2:	83 c0 0c             	add    $0xc,%eax
c00218d5:	50                   	push   %eax
c00218d6:	8d 83 60 08 00 00    	lea    0x860(%ebx),%eax
c00218dc:	50                   	push   %eax
c00218dd:	e8 60 7d 00 00       	call   c0029642 <list_push_back>
}
c00218e2:	83 c4 18             	add    $0x18,%esp
c00218e5:	5b                   	pop    %ebx
c00218e6:	c3                   	ret    

c00218e7 <syscall_get_file_handle>:

struct file_handle* syscall_get_file_handle(int fd) {
c00218e7:	55                   	push   %ebp
c00218e8:	57                   	push   %edi
c00218e9:	56                   	push   %esi
c00218ea:	53                   	push   %ebx
c00218eb:	83 ec 1c             	sub    $0x1c,%esp
c00218ee:	e8 48 c0 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00218f3:	81 c3 d9 7b 01 00    	add    $0x17bd9,%ebx
c00218f9:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  struct thread* cur =  thread_current();
c00218fd:	e8 81 f2 ff ff       	call   c0020b83 <thread_current>
c0021902:	89 44 24 0c          	mov    %eax,0xc(%esp)
  struct list_elem* i;
  for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i)) {
c0021906:	83 ec 0c             	sub    $0xc,%esp
c0021909:	8d 83 60 08 00 00    	lea    0x860(%ebx),%eax
c002190f:	50                   	push   %eax
c0021910:	e8 9f 77 00 00       	call   c00290b4 <list_begin>
c0021915:	89 c6                	mov    %eax,%esi
c0021917:	83 c4 10             	add    $0x10,%esp
c002191a:	8d bb 60 08 00 00    	lea    0x860(%ebx),%edi
c0021920:	83 ec 0c             	sub    $0xc,%esp
c0021923:	57                   	push   %edi
c0021924:	e8 2d 78 00 00       	call   c0029156 <list_end>
c0021929:	83 c4 10             	add    $0x10,%esp
c002192c:	39 f0                	cmp    %esi,%eax
c002192e:	74 23                	je     c0021953 <syscall_get_file_handle+0x6c>
    struct file_handle* t;
    t = list_entry(i, struct file_handle, elem);
    if (t->fd == fd){
c0021930:	39 6e f4             	cmp    %ebp,-0xc(%esi)
c0021933:	74 10                	je     c0021945 <syscall_get_file_handle+0x5e>
  for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i)) {
c0021935:	83 ec 0c             	sub    $0xc,%esp
c0021938:	56                   	push   %esi
c0021939:	e8 bb 77 00 00       	call   c00290f9 <list_next>
c002193e:	89 c6                	mov    %eax,%esi
c0021940:	83 c4 10             	add    $0x10,%esp
c0021943:	eb db                	jmp    c0021920 <syscall_get_file_handle+0x39>
      if (t->owned_thread != cur)
c0021945:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0021949:	39 46 fc             	cmp    %eax,-0x4(%esi)
c002194c:	75 12                	jne    c0021960 <syscall_get_file_handle+0x79>
    t = list_entry(i, struct file_handle, elem);
c002194e:	8d 46 f4             	lea    -0xc(%esi),%eax
        return NULL;
      else
        return t;
c0021951:	eb 05                	jmp    c0021958 <syscall_get_file_handle+0x71>
    }
  }
  return NULL;
c0021953:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021958:	83 c4 1c             	add    $0x1c,%esp
c002195b:	5b                   	pop    %ebx
c002195c:	5e                   	pop    %esi
c002195d:	5f                   	pop    %edi
c002195e:	5d                   	pop    %ebp
c002195f:	c3                   	ret    
        return NULL;
c0021960:	b8 00 00 00 00       	mov    $0x0,%eax
c0021965:	eb f1                	jmp    c0021958 <syscall_get_file_handle+0x71>

c0021967 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021967:	53                   	push   %ebx
	pushl %ebp
c0021968:	55                   	push   %ebp
	pushl %esi
c0021969:	56                   	push   %esi
	pushl %edi
c002196a:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c002196b:	8b 15 b8 90 03 c0    	mov    0xc00390b8,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021971:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021975:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021978:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c002197c:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c002197f:	5f                   	pop    %edi
	popl %esi
c0021980:	5e                   	pop    %esi
	popl %ebp
c0021981:	5d                   	pop    %ebp
	popl %ebx
c0021982:	5b                   	pop    %ebx
        ret
c0021983:	c3                   	ret    

c0021984 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021984:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021987:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021988:	e8 ed f3 ff ff       	call   c0020d7a <thread_schedule_tail>
	addl $4, %esp
c002198d:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021990:	c3                   	ret    

c0021991 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c0021991:	53                   	push   %ebx
c0021992:	83 ec 08             	sub    $0x8,%esp
c0021995:	e8 a1 bf 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002199a:	81 c3 32 7b 01 00    	add    $0x17b32,%ebx
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00219a0:	85 c0                	test   %eax,%eax
c00219a2:	74 2a                	je     c00219ce <make_gate+0x3d>
  ASSERT (dpl >= 0 && dpl <= 3);
c00219a4:	83 fa 03             	cmp    $0x3,%edx
c00219a7:	77 4e                	ja     c00219f7 <make_gate+0x66>
  ASSERT (type >= 0 && type <= 15);
c00219a9:	83 f9 0f             	cmp    $0xf,%ecx
c00219ac:	77 72                	ja     c0021a20 <make_gate+0x8f>

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c00219ae:	c1 e1 08             	shl    $0x8,%ecx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00219b1:	80 cd 80             	or     $0x80,%ch
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c00219b4:	c1 e2 0d             	shl    $0xd,%edx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00219b7:	09 ca                	or     %ecx,%edx
c00219b9:	89 c1                	mov    %eax,%ecx
c00219bb:	66 b9 00 00          	mov    $0x0,%cx
c00219bf:	09 ca                	or     %ecx,%edx
  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c00219c1:	0f b7 c0             	movzwl %ax,%eax
c00219c4:	0d 00 00 08 00       	or     $0x80000,%eax

  return e0 | ((uint64_t) e1 << 32);
}
c00219c9:	83 c4 08             	add    $0x8,%esp
c00219cc:	5b                   	pop    %ebx
c00219cd:	c3                   	ret    
  ASSERT (function != NULL);
c00219ce:	83 ec 0c             	sub    $0xc,%esp
c00219d1:	8d 83 e7 59 ff ff    	lea    -0xa619(%ebx),%eax
c00219d7:	50                   	push   %eax
c00219d8:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00219de:	50                   	push   %eax
c00219df:	8d 83 bc 46 ff ff    	lea    -0xb944(%ebx),%eax
c00219e5:	50                   	push   %eax
c00219e6:	68 2a 01 00 00       	push   $0x12a
c00219eb:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c00219f1:	50                   	push   %eax
c00219f2:	e8 98 75 00 00       	call   c0028f8f <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c00219f7:	83 ec 0c             	sub    $0xc,%esp
c00219fa:	8d 83 b4 5a ff ff    	lea    -0xa54c(%ebx),%eax
c0021a00:	50                   	push   %eax
c0021a01:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021a07:	50                   	push   %eax
c0021a08:	8d 83 bc 46 ff ff    	lea    -0xb944(%ebx),%eax
c0021a0e:	50                   	push   %eax
c0021a0f:	68 2b 01 00 00       	push   $0x12b
c0021a14:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021a1a:	50                   	push   %eax
c0021a1b:	e8 6f 75 00 00       	call   c0028f8f <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021a20:	83 ec 0c             	sub    $0xc,%esp
c0021a23:	8d 83 c9 5a ff ff    	lea    -0xa537(%ebx),%eax
c0021a29:	50                   	push   %eax
c0021a2a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021a30:	50                   	push   %eax
c0021a31:	8d 83 bc 46 ff ff    	lea    -0xb944(%ebx),%eax
c0021a37:	50                   	push   %eax
c0021a38:	68 2c 01 00 00       	push   $0x12c
c0021a3d:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021a43:	50                   	push   %eax
c0021a44:	e8 46 75 00 00       	call   c0028f8f <debug_panic>

c0021a49 <register_handler>:
{
c0021a49:	56                   	push   %esi
c0021a4a:	53                   	push   %ebx
c0021a4b:	83 ec 04             	sub    $0x4,%esp
c0021a4e:	e8 e8 be 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021a53:	81 c3 79 7a 01 00    	add    $0x17a79,%ebx
  ASSERT (intr_handlers[vec_no] == NULL);
c0021a59:	0f b6 f0             	movzbl %al,%esi
c0021a5c:	83 bc b3 b4 10 00 00 	cmpl   $0x0,0x10b4(%ebx,%esi,4)
c0021a63:	00 
c0021a64:	75 42                	jne    c0021aa8 <register_handler+0x5f>
  if (level == INTR_ON)
c0021a66:	83 f9 01             	cmp    $0x1,%ecx
c0021a69:	74 66                	je     c0021ad1 <register_handler+0x88>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021a6b:	c7 c0 bc 90 03 c0    	mov    $0xc00390bc,%eax
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c0021a71:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021a74:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021a79:	e8 13 ff ff ff       	call   c0021991 <make_gate>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021a7e:	89 84 f3 b4 14 00 00 	mov    %eax,0x14b4(%ebx,%esi,8)
c0021a85:	89 94 f3 b8 14 00 00 	mov    %edx,0x14b8(%ebx,%esi,8)
  intr_handlers[vec_no] = handler;
c0021a8c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021a90:	89 84 b3 b4 10 00 00 	mov    %eax,0x10b4(%ebx,%esi,4)
  intr_names[vec_no] = name;
c0021a97:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021a9b:	89 84 b3 b4 0c 00 00 	mov    %eax,0xcb4(%ebx,%esi,4)
}
c0021aa2:	83 c4 04             	add    $0x4,%esp
c0021aa5:	5b                   	pop    %ebx
c0021aa6:	5e                   	pop    %esi
c0021aa7:	c3                   	ret    
  ASSERT (intr_handlers[vec_no] == NULL);
c0021aa8:	83 ec 0c             	sub    $0xc,%esp
c0021aab:	8d 83 e1 5a ff ff    	lea    -0xa51f(%ebx),%eax
c0021ab1:	50                   	push   %eax
c0021ab2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021ab8:	50                   	push   %eax
c0021ab9:	8d 83 94 46 ff ff    	lea    -0xb96c(%ebx),%eax
c0021abf:	50                   	push   %eax
c0021ac0:	68 a8 00 00 00       	push   $0xa8
c0021ac5:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021acb:	50                   	push   %eax
c0021acc:	e8 be 74 00 00       	call   c0028f8f <debug_panic>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021ad1:	c7 c0 bc 90 03 c0    	mov    $0xc00390bc,%eax
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
c0021ad7:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021ada:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021adf:	e8 ad fe ff ff       	call   c0021991 <make_gate>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021ae4:	89 84 f3 b4 14 00 00 	mov    %eax,0x14b4(%ebx,%esi,8)
c0021aeb:	89 94 f3 b8 14 00 00 	mov    %edx,0x14b8(%ebx,%esi,8)
c0021af2:	eb 98                	jmp    c0021a8c <register_handler+0x43>

c0021af4 <intr_get_level>:
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021af4:	9c                   	pushf  
c0021af5:	58                   	pop    %eax
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021af6:	c1 e8 09             	shr    $0x9,%eax
c0021af9:	83 e0 01             	and    $0x1,%eax
}
c0021afc:	c3                   	ret    

c0021afd <intr_enable>:
{
c0021afd:	53                   	push   %ebx
c0021afe:	83 ec 08             	sub    $0x8,%esp
c0021b01:	e8 35 be 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021b06:	81 c3 c6 79 01 00    	add    $0x179c6,%ebx
  enum intr_level old_level = intr_get_level ();
c0021b0c:	e8 e3 ff ff ff       	call   c0021af4 <intr_get_level>
  ASSERT (!intr_context ());
c0021b11:	80 bb 95 08 00 00 00 	cmpb   $0x0,0x895(%ebx)
c0021b18:	75 06                	jne    c0021b20 <intr_enable+0x23>
  asm volatile ("sti");
c0021b1a:	fb                   	sti    
}
c0021b1b:	83 c4 08             	add    $0x8,%esp
c0021b1e:	5b                   	pop    %ebx
c0021b1f:	c3                   	ret    
  ASSERT (!intr_context ());
c0021b20:	83 ec 0c             	sub    $0xc,%esp
c0021b23:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0021b29:	50                   	push   %eax
c0021b2a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021b30:	50                   	push   %eax
c0021b31:	8d 83 c8 46 ff ff    	lea    -0xb938(%ebx),%eax
c0021b37:	50                   	push   %eax
c0021b38:	6a 5b                	push   $0x5b
c0021b3a:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021b40:	50                   	push   %eax
c0021b41:	e8 49 74 00 00       	call   c0028f8f <debug_panic>

c0021b46 <intr_disable>:
  enum intr_level old_level = intr_get_level ();
c0021b46:	e8 a9 ff ff ff       	call   c0021af4 <intr_get_level>
  asm volatile ("cli" : : : "memory");
c0021b4b:	fa                   	cli    
}
c0021b4c:	c3                   	ret    

c0021b4d <intr_set_level>:
{
c0021b4d:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021b50:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021b55:	74 09                	je     c0021b60 <intr_set_level+0x13>
c0021b57:	e8 ea ff ff ff       	call   c0021b46 <intr_disable>
}
c0021b5c:	83 c4 0c             	add    $0xc,%esp
c0021b5f:	c3                   	ret    
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021b60:	e8 98 ff ff ff       	call   c0021afd <intr_enable>
c0021b65:	eb f5                	jmp    c0021b5c <intr_set_level+0xf>

c0021b67 <intr_init>:
{
c0021b67:	57                   	push   %edi
c0021b68:	56                   	push   %esi
c0021b69:	53                   	push   %ebx
c0021b6a:	83 ec 10             	sub    $0x10,%esp
c0021b6d:	e8 d5 bd 00 00       	call   c002d947 <__x86.get_pc_thunk.si>
c0021b72:	81 c6 5a 79 01 00    	add    $0x1795a,%esi
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021b78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021b7d:	e6 21                	out    %al,$0x21
c0021b7f:	e6 a1                	out    %al,$0xa1
c0021b81:	b9 11 00 00 00       	mov    $0x11,%ecx
c0021b86:	89 c8                	mov    %ecx,%eax
c0021b88:	e6 20                	out    %al,$0x20
c0021b8a:	b8 20 00 00 00       	mov    $0x20,%eax
c0021b8f:	e6 21                	out    %al,$0x21
c0021b91:	b8 04 00 00 00       	mov    $0x4,%eax
c0021b96:	e6 21                	out    %al,$0x21
c0021b98:	ba 01 00 00 00       	mov    $0x1,%edx
c0021b9d:	89 d0                	mov    %edx,%eax
c0021b9f:	e6 21                	out    %al,$0x21
c0021ba1:	89 c8                	mov    %ecx,%eax
c0021ba3:	e6 a0                	out    %al,$0xa0
c0021ba5:	b8 28 00 00 00       	mov    $0x28,%eax
c0021baa:	e6 a1                	out    %al,$0xa1
c0021bac:	b8 02 00 00 00       	mov    $0x2,%eax
c0021bb1:	e6 a1                	out    %al,$0xa1
c0021bb3:	89 d0                	mov    %edx,%eax
c0021bb5:	e6 a1                	out    %al,$0xa1
c0021bb7:	b8 00 00 00 00       	mov    $0x0,%eax
c0021bbc:	e6 21                	out    %al,$0x21
c0021bbe:	e6 a1                	out    %al,$0xa1
  for (i = 0; i < INTR_CNT; i++)
c0021bc0:	bb 00 00 00 00       	mov    $0x0,%ebx
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021bc5:	c7 c7 bc 90 03 c0    	mov    $0xc00390bc,%edi
  return make_gate (function, dpl, 14);
c0021bcb:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
c0021bce:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021bd3:	ba 00 00 00 00       	mov    $0x0,%edx
c0021bd8:	e8 b4 fd ff ff       	call   c0021991 <make_gate>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021bdd:	89 84 de b4 14 00 00 	mov    %eax,0x14b4(%esi,%ebx,8)
c0021be4:	89 94 de b8 14 00 00 	mov    %edx,0x14b8(%esi,%ebx,8)
  for (i = 0; i < INTR_CNT; i++)
c0021beb:	83 c3 01             	add    $0x1,%ebx
c0021bee:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
c0021bf4:	75 d5                	jne    c0021bcb <intr_init+0x64>
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021bf6:	8d 86 b4 14 00 00    	lea    0x14b4(%esi),%eax
c0021bfc:	ba 00 00 00 00       	mov    $0x0,%edx
c0021c01:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021c05:	c1 e0 10             	shl    $0x10,%eax
c0021c08:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021c0d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021c11:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021c15:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c0021c1a:	8d 86 b4 0c 00 00    	lea    0xcb4(%esi),%eax
c0021c20:	8d 8e b4 10 00 00    	lea    0x10b4(%esi),%ecx
    intr_names[i] = "unknown";
c0021c26:	8d 96 ff 5a ff ff    	lea    -0xa501(%esi),%edx
c0021c2c:	89 10                	mov    %edx,(%eax)
c0021c2e:	83 c0 04             	add    $0x4,%eax
  for (i = 0; i < INTR_CNT; i++)
c0021c31:	39 c1                	cmp    %eax,%ecx
c0021c33:	75 f7                	jne    c0021c2c <intr_init+0xc5>
  intr_names[0] = "#DE Divide Error";
c0021c35:	8d 86 07 5b ff ff    	lea    -0xa4f9(%esi),%eax
c0021c3b:	89 86 b4 0c 00 00    	mov    %eax,0xcb4(%esi)
  intr_names[1] = "#DB Debug Exception";
c0021c41:	8d 86 18 5b ff ff    	lea    -0xa4e8(%esi),%eax
c0021c47:	89 86 b8 0c 00 00    	mov    %eax,0xcb8(%esi)
  intr_names[2] = "NMI Interrupt";
c0021c4d:	8d 86 2c 5b ff ff    	lea    -0xa4d4(%esi),%eax
c0021c53:	89 86 bc 0c 00 00    	mov    %eax,0xcbc(%esi)
  intr_names[3] = "#BP Breakpoint Exception";
c0021c59:	8d 86 3a 5b ff ff    	lea    -0xa4c6(%esi),%eax
c0021c5f:	89 86 c0 0c 00 00    	mov    %eax,0xcc0(%esi)
  intr_names[4] = "#OF Overflow Exception";
c0021c65:	8d 86 53 5b ff ff    	lea    -0xa4ad(%esi),%eax
c0021c6b:	89 86 c4 0c 00 00    	mov    %eax,0xcc4(%esi)
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021c71:	8d 86 90 5c ff ff    	lea    -0xa370(%esi),%eax
c0021c77:	89 86 c8 0c 00 00    	mov    %eax,0xcc8(%esi)
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021c7d:	8d 86 6a 5b ff ff    	lea    -0xa496(%esi),%eax
c0021c83:	89 86 cc 0c 00 00    	mov    %eax,0xccc(%esi)
  intr_names[7] = "#NM Device Not Available Exception";
c0021c89:	8d 86 b4 5c ff ff    	lea    -0xa34c(%esi),%eax
c0021c8f:	89 86 d0 0c 00 00    	mov    %eax,0xcd0(%esi)
  intr_names[8] = "#DF Double Fault Exception";
c0021c95:	8d 86 87 5b ff ff    	lea    -0xa479(%esi),%eax
c0021c9b:	89 86 d4 0c 00 00    	mov    %eax,0xcd4(%esi)
  intr_names[9] = "Coprocessor Segment Overrun";
c0021ca1:	8d 86 a2 5b ff ff    	lea    -0xa45e(%esi),%eax
c0021ca7:	89 86 d8 0c 00 00    	mov    %eax,0xcd8(%esi)
  intr_names[10] = "#TS Invalid TSS Exception";
c0021cad:	8d 86 be 5b ff ff    	lea    -0xa442(%esi),%eax
c0021cb3:	89 86 dc 0c 00 00    	mov    %eax,0xcdc(%esi)
  intr_names[11] = "#NP Segment Not Present";
c0021cb9:	8d 86 d8 5b ff ff    	lea    -0xa428(%esi),%eax
c0021cbf:	89 86 e0 0c 00 00    	mov    %eax,0xce0(%esi)
  intr_names[12] = "#SS Stack Fault Exception";
c0021cc5:	8d 86 f0 5b ff ff    	lea    -0xa410(%esi),%eax
c0021ccb:	89 86 e4 0c 00 00    	mov    %eax,0xce4(%esi)
  intr_names[13] = "#GP General Protection Exception";
c0021cd1:	8d 86 d8 5c ff ff    	lea    -0xa328(%esi),%eax
c0021cd7:	89 86 e8 0c 00 00    	mov    %eax,0xce8(%esi)
  intr_names[14] = "#PF Page-Fault Exception";
c0021cdd:	8d 86 0a 5c ff ff    	lea    -0xa3f6(%esi),%eax
c0021ce3:	89 86 ec 0c 00 00    	mov    %eax,0xcec(%esi)
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021ce9:	8d 86 fc 5c ff ff    	lea    -0xa304(%esi),%eax
c0021cef:	89 86 f4 0c 00 00    	mov    %eax,0xcf4(%esi)
  intr_names[17] = "#AC Alignment Check Exception";
c0021cf5:	8d 86 23 5c ff ff    	lea    -0xa3dd(%esi),%eax
c0021cfb:	89 86 f8 0c 00 00    	mov    %eax,0xcf8(%esi)
  intr_names[18] = "#MC Machine-Check Exception";
c0021d01:	8d 86 41 5c ff ff    	lea    -0xa3bf(%esi),%eax
c0021d07:	89 86 fc 0c 00 00    	mov    %eax,0xcfc(%esi)
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021d0d:	8d 86 20 5d ff ff    	lea    -0xa2e0(%esi),%eax
c0021d13:	89 86 00 0d 00 00    	mov    %eax,0xd00(%esi)
}
c0021d19:	83 c4 10             	add    $0x10,%esp
c0021d1c:	5b                   	pop    %ebx
c0021d1d:	5e                   	pop    %esi
c0021d1e:	5f                   	pop    %edi
c0021d1f:	c3                   	ret    

c0021d20 <intr_register_ext>:
{
c0021d20:	53                   	push   %ebx
c0021d21:	83 ec 08             	sub    $0x8,%esp
c0021d24:	e8 12 bc 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021d29:	81 c3 a3 77 01 00    	add    $0x177a3,%ebx
c0021d2f:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021d33:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021d36:	80 fa 0f             	cmp    $0xf,%dl
c0021d39:	77 22                	ja     c0021d5d <intr_register_ext+0x3d>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021d3b:	0f b6 c0             	movzbl %al,%eax
c0021d3e:	83 ec 08             	sub    $0x8,%esp
c0021d41:	ff 74 24 20          	pushl  0x20(%esp)
c0021d45:	ff 74 24 20          	pushl  0x20(%esp)
c0021d49:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021d4e:	ba 00 00 00 00       	mov    $0x0,%edx
c0021d53:	e8 f1 fc ff ff       	call   c0021a49 <register_handler>
}
c0021d58:	83 c4 18             	add    $0x18,%esp
c0021d5b:	5b                   	pop    %ebx
c0021d5c:	c3                   	ret    
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021d5d:	83 ec 0c             	sub    $0xc,%esp
c0021d60:	8d 83 44 5d ff ff    	lea    -0xa2bc(%ebx),%eax
c0021d66:	50                   	push   %eax
c0021d67:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021d6d:	50                   	push   %eax
c0021d6e:	8d 83 a8 46 ff ff    	lea    -0xb958(%ebx),%eax
c0021d74:	50                   	push   %eax
c0021d75:	68 b8 00 00 00       	push   $0xb8
c0021d7a:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021d80:	50                   	push   %eax
c0021d81:	e8 09 72 00 00       	call   c0028f8f <debug_panic>

c0021d86 <intr_register_int>:
{
c0021d86:	53                   	push   %ebx
c0021d87:	83 ec 08             	sub    $0x8,%esp
c0021d8a:	e8 ac bb 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021d8f:	81 c3 3d 77 01 00    	add    $0x1773d,%ebx
c0021d95:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021d99:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021d9c:	80 fa 0f             	cmp    $0xf,%dl
c0021d9f:	76 20                	jbe    c0021dc1 <intr_register_int+0x3b>
  register_handler (vec_no, dpl, level, handler, name);
c0021da1:	0f b6 c0             	movzbl %al,%eax
c0021da4:	83 ec 08             	sub    $0x8,%esp
c0021da7:	ff 74 24 28          	pushl  0x28(%esp)
c0021dab:	ff 74 24 28          	pushl  0x28(%esp)
c0021daf:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0021db3:	8b 54 24 24          	mov    0x24(%esp),%edx
c0021db7:	e8 8d fc ff ff       	call   c0021a49 <register_handler>
}
c0021dbc:	83 c4 18             	add    $0x18,%esp
c0021dbf:	5b                   	pop    %ebx
c0021dc0:	c3                   	ret    
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021dc1:	83 ec 0c             	sub    $0xc,%esp
c0021dc4:	8d 83 68 5d ff ff    	lea    -0xa298(%ebx),%eax
c0021dca:	50                   	push   %eax
c0021dcb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021dd1:	50                   	push   %eax
c0021dd2:	8d 83 80 46 ff ff    	lea    -0xb980(%ebx),%eax
c0021dd8:	50                   	push   %eax
c0021dd9:	68 cd 00 00 00       	push   $0xcd
c0021dde:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021de4:	50                   	push   %eax
c0021de5:	e8 a5 71 00 00       	call   c0028f8f <debug_panic>

c0021dea <intr_context>:
{
c0021dea:	e8 50 bb 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0021def:	05 dd 76 01 00       	add    $0x176dd,%eax
  return in_external_intr;
c0021df4:	0f b6 80 95 08 00 00 	movzbl 0x895(%eax),%eax
}
c0021dfb:	c3                   	ret    

c0021dfc <intr_yield_on_return>:
{
c0021dfc:	53                   	push   %ebx
c0021dfd:	83 ec 08             	sub    $0x8,%esp
c0021e00:	e8 36 bb 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021e05:	81 c3 c7 76 01 00    	add    $0x176c7,%ebx
  ASSERT (intr_context ());
c0021e0b:	80 bb 95 08 00 00 00 	cmpb   $0x0,0x895(%ebx)
c0021e12:	74 0c                	je     c0021e20 <intr_yield_on_return+0x24>
  yield_on_return = true;
c0021e14:	c6 83 94 08 00 00 01 	movb   $0x1,0x894(%ebx)
}
c0021e1b:	83 c4 08             	add    $0x8,%esp
c0021e1e:	5b                   	pop    %ebx
c0021e1f:	c3                   	ret    
  ASSERT (intr_context ());
c0021e20:	83 ec 0c             	sub    $0xc,%esp
c0021e23:	8d 93 d7 59 ff ff    	lea    -0xa629(%ebx),%edx
c0021e29:	52                   	push   %edx
c0021e2a:	8d 93 eb 55 ff ff    	lea    -0xaa15(%ebx),%edx
c0021e30:	52                   	push   %edx
c0021e31:	8d 93 68 46 ff ff    	lea    -0xb998(%ebx),%edx
c0021e37:	52                   	push   %edx
c0021e38:	68 e0 00 00 00       	push   $0xe0
c0021e3d:	8d 93 9a 5a ff ff    	lea    -0xa566(%ebx),%edx
c0021e43:	52                   	push   %edx
c0021e44:	e8 46 71 00 00       	call   c0028f8f <debug_panic>

c0021e49 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021e49:	55                   	push   %ebp
c0021e4a:	57                   	push   %edi
c0021e4b:	56                   	push   %esi
c0021e4c:	53                   	push   %ebx
c0021e4d:	83 ec 0c             	sub    $0xc,%esp
c0021e50:	e8 e6 ba 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0021e55:	81 c3 77 76 01 00    	add    $0x17677,%ebx
c0021e5b:	8b 7c 24 20          	mov    0x20(%esp),%edi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021e5f:	8b 47 30             	mov    0x30(%edi),%eax
c0021e62:	8d 70 e0             	lea    -0x20(%eax),%esi
  if (external) 
c0021e65:	83 fe 0f             	cmp    $0xf,%esi
c0021e68:	76 2c                	jbe    c0021e96 <intr_handler+0x4d>
      in_external_intr = true;
      yield_on_return = false;
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021e6a:	8b 57 30             	mov    0x30(%edi),%edx
c0021e6d:	8b 84 93 b4 10 00 00 	mov    0x10b4(%ebx,%edx,4),%eax
  if (handler != NULL)
c0021e74:	85 c0                	test   %eax,%eax
c0021e76:	0f 84 8e 00 00 00    	je     c0021f0a <intr_handler+0xc1>
    handler (frame);
c0021e7c:	83 ec 0c             	sub    $0xc,%esp
c0021e7f:	57                   	push   %edi
c0021e80:	ff d0                	call   *%eax
c0021e82:	83 c4 10             	add    $0x10,%esp
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021e85:	83 fe 0f             	cmp    $0xf,%esi
c0021e88:	0f 86 c2 00 00 00    	jbe    c0021f50 <intr_handler+0x107>
      pic_end_of_interrupt (frame->vec_no); 

      if (yield_on_return) 
        thread_yield (); 
    }
}
c0021e8e:	83 c4 0c             	add    $0xc,%esp
c0021e91:	5b                   	pop    %ebx
c0021e92:	5e                   	pop    %esi
c0021e93:	5f                   	pop    %edi
c0021e94:	5d                   	pop    %ebp
c0021e95:	c3                   	ret    
      ASSERT (intr_get_level () == INTR_OFF);
c0021e96:	e8 59 fc ff ff       	call   c0021af4 <intr_get_level>
c0021e9b:	85 c0                	test   %eax,%eax
c0021e9d:	75 19                	jne    c0021eb8 <intr_handler+0x6f>
      ASSERT (!intr_context ());
c0021e9f:	80 bb 95 08 00 00 00 	cmpb   $0x0,0x895(%ebx)
c0021ea6:	75 39                	jne    c0021ee1 <intr_handler+0x98>
      in_external_intr = true;
c0021ea8:	c6 83 95 08 00 00 01 	movb   $0x1,0x895(%ebx)
      yield_on_return = false;
c0021eaf:	c6 83 94 08 00 00 00 	movb   $0x0,0x894(%ebx)
c0021eb6:	eb b2                	jmp    c0021e6a <intr_handler+0x21>
      ASSERT (intr_get_level () == INTR_OFF);
c0021eb8:	83 ec 0c             	sub    $0xc,%esp
c0021ebb:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0021ec1:	50                   	push   %eax
c0021ec2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021ec8:	50                   	push   %eax
c0021ec9:	8d 83 58 46 ff ff    	lea    -0xb9a8(%ebx),%eax
c0021ecf:	50                   	push   %eax
c0021ed0:	68 65 01 00 00       	push   $0x165
c0021ed5:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021edb:	50                   	push   %eax
c0021edc:	e8 ae 70 00 00       	call   c0028f8f <debug_panic>
      ASSERT (!intr_context ());
c0021ee1:	83 ec 0c             	sub    $0xc,%esp
c0021ee4:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0021eea:	50                   	push   %eax
c0021eeb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021ef1:	50                   	push   %eax
c0021ef2:	8d 83 58 46 ff ff    	lea    -0xb9a8(%ebx),%eax
c0021ef8:	50                   	push   %eax
c0021ef9:	68 66 01 00 00       	push   $0x166
c0021efe:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021f04:	50                   	push   %eax
c0021f05:	e8 85 70 00 00       	call   c0028f8f <debug_panic>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021f0a:	89 d0                	mov    %edx,%eax
c0021f0c:	83 e0 f7             	and    $0xfffffff7,%eax
c0021f0f:	83 f8 27             	cmp    $0x27,%eax
c0021f12:	0f 84 6d ff ff ff    	je     c0021e85 <intr_handler+0x3c>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021f18:	8d ab b4 08 00 00    	lea    0x8b4(%ebx),%ebp
c0021f1e:	8b 4c 95 00          	mov    0x0(%ebp,%edx,4),%ecx
c0021f22:	8d 41 01             	lea    0x1(%ecx),%eax
c0021f25:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021f29:	85 c1                	test   %eax,%ecx
c0021f2b:	0f 85 54 ff ff ff    	jne    c0021e85 <intr_handler+0x3c>
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021f31:	83 ec 04             	sub    $0x4,%esp
c0021f34:	ff b4 93 b4 0c 00 00 	pushl  0xcb4(%ebx,%edx,4)
c0021f3b:	52                   	push   %edx
c0021f3c:	8d 83 88 5d ff ff    	lea    -0xa278(%ebx),%eax
c0021f42:	50                   	push   %eax
c0021f43:	e8 b0 52 00 00       	call   c00271f8 <printf>
c0021f48:	83 c4 10             	add    $0x10,%esp
c0021f4b:	e9 35 ff ff ff       	jmp    c0021e85 <intr_handler+0x3c>
      ASSERT (intr_get_level () == INTR_OFF);
c0021f50:	e8 9f fb ff ff       	call   c0021af4 <intr_get_level>
c0021f55:	85 c0                	test   %eax,%eax
c0021f57:	75 40                	jne    c0021f99 <intr_handler+0x150>
      ASSERT (intr_context ());
c0021f59:	80 bb 95 08 00 00 00 	cmpb   $0x0,0x895(%ebx)
c0021f60:	74 60                	je     c0021fc2 <intr_handler+0x179>
      in_external_intr = false;
c0021f62:	c6 83 95 08 00 00 00 	movb   $0x0,0x895(%ebx)
      pic_end_of_interrupt (frame->vec_no); 
c0021f69:	8b 57 30             	mov    0x30(%edi),%edx
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021f6c:	8d 42 e0             	lea    -0x20(%edx),%eax
c0021f6f:	83 f8 0f             	cmp    $0xf,%eax
c0021f72:	77 77                	ja     c0021feb <intr_handler+0x1a2>
c0021f74:	b8 20 00 00 00       	mov    $0x20,%eax
c0021f79:	e6 20                	out    %al,$0x20
  if (irq >= 0x28)
c0021f7b:	83 fa 27             	cmp    $0x27,%edx
c0021f7e:	7e 02                	jle    c0021f82 <intr_handler+0x139>
c0021f80:	e6 a0                	out    %al,$0xa0
      if (yield_on_return) 
c0021f82:	80 bb 94 08 00 00 00 	cmpb   $0x0,0x894(%ebx)
c0021f89:	0f 84 ff fe ff ff    	je     c0021e8e <intr_handler+0x45>
        thread_yield (); 
c0021f8f:	e8 39 f1 ff ff       	call   c00210cd <thread_yield>
}
c0021f94:	e9 f5 fe ff ff       	jmp    c0021e8e <intr_handler+0x45>
      ASSERT (intr_get_level () == INTR_OFF);
c0021f99:	83 ec 0c             	sub    $0xc,%esp
c0021f9c:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0021fa2:	50                   	push   %eax
c0021fa3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021fa9:	50                   	push   %eax
c0021faa:	8d 83 58 46 ff ff    	lea    -0xb9a8(%ebx),%eax
c0021fb0:	50                   	push   %eax
c0021fb1:	68 7c 01 00 00       	push   $0x17c
c0021fb6:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021fbc:	50                   	push   %eax
c0021fbd:	e8 cd 6f 00 00       	call   c0028f8f <debug_panic>
      ASSERT (intr_context ());
c0021fc2:	83 ec 0c             	sub    $0xc,%esp
c0021fc5:	8d 83 d7 59 ff ff    	lea    -0xa629(%ebx),%eax
c0021fcb:	50                   	push   %eax
c0021fcc:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021fd2:	50                   	push   %eax
c0021fd3:	8d 83 58 46 ff ff    	lea    -0xb9a8(%ebx),%eax
c0021fd9:	50                   	push   %eax
c0021fda:	68 7d 01 00 00       	push   $0x17d
c0021fdf:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c0021fe5:	50                   	push   %eax
c0021fe6:	e8 a4 6f 00 00       	call   c0028f8f <debug_panic>
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021feb:	83 ec 0c             	sub    $0xc,%esp
c0021fee:	8d 83 5d 5c ff ff    	lea    -0xa3a3(%ebx),%eax
c0021ff4:	50                   	push   %eax
c0021ff5:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0021ffb:	50                   	push   %eax
c0021ffc:	8d 83 40 46 ff ff    	lea    -0xb9c0(%ebx),%eax
c0022002:	50                   	push   %eax
c0022003:	68 0b 01 00 00       	push   $0x10b
c0022008:	8d 83 9a 5a ff ff    	lea    -0xa566(%ebx),%eax
c002200e:	50                   	push   %eax
c002200f:	e8 7b 6f 00 00       	call   c0028f8f <debug_panic>

c0022014 <intr_dump_frame>:
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0022014:	57                   	push   %edi
c0022015:	56                   	push   %esi
c0022016:	53                   	push   %ebx
c0022017:	e8 1f b9 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002201c:	81 c3 b0 74 01 00    	add    $0x174b0,%ebx
c0022022:	8b 74 24 10          	mov    0x10(%esp),%esi
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0022026:	0f 20 d7             	mov    %cr2,%edi

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c0022029:	8b 46 30             	mov    0x30(%esi),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c002202c:	ff 76 3c             	pushl  0x3c(%esi)
c002202f:	ff b4 83 b4 0c 00 00 	pushl  0xcb4(%ebx,%eax,4)
c0022036:	50                   	push   %eax
c0022037:	8d 83 ac 5d ff ff    	lea    -0xa254(%ebx),%eax
c002203d:	50                   	push   %eax
c002203e:	e8 b5 51 00 00       	call   c00271f8 <printf>
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0022043:	83 c4 0c             	add    $0xc,%esp
c0022046:	ff 76 34             	pushl  0x34(%esi)
c0022049:	57                   	push   %edi
c002204a:	8d 83 77 5c ff ff    	lea    -0xa389(%ebx),%eax
c0022050:	50                   	push   %eax
c0022051:	e8 a2 51 00 00       	call   c00271f8 <printf>
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0022056:	83 c4 04             	add    $0x4,%esp
c0022059:	ff 76 14             	pushl  0x14(%esi)
c002205c:	ff 76 18             	pushl  0x18(%esi)
c002205f:	ff 76 10             	pushl  0x10(%esi)
c0022062:	ff 76 1c             	pushl  0x1c(%esi)
c0022065:	8d 83 cc 5d ff ff    	lea    -0xa234(%ebx),%eax
c002206b:	50                   	push   %eax
c002206c:	e8 87 51 00 00       	call   c00271f8 <printf>
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0022071:	83 c4 14             	add    $0x14,%esp
c0022074:	ff 76 08             	pushl  0x8(%esi)
c0022077:	ff 76 48             	pushl  0x48(%esi)
c002207a:	ff 36                	pushl  (%esi)
c002207c:	ff 76 04             	pushl  0x4(%esi)
c002207f:	8d 83 f4 5d ff ff    	lea    -0xa20c(%ebx),%eax
c0022085:	50                   	push   %eax
c0022086:	e8 6d 51 00 00       	call   c00271f8 <printf>
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c002208b:	83 c4 14             	add    $0x14,%esp
c002208e:	0f b7 46 4c          	movzwl 0x4c(%esi),%eax
c0022092:	50                   	push   %eax
c0022093:	0f b7 46 28          	movzwl 0x28(%esi),%eax
c0022097:	50                   	push   %eax
c0022098:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
c002209c:	50                   	push   %eax
c002209d:	0f b7 46 40          	movzwl 0x40(%esi),%eax
c00220a1:	50                   	push   %eax
c00220a2:	8d 83 1c 5e ff ff    	lea    -0xa1e4(%ebx),%eax
c00220a8:	50                   	push   %eax
c00220a9:	e8 4a 51 00 00       	call   c00271f8 <printf>
          f->cs, f->ds, f->es, f->ss);
}
c00220ae:	83 c4 20             	add    $0x20,%esp
c00220b1:	5b                   	pop    %ebx
c00220b2:	5e                   	pop    %esi
c00220b3:	5f                   	pop    %edi
c00220b4:	c3                   	ret    

c00220b5 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c00220b5:	e8 85 b8 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c00220ba:	05 12 74 01 00       	add    $0x17412,%eax
  return intr_names[vec];
c00220bf:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c00220c4:	8b 84 90 b4 0c 00 00 	mov    0xcb4(%eax,%edx,4),%eax
}
c00220cb:	c3                   	ret    

c00220cc <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c00220cc:	1e                   	push   %ds
	pushl %es
c00220cd:	06                   	push   %es
	pushl %fs
c00220ce:	0f a0                	push   %fs
	pushl %gs
c00220d0:	0f a8                	push   %gs
	pushal
c00220d2:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c00220d3:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c00220d4:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00220d9:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00220db:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00220dd:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00220e1:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c00220e2:	e8 62 fd ff ff       	call   c0021e49 <intr_handler>
	addl $4, %esp
c00220e7:	83 c4 04             	add    $0x4,%esp

c00220ea <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c00220ea:	61                   	popa   
	popl %gs
c00220eb:	0f a9                	pop    %gs
	popl %fs
c00220ed:	0f a1                	pop    %fs
	popl %es
c00220ef:	07                   	pop    %es
	popl %ds
c00220f0:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c00220f1:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c00220f4:	cf                   	iret   

c00220f5 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c00220f5:	55                   	push   %ebp
c00220f6:	6a 00                	push   $0x0
c00220f8:	6a 00                	push   $0x0
c00220fa:	eb d0                	jmp    c00220cc <intr_entry>

c00220fc <intr01_stub>:
c00220fc:	55                   	push   %ebp
c00220fd:	6a 00                	push   $0x0
c00220ff:	6a 01                	push   $0x1
c0022101:	eb c9                	jmp    c00220cc <intr_entry>

c0022103 <intr02_stub>:
c0022103:	55                   	push   %ebp
c0022104:	6a 00                	push   $0x0
c0022106:	6a 02                	push   $0x2
c0022108:	eb c2                	jmp    c00220cc <intr_entry>

c002210a <intr03_stub>:
c002210a:	55                   	push   %ebp
c002210b:	6a 00                	push   $0x0
c002210d:	6a 03                	push   $0x3
c002210f:	eb bb                	jmp    c00220cc <intr_entry>

c0022111 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0022111:	55                   	push   %ebp
c0022112:	6a 00                	push   $0x0
c0022114:	6a 04                	push   $0x4
c0022116:	eb b4                	jmp    c00220cc <intr_entry>

c0022118 <intr05_stub>:
c0022118:	55                   	push   %ebp
c0022119:	6a 00                	push   $0x0
c002211b:	6a 05                	push   $0x5
c002211d:	eb ad                	jmp    c00220cc <intr_entry>

c002211f <intr06_stub>:
c002211f:	55                   	push   %ebp
c0022120:	6a 00                	push   $0x0
c0022122:	6a 06                	push   $0x6
c0022124:	eb a6                	jmp    c00220cc <intr_entry>

c0022126 <intr07_stub>:
c0022126:	55                   	push   %ebp
c0022127:	6a 00                	push   $0x0
c0022129:	6a 07                	push   $0x7
c002212b:	eb 9f                	jmp    c00220cc <intr_entry>

c002212d <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c002212d:	ff 34 24             	pushl  (%esp)
c0022130:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022134:	6a 08                	push   $0x8
c0022136:	eb 94                	jmp    c00220cc <intr_entry>

c0022138 <intr09_stub>:
c0022138:	55                   	push   %ebp
c0022139:	6a 00                	push   $0x0
c002213b:	6a 09                	push   $0x9
c002213d:	eb 8d                	jmp    c00220cc <intr_entry>

c002213f <intr0a_stub>:
c002213f:	ff 34 24             	pushl  (%esp)
c0022142:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022146:	6a 0a                	push   $0xa
c0022148:	eb 82                	jmp    c00220cc <intr_entry>

c002214a <intr0b_stub>:
c002214a:	ff 34 24             	pushl  (%esp)
c002214d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022151:	6a 0b                	push   $0xb
c0022153:	e9 74 ff ff ff       	jmp    c00220cc <intr_entry>

c0022158 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0022158:	55                   	push   %ebp
c0022159:	6a 00                	push   $0x0
c002215b:	6a 0c                	push   $0xc
c002215d:	e9 6a ff ff ff       	jmp    c00220cc <intr_entry>

c0022162 <intr0d_stub>:
c0022162:	ff 34 24             	pushl  (%esp)
c0022165:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022169:	6a 0d                	push   $0xd
c002216b:	e9 5c ff ff ff       	jmp    c00220cc <intr_entry>

c0022170 <intr0e_stub>:
c0022170:	ff 34 24             	pushl  (%esp)
c0022173:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022177:	6a 0e                	push   $0xe
c0022179:	e9 4e ff ff ff       	jmp    c00220cc <intr_entry>

c002217e <intr0f_stub>:
c002217e:	55                   	push   %ebp
c002217f:	6a 00                	push   $0x0
c0022181:	6a 0f                	push   $0xf
c0022183:	e9 44 ff ff ff       	jmp    c00220cc <intr_entry>

c0022188 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0022188:	55                   	push   %ebp
c0022189:	6a 00                	push   $0x0
c002218b:	6a 10                	push   $0x10
c002218d:	e9 3a ff ff ff       	jmp    c00220cc <intr_entry>

c0022192 <intr11_stub>:
c0022192:	ff 34 24             	pushl  (%esp)
c0022195:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022199:	6a 11                	push   $0x11
c002219b:	e9 2c ff ff ff       	jmp    c00220cc <intr_entry>

c00221a0 <intr12_stub>:
c00221a0:	55                   	push   %ebp
c00221a1:	6a 00                	push   $0x0
c00221a3:	6a 12                	push   $0x12
c00221a5:	e9 22 ff ff ff       	jmp    c00220cc <intr_entry>

c00221aa <intr13_stub>:
c00221aa:	55                   	push   %ebp
c00221ab:	6a 00                	push   $0x0
c00221ad:	6a 13                	push   $0x13
c00221af:	e9 18 ff ff ff       	jmp    c00220cc <intr_entry>

c00221b4 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c00221b4:	55                   	push   %ebp
c00221b5:	6a 00                	push   $0x0
c00221b7:	6a 14                	push   $0x14
c00221b9:	e9 0e ff ff ff       	jmp    c00220cc <intr_entry>

c00221be <intr15_stub>:
c00221be:	55                   	push   %ebp
c00221bf:	6a 00                	push   $0x0
c00221c1:	6a 15                	push   $0x15
c00221c3:	e9 04 ff ff ff       	jmp    c00220cc <intr_entry>

c00221c8 <intr16_stub>:
c00221c8:	55                   	push   %ebp
c00221c9:	6a 00                	push   $0x0
c00221cb:	6a 16                	push   $0x16
c00221cd:	e9 fa fe ff ff       	jmp    c00220cc <intr_entry>

c00221d2 <intr17_stub>:
c00221d2:	55                   	push   %ebp
c00221d3:	6a 00                	push   $0x0
c00221d5:	6a 17                	push   $0x17
c00221d7:	e9 f0 fe ff ff       	jmp    c00220cc <intr_entry>

c00221dc <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00221dc:	ff 34 24             	pushl  (%esp)
c00221df:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00221e3:	6a 18                	push   $0x18
c00221e5:	e9 e2 fe ff ff       	jmp    c00220cc <intr_entry>

c00221ea <intr19_stub>:
c00221ea:	55                   	push   %ebp
c00221eb:	6a 00                	push   $0x0
c00221ed:	6a 19                	push   $0x19
c00221ef:	e9 d8 fe ff ff       	jmp    c00220cc <intr_entry>

c00221f4 <intr1a_stub>:
c00221f4:	ff 34 24             	pushl  (%esp)
c00221f7:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00221fb:	6a 1a                	push   $0x1a
c00221fd:	e9 ca fe ff ff       	jmp    c00220cc <intr_entry>

c0022202 <intr1b_stub>:
c0022202:	ff 34 24             	pushl  (%esp)
c0022205:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022209:	6a 1b                	push   $0x1b
c002220b:	e9 bc fe ff ff       	jmp    c00220cc <intr_entry>

c0022210 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0022210:	55                   	push   %ebp
c0022211:	6a 00                	push   $0x0
c0022213:	6a 1c                	push   $0x1c
c0022215:	e9 b2 fe ff ff       	jmp    c00220cc <intr_entry>

c002221a <intr1d_stub>:
c002221a:	ff 34 24             	pushl  (%esp)
c002221d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022221:	6a 1d                	push   $0x1d
c0022223:	e9 a4 fe ff ff       	jmp    c00220cc <intr_entry>

c0022228 <intr1e_stub>:
c0022228:	ff 34 24             	pushl  (%esp)
c002222b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002222f:	6a 1e                	push   $0x1e
c0022231:	e9 96 fe ff ff       	jmp    c00220cc <intr_entry>

c0022236 <intr1f_stub>:
c0022236:	55                   	push   %ebp
c0022237:	6a 00                	push   $0x0
c0022239:	6a 1f                	push   $0x1f
c002223b:	e9 8c fe ff ff       	jmp    c00220cc <intr_entry>

c0022240 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0022240:	55                   	push   %ebp
c0022241:	6a 00                	push   $0x0
c0022243:	6a 20                	push   $0x20
c0022245:	e9 82 fe ff ff       	jmp    c00220cc <intr_entry>

c002224a <intr21_stub>:
c002224a:	55                   	push   %ebp
c002224b:	6a 00                	push   $0x0
c002224d:	6a 21                	push   $0x21
c002224f:	e9 78 fe ff ff       	jmp    c00220cc <intr_entry>

c0022254 <intr22_stub>:
c0022254:	55                   	push   %ebp
c0022255:	6a 00                	push   $0x0
c0022257:	6a 22                	push   $0x22
c0022259:	e9 6e fe ff ff       	jmp    c00220cc <intr_entry>

c002225e <intr23_stub>:
c002225e:	55                   	push   %ebp
c002225f:	6a 00                	push   $0x0
c0022261:	6a 23                	push   $0x23
c0022263:	e9 64 fe ff ff       	jmp    c00220cc <intr_entry>

c0022268 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022268:	55                   	push   %ebp
c0022269:	6a 00                	push   $0x0
c002226b:	6a 24                	push   $0x24
c002226d:	e9 5a fe ff ff       	jmp    c00220cc <intr_entry>

c0022272 <intr25_stub>:
c0022272:	55                   	push   %ebp
c0022273:	6a 00                	push   $0x0
c0022275:	6a 25                	push   $0x25
c0022277:	e9 50 fe ff ff       	jmp    c00220cc <intr_entry>

c002227c <intr26_stub>:
c002227c:	55                   	push   %ebp
c002227d:	6a 00                	push   $0x0
c002227f:	6a 26                	push   $0x26
c0022281:	e9 46 fe ff ff       	jmp    c00220cc <intr_entry>

c0022286 <intr27_stub>:
c0022286:	55                   	push   %ebp
c0022287:	6a 00                	push   $0x0
c0022289:	6a 27                	push   $0x27
c002228b:	e9 3c fe ff ff       	jmp    c00220cc <intr_entry>

c0022290 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0022290:	55                   	push   %ebp
c0022291:	6a 00                	push   $0x0
c0022293:	6a 28                	push   $0x28
c0022295:	e9 32 fe ff ff       	jmp    c00220cc <intr_entry>

c002229a <intr29_stub>:
c002229a:	55                   	push   %ebp
c002229b:	6a 00                	push   $0x0
c002229d:	6a 29                	push   $0x29
c002229f:	e9 28 fe ff ff       	jmp    c00220cc <intr_entry>

c00222a4 <intr2a_stub>:
c00222a4:	55                   	push   %ebp
c00222a5:	6a 00                	push   $0x0
c00222a7:	6a 2a                	push   $0x2a
c00222a9:	e9 1e fe ff ff       	jmp    c00220cc <intr_entry>

c00222ae <intr2b_stub>:
c00222ae:	55                   	push   %ebp
c00222af:	6a 00                	push   $0x0
c00222b1:	6a 2b                	push   $0x2b
c00222b3:	e9 14 fe ff ff       	jmp    c00220cc <intr_entry>

c00222b8 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c00222b8:	55                   	push   %ebp
c00222b9:	6a 00                	push   $0x0
c00222bb:	6a 2c                	push   $0x2c
c00222bd:	e9 0a fe ff ff       	jmp    c00220cc <intr_entry>

c00222c2 <intr2d_stub>:
c00222c2:	55                   	push   %ebp
c00222c3:	6a 00                	push   $0x0
c00222c5:	6a 2d                	push   $0x2d
c00222c7:	e9 00 fe ff ff       	jmp    c00220cc <intr_entry>

c00222cc <intr2e_stub>:
c00222cc:	55                   	push   %ebp
c00222cd:	6a 00                	push   $0x0
c00222cf:	6a 2e                	push   $0x2e
c00222d1:	e9 f6 fd ff ff       	jmp    c00220cc <intr_entry>

c00222d6 <intr2f_stub>:
c00222d6:	55                   	push   %ebp
c00222d7:	6a 00                	push   $0x0
c00222d9:	6a 2f                	push   $0x2f
c00222db:	e9 ec fd ff ff       	jmp    c00220cc <intr_entry>

c00222e0 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00222e0:	55                   	push   %ebp
c00222e1:	6a 00                	push   $0x0
c00222e3:	6a 30                	push   $0x30
c00222e5:	e9 e2 fd ff ff       	jmp    c00220cc <intr_entry>

c00222ea <intr31_stub>:
c00222ea:	55                   	push   %ebp
c00222eb:	6a 00                	push   $0x0
c00222ed:	6a 31                	push   $0x31
c00222ef:	e9 d8 fd ff ff       	jmp    c00220cc <intr_entry>

c00222f4 <intr32_stub>:
c00222f4:	55                   	push   %ebp
c00222f5:	6a 00                	push   $0x0
c00222f7:	6a 32                	push   $0x32
c00222f9:	e9 ce fd ff ff       	jmp    c00220cc <intr_entry>

c00222fe <intr33_stub>:
c00222fe:	55                   	push   %ebp
c00222ff:	6a 00                	push   $0x0
c0022301:	6a 33                	push   $0x33
c0022303:	e9 c4 fd ff ff       	jmp    c00220cc <intr_entry>

c0022308 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0022308:	55                   	push   %ebp
c0022309:	6a 00                	push   $0x0
c002230b:	6a 34                	push   $0x34
c002230d:	e9 ba fd ff ff       	jmp    c00220cc <intr_entry>

c0022312 <intr35_stub>:
c0022312:	55                   	push   %ebp
c0022313:	6a 00                	push   $0x0
c0022315:	6a 35                	push   $0x35
c0022317:	e9 b0 fd ff ff       	jmp    c00220cc <intr_entry>

c002231c <intr36_stub>:
c002231c:	55                   	push   %ebp
c002231d:	6a 00                	push   $0x0
c002231f:	6a 36                	push   $0x36
c0022321:	e9 a6 fd ff ff       	jmp    c00220cc <intr_entry>

c0022326 <intr37_stub>:
c0022326:	55                   	push   %ebp
c0022327:	6a 00                	push   $0x0
c0022329:	6a 37                	push   $0x37
c002232b:	e9 9c fd ff ff       	jmp    c00220cc <intr_entry>

c0022330 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0022330:	55                   	push   %ebp
c0022331:	6a 00                	push   $0x0
c0022333:	6a 38                	push   $0x38
c0022335:	e9 92 fd ff ff       	jmp    c00220cc <intr_entry>

c002233a <intr39_stub>:
c002233a:	55                   	push   %ebp
c002233b:	6a 00                	push   $0x0
c002233d:	6a 39                	push   $0x39
c002233f:	e9 88 fd ff ff       	jmp    c00220cc <intr_entry>

c0022344 <intr3a_stub>:
c0022344:	55                   	push   %ebp
c0022345:	6a 00                	push   $0x0
c0022347:	6a 3a                	push   $0x3a
c0022349:	e9 7e fd ff ff       	jmp    c00220cc <intr_entry>

c002234e <intr3b_stub>:
c002234e:	55                   	push   %ebp
c002234f:	6a 00                	push   $0x0
c0022351:	6a 3b                	push   $0x3b
c0022353:	e9 74 fd ff ff       	jmp    c00220cc <intr_entry>

c0022358 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022358:	55                   	push   %ebp
c0022359:	6a 00                	push   $0x0
c002235b:	6a 3c                	push   $0x3c
c002235d:	e9 6a fd ff ff       	jmp    c00220cc <intr_entry>

c0022362 <intr3d_stub>:
c0022362:	55                   	push   %ebp
c0022363:	6a 00                	push   $0x0
c0022365:	6a 3d                	push   $0x3d
c0022367:	e9 60 fd ff ff       	jmp    c00220cc <intr_entry>

c002236c <intr3e_stub>:
c002236c:	55                   	push   %ebp
c002236d:	6a 00                	push   $0x0
c002236f:	6a 3e                	push   $0x3e
c0022371:	e9 56 fd ff ff       	jmp    c00220cc <intr_entry>

c0022376 <intr3f_stub>:
c0022376:	55                   	push   %ebp
c0022377:	6a 00                	push   $0x0
c0022379:	6a 3f                	push   $0x3f
c002237b:	e9 4c fd ff ff       	jmp    c00220cc <intr_entry>

c0022380 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0022380:	55                   	push   %ebp
c0022381:	6a 00                	push   $0x0
c0022383:	6a 40                	push   $0x40
c0022385:	e9 42 fd ff ff       	jmp    c00220cc <intr_entry>

c002238a <intr41_stub>:
c002238a:	55                   	push   %ebp
c002238b:	6a 00                	push   $0x0
c002238d:	6a 41                	push   $0x41
c002238f:	e9 38 fd ff ff       	jmp    c00220cc <intr_entry>

c0022394 <intr42_stub>:
c0022394:	55                   	push   %ebp
c0022395:	6a 00                	push   $0x0
c0022397:	6a 42                	push   $0x42
c0022399:	e9 2e fd ff ff       	jmp    c00220cc <intr_entry>

c002239e <intr43_stub>:
c002239e:	55                   	push   %ebp
c002239f:	6a 00                	push   $0x0
c00223a1:	6a 43                	push   $0x43
c00223a3:	e9 24 fd ff ff       	jmp    c00220cc <intr_entry>

c00223a8 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c00223a8:	55                   	push   %ebp
c00223a9:	6a 00                	push   $0x0
c00223ab:	6a 44                	push   $0x44
c00223ad:	e9 1a fd ff ff       	jmp    c00220cc <intr_entry>

c00223b2 <intr45_stub>:
c00223b2:	55                   	push   %ebp
c00223b3:	6a 00                	push   $0x0
c00223b5:	6a 45                	push   $0x45
c00223b7:	e9 10 fd ff ff       	jmp    c00220cc <intr_entry>

c00223bc <intr46_stub>:
c00223bc:	55                   	push   %ebp
c00223bd:	6a 00                	push   $0x0
c00223bf:	6a 46                	push   $0x46
c00223c1:	e9 06 fd ff ff       	jmp    c00220cc <intr_entry>

c00223c6 <intr47_stub>:
c00223c6:	55                   	push   %ebp
c00223c7:	6a 00                	push   $0x0
c00223c9:	6a 47                	push   $0x47
c00223cb:	e9 fc fc ff ff       	jmp    c00220cc <intr_entry>

c00223d0 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00223d0:	55                   	push   %ebp
c00223d1:	6a 00                	push   $0x0
c00223d3:	6a 48                	push   $0x48
c00223d5:	e9 f2 fc ff ff       	jmp    c00220cc <intr_entry>

c00223da <intr49_stub>:
c00223da:	55                   	push   %ebp
c00223db:	6a 00                	push   $0x0
c00223dd:	6a 49                	push   $0x49
c00223df:	e9 e8 fc ff ff       	jmp    c00220cc <intr_entry>

c00223e4 <intr4a_stub>:
c00223e4:	55                   	push   %ebp
c00223e5:	6a 00                	push   $0x0
c00223e7:	6a 4a                	push   $0x4a
c00223e9:	e9 de fc ff ff       	jmp    c00220cc <intr_entry>

c00223ee <intr4b_stub>:
c00223ee:	55                   	push   %ebp
c00223ef:	6a 00                	push   $0x0
c00223f1:	6a 4b                	push   $0x4b
c00223f3:	e9 d4 fc ff ff       	jmp    c00220cc <intr_entry>

c00223f8 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00223f8:	55                   	push   %ebp
c00223f9:	6a 00                	push   $0x0
c00223fb:	6a 4c                	push   $0x4c
c00223fd:	e9 ca fc ff ff       	jmp    c00220cc <intr_entry>

c0022402 <intr4d_stub>:
c0022402:	55                   	push   %ebp
c0022403:	6a 00                	push   $0x0
c0022405:	6a 4d                	push   $0x4d
c0022407:	e9 c0 fc ff ff       	jmp    c00220cc <intr_entry>

c002240c <intr4e_stub>:
c002240c:	55                   	push   %ebp
c002240d:	6a 00                	push   $0x0
c002240f:	6a 4e                	push   $0x4e
c0022411:	e9 b6 fc ff ff       	jmp    c00220cc <intr_entry>

c0022416 <intr4f_stub>:
c0022416:	55                   	push   %ebp
c0022417:	6a 00                	push   $0x0
c0022419:	6a 4f                	push   $0x4f
c002241b:	e9 ac fc ff ff       	jmp    c00220cc <intr_entry>

c0022420 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022420:	55                   	push   %ebp
c0022421:	6a 00                	push   $0x0
c0022423:	6a 50                	push   $0x50
c0022425:	e9 a2 fc ff ff       	jmp    c00220cc <intr_entry>

c002242a <intr51_stub>:
c002242a:	55                   	push   %ebp
c002242b:	6a 00                	push   $0x0
c002242d:	6a 51                	push   $0x51
c002242f:	e9 98 fc ff ff       	jmp    c00220cc <intr_entry>

c0022434 <intr52_stub>:
c0022434:	55                   	push   %ebp
c0022435:	6a 00                	push   $0x0
c0022437:	6a 52                	push   $0x52
c0022439:	e9 8e fc ff ff       	jmp    c00220cc <intr_entry>

c002243e <intr53_stub>:
c002243e:	55                   	push   %ebp
c002243f:	6a 00                	push   $0x0
c0022441:	6a 53                	push   $0x53
c0022443:	e9 84 fc ff ff       	jmp    c00220cc <intr_entry>

c0022448 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0022448:	55                   	push   %ebp
c0022449:	6a 00                	push   $0x0
c002244b:	6a 54                	push   $0x54
c002244d:	e9 7a fc ff ff       	jmp    c00220cc <intr_entry>

c0022452 <intr55_stub>:
c0022452:	55                   	push   %ebp
c0022453:	6a 00                	push   $0x0
c0022455:	6a 55                	push   $0x55
c0022457:	e9 70 fc ff ff       	jmp    c00220cc <intr_entry>

c002245c <intr56_stub>:
c002245c:	55                   	push   %ebp
c002245d:	6a 00                	push   $0x0
c002245f:	6a 56                	push   $0x56
c0022461:	e9 66 fc ff ff       	jmp    c00220cc <intr_entry>

c0022466 <intr57_stub>:
c0022466:	55                   	push   %ebp
c0022467:	6a 00                	push   $0x0
c0022469:	6a 57                	push   $0x57
c002246b:	e9 5c fc ff ff       	jmp    c00220cc <intr_entry>

c0022470 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0022470:	55                   	push   %ebp
c0022471:	6a 00                	push   $0x0
c0022473:	6a 58                	push   $0x58
c0022475:	e9 52 fc ff ff       	jmp    c00220cc <intr_entry>

c002247a <intr59_stub>:
c002247a:	55                   	push   %ebp
c002247b:	6a 00                	push   $0x0
c002247d:	6a 59                	push   $0x59
c002247f:	e9 48 fc ff ff       	jmp    c00220cc <intr_entry>

c0022484 <intr5a_stub>:
c0022484:	55                   	push   %ebp
c0022485:	6a 00                	push   $0x0
c0022487:	6a 5a                	push   $0x5a
c0022489:	e9 3e fc ff ff       	jmp    c00220cc <intr_entry>

c002248e <intr5b_stub>:
c002248e:	55                   	push   %ebp
c002248f:	6a 00                	push   $0x0
c0022491:	6a 5b                	push   $0x5b
c0022493:	e9 34 fc ff ff       	jmp    c00220cc <intr_entry>

c0022498 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0022498:	55                   	push   %ebp
c0022499:	6a 00                	push   $0x0
c002249b:	6a 5c                	push   $0x5c
c002249d:	e9 2a fc ff ff       	jmp    c00220cc <intr_entry>

c00224a2 <intr5d_stub>:
c00224a2:	55                   	push   %ebp
c00224a3:	6a 00                	push   $0x0
c00224a5:	6a 5d                	push   $0x5d
c00224a7:	e9 20 fc ff ff       	jmp    c00220cc <intr_entry>

c00224ac <intr5e_stub>:
c00224ac:	55                   	push   %ebp
c00224ad:	6a 00                	push   $0x0
c00224af:	6a 5e                	push   $0x5e
c00224b1:	e9 16 fc ff ff       	jmp    c00220cc <intr_entry>

c00224b6 <intr5f_stub>:
c00224b6:	55                   	push   %ebp
c00224b7:	6a 00                	push   $0x0
c00224b9:	6a 5f                	push   $0x5f
c00224bb:	e9 0c fc ff ff       	jmp    c00220cc <intr_entry>

c00224c0 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c00224c0:	55                   	push   %ebp
c00224c1:	6a 00                	push   $0x0
c00224c3:	6a 60                	push   $0x60
c00224c5:	e9 02 fc ff ff       	jmp    c00220cc <intr_entry>

c00224ca <intr61_stub>:
c00224ca:	55                   	push   %ebp
c00224cb:	6a 00                	push   $0x0
c00224cd:	6a 61                	push   $0x61
c00224cf:	e9 f8 fb ff ff       	jmp    c00220cc <intr_entry>

c00224d4 <intr62_stub>:
c00224d4:	55                   	push   %ebp
c00224d5:	6a 00                	push   $0x0
c00224d7:	6a 62                	push   $0x62
c00224d9:	e9 ee fb ff ff       	jmp    c00220cc <intr_entry>

c00224de <intr63_stub>:
c00224de:	55                   	push   %ebp
c00224df:	6a 00                	push   $0x0
c00224e1:	6a 63                	push   $0x63
c00224e3:	e9 e4 fb ff ff       	jmp    c00220cc <intr_entry>

c00224e8 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00224e8:	55                   	push   %ebp
c00224e9:	6a 00                	push   $0x0
c00224eb:	6a 64                	push   $0x64
c00224ed:	e9 da fb ff ff       	jmp    c00220cc <intr_entry>

c00224f2 <intr65_stub>:
c00224f2:	55                   	push   %ebp
c00224f3:	6a 00                	push   $0x0
c00224f5:	6a 65                	push   $0x65
c00224f7:	e9 d0 fb ff ff       	jmp    c00220cc <intr_entry>

c00224fc <intr66_stub>:
c00224fc:	55                   	push   %ebp
c00224fd:	6a 00                	push   $0x0
c00224ff:	6a 66                	push   $0x66
c0022501:	e9 c6 fb ff ff       	jmp    c00220cc <intr_entry>

c0022506 <intr67_stub>:
c0022506:	55                   	push   %ebp
c0022507:	6a 00                	push   $0x0
c0022509:	6a 67                	push   $0x67
c002250b:	e9 bc fb ff ff       	jmp    c00220cc <intr_entry>

c0022510 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0022510:	55                   	push   %ebp
c0022511:	6a 00                	push   $0x0
c0022513:	6a 68                	push   $0x68
c0022515:	e9 b2 fb ff ff       	jmp    c00220cc <intr_entry>

c002251a <intr69_stub>:
c002251a:	55                   	push   %ebp
c002251b:	6a 00                	push   $0x0
c002251d:	6a 69                	push   $0x69
c002251f:	e9 a8 fb ff ff       	jmp    c00220cc <intr_entry>

c0022524 <intr6a_stub>:
c0022524:	55                   	push   %ebp
c0022525:	6a 00                	push   $0x0
c0022527:	6a 6a                	push   $0x6a
c0022529:	e9 9e fb ff ff       	jmp    c00220cc <intr_entry>

c002252e <intr6b_stub>:
c002252e:	55                   	push   %ebp
c002252f:	6a 00                	push   $0x0
c0022531:	6a 6b                	push   $0x6b
c0022533:	e9 94 fb ff ff       	jmp    c00220cc <intr_entry>

c0022538 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022538:	55                   	push   %ebp
c0022539:	6a 00                	push   $0x0
c002253b:	6a 6c                	push   $0x6c
c002253d:	e9 8a fb ff ff       	jmp    c00220cc <intr_entry>

c0022542 <intr6d_stub>:
c0022542:	55                   	push   %ebp
c0022543:	6a 00                	push   $0x0
c0022545:	6a 6d                	push   $0x6d
c0022547:	e9 80 fb ff ff       	jmp    c00220cc <intr_entry>

c002254c <intr6e_stub>:
c002254c:	55                   	push   %ebp
c002254d:	6a 00                	push   $0x0
c002254f:	6a 6e                	push   $0x6e
c0022551:	e9 76 fb ff ff       	jmp    c00220cc <intr_entry>

c0022556 <intr6f_stub>:
c0022556:	55                   	push   %ebp
c0022557:	6a 00                	push   $0x0
c0022559:	6a 6f                	push   $0x6f
c002255b:	e9 6c fb ff ff       	jmp    c00220cc <intr_entry>

c0022560 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c0022560:	55                   	push   %ebp
c0022561:	6a 00                	push   $0x0
c0022563:	6a 70                	push   $0x70
c0022565:	e9 62 fb ff ff       	jmp    c00220cc <intr_entry>

c002256a <intr71_stub>:
c002256a:	55                   	push   %ebp
c002256b:	6a 00                	push   $0x0
c002256d:	6a 71                	push   $0x71
c002256f:	e9 58 fb ff ff       	jmp    c00220cc <intr_entry>

c0022574 <intr72_stub>:
c0022574:	55                   	push   %ebp
c0022575:	6a 00                	push   $0x0
c0022577:	6a 72                	push   $0x72
c0022579:	e9 4e fb ff ff       	jmp    c00220cc <intr_entry>

c002257e <intr73_stub>:
c002257e:	55                   	push   %ebp
c002257f:	6a 00                	push   $0x0
c0022581:	6a 73                	push   $0x73
c0022583:	e9 44 fb ff ff       	jmp    c00220cc <intr_entry>

c0022588 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022588:	55                   	push   %ebp
c0022589:	6a 00                	push   $0x0
c002258b:	6a 74                	push   $0x74
c002258d:	e9 3a fb ff ff       	jmp    c00220cc <intr_entry>

c0022592 <intr75_stub>:
c0022592:	55                   	push   %ebp
c0022593:	6a 00                	push   $0x0
c0022595:	6a 75                	push   $0x75
c0022597:	e9 30 fb ff ff       	jmp    c00220cc <intr_entry>

c002259c <intr76_stub>:
c002259c:	55                   	push   %ebp
c002259d:	6a 00                	push   $0x0
c002259f:	6a 76                	push   $0x76
c00225a1:	e9 26 fb ff ff       	jmp    c00220cc <intr_entry>

c00225a6 <intr77_stub>:
c00225a6:	55                   	push   %ebp
c00225a7:	6a 00                	push   $0x0
c00225a9:	6a 77                	push   $0x77
c00225ab:	e9 1c fb ff ff       	jmp    c00220cc <intr_entry>

c00225b0 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00225b0:	55                   	push   %ebp
c00225b1:	6a 00                	push   $0x0
c00225b3:	6a 78                	push   $0x78
c00225b5:	e9 12 fb ff ff       	jmp    c00220cc <intr_entry>

c00225ba <intr79_stub>:
c00225ba:	55                   	push   %ebp
c00225bb:	6a 00                	push   $0x0
c00225bd:	6a 79                	push   $0x79
c00225bf:	e9 08 fb ff ff       	jmp    c00220cc <intr_entry>

c00225c4 <intr7a_stub>:
c00225c4:	55                   	push   %ebp
c00225c5:	6a 00                	push   $0x0
c00225c7:	6a 7a                	push   $0x7a
c00225c9:	e9 fe fa ff ff       	jmp    c00220cc <intr_entry>

c00225ce <intr7b_stub>:
c00225ce:	55                   	push   %ebp
c00225cf:	6a 00                	push   $0x0
c00225d1:	6a 7b                	push   $0x7b
c00225d3:	e9 f4 fa ff ff       	jmp    c00220cc <intr_entry>

c00225d8 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00225d8:	55                   	push   %ebp
c00225d9:	6a 00                	push   $0x0
c00225db:	6a 7c                	push   $0x7c
c00225dd:	e9 ea fa ff ff       	jmp    c00220cc <intr_entry>

c00225e2 <intr7d_stub>:
c00225e2:	55                   	push   %ebp
c00225e3:	6a 00                	push   $0x0
c00225e5:	6a 7d                	push   $0x7d
c00225e7:	e9 e0 fa ff ff       	jmp    c00220cc <intr_entry>

c00225ec <intr7e_stub>:
c00225ec:	55                   	push   %ebp
c00225ed:	6a 00                	push   $0x0
c00225ef:	6a 7e                	push   $0x7e
c00225f1:	e9 d6 fa ff ff       	jmp    c00220cc <intr_entry>

c00225f6 <intr7f_stub>:
c00225f6:	55                   	push   %ebp
c00225f7:	6a 00                	push   $0x0
c00225f9:	6a 7f                	push   $0x7f
c00225fb:	e9 cc fa ff ff       	jmp    c00220cc <intr_entry>

c0022600 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022600:	55                   	push   %ebp
c0022601:	6a 00                	push   $0x0
c0022603:	68 80 00 00 00       	push   $0x80
c0022608:	e9 bf fa ff ff       	jmp    c00220cc <intr_entry>

c002260d <intr81_stub>:
c002260d:	55                   	push   %ebp
c002260e:	6a 00                	push   $0x0
c0022610:	68 81 00 00 00       	push   $0x81
c0022615:	e9 b2 fa ff ff       	jmp    c00220cc <intr_entry>

c002261a <intr82_stub>:
c002261a:	55                   	push   %ebp
c002261b:	6a 00                	push   $0x0
c002261d:	68 82 00 00 00       	push   $0x82
c0022622:	e9 a5 fa ff ff       	jmp    c00220cc <intr_entry>

c0022627 <intr83_stub>:
c0022627:	55                   	push   %ebp
c0022628:	6a 00                	push   $0x0
c002262a:	68 83 00 00 00       	push   $0x83
c002262f:	e9 98 fa ff ff       	jmp    c00220cc <intr_entry>

c0022634 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	68 84 00 00 00       	push   $0x84
c002263c:	e9 8b fa ff ff       	jmp    c00220cc <intr_entry>

c0022641 <intr85_stub>:
c0022641:	55                   	push   %ebp
c0022642:	6a 00                	push   $0x0
c0022644:	68 85 00 00 00       	push   $0x85
c0022649:	e9 7e fa ff ff       	jmp    c00220cc <intr_entry>

c002264e <intr86_stub>:
c002264e:	55                   	push   %ebp
c002264f:	6a 00                	push   $0x0
c0022651:	68 86 00 00 00       	push   $0x86
c0022656:	e9 71 fa ff ff       	jmp    c00220cc <intr_entry>

c002265b <intr87_stub>:
c002265b:	55                   	push   %ebp
c002265c:	6a 00                	push   $0x0
c002265e:	68 87 00 00 00       	push   $0x87
c0022663:	e9 64 fa ff ff       	jmp    c00220cc <intr_entry>

c0022668 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022668:	55                   	push   %ebp
c0022669:	6a 00                	push   $0x0
c002266b:	68 88 00 00 00       	push   $0x88
c0022670:	e9 57 fa ff ff       	jmp    c00220cc <intr_entry>

c0022675 <intr89_stub>:
c0022675:	55                   	push   %ebp
c0022676:	6a 00                	push   $0x0
c0022678:	68 89 00 00 00       	push   $0x89
c002267d:	e9 4a fa ff ff       	jmp    c00220cc <intr_entry>

c0022682 <intr8a_stub>:
c0022682:	55                   	push   %ebp
c0022683:	6a 00                	push   $0x0
c0022685:	68 8a 00 00 00       	push   $0x8a
c002268a:	e9 3d fa ff ff       	jmp    c00220cc <intr_entry>

c002268f <intr8b_stub>:
c002268f:	55                   	push   %ebp
c0022690:	6a 00                	push   $0x0
c0022692:	68 8b 00 00 00       	push   $0x8b
c0022697:	e9 30 fa ff ff       	jmp    c00220cc <intr_entry>

c002269c <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c002269c:	55                   	push   %ebp
c002269d:	6a 00                	push   $0x0
c002269f:	68 8c 00 00 00       	push   $0x8c
c00226a4:	e9 23 fa ff ff       	jmp    c00220cc <intr_entry>

c00226a9 <intr8d_stub>:
c00226a9:	55                   	push   %ebp
c00226aa:	6a 00                	push   $0x0
c00226ac:	68 8d 00 00 00       	push   $0x8d
c00226b1:	e9 16 fa ff ff       	jmp    c00220cc <intr_entry>

c00226b6 <intr8e_stub>:
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	68 8e 00 00 00       	push   $0x8e
c00226be:	e9 09 fa ff ff       	jmp    c00220cc <intr_entry>

c00226c3 <intr8f_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	68 8f 00 00 00       	push   $0x8f
c00226cb:	e9 fc f9 ff ff       	jmp    c00220cc <intr_entry>

c00226d0 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00226d0:	55                   	push   %ebp
c00226d1:	6a 00                	push   $0x0
c00226d3:	68 90 00 00 00       	push   $0x90
c00226d8:	e9 ef f9 ff ff       	jmp    c00220cc <intr_entry>

c00226dd <intr91_stub>:
c00226dd:	55                   	push   %ebp
c00226de:	6a 00                	push   $0x0
c00226e0:	68 91 00 00 00       	push   $0x91
c00226e5:	e9 e2 f9 ff ff       	jmp    c00220cc <intr_entry>

c00226ea <intr92_stub>:
c00226ea:	55                   	push   %ebp
c00226eb:	6a 00                	push   $0x0
c00226ed:	68 92 00 00 00       	push   $0x92
c00226f2:	e9 d5 f9 ff ff       	jmp    c00220cc <intr_entry>

c00226f7 <intr93_stub>:
c00226f7:	55                   	push   %ebp
c00226f8:	6a 00                	push   $0x0
c00226fa:	68 93 00 00 00       	push   $0x93
c00226ff:	e9 c8 f9 ff ff       	jmp    c00220cc <intr_entry>

c0022704 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022704:	55                   	push   %ebp
c0022705:	6a 00                	push   $0x0
c0022707:	68 94 00 00 00       	push   $0x94
c002270c:	e9 bb f9 ff ff       	jmp    c00220cc <intr_entry>

c0022711 <intr95_stub>:
c0022711:	55                   	push   %ebp
c0022712:	6a 00                	push   $0x0
c0022714:	68 95 00 00 00       	push   $0x95
c0022719:	e9 ae f9 ff ff       	jmp    c00220cc <intr_entry>

c002271e <intr96_stub>:
c002271e:	55                   	push   %ebp
c002271f:	6a 00                	push   $0x0
c0022721:	68 96 00 00 00       	push   $0x96
c0022726:	e9 a1 f9 ff ff       	jmp    c00220cc <intr_entry>

c002272b <intr97_stub>:
c002272b:	55                   	push   %ebp
c002272c:	6a 00                	push   $0x0
c002272e:	68 97 00 00 00       	push   $0x97
c0022733:	e9 94 f9 ff ff       	jmp    c00220cc <intr_entry>

c0022738 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022738:	55                   	push   %ebp
c0022739:	6a 00                	push   $0x0
c002273b:	68 98 00 00 00       	push   $0x98
c0022740:	e9 87 f9 ff ff       	jmp    c00220cc <intr_entry>

c0022745 <intr99_stub>:
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	68 99 00 00 00       	push   $0x99
c002274d:	e9 7a f9 ff ff       	jmp    c00220cc <intr_entry>

c0022752 <intr9a_stub>:
c0022752:	55                   	push   %ebp
c0022753:	6a 00                	push   $0x0
c0022755:	68 9a 00 00 00       	push   $0x9a
c002275a:	e9 6d f9 ff ff       	jmp    c00220cc <intr_entry>

c002275f <intr9b_stub>:
c002275f:	55                   	push   %ebp
c0022760:	6a 00                	push   $0x0
c0022762:	68 9b 00 00 00       	push   $0x9b
c0022767:	e9 60 f9 ff ff       	jmp    c00220cc <intr_entry>

c002276c <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c002276c:	55                   	push   %ebp
c002276d:	6a 00                	push   $0x0
c002276f:	68 9c 00 00 00       	push   $0x9c
c0022774:	e9 53 f9 ff ff       	jmp    c00220cc <intr_entry>

c0022779 <intr9d_stub>:
c0022779:	55                   	push   %ebp
c002277a:	6a 00                	push   $0x0
c002277c:	68 9d 00 00 00       	push   $0x9d
c0022781:	e9 46 f9 ff ff       	jmp    c00220cc <intr_entry>

c0022786 <intr9e_stub>:
c0022786:	55                   	push   %ebp
c0022787:	6a 00                	push   $0x0
c0022789:	68 9e 00 00 00       	push   $0x9e
c002278e:	e9 39 f9 ff ff       	jmp    c00220cc <intr_entry>

c0022793 <intr9f_stub>:
c0022793:	55                   	push   %ebp
c0022794:	6a 00                	push   $0x0
c0022796:	68 9f 00 00 00       	push   $0x9f
c002279b:	e9 2c f9 ff ff       	jmp    c00220cc <intr_entry>

c00227a0 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00227a0:	55                   	push   %ebp
c00227a1:	6a 00                	push   $0x0
c00227a3:	68 a0 00 00 00       	push   $0xa0
c00227a8:	e9 1f f9 ff ff       	jmp    c00220cc <intr_entry>

c00227ad <intra1_stub>:
c00227ad:	55                   	push   %ebp
c00227ae:	6a 00                	push   $0x0
c00227b0:	68 a1 00 00 00       	push   $0xa1
c00227b5:	e9 12 f9 ff ff       	jmp    c00220cc <intr_entry>

c00227ba <intra2_stub>:
c00227ba:	55                   	push   %ebp
c00227bb:	6a 00                	push   $0x0
c00227bd:	68 a2 00 00 00       	push   $0xa2
c00227c2:	e9 05 f9 ff ff       	jmp    c00220cc <intr_entry>

c00227c7 <intra3_stub>:
c00227c7:	55                   	push   %ebp
c00227c8:	6a 00                	push   $0x0
c00227ca:	68 a3 00 00 00       	push   $0xa3
c00227cf:	e9 f8 f8 ff ff       	jmp    c00220cc <intr_entry>

c00227d4 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00227d4:	55                   	push   %ebp
c00227d5:	6a 00                	push   $0x0
c00227d7:	68 a4 00 00 00       	push   $0xa4
c00227dc:	e9 eb f8 ff ff       	jmp    c00220cc <intr_entry>

c00227e1 <intra5_stub>:
c00227e1:	55                   	push   %ebp
c00227e2:	6a 00                	push   $0x0
c00227e4:	68 a5 00 00 00       	push   $0xa5
c00227e9:	e9 de f8 ff ff       	jmp    c00220cc <intr_entry>

c00227ee <intra6_stub>:
c00227ee:	55                   	push   %ebp
c00227ef:	6a 00                	push   $0x0
c00227f1:	68 a6 00 00 00       	push   $0xa6
c00227f6:	e9 d1 f8 ff ff       	jmp    c00220cc <intr_entry>

c00227fb <intra7_stub>:
c00227fb:	55                   	push   %ebp
c00227fc:	6a 00                	push   $0x0
c00227fe:	68 a7 00 00 00       	push   $0xa7
c0022803:	e9 c4 f8 ff ff       	jmp    c00220cc <intr_entry>

c0022808 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022808:	55                   	push   %ebp
c0022809:	6a 00                	push   $0x0
c002280b:	68 a8 00 00 00       	push   $0xa8
c0022810:	e9 b7 f8 ff ff       	jmp    c00220cc <intr_entry>

c0022815 <intra9_stub>:
c0022815:	55                   	push   %ebp
c0022816:	6a 00                	push   $0x0
c0022818:	68 a9 00 00 00       	push   $0xa9
c002281d:	e9 aa f8 ff ff       	jmp    c00220cc <intr_entry>

c0022822 <intraa_stub>:
c0022822:	55                   	push   %ebp
c0022823:	6a 00                	push   $0x0
c0022825:	68 aa 00 00 00       	push   $0xaa
c002282a:	e9 9d f8 ff ff       	jmp    c00220cc <intr_entry>

c002282f <intrab_stub>:
c002282f:	55                   	push   %ebp
c0022830:	6a 00                	push   $0x0
c0022832:	68 ab 00 00 00       	push   $0xab
c0022837:	e9 90 f8 ff ff       	jmp    c00220cc <intr_entry>

c002283c <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c002283c:	55                   	push   %ebp
c002283d:	6a 00                	push   $0x0
c002283f:	68 ac 00 00 00       	push   $0xac
c0022844:	e9 83 f8 ff ff       	jmp    c00220cc <intr_entry>

c0022849 <intrad_stub>:
c0022849:	55                   	push   %ebp
c002284a:	6a 00                	push   $0x0
c002284c:	68 ad 00 00 00       	push   $0xad
c0022851:	e9 76 f8 ff ff       	jmp    c00220cc <intr_entry>

c0022856 <intrae_stub>:
c0022856:	55                   	push   %ebp
c0022857:	6a 00                	push   $0x0
c0022859:	68 ae 00 00 00       	push   $0xae
c002285e:	e9 69 f8 ff ff       	jmp    c00220cc <intr_entry>

c0022863 <intraf_stub>:
c0022863:	55                   	push   %ebp
c0022864:	6a 00                	push   $0x0
c0022866:	68 af 00 00 00       	push   $0xaf
c002286b:	e9 5c f8 ff ff       	jmp    c00220cc <intr_entry>

c0022870 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022870:	55                   	push   %ebp
c0022871:	6a 00                	push   $0x0
c0022873:	68 b0 00 00 00       	push   $0xb0
c0022878:	e9 4f f8 ff ff       	jmp    c00220cc <intr_entry>

c002287d <intrb1_stub>:
c002287d:	55                   	push   %ebp
c002287e:	6a 00                	push   $0x0
c0022880:	68 b1 00 00 00       	push   $0xb1
c0022885:	e9 42 f8 ff ff       	jmp    c00220cc <intr_entry>

c002288a <intrb2_stub>:
c002288a:	55                   	push   %ebp
c002288b:	6a 00                	push   $0x0
c002288d:	68 b2 00 00 00       	push   $0xb2
c0022892:	e9 35 f8 ff ff       	jmp    c00220cc <intr_entry>

c0022897 <intrb3_stub>:
c0022897:	55                   	push   %ebp
c0022898:	6a 00                	push   $0x0
c002289a:	68 b3 00 00 00       	push   $0xb3
c002289f:	e9 28 f8 ff ff       	jmp    c00220cc <intr_entry>

c00228a4 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00228a4:	55                   	push   %ebp
c00228a5:	6a 00                	push   $0x0
c00228a7:	68 b4 00 00 00       	push   $0xb4
c00228ac:	e9 1b f8 ff ff       	jmp    c00220cc <intr_entry>

c00228b1 <intrb5_stub>:
c00228b1:	55                   	push   %ebp
c00228b2:	6a 00                	push   $0x0
c00228b4:	68 b5 00 00 00       	push   $0xb5
c00228b9:	e9 0e f8 ff ff       	jmp    c00220cc <intr_entry>

c00228be <intrb6_stub>:
c00228be:	55                   	push   %ebp
c00228bf:	6a 00                	push   $0x0
c00228c1:	68 b6 00 00 00       	push   $0xb6
c00228c6:	e9 01 f8 ff ff       	jmp    c00220cc <intr_entry>

c00228cb <intrb7_stub>:
c00228cb:	55                   	push   %ebp
c00228cc:	6a 00                	push   $0x0
c00228ce:	68 b7 00 00 00       	push   $0xb7
c00228d3:	e9 f4 f7 ff ff       	jmp    c00220cc <intr_entry>

c00228d8 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c00228d8:	55                   	push   %ebp
c00228d9:	6a 00                	push   $0x0
c00228db:	68 b8 00 00 00       	push   $0xb8
c00228e0:	e9 e7 f7 ff ff       	jmp    c00220cc <intr_entry>

c00228e5 <intrb9_stub>:
c00228e5:	55                   	push   %ebp
c00228e6:	6a 00                	push   $0x0
c00228e8:	68 b9 00 00 00       	push   $0xb9
c00228ed:	e9 da f7 ff ff       	jmp    c00220cc <intr_entry>

c00228f2 <intrba_stub>:
c00228f2:	55                   	push   %ebp
c00228f3:	6a 00                	push   $0x0
c00228f5:	68 ba 00 00 00       	push   $0xba
c00228fa:	e9 cd f7 ff ff       	jmp    c00220cc <intr_entry>

c00228ff <intrbb_stub>:
c00228ff:	55                   	push   %ebp
c0022900:	6a 00                	push   $0x0
c0022902:	68 bb 00 00 00       	push   $0xbb
c0022907:	e9 c0 f7 ff ff       	jmp    c00220cc <intr_entry>

c002290c <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c002290c:	55                   	push   %ebp
c002290d:	6a 00                	push   $0x0
c002290f:	68 bc 00 00 00       	push   $0xbc
c0022914:	e9 b3 f7 ff ff       	jmp    c00220cc <intr_entry>

c0022919 <intrbd_stub>:
c0022919:	55                   	push   %ebp
c002291a:	6a 00                	push   $0x0
c002291c:	68 bd 00 00 00       	push   $0xbd
c0022921:	e9 a6 f7 ff ff       	jmp    c00220cc <intr_entry>

c0022926 <intrbe_stub>:
c0022926:	55                   	push   %ebp
c0022927:	6a 00                	push   $0x0
c0022929:	68 be 00 00 00       	push   $0xbe
c002292e:	e9 99 f7 ff ff       	jmp    c00220cc <intr_entry>

c0022933 <intrbf_stub>:
c0022933:	55                   	push   %ebp
c0022934:	6a 00                	push   $0x0
c0022936:	68 bf 00 00 00       	push   $0xbf
c002293b:	e9 8c f7 ff ff       	jmp    c00220cc <intr_entry>

c0022940 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022940:	55                   	push   %ebp
c0022941:	6a 00                	push   $0x0
c0022943:	68 c0 00 00 00       	push   $0xc0
c0022948:	e9 7f f7 ff ff       	jmp    c00220cc <intr_entry>

c002294d <intrc1_stub>:
c002294d:	55                   	push   %ebp
c002294e:	6a 00                	push   $0x0
c0022950:	68 c1 00 00 00       	push   $0xc1
c0022955:	e9 72 f7 ff ff       	jmp    c00220cc <intr_entry>

c002295a <intrc2_stub>:
c002295a:	55                   	push   %ebp
c002295b:	6a 00                	push   $0x0
c002295d:	68 c2 00 00 00       	push   $0xc2
c0022962:	e9 65 f7 ff ff       	jmp    c00220cc <intr_entry>

c0022967 <intrc3_stub>:
c0022967:	55                   	push   %ebp
c0022968:	6a 00                	push   $0x0
c002296a:	68 c3 00 00 00       	push   $0xc3
c002296f:	e9 58 f7 ff ff       	jmp    c00220cc <intr_entry>

c0022974 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022974:	55                   	push   %ebp
c0022975:	6a 00                	push   $0x0
c0022977:	68 c4 00 00 00       	push   $0xc4
c002297c:	e9 4b f7 ff ff       	jmp    c00220cc <intr_entry>

c0022981 <intrc5_stub>:
c0022981:	55                   	push   %ebp
c0022982:	6a 00                	push   $0x0
c0022984:	68 c5 00 00 00       	push   $0xc5
c0022989:	e9 3e f7 ff ff       	jmp    c00220cc <intr_entry>

c002298e <intrc6_stub>:
c002298e:	55                   	push   %ebp
c002298f:	6a 00                	push   $0x0
c0022991:	68 c6 00 00 00       	push   $0xc6
c0022996:	e9 31 f7 ff ff       	jmp    c00220cc <intr_entry>

c002299b <intrc7_stub>:
c002299b:	55                   	push   %ebp
c002299c:	6a 00                	push   $0x0
c002299e:	68 c7 00 00 00       	push   $0xc7
c00229a3:	e9 24 f7 ff ff       	jmp    c00220cc <intr_entry>

c00229a8 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c00229a8:	55                   	push   %ebp
c00229a9:	6a 00                	push   $0x0
c00229ab:	68 c8 00 00 00       	push   $0xc8
c00229b0:	e9 17 f7 ff ff       	jmp    c00220cc <intr_entry>

c00229b5 <intrc9_stub>:
c00229b5:	55                   	push   %ebp
c00229b6:	6a 00                	push   $0x0
c00229b8:	68 c9 00 00 00       	push   $0xc9
c00229bd:	e9 0a f7 ff ff       	jmp    c00220cc <intr_entry>

c00229c2 <intrca_stub>:
c00229c2:	55                   	push   %ebp
c00229c3:	6a 00                	push   $0x0
c00229c5:	68 ca 00 00 00       	push   $0xca
c00229ca:	e9 fd f6 ff ff       	jmp    c00220cc <intr_entry>

c00229cf <intrcb_stub>:
c00229cf:	55                   	push   %ebp
c00229d0:	6a 00                	push   $0x0
c00229d2:	68 cb 00 00 00       	push   $0xcb
c00229d7:	e9 f0 f6 ff ff       	jmp    c00220cc <intr_entry>

c00229dc <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c00229dc:	55                   	push   %ebp
c00229dd:	6a 00                	push   $0x0
c00229df:	68 cc 00 00 00       	push   $0xcc
c00229e4:	e9 e3 f6 ff ff       	jmp    c00220cc <intr_entry>

c00229e9 <intrcd_stub>:
c00229e9:	55                   	push   %ebp
c00229ea:	6a 00                	push   $0x0
c00229ec:	68 cd 00 00 00       	push   $0xcd
c00229f1:	e9 d6 f6 ff ff       	jmp    c00220cc <intr_entry>

c00229f6 <intrce_stub>:
c00229f6:	55                   	push   %ebp
c00229f7:	6a 00                	push   $0x0
c00229f9:	68 ce 00 00 00       	push   $0xce
c00229fe:	e9 c9 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a03 <intrcf_stub>:
c0022a03:	55                   	push   %ebp
c0022a04:	6a 00                	push   $0x0
c0022a06:	68 cf 00 00 00       	push   $0xcf
c0022a0b:	e9 bc f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a10 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022a10:	55                   	push   %ebp
c0022a11:	6a 00                	push   $0x0
c0022a13:	68 d0 00 00 00       	push   $0xd0
c0022a18:	e9 af f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a1d <intrd1_stub>:
c0022a1d:	55                   	push   %ebp
c0022a1e:	6a 00                	push   $0x0
c0022a20:	68 d1 00 00 00       	push   $0xd1
c0022a25:	e9 a2 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a2a <intrd2_stub>:
c0022a2a:	55                   	push   %ebp
c0022a2b:	6a 00                	push   $0x0
c0022a2d:	68 d2 00 00 00       	push   $0xd2
c0022a32:	e9 95 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a37 <intrd3_stub>:
c0022a37:	55                   	push   %ebp
c0022a38:	6a 00                	push   $0x0
c0022a3a:	68 d3 00 00 00       	push   $0xd3
c0022a3f:	e9 88 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a44 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022a44:	55                   	push   %ebp
c0022a45:	6a 00                	push   $0x0
c0022a47:	68 d4 00 00 00       	push   $0xd4
c0022a4c:	e9 7b f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a51 <intrd5_stub>:
c0022a51:	55                   	push   %ebp
c0022a52:	6a 00                	push   $0x0
c0022a54:	68 d5 00 00 00       	push   $0xd5
c0022a59:	e9 6e f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a5e <intrd6_stub>:
c0022a5e:	55                   	push   %ebp
c0022a5f:	6a 00                	push   $0x0
c0022a61:	68 d6 00 00 00       	push   $0xd6
c0022a66:	e9 61 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a6b <intrd7_stub>:
c0022a6b:	55                   	push   %ebp
c0022a6c:	6a 00                	push   $0x0
c0022a6e:	68 d7 00 00 00       	push   $0xd7
c0022a73:	e9 54 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a78 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022a78:	55                   	push   %ebp
c0022a79:	6a 00                	push   $0x0
c0022a7b:	68 d8 00 00 00       	push   $0xd8
c0022a80:	e9 47 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a85 <intrd9_stub>:
c0022a85:	55                   	push   %ebp
c0022a86:	6a 00                	push   $0x0
c0022a88:	68 d9 00 00 00       	push   $0xd9
c0022a8d:	e9 3a f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a92 <intrda_stub>:
c0022a92:	55                   	push   %ebp
c0022a93:	6a 00                	push   $0x0
c0022a95:	68 da 00 00 00       	push   $0xda
c0022a9a:	e9 2d f6 ff ff       	jmp    c00220cc <intr_entry>

c0022a9f <intrdb_stub>:
c0022a9f:	55                   	push   %ebp
c0022aa0:	6a 00                	push   $0x0
c0022aa2:	68 db 00 00 00       	push   $0xdb
c0022aa7:	e9 20 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022aac <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022aac:	55                   	push   %ebp
c0022aad:	6a 00                	push   $0x0
c0022aaf:	68 dc 00 00 00       	push   $0xdc
c0022ab4:	e9 13 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022ab9 <intrdd_stub>:
c0022ab9:	55                   	push   %ebp
c0022aba:	6a 00                	push   $0x0
c0022abc:	68 dd 00 00 00       	push   $0xdd
c0022ac1:	e9 06 f6 ff ff       	jmp    c00220cc <intr_entry>

c0022ac6 <intrde_stub>:
c0022ac6:	55                   	push   %ebp
c0022ac7:	6a 00                	push   $0x0
c0022ac9:	68 de 00 00 00       	push   $0xde
c0022ace:	e9 f9 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022ad3 <intrdf_stub>:
c0022ad3:	55                   	push   %ebp
c0022ad4:	6a 00                	push   $0x0
c0022ad6:	68 df 00 00 00       	push   $0xdf
c0022adb:	e9 ec f5 ff ff       	jmp    c00220cc <intr_entry>

c0022ae0 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022ae0:	55                   	push   %ebp
c0022ae1:	6a 00                	push   $0x0
c0022ae3:	68 e0 00 00 00       	push   $0xe0
c0022ae8:	e9 df f5 ff ff       	jmp    c00220cc <intr_entry>

c0022aed <intre1_stub>:
c0022aed:	55                   	push   %ebp
c0022aee:	6a 00                	push   $0x0
c0022af0:	68 e1 00 00 00       	push   $0xe1
c0022af5:	e9 d2 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022afa <intre2_stub>:
c0022afa:	55                   	push   %ebp
c0022afb:	6a 00                	push   $0x0
c0022afd:	68 e2 00 00 00       	push   $0xe2
c0022b02:	e9 c5 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b07 <intre3_stub>:
c0022b07:	55                   	push   %ebp
c0022b08:	6a 00                	push   $0x0
c0022b0a:	68 e3 00 00 00       	push   $0xe3
c0022b0f:	e9 b8 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b14 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022b14:	55                   	push   %ebp
c0022b15:	6a 00                	push   $0x0
c0022b17:	68 e4 00 00 00       	push   $0xe4
c0022b1c:	e9 ab f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b21 <intre5_stub>:
c0022b21:	55                   	push   %ebp
c0022b22:	6a 00                	push   $0x0
c0022b24:	68 e5 00 00 00       	push   $0xe5
c0022b29:	e9 9e f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b2e <intre6_stub>:
c0022b2e:	55                   	push   %ebp
c0022b2f:	6a 00                	push   $0x0
c0022b31:	68 e6 00 00 00       	push   $0xe6
c0022b36:	e9 91 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b3b <intre7_stub>:
c0022b3b:	55                   	push   %ebp
c0022b3c:	6a 00                	push   $0x0
c0022b3e:	68 e7 00 00 00       	push   $0xe7
c0022b43:	e9 84 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b48 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022b48:	55                   	push   %ebp
c0022b49:	6a 00                	push   $0x0
c0022b4b:	68 e8 00 00 00       	push   $0xe8
c0022b50:	e9 77 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b55 <intre9_stub>:
c0022b55:	55                   	push   %ebp
c0022b56:	6a 00                	push   $0x0
c0022b58:	68 e9 00 00 00       	push   $0xe9
c0022b5d:	e9 6a f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b62 <intrea_stub>:
c0022b62:	55                   	push   %ebp
c0022b63:	6a 00                	push   $0x0
c0022b65:	68 ea 00 00 00       	push   $0xea
c0022b6a:	e9 5d f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b6f <intreb_stub>:
c0022b6f:	55                   	push   %ebp
c0022b70:	6a 00                	push   $0x0
c0022b72:	68 eb 00 00 00       	push   $0xeb
c0022b77:	e9 50 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b7c <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022b7c:	55                   	push   %ebp
c0022b7d:	6a 00                	push   $0x0
c0022b7f:	68 ec 00 00 00       	push   $0xec
c0022b84:	e9 43 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b89 <intred_stub>:
c0022b89:	55                   	push   %ebp
c0022b8a:	6a 00                	push   $0x0
c0022b8c:	68 ed 00 00 00       	push   $0xed
c0022b91:	e9 36 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022b96 <intree_stub>:
c0022b96:	55                   	push   %ebp
c0022b97:	6a 00                	push   $0x0
c0022b99:	68 ee 00 00 00       	push   $0xee
c0022b9e:	e9 29 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022ba3 <intref_stub>:
c0022ba3:	55                   	push   %ebp
c0022ba4:	6a 00                	push   $0x0
c0022ba6:	68 ef 00 00 00       	push   $0xef
c0022bab:	e9 1c f5 ff ff       	jmp    c00220cc <intr_entry>

c0022bb0 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022bb0:	55                   	push   %ebp
c0022bb1:	6a 00                	push   $0x0
c0022bb3:	68 f0 00 00 00       	push   $0xf0
c0022bb8:	e9 0f f5 ff ff       	jmp    c00220cc <intr_entry>

c0022bbd <intrf1_stub>:
c0022bbd:	55                   	push   %ebp
c0022bbe:	6a 00                	push   $0x0
c0022bc0:	68 f1 00 00 00       	push   $0xf1
c0022bc5:	e9 02 f5 ff ff       	jmp    c00220cc <intr_entry>

c0022bca <intrf2_stub>:
c0022bca:	55                   	push   %ebp
c0022bcb:	6a 00                	push   $0x0
c0022bcd:	68 f2 00 00 00       	push   $0xf2
c0022bd2:	e9 f5 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022bd7 <intrf3_stub>:
c0022bd7:	55                   	push   %ebp
c0022bd8:	6a 00                	push   $0x0
c0022bda:	68 f3 00 00 00       	push   $0xf3
c0022bdf:	e9 e8 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022be4 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022be4:	55                   	push   %ebp
c0022be5:	6a 00                	push   $0x0
c0022be7:	68 f4 00 00 00       	push   $0xf4
c0022bec:	e9 db f4 ff ff       	jmp    c00220cc <intr_entry>

c0022bf1 <intrf5_stub>:
c0022bf1:	55                   	push   %ebp
c0022bf2:	6a 00                	push   $0x0
c0022bf4:	68 f5 00 00 00       	push   $0xf5
c0022bf9:	e9 ce f4 ff ff       	jmp    c00220cc <intr_entry>

c0022bfe <intrf6_stub>:
c0022bfe:	55                   	push   %ebp
c0022bff:	6a 00                	push   $0x0
c0022c01:	68 f6 00 00 00       	push   $0xf6
c0022c06:	e9 c1 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c0b <intrf7_stub>:
c0022c0b:	55                   	push   %ebp
c0022c0c:	6a 00                	push   $0x0
c0022c0e:	68 f7 00 00 00       	push   $0xf7
c0022c13:	e9 b4 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c18 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022c18:	55                   	push   %ebp
c0022c19:	6a 00                	push   $0x0
c0022c1b:	68 f8 00 00 00       	push   $0xf8
c0022c20:	e9 a7 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c25 <intrf9_stub>:
c0022c25:	55                   	push   %ebp
c0022c26:	6a 00                	push   $0x0
c0022c28:	68 f9 00 00 00       	push   $0xf9
c0022c2d:	e9 9a f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c32 <intrfa_stub>:
c0022c32:	55                   	push   %ebp
c0022c33:	6a 00                	push   $0x0
c0022c35:	68 fa 00 00 00       	push   $0xfa
c0022c3a:	e9 8d f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c3f <intrfb_stub>:
c0022c3f:	55                   	push   %ebp
c0022c40:	6a 00                	push   $0x0
c0022c42:	68 fb 00 00 00       	push   $0xfb
c0022c47:	e9 80 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c4c <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022c4c:	55                   	push   %ebp
c0022c4d:	6a 00                	push   $0x0
c0022c4f:	68 fc 00 00 00       	push   $0xfc
c0022c54:	e9 73 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c59 <intrfd_stub>:
c0022c59:	55                   	push   %ebp
c0022c5a:	6a 00                	push   $0x0
c0022c5c:	68 fd 00 00 00       	push   $0xfd
c0022c61:	e9 66 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c66 <intrfe_stub>:
c0022c66:	55                   	push   %ebp
c0022c67:	6a 00                	push   $0x0
c0022c69:	68 fe 00 00 00       	push   $0xfe
c0022c6e:	e9 59 f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c73 <intrff_stub>:
c0022c73:	55                   	push   %ebp
c0022c74:	6a 00                	push   $0x0
c0022c76:	68 ff 00 00 00       	push   $0xff
c0022c7b:	e9 4c f4 ff ff       	jmp    c00220cc <intr_entry>

c0022c80 <cond_sema_cmp_priority>:

bool lock_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {
  return list_entry(a, struct lock, elem)->max_priority > list_entry(b, struct lock, elem)->max_priority;
}

bool cond_sema_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {
c0022c80:	56                   	push   %esi
c0022c81:	53                   	push   %ebx
c0022c82:	83 ec 10             	sub    $0x10,%esp
c0022c85:	e8 b1 ac 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022c8a:	81 c3 42 68 01 00    	add    $0x16842,%ebx
  struct semaphore_elem *sa = list_entry(a, struct semaphore_elem, elem);
  struct semaphore_elem *sb = list_entry(b, struct semaphore_elem, elem);
  return list_entry(list_front(&sa->semaphore.waiters), struct thread, elem)->priority > list_entry(list_front(&sb->semaphore.waiters), struct thread, elem)->priority;
c0022c90:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0022c94:	83 c0 0c             	add    $0xc,%eax
c0022c97:	50                   	push   %eax
c0022c98:	e8 88 6a 00 00       	call   c0029725 <list_front>
c0022c9d:	8b 70 f4             	mov    -0xc(%eax),%esi
c0022ca0:	8b 44 24 24          	mov    0x24(%esp),%eax
c0022ca4:	83 c0 0c             	add    $0xc,%eax
c0022ca7:	89 04 24             	mov    %eax,(%esp)
c0022caa:	e8 76 6a 00 00       	call   c0029725 <list_front>
c0022caf:	3b 70 f4             	cmp    -0xc(%eax),%esi
c0022cb2:	0f 9f c0             	setg   %al
c0022cb5:	83 c4 14             	add    $0x14,%esp
c0022cb8:	5b                   	pop    %ebx
c0022cb9:	5e                   	pop    %esi
c0022cba:	c3                   	ret    

c0022cbb <sema_init>:
{
c0022cbb:	53                   	push   %ebx
c0022cbc:	83 ec 08             	sub    $0x8,%esp
c0022cbf:	e8 77 ac 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022cc4:	81 c3 08 68 01 00    	add    $0x16808,%ebx
c0022cca:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (sema != NULL);
c0022cce:	85 c0                	test   %eax,%eax
c0022cd0:	74 17                	je     c0022ce9 <sema_init+0x2e>
  sema->value = value;
c0022cd2:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022cd6:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022cd8:	83 ec 0c             	sub    $0xc,%esp
c0022cdb:	83 c0 04             	add    $0x4,%eax
c0022cde:	50                   	push   %eax
c0022cdf:	e8 78 63 00 00       	call   c002905c <list_init>
}
c0022ce4:	83 c4 18             	add    $0x18,%esp
c0022ce7:	5b                   	pop    %ebx
c0022ce8:	c3                   	ret    
  ASSERT (sema != NULL);
c0022ce9:	83 ec 0c             	sub    $0xc,%esp
c0022cec:	8d 83 42 5e ff ff    	lea    -0xa1be(%ebx),%eax
c0022cf2:	50                   	push   %eax
c0022cf3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0022cf9:	50                   	push   %eax
c0022cfa:	8d 83 88 47 ff ff    	lea    -0xb878(%ebx),%eax
c0022d00:	50                   	push   %eax
c0022d01:	6a 2f                	push   $0x2f
c0022d03:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0022d09:	50                   	push   %eax
c0022d0a:	e8 80 62 00 00       	call   c0028f8f <debug_panic>

c0022d0f <sema_down>:
{
c0022d0f:	55                   	push   %ebp
c0022d10:	57                   	push   %edi
c0022d11:	56                   	push   %esi
c0022d12:	53                   	push   %ebx
c0022d13:	83 ec 1c             	sub    $0x1c,%esp
c0022d16:	e8 20 ac 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022d1b:	81 c3 b1 67 01 00    	add    $0x167b1,%ebx
c0022d21:	8b 74 24 30          	mov    0x30(%esp),%esi
  ASSERT (sema != NULL);
c0022d25:	85 f6                	test   %esi,%esi
c0022d27:	74 5a                	je     c0022d83 <sema_down+0x74>
  ASSERT (!intr_context ());
c0022d29:	e8 bc f0 ff ff       	call   c0021dea <intr_context>
c0022d2e:	84 c0                	test   %al,%al
c0022d30:	75 77                	jne    c0022da9 <sema_down+0x9a>
  old_level = intr_disable ();
c0022d32:	e8 0f ee ff ff       	call   c0021b46 <intr_disable>
c0022d37:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (sema->value == 0) 
c0022d3b:	8b 06                	mov    (%esi),%eax
c0022d3d:	85 c0                	test   %eax,%eax
c0022d3f:	75 29                	jne    c0022d6a <sema_down+0x5b>
      list_insert_ordered(&sema->waiters, &thread_current()->elem, thread_cmp_priority, NULL);
c0022d41:	c7 c5 a2 07 02 c0    	mov    $0xc00207a2,%ebp
c0022d47:	8d 7e 04             	lea    0x4(%esi),%edi
c0022d4a:	e8 34 de ff ff       	call   c0020b83 <thread_current>
c0022d4f:	6a 00                	push   $0x0
c0022d51:	55                   	push   %ebp
c0022d52:	83 c0 28             	add    $0x28,%eax
c0022d55:	50                   	push   %eax
c0022d56:	57                   	push   %edi
c0022d57:	e8 f8 6d 00 00       	call   c0029b54 <list_insert_ordered>
      thread_block ();
c0022d5c:	e8 d1 e1 ff ff       	call   c0020f32 <thread_block>
  while (sema->value == 0) 
c0022d61:	8b 06                	mov    (%esi),%eax
c0022d63:	83 c4 10             	add    $0x10,%esp
c0022d66:	85 c0                	test   %eax,%eax
c0022d68:	74 e0                	je     c0022d4a <sema_down+0x3b>
  sema->value--;
c0022d6a:	83 e8 01             	sub    $0x1,%eax
c0022d6d:	89 06                	mov    %eax,(%esi)
  intr_set_level (old_level);
c0022d6f:	83 ec 0c             	sub    $0xc,%esp
c0022d72:	ff 74 24 18          	pushl  0x18(%esp)
c0022d76:	e8 d2 ed ff ff       	call   c0021b4d <intr_set_level>
}
c0022d7b:	83 c4 2c             	add    $0x2c,%esp
c0022d7e:	5b                   	pop    %ebx
c0022d7f:	5e                   	pop    %esi
c0022d80:	5f                   	pop    %edi
c0022d81:	5d                   	pop    %ebp
c0022d82:	c3                   	ret    
  ASSERT (sema != NULL);
c0022d83:	83 ec 0c             	sub    $0xc,%esp
c0022d86:	8d 83 42 5e ff ff    	lea    -0xa1be(%ebx),%eax
c0022d8c:	50                   	push   %eax
c0022d8d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0022d93:	50                   	push   %eax
c0022d94:	8d 83 7c 47 ff ff    	lea    -0xb884(%ebx),%eax
c0022d9a:	50                   	push   %eax
c0022d9b:	6a 41                	push   $0x41
c0022d9d:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0022da3:	50                   	push   %eax
c0022da4:	e8 e6 61 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!intr_context ());
c0022da9:	83 ec 0c             	sub    $0xc,%esp
c0022dac:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0022db2:	50                   	push   %eax
c0022db3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0022db9:	50                   	push   %eax
c0022dba:	8d 83 7c 47 ff ff    	lea    -0xb884(%ebx),%eax
c0022dc0:	50                   	push   %eax
c0022dc1:	6a 42                	push   $0x42
c0022dc3:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0022dc9:	50                   	push   %eax
c0022dca:	e8 c0 61 00 00       	call   c0028f8f <debug_panic>

c0022dcf <sema_try_down>:
{
c0022dcf:	57                   	push   %edi
c0022dd0:	56                   	push   %esi
c0022dd1:	53                   	push   %ebx
c0022dd2:	e8 64 ab 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022dd7:	81 c3 f5 66 01 00    	add    $0x166f5,%ebx
c0022ddd:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (sema != NULL);
c0022de1:	85 f6                	test   %esi,%esi
c0022de3:	74 2c                	je     c0022e11 <sema_try_down+0x42>
  old_level = intr_disable ();
c0022de5:	e8 5c ed ff ff       	call   c0021b46 <intr_disable>
  if (sema->value > 0) 
c0022dea:	8b 16                	mov    (%esi),%edx
    success = false;
c0022dec:	bf 00 00 00 00       	mov    $0x0,%edi
  if (sema->value > 0) 
c0022df1:	85 d2                	test   %edx,%edx
c0022df3:	74 0a                	je     c0022dff <sema_try_down+0x30>
      sema->value--;
c0022df5:	83 ea 01             	sub    $0x1,%edx
c0022df8:	89 16                	mov    %edx,(%esi)
      success = true; 
c0022dfa:	bf 01 00 00 00       	mov    $0x1,%edi
  intr_set_level (old_level);
c0022dff:	83 ec 0c             	sub    $0xc,%esp
c0022e02:	50                   	push   %eax
c0022e03:	e8 45 ed ff ff       	call   c0021b4d <intr_set_level>
  return success;
c0022e08:	83 c4 10             	add    $0x10,%esp
}
c0022e0b:	89 f8                	mov    %edi,%eax
c0022e0d:	5b                   	pop    %ebx
c0022e0e:	5e                   	pop    %esi
c0022e0f:	5f                   	pop    %edi
c0022e10:	c3                   	ret    
  ASSERT (sema != NULL);
c0022e11:	83 ec 0c             	sub    $0xc,%esp
c0022e14:	8d 83 42 5e ff ff    	lea    -0xa1be(%ebx),%eax
c0022e1a:	50                   	push   %eax
c0022e1b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0022e21:	50                   	push   %eax
c0022e22:	8d 83 6c 47 ff ff    	lea    -0xb894(%ebx),%eax
c0022e28:	50                   	push   %eax
c0022e29:	6a 5a                	push   $0x5a
c0022e2b:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0022e31:	50                   	push   %eax
c0022e32:	e8 58 61 00 00       	call   c0028f8f <debug_panic>

c0022e37 <sema_up>:
{
c0022e37:	55                   	push   %ebp
c0022e38:	57                   	push   %edi
c0022e39:	56                   	push   %esi
c0022e3a:	53                   	push   %ebx
c0022e3b:	83 ec 0c             	sub    $0xc,%esp
c0022e3e:	e8 f8 aa 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022e43:	81 c3 89 66 01 00    	add    $0x16689,%ebx
c0022e49:	8b 74 24 20          	mov    0x20(%esp),%esi
  ASSERT (sema != NULL);
c0022e4d:	85 f6                	test   %esi,%esi
c0022e4f:	74 33                	je     c0022e84 <sema_up+0x4d>
  old_level = intr_disable ();
c0022e51:	e8 f0 ec ff ff       	call   c0021b46 <intr_disable>
c0022e56:	89 c5                	mov    %eax,%ebp
  if (!list_empty (&sema->waiters)) {
c0022e58:	8d 7e 04             	lea    0x4(%esi),%edi
c0022e5b:	83 ec 0c             	sub    $0xc,%esp
c0022e5e:	57                   	push   %edi
c0022e5f:	e8 9d 68 00 00       	call   c0029701 <list_empty>
c0022e64:	83 c4 10             	add    $0x10,%esp
c0022e67:	84 c0                	test   %al,%al
c0022e69:	74 3f                	je     c0022eaa <sema_up+0x73>
  sema->value++;
c0022e6b:	83 06 01             	addl   $0x1,(%esi)
  thread_yield();
c0022e6e:	e8 5a e2 ff ff       	call   c00210cd <thread_yield>
  intr_set_level (old_level);
c0022e73:	83 ec 0c             	sub    $0xc,%esp
c0022e76:	55                   	push   %ebp
c0022e77:	e8 d1 ec ff ff       	call   c0021b4d <intr_set_level>
}
c0022e7c:	83 c4 1c             	add    $0x1c,%esp
c0022e7f:	5b                   	pop    %ebx
c0022e80:	5e                   	pop    %esi
c0022e81:	5f                   	pop    %edi
c0022e82:	5d                   	pop    %ebp
c0022e83:	c3                   	ret    
  ASSERT (sema != NULL);
c0022e84:	83 ec 0c             	sub    $0xc,%esp
c0022e87:	8d 83 42 5e ff ff    	lea    -0xa1be(%ebx),%eax
c0022e8d:	50                   	push   %eax
c0022e8e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0022e94:	50                   	push   %eax
c0022e95:	8d 83 64 47 ff ff    	lea    -0xb89c(%ebx),%eax
c0022e9b:	50                   	push   %eax
c0022e9c:	6a 72                	push   $0x72
c0022e9e:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0022ea4:	50                   	push   %eax
c0022ea5:	e8 e5 60 00 00       	call   c0028f8f <debug_panic>
    list_sort(&sema->waiters, thread_cmp_priority, NULL);
c0022eaa:	83 ec 04             	sub    $0x4,%esp
c0022ead:	6a 00                	push   $0x0
c0022eaf:	ff b3 f8 ff ff ff    	pushl  -0x8(%ebx)
c0022eb5:	57                   	push   %edi
c0022eb6:	e8 ac 69 00 00       	call   c0029867 <list_sort>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022ebb:	89 3c 24             	mov    %edi,(%esp)
c0022ebe:	e8 b5 68 00 00       	call   c0029778 <list_pop_front>
c0022ec3:	83 e8 28             	sub    $0x28,%eax
c0022ec6:	89 04 24             	mov    %eax,(%esp)
c0022ec9:	e8 08 dc ff ff       	call   c0020ad6 <thread_unblock>
c0022ece:	83 c4 10             	add    $0x10,%esp
c0022ed1:	eb 98                	jmp    c0022e6b <sema_up+0x34>

c0022ed3 <sema_test_helper>:
{
c0022ed3:	57                   	push   %edi
c0022ed4:	56                   	push   %esi
c0022ed5:	53                   	push   %ebx
c0022ed6:	8b 74 24 10          	mov    0x10(%esp),%esi
c0022eda:	bb 0a 00 00 00       	mov    $0xa,%ebx
      sema_up (&sema[1]);
c0022edf:	8d 7e 14             	lea    0x14(%esi),%edi
      sema_down (&sema[0]);
c0022ee2:	83 ec 0c             	sub    $0xc,%esp
c0022ee5:	56                   	push   %esi
c0022ee6:	e8 24 fe ff ff       	call   c0022d0f <sema_down>
      sema_up (&sema[1]);
c0022eeb:	89 3c 24             	mov    %edi,(%esp)
c0022eee:	e8 44 ff ff ff       	call   c0022e37 <sema_up>
  for (i = 0; i < 10; i++) 
c0022ef3:	83 c4 10             	add    $0x10,%esp
c0022ef6:	83 eb 01             	sub    $0x1,%ebx
c0022ef9:	75 e7                	jne    c0022ee2 <sema_test_helper+0xf>
}
c0022efb:	5b                   	pop    %ebx
c0022efc:	5e                   	pop    %esi
c0022efd:	5f                   	pop    %edi
c0022efe:	c3                   	ret    

c0022eff <sema_self_test>:
{
c0022eff:	55                   	push   %ebp
c0022f00:	57                   	push   %edi
c0022f01:	56                   	push   %esi
c0022f02:	53                   	push   %ebx
c0022f03:	83 ec 48             	sub    $0x48,%esp
c0022f06:	e8 30 aa 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022f0b:	81 c3 c1 65 01 00    	add    $0x165c1,%ebx
  printf ("Testing semaphores...");
c0022f11:	8d 83 65 5e ff ff    	lea    -0xa19b(%ebx),%eax
c0022f17:	50                   	push   %eax
c0022f18:	e8 db 42 00 00       	call   c00271f8 <printf>
  sema_init (&sema[0], 0);
c0022f1d:	83 c4 08             	add    $0x8,%esp
c0022f20:	6a 00                	push   $0x0
c0022f22:	8d 74 24 14          	lea    0x14(%esp),%esi
c0022f26:	56                   	push   %esi
c0022f27:	e8 8f fd ff ff       	call   c0022cbb <sema_init>
  sema_init (&sema[1], 0);
c0022f2c:	83 c4 08             	add    $0x8,%esp
c0022f2f:	6a 00                	push   $0x0
c0022f31:	8d 44 24 28          	lea    0x28(%esp),%eax
c0022f35:	50                   	push   %eax
c0022f36:	e8 80 fd ff ff       	call   c0022cbb <sema_init>
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022f3b:	56                   	push   %esi
c0022f3c:	8d 83 07 9a fe ff    	lea    -0x165f9(%ebx),%eax
c0022f42:	50                   	push   %eax
c0022f43:	6a 1f                	push   $0x1f
c0022f45:	8d 83 7b 5e ff ff    	lea    -0xa185(%ebx),%eax
c0022f4b:	50                   	push   %eax
c0022f4c:	e8 0a e2 ff ff       	call   c002115b <thread_create>
c0022f51:	83 c4 20             	add    $0x20,%esp
c0022f54:	be 0a 00 00 00       	mov    $0xa,%esi
      sema_up (&sema[0]);
c0022f59:	8d 6c 24 08          	lea    0x8(%esp),%ebp
      sema_down (&sema[1]);
c0022f5d:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
      sema_up (&sema[0]);
c0022f61:	83 ec 0c             	sub    $0xc,%esp
c0022f64:	55                   	push   %ebp
c0022f65:	e8 cd fe ff ff       	call   c0022e37 <sema_up>
      sema_down (&sema[1]);
c0022f6a:	89 3c 24             	mov    %edi,(%esp)
c0022f6d:	e8 9d fd ff ff       	call   c0022d0f <sema_down>
  for (i = 0; i < 10; i++) 
c0022f72:	83 c4 10             	add    $0x10,%esp
c0022f75:	83 ee 01             	sub    $0x1,%esi
c0022f78:	75 e7                	jne    c0022f61 <sema_self_test+0x62>
  printf ("done.\n");
c0022f7a:	83 ec 0c             	sub    $0xc,%esp
c0022f7d:	8d 83 85 5e ff ff    	lea    -0xa17b(%ebx),%eax
c0022f83:	50                   	push   %eax
c0022f84:	e8 2a 7f 00 00       	call   c002aeb3 <puts>
}
c0022f89:	83 c4 4c             	add    $0x4c,%esp
c0022f8c:	5b                   	pop    %ebx
c0022f8d:	5e                   	pop    %esi
c0022f8e:	5f                   	pop    %edi
c0022f8f:	5d                   	pop    %ebp
c0022f90:	c3                   	ret    

c0022f91 <lock_init>:
{
c0022f91:	53                   	push   %ebx
c0022f92:	83 ec 08             	sub    $0x8,%esp
c0022f95:	e8 a1 a9 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022f9a:	81 c3 32 65 01 00    	add    $0x16532,%ebx
c0022fa0:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022fa4:	85 c0                	test   %eax,%eax
c0022fa6:	74 19                	je     c0022fc1 <lock_init+0x30>
  lock->holder = NULL;
c0022fa8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022fae:	83 ec 08             	sub    $0x8,%esp
c0022fb1:	6a 01                	push   $0x1
c0022fb3:	83 c0 04             	add    $0x4,%eax
c0022fb6:	50                   	push   %eax
c0022fb7:	e8 ff fc ff ff       	call   c0022cbb <sema_init>
}
c0022fbc:	83 c4 18             	add    $0x18,%esp
c0022fbf:	5b                   	pop    %ebx
c0022fc0:	c3                   	ret    
  ASSERT (lock != NULL);
c0022fc1:	83 ec 0c             	sub    $0xc,%esp
c0022fc4:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c0022fca:	50                   	push   %eax
c0022fcb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0022fd1:	50                   	push   %eax
c0022fd2:	8d 83 58 47 ff ff    	lea    -0xb8a8(%ebx),%eax
c0022fd8:	50                   	push   %eax
c0022fd9:	68 b6 00 00 00       	push   $0xb6
c0022fde:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0022fe4:	50                   	push   %eax
c0022fe5:	e8 a5 5f 00 00       	call   c0028f8f <debug_panic>

c0022fea <lock_held_by_current_thread>:
{
c0022fea:	56                   	push   %esi
c0022feb:	53                   	push   %ebx
c0022fec:	83 ec 04             	sub    $0x4,%esp
c0022fef:	e8 47 a9 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0022ff4:	81 c3 d8 64 01 00    	add    $0x164d8,%ebx
c0022ffa:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022ffe:	85 c0                	test   %eax,%eax
c0023000:	74 12                	je     c0023014 <lock_held_by_current_thread+0x2a>
  return lock->holder == thread_current ();
c0023002:	8b 30                	mov    (%eax),%esi
c0023004:	e8 7a db ff ff       	call   c0020b83 <thread_current>
c0023009:	39 c6                	cmp    %eax,%esi
c002300b:	0f 94 c0             	sete   %al
}
c002300e:	83 c4 04             	add    $0x4,%esp
c0023011:	5b                   	pop    %ebx
c0023012:	5e                   	pop    %esi
c0023013:	c3                   	ret    
  ASSERT (lock != NULL);
c0023014:	83 ec 0c             	sub    $0xc,%esp
c0023017:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c002301d:	50                   	push   %eax
c002301e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023024:	50                   	push   %eax
c0023025:	8d 83 08 47 ff ff    	lea    -0xb8f8(%ebx),%eax
c002302b:	50                   	push   %eax
c002302c:	68 1a 01 00 00       	push   $0x11a
c0023031:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023037:	50                   	push   %eax
c0023038:	e8 52 5f 00 00       	call   c0028f8f <debug_panic>

c002303d <lock_acquire>:
{
c002303d:	55                   	push   %ebp
c002303e:	57                   	push   %edi
c002303f:	56                   	push   %esi
c0023040:	53                   	push   %ebx
c0023041:	83 ec 0c             	sub    $0xc,%esp
c0023044:	e8 f2 a8 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023049:	81 c3 83 64 01 00    	add    $0x16483,%ebx
c002304f:	8b 7c 24 20          	mov    0x20(%esp),%edi
  struct thread *current_thread = thread_current ();
c0023053:	e8 2b db ff ff       	call   c0020b83 <thread_current>
  ASSERT (lock != NULL);
c0023058:	85 ff                	test   %edi,%edi
c002305a:	0f 84 a0 00 00 00    	je     c0023100 <lock_acquire+0xc3>
c0023060:	89 c5                	mov    %eax,%ebp
  ASSERT (!intr_context ());
c0023062:	e8 83 ed ff ff       	call   c0021dea <intr_context>
c0023067:	84 c0                	test   %al,%al
c0023069:	0f 85 ba 00 00 00    	jne    c0023129 <lock_acquire+0xec>
  ASSERT (!lock_held_by_current_thread (lock));
c002306f:	83 ec 0c             	sub    $0xc,%esp
c0023072:	57                   	push   %edi
c0023073:	e8 72 ff ff ff       	call   c0022fea <lock_held_by_current_thread>
c0023078:	83 c4 10             	add    $0x10,%esp
c002307b:	84 c0                	test   %al,%al
c002307d:	0f 85 cf 00 00 00    	jne    c0023152 <lock_acquire+0x115>
  if (lock->holder != NULL && !thread_mlfqs) {
c0023083:	83 3f 00             	cmpl   $0x0,(%edi)
c0023086:	74 39                	je     c00230c1 <lock_acquire+0x84>
c0023088:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002308e:	80 38 00             	cmpb   $0x0,(%eax)
c0023091:	75 2e                	jne    c00230c1 <lock_acquire+0x84>
    current_thread->lock_waiting = lock;
c0023093:	89 7d 50             	mov    %edi,0x50(%ebp)
    while (l && current_thread->priority > l->max_priority) {
c0023096:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0023099:	3b 47 20             	cmp    0x20(%edi),%eax
c002309c:	7e 23                	jle    c00230c1 <lock_acquire+0x84>
    l = lock;
c002309e:	89 fe                	mov    %edi,%esi
      l->max_priority = current_thread->priority;
c00230a0:	89 46 20             	mov    %eax,0x20(%esi)
      thread_donate_priority(l->holder);
c00230a3:	83 ec 0c             	sub    $0xc,%esp
c00230a6:	ff 36                	pushl  (%esi)
c00230a8:	e8 30 e4 ff ff       	call   c00214dd <thread_donate_priority>
      l = l->holder->lock_waiting;
c00230ad:	8b 06                	mov    (%esi),%eax
c00230af:	8b 70 50             	mov    0x50(%eax),%esi
    while (l && current_thread->priority > l->max_priority) {
c00230b2:	83 c4 10             	add    $0x10,%esp
c00230b5:	85 f6                	test   %esi,%esi
c00230b7:	74 08                	je     c00230c1 <lock_acquire+0x84>
c00230b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00230bc:	3b 46 20             	cmp    0x20(%esi),%eax
c00230bf:	7f df                	jg     c00230a0 <lock_acquire+0x63>
  sema_down (&lock->semaphore);
c00230c1:	83 ec 0c             	sub    $0xc,%esp
c00230c4:	8d 47 04             	lea    0x4(%edi),%eax
c00230c7:	50                   	push   %eax
c00230c8:	e8 42 fc ff ff       	call   c0022d0f <sema_down>
  old_level = intr_disable();
c00230cd:	e8 74 ea ff ff       	call   c0021b46 <intr_disable>
c00230d2:	89 c5                	mov    %eax,%ebp
  current_thread = thread_current();
c00230d4:	e8 aa da ff ff       	call   c0020b83 <thread_current>
c00230d9:	89 c6                	mov    %eax,%esi
  if (!thread_mlfqs) {
c00230db:	83 c4 10             	add    $0x10,%esp
c00230de:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c00230e4:	80 38 00             	cmpb   $0x0,(%eax)
c00230e7:	0f 84 8e 00 00 00    	je     c002317b <lock_acquire+0x13e>
  lock->holder = current_thread;
c00230ed:	89 37                	mov    %esi,(%edi)
  intr_set_level(old_level);
c00230ef:	83 ec 0c             	sub    $0xc,%esp
c00230f2:	55                   	push   %ebp
c00230f3:	e8 55 ea ff ff       	call   c0021b4d <intr_set_level>
}
c00230f8:	83 c4 1c             	add    $0x1c,%esp
c00230fb:	5b                   	pop    %ebx
c00230fc:	5e                   	pop    %esi
c00230fd:	5f                   	pop    %edi
c00230fe:	5d                   	pop    %ebp
c00230ff:	c3                   	ret    
  ASSERT (lock != NULL);
c0023100:	83 ec 0c             	sub    $0xc,%esp
c0023103:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c0023109:	50                   	push   %eax
c002310a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023110:	50                   	push   %eax
c0023111:	8d 83 48 47 ff ff    	lea    -0xb8b8(%ebx),%eax
c0023117:	50                   	push   %eax
c0023118:	68 cb 00 00 00       	push   $0xcb
c002311d:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023123:	50                   	push   %eax
c0023124:	e8 66 5e 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!intr_context ());
c0023129:	83 ec 0c             	sub    $0xc,%esp
c002312c:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0023132:	50                   	push   %eax
c0023133:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023139:	50                   	push   %eax
c002313a:	8d 83 48 47 ff ff    	lea    -0xb8b8(%ebx),%eax
c0023140:	50                   	push   %eax
c0023141:	68 cc 00 00 00       	push   $0xcc
c0023146:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c002314c:	50                   	push   %eax
c002314d:	e8 3d 5e 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0023152:	83 ec 0c             	sub    $0xc,%esp
c0023155:	8d 83 a8 5e ff ff    	lea    -0xa158(%ebx),%eax
c002315b:	50                   	push   %eax
c002315c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023162:	50                   	push   %eax
c0023163:	8d 83 48 47 ff ff    	lea    -0xb8b8(%ebx),%eax
c0023169:	50                   	push   %eax
c002316a:	68 cd 00 00 00       	push   $0xcd
c002316f:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023175:	50                   	push   %eax
c0023176:	e8 14 5e 00 00       	call   c0028f8f <debug_panic>
    current_thread->lock_waiting = NULL;
c002317b:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
    lock->max_priority = current_thread->priority;
c0023182:	8b 46 1c             	mov    0x1c(%esi),%eax
c0023185:	89 47 20             	mov    %eax,0x20(%edi)
    thread_hold_the_lock(lock);
c0023188:	83 ec 0c             	sub    $0xc,%esp
c002318b:	57                   	push   %edi
c002318c:	e8 3b e2 ff ff       	call   c00213cc <thread_hold_the_lock>
c0023191:	83 c4 10             	add    $0x10,%esp
c0023194:	e9 54 ff ff ff       	jmp    c00230ed <lock_acquire+0xb0>

c0023199 <lock_try_acquire>:
{
c0023199:	57                   	push   %edi
c002319a:	56                   	push   %esi
c002319b:	53                   	push   %ebx
c002319c:	e8 9a a7 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00231a1:	81 c3 2b 63 01 00    	add    $0x1632b,%ebx
c00231a7:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (lock != NULL);
c00231ab:	85 f6                	test   %esi,%esi
c00231ad:	74 2b                	je     c00231da <lock_try_acquire+0x41>
  ASSERT (!lock_held_by_current_thread (lock));
c00231af:	83 ec 0c             	sub    $0xc,%esp
c00231b2:	56                   	push   %esi
c00231b3:	e8 32 fe ff ff       	call   c0022fea <lock_held_by_current_thread>
c00231b8:	83 c4 10             	add    $0x10,%esp
c00231bb:	84 c0                	test   %al,%al
c00231bd:	75 44                	jne    c0023203 <lock_try_acquire+0x6a>
  success = sema_try_down (&lock->semaphore);
c00231bf:	83 ec 0c             	sub    $0xc,%esp
c00231c2:	8d 46 04             	lea    0x4(%esi),%eax
c00231c5:	50                   	push   %eax
c00231c6:	e8 04 fc ff ff       	call   c0022dcf <sema_try_down>
c00231cb:	89 c7                	mov    %eax,%edi
  if (success)
c00231cd:	83 c4 10             	add    $0x10,%esp
c00231d0:	84 c0                	test   %al,%al
c00231d2:	75 58                	jne    c002322c <lock_try_acquire+0x93>
}
c00231d4:	89 f8                	mov    %edi,%eax
c00231d6:	5b                   	pop    %ebx
c00231d7:	5e                   	pop    %esi
c00231d8:	5f                   	pop    %edi
c00231d9:	c3                   	ret    
  ASSERT (lock != NULL);
c00231da:	83 ec 0c             	sub    $0xc,%esp
c00231dd:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c00231e3:	50                   	push   %eax
c00231e4:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00231ea:	50                   	push   %eax
c00231eb:	8d 83 34 47 ff ff    	lea    -0xb8cc(%ebx),%eax
c00231f1:	50                   	push   %eax
c00231f2:	68 f3 00 00 00       	push   $0xf3
c00231f7:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00231fd:	50                   	push   %eax
c00231fe:	e8 8c 5d 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0023203:	83 ec 0c             	sub    $0xc,%esp
c0023206:	8d 83 a8 5e ff ff    	lea    -0xa158(%ebx),%eax
c002320c:	50                   	push   %eax
c002320d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023213:	50                   	push   %eax
c0023214:	8d 83 34 47 ff ff    	lea    -0xb8cc(%ebx),%eax
c002321a:	50                   	push   %eax
c002321b:	68 f4 00 00 00       	push   $0xf4
c0023220:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023226:	50                   	push   %eax
c0023227:	e8 63 5d 00 00       	call   c0028f8f <debug_panic>
    lock->holder = thread_current ();
c002322c:	e8 52 d9 ff ff       	call   c0020b83 <thread_current>
c0023231:	89 06                	mov    %eax,(%esi)
  return success;
c0023233:	eb 9f                	jmp    c00231d4 <lock_try_acquire+0x3b>

c0023235 <lock_release>:
{
c0023235:	57                   	push   %edi
c0023236:	56                   	push   %esi
c0023237:	53                   	push   %ebx
c0023238:	e8 fe a6 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002323d:	81 c3 8f 62 01 00    	add    $0x1628f,%ebx
c0023243:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (lock != NULL);
c0023247:	85 f6                	test   %esi,%esi
c0023249:	74 43                	je     c002328e <lock_release+0x59>
  ASSERT (lock_held_by_current_thread (lock));
c002324b:	83 ec 0c             	sub    $0xc,%esp
c002324e:	56                   	push   %esi
c002324f:	e8 96 fd ff ff       	call   c0022fea <lock_held_by_current_thread>
c0023254:	83 c4 10             	add    $0x10,%esp
c0023257:	84 c0                	test   %al,%al
c0023259:	74 5c                	je     c00232b7 <lock_release+0x82>
  old_level = intr_disable();
c002325b:	e8 e6 e8 ff ff       	call   c0021b46 <intr_disable>
c0023260:	89 c7                	mov    %eax,%edi
  if (!thread_mlfqs)
c0023262:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c0023268:	80 38 00             	cmpb   $0x0,(%eax)
c002326b:	74 73                	je     c00232e0 <lock_release+0xab>
  lock->holder = NULL;
c002326d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  sema_up (&lock->semaphore);
c0023273:	83 ec 0c             	sub    $0xc,%esp
c0023276:	83 c6 04             	add    $0x4,%esi
c0023279:	56                   	push   %esi
c002327a:	e8 b8 fb ff ff       	call   c0022e37 <sema_up>
  intr_set_level(old_level);
c002327f:	89 3c 24             	mov    %edi,(%esp)
c0023282:	e8 c6 e8 ff ff       	call   c0021b4d <intr_set_level>
}
c0023287:	83 c4 10             	add    $0x10,%esp
c002328a:	5b                   	pop    %ebx
c002328b:	5e                   	pop    %esi
c002328c:	5f                   	pop    %edi
c002328d:	c3                   	ret    
  ASSERT (lock != NULL);
c002328e:	83 ec 0c             	sub    $0xc,%esp
c0023291:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c0023297:	50                   	push   %eax
c0023298:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002329e:	50                   	push   %eax
c002329f:	8d 83 24 47 ff ff    	lea    -0xb8dc(%ebx),%eax
c00232a5:	50                   	push   %eax
c00232a6:	68 06 01 00 00       	push   $0x106
c00232ab:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00232b1:	50                   	push   %eax
c00232b2:	e8 d8 5c 00 00       	call   c0028f8f <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00232b7:	83 ec 0c             	sub    $0xc,%esp
c00232ba:	8d 83 cc 5e ff ff    	lea    -0xa134(%ebx),%eax
c00232c0:	50                   	push   %eax
c00232c1:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00232c7:	50                   	push   %eax
c00232c8:	8d 83 24 47 ff ff    	lea    -0xb8dc(%ebx),%eax
c00232ce:	50                   	push   %eax
c00232cf:	68 07 01 00 00       	push   $0x107
c00232d4:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00232da:	50                   	push   %eax
c00232db:	e8 af 5c 00 00       	call   c0028f8f <debug_panic>
    thread_remove_lock(lock);
c00232e0:	83 ec 0c             	sub    $0xc,%esp
c00232e3:	56                   	push   %esi
c00232e4:	e8 b2 e1 ff ff       	call   c002149b <thread_remove_lock>
c00232e9:	83 c4 10             	add    $0x10,%esp
c00232ec:	e9 7c ff ff ff       	jmp    c002326d <lock_release+0x38>

c00232f1 <cond_init>:
{
c00232f1:	53                   	push   %ebx
c00232f2:	83 ec 08             	sub    $0x8,%esp
c00232f5:	e8 41 a6 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00232fa:	81 c3 d2 61 01 00    	add    $0x161d2,%ebx
c0023300:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (cond != NULL);
c0023304:	85 c0                	test   %eax,%eax
c0023306:	74 0e                	je     c0023316 <cond_init+0x25>
  list_init (&cond->waiters);
c0023308:	83 ec 0c             	sub    $0xc,%esp
c002330b:	50                   	push   %eax
c002330c:	e8 4b 5d 00 00       	call   c002905c <list_init>
}
c0023311:	83 c4 18             	add    $0x18,%esp
c0023314:	5b                   	pop    %ebx
c0023315:	c3                   	ret    
  ASSERT (cond != NULL);
c0023316:	83 ec 0c             	sub    $0xc,%esp
c0023319:	8d 83 98 5e ff ff    	lea    -0xa168(%ebx),%eax
c002331f:	50                   	push   %eax
c0023320:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023326:	50                   	push   %eax
c0023327:	8d 83 fc 46 ff ff    	lea    -0xb904(%ebx),%eax
c002332d:	50                   	push   %eax
c002332e:	68 2c 01 00 00       	push   $0x12c
c0023333:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023339:	50                   	push   %eax
c002333a:	e8 50 5c 00 00       	call   c0028f8f <debug_panic>

c002333f <cond_wait>:
{
c002333f:	55                   	push   %ebp
c0023340:	57                   	push   %edi
c0023341:	56                   	push   %esi
c0023342:	53                   	push   %ebx
c0023343:	83 ec 2c             	sub    $0x2c,%esp
c0023346:	e8 f0 a5 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002334b:	81 c3 81 61 01 00    	add    $0x16181,%ebx
c0023351:	8b 74 24 44          	mov    0x44(%esp),%esi
  ASSERT (cond != NULL);
c0023355:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c002335a:	74 69                	je     c00233c5 <cond_wait+0x86>
  ASSERT (lock != NULL);
c002335c:	85 f6                	test   %esi,%esi
c002335e:	0f 84 8a 00 00 00    	je     c00233ee <cond_wait+0xaf>
  ASSERT (!intr_context ());
c0023364:	e8 81 ea ff ff       	call   c0021dea <intr_context>
c0023369:	84 c0                	test   %al,%al
c002336b:	0f 85 a6 00 00 00    	jne    c0023417 <cond_wait+0xd8>
  ASSERT (lock_held_by_current_thread (lock));
c0023371:	83 ec 0c             	sub    $0xc,%esp
c0023374:	56                   	push   %esi
c0023375:	e8 70 fc ff ff       	call   c0022fea <lock_held_by_current_thread>
c002337a:	83 c4 10             	add    $0x10,%esp
c002337d:	84 c0                	test   %al,%al
c002337f:	0f 84 bb 00 00 00    	je     c0023440 <cond_wait+0x101>
  sema_init (&waiter.semaphore, 0);
c0023385:	83 ec 08             	sub    $0x8,%esp
c0023388:	6a 00                	push   $0x0
c002338a:	8d 7c 24 10          	lea    0x10(%esp),%edi
c002338e:	8d 6c 24 18          	lea    0x18(%esp),%ebp
c0023392:	55                   	push   %ebp
c0023393:	e8 23 f9 ff ff       	call   c0022cbb <sema_init>
  list_push_back (&cond->waiters, &waiter.elem);
c0023398:	83 c4 08             	add    $0x8,%esp
c002339b:	57                   	push   %edi
c002339c:	ff 74 24 4c          	pushl  0x4c(%esp)
c00233a0:	e8 9d 62 00 00       	call   c0029642 <list_push_back>
  lock_release (lock);
c00233a5:	89 34 24             	mov    %esi,(%esp)
c00233a8:	e8 88 fe ff ff       	call   c0023235 <lock_release>
  sema_down (&waiter.semaphore);
c00233ad:	89 2c 24             	mov    %ebp,(%esp)
c00233b0:	e8 5a f9 ff ff       	call   c0022d0f <sema_down>
  lock_acquire (lock);
c00233b5:	89 34 24             	mov    %esi,(%esp)
c00233b8:	e8 80 fc ff ff       	call   c002303d <lock_acquire>
}
c00233bd:	83 c4 3c             	add    $0x3c,%esp
c00233c0:	5b                   	pop    %ebx
c00233c1:	5e                   	pop    %esi
c00233c2:	5f                   	pop    %edi
c00233c3:	5d                   	pop    %ebp
c00233c4:	c3                   	ret    
  ASSERT (cond != NULL);
c00233c5:	83 ec 0c             	sub    $0xc,%esp
c00233c8:	8d 83 98 5e ff ff    	lea    -0xa168(%ebx),%eax
c00233ce:	50                   	push   %eax
c00233cf:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00233d5:	50                   	push   %eax
c00233d6:	8d 83 f0 46 ff ff    	lea    -0xb910(%ebx),%eax
c00233dc:	50                   	push   %eax
c00233dd:	68 4a 01 00 00       	push   $0x14a
c00233e2:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00233e8:	50                   	push   %eax
c00233e9:	e8 a1 5b 00 00       	call   c0028f8f <debug_panic>
  ASSERT (lock != NULL);
c00233ee:	83 ec 0c             	sub    $0xc,%esp
c00233f1:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c00233f7:	50                   	push   %eax
c00233f8:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00233fe:	50                   	push   %eax
c00233ff:	8d 83 f0 46 ff ff    	lea    -0xb910(%ebx),%eax
c0023405:	50                   	push   %eax
c0023406:	68 4b 01 00 00       	push   $0x14b
c002340b:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023411:	50                   	push   %eax
c0023412:	e8 78 5b 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!intr_context ());
c0023417:	83 ec 0c             	sub    $0xc,%esp
c002341a:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0023420:	50                   	push   %eax
c0023421:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023427:	50                   	push   %eax
c0023428:	8d 83 f0 46 ff ff    	lea    -0xb910(%ebx),%eax
c002342e:	50                   	push   %eax
c002342f:	68 4c 01 00 00       	push   $0x14c
c0023434:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c002343a:	50                   	push   %eax
c002343b:	e8 4f 5b 00 00       	call   c0028f8f <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023440:	83 ec 0c             	sub    $0xc,%esp
c0023443:	8d 83 cc 5e ff ff    	lea    -0xa134(%ebx),%eax
c0023449:	50                   	push   %eax
c002344a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023450:	50                   	push   %eax
c0023451:	8d 83 f0 46 ff ff    	lea    -0xb910(%ebx),%eax
c0023457:	50                   	push   %eax
c0023458:	68 4d 01 00 00       	push   $0x14d
c002345d:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023463:	50                   	push   %eax
c0023464:	e8 26 5b 00 00       	call   c0028f8f <debug_panic>

c0023469 <cond_signal>:
{
c0023469:	57                   	push   %edi
c002346a:	56                   	push   %esi
c002346b:	53                   	push   %ebx
c002346c:	e8 ca a4 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023471:	81 c3 5b 60 01 00    	add    $0x1605b,%ebx
c0023477:	8b 74 24 10          	mov    0x10(%esp),%esi
c002347b:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (cond != NULL);
c002347f:	85 f6                	test   %esi,%esi
c0023481:	74 39                	je     c00234bc <cond_signal+0x53>
  ASSERT (lock != NULL);
c0023483:	85 ff                	test   %edi,%edi
c0023485:	74 5e                	je     c00234e5 <cond_signal+0x7c>
  ASSERT (!intr_context ());
c0023487:	e8 5e e9 ff ff       	call   c0021dea <intr_context>
c002348c:	84 c0                	test   %al,%al
c002348e:	75 7e                	jne    c002350e <cond_signal+0xa5>
  ASSERT (lock_held_by_current_thread (lock));
c0023490:	83 ec 0c             	sub    $0xc,%esp
c0023493:	57                   	push   %edi
c0023494:	e8 51 fb ff ff       	call   c0022fea <lock_held_by_current_thread>
c0023499:	83 c4 10             	add    $0x10,%esp
c002349c:	84 c0                	test   %al,%al
c002349e:	0f 84 93 00 00 00    	je     c0023537 <cond_signal+0xce>
  if (!list_empty(&cond->waiters)) {
c00234a4:	83 ec 0c             	sub    $0xc,%esp
c00234a7:	56                   	push   %esi
c00234a8:	e8 54 62 00 00       	call   c0029701 <list_empty>
c00234ad:	83 c4 10             	add    $0x10,%esp
c00234b0:	84 c0                	test   %al,%al
c00234b2:	0f 84 a8 00 00 00    	je     c0023560 <cond_signal+0xf7>
}
c00234b8:	5b                   	pop    %ebx
c00234b9:	5e                   	pop    %esi
c00234ba:	5f                   	pop    %edi
c00234bb:	c3                   	ret    
  ASSERT (cond != NULL);
c00234bc:	83 ec 0c             	sub    $0xc,%esp
c00234bf:	8d 83 98 5e ff ff    	lea    -0xa168(%ebx),%eax
c00234c5:	50                   	push   %eax
c00234c6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00234cc:	50                   	push   %eax
c00234cd:	8d 83 e4 46 ff ff    	lea    -0xb91c(%ebx),%eax
c00234d3:	50                   	push   %eax
c00234d4:	68 60 01 00 00       	push   $0x160
c00234d9:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00234df:	50                   	push   %eax
c00234e0:	e8 aa 5a 00 00       	call   c0028f8f <debug_panic>
  ASSERT (lock != NULL);
c00234e5:	83 ec 0c             	sub    $0xc,%esp
c00234e8:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c00234ee:	50                   	push   %eax
c00234ef:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00234f5:	50                   	push   %eax
c00234f6:	8d 83 e4 46 ff ff    	lea    -0xb91c(%ebx),%eax
c00234fc:	50                   	push   %eax
c00234fd:	68 61 01 00 00       	push   $0x161
c0023502:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023508:	50                   	push   %eax
c0023509:	e8 81 5a 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!intr_context ());
c002350e:	83 ec 0c             	sub    $0xc,%esp
c0023511:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0023517:	50                   	push   %eax
c0023518:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002351e:	50                   	push   %eax
c002351f:	8d 83 e4 46 ff ff    	lea    -0xb91c(%ebx),%eax
c0023525:	50                   	push   %eax
c0023526:	68 62 01 00 00       	push   $0x162
c002352b:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c0023531:	50                   	push   %eax
c0023532:	e8 58 5a 00 00       	call   c0028f8f <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023537:	83 ec 0c             	sub    $0xc,%esp
c002353a:	8d 83 cc 5e ff ff    	lea    -0xa134(%ebx),%eax
c0023540:	50                   	push   %eax
c0023541:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023547:	50                   	push   %eax
c0023548:	8d 83 e4 46 ff ff    	lea    -0xb91c(%ebx),%eax
c002354e:	50                   	push   %eax
c002354f:	68 63 01 00 00       	push   $0x163
c0023554:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c002355a:	50                   	push   %eax
c002355b:	e8 2f 5a 00 00       	call   c0028f8f <debug_panic>
    list_sort(&cond->waiters, cond_sema_cmp_priority, NULL);
c0023560:	83 ec 04             	sub    $0x4,%esp
c0023563:	6a 00                	push   $0x0
c0023565:	8d 83 b4 97 fe ff    	lea    -0x1684c(%ebx),%eax
c002356b:	50                   	push   %eax
c002356c:	56                   	push   %esi
c002356d:	e8 f5 62 00 00       	call   c0029867 <list_sort>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0023572:	89 34 24             	mov    %esi,(%esp)
c0023575:	e8 fe 61 00 00       	call   c0029778 <list_pop_front>
c002357a:	83 c0 08             	add    $0x8,%eax
c002357d:	89 04 24             	mov    %eax,(%esp)
c0023580:	e8 b2 f8 ff ff       	call   c0022e37 <sema_up>
c0023585:	83 c4 10             	add    $0x10,%esp
}
c0023588:	e9 2b ff ff ff       	jmp    c00234b8 <cond_signal+0x4f>

c002358d <cond_broadcast>:
{
c002358d:	57                   	push   %edi
c002358e:	56                   	push   %esi
c002358f:	53                   	push   %ebx
c0023590:	e8 a6 a3 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023595:	81 c3 37 5f 01 00    	add    $0x15f37,%ebx
c002359b:	8b 74 24 10          	mov    0x10(%esp),%esi
c002359f:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (cond != NULL);
c00235a3:	85 f6                	test   %esi,%esi
c00235a5:	74 2d                	je     c00235d4 <cond_broadcast+0x47>
  ASSERT (lock != NULL);
c00235a7:	85 ff                	test   %edi,%edi
c00235a9:	75 5f                	jne    c002360a <cond_broadcast+0x7d>
c00235ab:	83 ec 0c             	sub    $0xc,%esp
c00235ae:	8d 83 8b 5e ff ff    	lea    -0xa175(%ebx),%eax
c00235b4:	50                   	push   %eax
c00235b5:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00235bb:	50                   	push   %eax
c00235bc:	8d 83 d4 46 ff ff    	lea    -0xb92c(%ebx),%eax
c00235c2:	50                   	push   %eax
c00235c3:	68 76 01 00 00       	push   $0x176
c00235c8:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00235ce:	50                   	push   %eax
c00235cf:	e8 bb 59 00 00       	call   c0028f8f <debug_panic>
  ASSERT (cond != NULL);
c00235d4:	83 ec 0c             	sub    $0xc,%esp
c00235d7:	8d 83 98 5e ff ff    	lea    -0xa168(%ebx),%eax
c00235dd:	50                   	push   %eax
c00235de:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00235e4:	50                   	push   %eax
c00235e5:	8d 83 d4 46 ff ff    	lea    -0xb92c(%ebx),%eax
c00235eb:	50                   	push   %eax
c00235ec:	68 75 01 00 00       	push   $0x175
c00235f1:	8d 83 4f 5e ff ff    	lea    -0xa1b1(%ebx),%eax
c00235f7:	50                   	push   %eax
c00235f8:	e8 92 59 00 00       	call   c0028f8f <debug_panic>
    cond_signal (cond, lock);
c00235fd:	83 ec 08             	sub    $0x8,%esp
c0023600:	57                   	push   %edi
c0023601:	56                   	push   %esi
c0023602:	e8 62 fe ff ff       	call   c0023469 <cond_signal>
c0023607:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c002360a:	83 ec 0c             	sub    $0xc,%esp
c002360d:	56                   	push   %esi
c002360e:	e8 ee 60 00 00       	call   c0029701 <list_empty>
c0023613:	83 c4 10             	add    $0x10,%esp
c0023616:	84 c0                	test   %al,%al
c0023618:	74 e3                	je     c00235fd <cond_broadcast+0x70>
}
c002361a:	5b                   	pop    %ebx
c002361b:	5e                   	pop    %esi
c002361c:	5f                   	pop    %edi
c002361d:	c3                   	ret    

c002361e <lock_cmp_priority>:
  return list_entry(a, struct lock, elem)->max_priority > list_entry(b, struct lock, elem)->max_priority;
c002361e:	8b 54 24 04          	mov    0x4(%esp),%edx
c0023622:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023626:	8b 40 08             	mov    0x8(%eax),%eax
c0023629:	39 42 08             	cmp    %eax,0x8(%edx)
c002362c:	0f 9f c0             	setg   %al
}
c002362f:	c3                   	ret    

c0023630 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023630:	55                   	push   %ebp
c0023631:	57                   	push   %edi
c0023632:	56                   	push   %esi
c0023633:	53                   	push   %ebx
c0023634:	83 ec 28             	sub    $0x28,%esp
c0023637:	e8 ff a2 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002363c:	81 c3 90 5e 01 00    	add    $0x15e90,%ebx
c0023642:	89 c5                	mov    %eax,%ebp
c0023644:	89 54 24 18          	mov    %edx,0x18(%esp)
c0023648:	89 cf                	mov    %ecx,%edi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c002364a:	51                   	push   %ecx
c002364b:	e8 ea 67 00 00       	call   c0029e3a <bitmap_buf_size>
c0023650:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
c0023656:	89 f0                	mov    %esi,%eax
c0023658:	c1 e8 0c             	shr    $0xc,%eax
  if (bm_pages > page_cnt)
c002365b:	83 c4 10             	add    $0x10,%esp
c002365e:	39 c7                	cmp    %eax,%edi
c0023660:	72 44                	jb     c00236a6 <init_pool+0x76>
    PANIC ("Not enough memory in %s for bitmap.", name);
  page_cnt -= bm_pages;
c0023662:	29 c7                	sub    %eax,%edi

  printf ("%zu pages available in %s.\n", page_cnt, name);
c0023664:	83 ec 04             	sub    $0x4,%esp
c0023667:	ff 74 24 34          	pushl  0x34(%esp)
c002366b:	57                   	push   %edi
c002366c:	8d 83 5b 5f ff ff    	lea    -0xa0a5(%ebx),%eax
c0023672:	50                   	push   %eax
c0023673:	e8 80 3b 00 00       	call   c00271f8 <printf>

  /* Initialize the pool. */
  lock_init (&p->lock);
c0023678:	89 2c 24             	mov    %ebp,(%esp)
c002367b:	e8 11 f9 ff ff       	call   c0022f91 <lock_init>
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0023680:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c0023686:	83 c4 0c             	add    $0xc,%esp
c0023689:	56                   	push   %esi
c002368a:	ff 74 24 14          	pushl  0x14(%esp)
c002368e:	57                   	push   %edi
c002368f:	e8 0f 6b 00 00       	call   c002a1a3 <bitmap_create_in_buf>
c0023694:	89 45 24             	mov    %eax,0x24(%ebp)
  p->base = base + bm_pages * PGSIZE;
c0023697:	03 74 24 1c          	add    0x1c(%esp),%esi
c002369b:	89 75 28             	mov    %esi,0x28(%ebp)
}
c002369e:	83 c4 2c             	add    $0x2c,%esp
c00236a1:	5b                   	pop    %ebx
c00236a2:	5e                   	pop    %esi
c00236a3:	5f                   	pop    %edi
c00236a4:	5d                   	pop    %ebp
c00236a5:	c3                   	ret    
    PANIC ("Not enough memory in %s for bitmap.", name);
c00236a6:	83 ec 0c             	sub    $0xc,%esp
c00236a9:	ff 74 24 3c          	pushl  0x3c(%esp)
c00236ad:	8d 83 f0 5e ff ff    	lea    -0xa110(%ebx),%eax
c00236b3:	50                   	push   %eax
c00236b4:	8d 83 c0 47 ff ff    	lea    -0xb840(%ebx),%eax
c00236ba:	50                   	push   %eax
c00236bb:	68 a1 00 00 00       	push   $0xa1
c00236c0:	8d 83 44 5f ff ff    	lea    -0xa0bc(%ebx),%eax
c00236c6:	50                   	push   %eax
c00236c7:	e8 c3 58 00 00       	call   c0028f8f <debug_panic>

c00236cc <palloc_init>:
{
c00236cc:	57                   	push   %edi
c00236cd:	56                   	push   %esi
c00236ce:	53                   	push   %ebx
c00236cf:	e8 67 a2 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00236d4:	81 c3 f8 5d 01 00    	add    $0x15df8,%ebx
c00236da:	8b 54 24 10          	mov    0x10(%esp),%edx
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c00236de:	c7 c0 7e 01 02 c0    	mov    $0xc002017e,%eax
c00236e4:	8b 00                	mov    (%eax),%eax
c00236e6:	c1 e0 0c             	shl    $0xc,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c00236e9:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00236ee:	77 5e                	ja     c002374e <palloc_init+0x82>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c00236f0:	8d b0 ff 0f f0 ff    	lea    -0xff001(%eax),%esi
c00236f6:	2d 00 00 10 00       	sub    $0x100000,%eax
c00236fb:	0f 49 f0             	cmovns %eax,%esi
c00236fe:	c1 fe 0c             	sar    $0xc,%esi
  size_t user_pages = free_pages / 2;
c0023701:	89 f7                	mov    %esi,%edi
c0023703:	d1 ef                	shr    %edi
c0023705:	39 d7                	cmp    %edx,%edi
c0023707:	0f 47 fa             	cmova  %edx,%edi
  kernel_pages = free_pages - user_pages;
c002370a:	29 fe                	sub    %edi,%esi
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c002370c:	83 ec 0c             	sub    $0xc,%esp
c002370f:	8d 83 92 5f ff ff    	lea    -0xa06e(%ebx),%eax
c0023715:	50                   	push   %eax
c0023716:	89 f1                	mov    %esi,%ecx
c0023718:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c002371d:	8d 83 f4 1c 00 00    	lea    0x1cf4(%ebx),%eax
c0023723:	e8 08 ff ff ff       	call   c0023630 <init_pool>
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0023728:	c1 e6 0c             	shl    $0xc,%esi
c002372b:	8d 96 00 00 10 c0    	lea    -0x3ff00000(%esi),%edx
c0023731:	8d 83 9e 5f ff ff    	lea    -0xa062(%ebx),%eax
c0023737:	89 04 24             	mov    %eax,(%esp)
c002373a:	89 f9                	mov    %edi,%ecx
c002373c:	8d 83 b4 1c 00 00    	lea    0x1cb4(%ebx),%eax
c0023742:	e8 e9 fe ff ff       	call   c0023630 <init_pool>
}
c0023747:	83 c4 10             	add    $0x10,%esp
c002374a:	5b                   	pop    %ebx
c002374b:	5e                   	pop    %esi
c002374c:	5f                   	pop    %edi
c002374d:	c3                   	ret    
c002374e:	83 ec 0c             	sub    $0xc,%esp
c0023751:	8d 83 77 5f ff ff    	lea    -0xa089(%ebx),%eax
c0023757:	50                   	push   %eax
c0023758:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002375e:	50                   	push   %eax
c002375f:	8d 83 cc 47 ff ff    	lea    -0xb834(%ebx),%eax
c0023765:	50                   	push   %eax
c0023766:	6a 4a                	push   $0x4a
c0023768:	8d 83 2e 56 ff ff    	lea    -0xa9d2(%ebx),%eax
c002376e:	50                   	push   %eax
c002376f:	e8 1b 58 00 00       	call   c0028f8f <debug_panic>

c0023774 <palloc_get_multiple>:
{
c0023774:	55                   	push   %ebp
c0023775:	57                   	push   %edi
c0023776:	56                   	push   %esi
c0023777:	53                   	push   %ebx
c0023778:	83 ec 0c             	sub    $0xc,%esp
c002377b:	e8 bb a1 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023780:	81 c3 4c 5d 01 00    	add    $0x15d4c,%ebx
c0023786:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002378a:	8b 44 24 20          	mov    0x20(%esp),%eax
c002378e:	83 e0 04             	and    $0x4,%eax
c0023791:	8d b3 b4 1c 00 00    	lea    0x1cb4(%ebx),%esi
c0023797:	8d 83 f4 1c 00 00    	lea    0x1cf4(%ebx),%eax
c002379d:	0f 44 f0             	cmove  %eax,%esi
  if (page_cnt == 0)
c00237a0:	85 ed                	test   %ebp,%ebp
c00237a2:	74 7e                	je     c0023822 <palloc_get_multiple+0xae>
  lock_acquire (&pool->lock);
c00237a4:	83 ec 0c             	sub    $0xc,%esp
c00237a7:	56                   	push   %esi
c00237a8:	e8 90 f8 ff ff       	call   c002303d <lock_acquire>
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00237ad:	6a 00                	push   $0x0
c00237af:	55                   	push   %ebp
c00237b0:	6a 00                	push   $0x0
c00237b2:	ff 76 24             	pushl  0x24(%esi)
c00237b5:	e8 56 6d 00 00       	call   c002a510 <bitmap_scan_and_flip>
c00237ba:	89 c7                	mov    %eax,%edi
  lock_release (&pool->lock);
c00237bc:	83 c4 14             	add    $0x14,%esp
c00237bf:	56                   	push   %esi
c00237c0:	e8 70 fa ff ff       	call   c0023235 <lock_release>
  if (page_idx != BITMAP_ERROR)
c00237c5:	83 c4 10             	add    $0x10,%esp
c00237c8:	83 ff ff             	cmp    $0xffffffff,%edi
c00237cb:	74 23                	je     c00237f0 <palloc_get_multiple+0x7c>
    pages = pool->base + PGSIZE * page_idx;
c00237cd:	c1 e7 0c             	shl    $0xc,%edi
  if (pages != NULL) 
c00237d0:	03 7e 28             	add    0x28(%esi),%edi
c00237d3:	74 1b                	je     c00237f0 <palloc_get_multiple+0x7c>
      if (flags & PAL_ZERO)
c00237d5:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c00237da:	74 20                	je     c00237fc <palloc_get_multiple+0x88>
        memset (pages, 0, PGSIZE * page_cnt);
c00237dc:	c1 e5 0c             	shl    $0xc,%ebp
c00237df:	83 ec 04             	sub    $0x4,%esp
c00237e2:	55                   	push   %ebp
c00237e3:	6a 00                	push   $0x0
c00237e5:	57                   	push   %edi
c00237e6:	e8 23 4d 00 00       	call   c002850e <memset>
c00237eb:	83 c4 10             	add    $0x10,%esp
c00237ee:	eb 0c                	jmp    c00237fc <palloc_get_multiple+0x88>
      if (flags & PAL_ASSERT)
c00237f0:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c00237f5:	75 0f                	jne    c0023806 <palloc_get_multiple+0x92>
c00237f7:	bf 00 00 00 00       	mov    $0x0,%edi
}
c00237fc:	89 f8                	mov    %edi,%eax
c00237fe:	83 c4 0c             	add    $0xc,%esp
c0023801:	5b                   	pop    %ebx
c0023802:	5e                   	pop    %esi
c0023803:	5f                   	pop    %edi
c0023804:	5d                   	pop    %ebp
c0023805:	c3                   	ret    
        PANIC ("palloc_get: out of pages");
c0023806:	8d 83 a8 5f ff ff    	lea    -0xa058(%ebx),%eax
c002380c:	50                   	push   %eax
c002380d:	8d 83 ac 47 ff ff    	lea    -0xb854(%ebx),%eax
c0023813:	50                   	push   %eax
c0023814:	6a 61                	push   $0x61
c0023816:	8d 83 44 5f ff ff    	lea    -0xa0bc(%ebx),%eax
c002381c:	50                   	push   %eax
c002381d:	e8 6d 57 00 00       	call   c0028f8f <debug_panic>
    return NULL;
c0023822:	bf 00 00 00 00       	mov    $0x0,%edi
c0023827:	eb d3                	jmp    c00237fc <palloc_get_multiple+0x88>

c0023829 <palloc_get_page>:
{
c0023829:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple (flags, 1);
c002382c:	6a 01                	push   $0x1
c002382e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023832:	e8 3d ff ff ff       	call   c0023774 <palloc_get_multiple>
}
c0023837:	83 c4 1c             	add    $0x1c,%esp
c002383a:	c3                   	ret    

c002383b <palloc_free_multiple>:
{
c002383b:	55                   	push   %ebp
c002383c:	57                   	push   %edi
c002383d:	56                   	push   %esi
c002383e:	53                   	push   %ebx
c002383f:	83 ec 0c             	sub    $0xc,%esp
c0023842:	e8 f4 a0 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023847:	81 c3 85 5c 01 00    	add    $0x15c85,%ebx
c002384d:	8b 74 24 20          	mov    0x20(%esp),%esi
  ASSERT (pg_ofs (pages) == 0);
c0023851:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c0023857:	0f 85 9d 00 00 00    	jne    c00238fa <palloc_free_multiple+0xbf>
  if (pages == NULL || page_cnt == 0)
c002385d:	85 f6                	test   %esi,%esi
c002385f:	0f 84 8d 00 00 00    	je     c00238f2 <palloc_free_multiple+0xb7>
c0023865:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c002386a:	0f 84 82 00 00 00    	je     c00238f2 <palloc_free_multiple+0xb7>
  return (uintptr_t) va >> PGBITS;
c0023870:	89 f7                	mov    %esi,%edi
c0023872:	c1 ef 0c             	shr    $0xc,%edi
c0023875:	8b 83 1c 1d 00 00    	mov    0x1d1c(%ebx),%eax
c002387b:	c1 e8 0c             	shr    $0xc,%eax
c002387e:	89 c5                	mov    %eax,%ebp
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023880:	83 ec 0c             	sub    $0xc,%esp
c0023883:	ff b3 18 1d 00 00    	pushl  0x1d18(%ebx)
c0023889:	e8 f2 65 00 00       	call   c0029e80 <bitmap_size>
c002388e:	89 ea                	mov    %ebp,%edx
c0023890:	01 e8                	add    %ebp,%eax

  return page_no >= start_page && page_no < end_page;
c0023892:	83 c4 10             	add    $0x10,%esp
  if (page_from_pool (&kernel_pool, pages))
c0023895:	39 c7                	cmp    %eax,%edi
c0023897:	0f 83 83 00 00 00    	jae    c0023920 <palloc_free_multiple+0xe5>
    pool = &kernel_pool;
c002389d:	8d ab f4 1c 00 00    	lea    0x1cf4(%ebx),%ebp
  if (page_from_pool (&kernel_pool, pages))
c00238a3:	39 d7                	cmp    %edx,%edi
c00238a5:	72 79                	jb     c0023920 <palloc_free_multiple+0xe5>
c00238a7:	8b 45 28             	mov    0x28(%ebp),%eax
c00238aa:	c1 e8 0c             	shr    $0xc,%eax
  page_idx = pg_no (pages) - pg_no (pool->base);
c00238ad:	29 c7                	sub    %eax,%edi
  memset (pages, 0xcc, PGSIZE * page_cnt);
c00238af:	83 ec 04             	sub    $0x4,%esp
c00238b2:	8b 44 24 28          	mov    0x28(%esp),%eax
c00238b6:	c1 e0 0c             	shl    $0xc,%eax
c00238b9:	50                   	push   %eax
c00238ba:	68 cc 00 00 00       	push   $0xcc
c00238bf:	56                   	push   %esi
c00238c0:	e8 49 4c 00 00       	call   c002850e <memset>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c00238c5:	83 c4 0c             	add    $0xc,%esp
c00238c8:	ff 74 24 28          	pushl  0x28(%esp)
c00238cc:	57                   	push   %edi
c00238cd:	ff 75 24             	pushl  0x24(%ebp)
c00238d0:	e8 4e 6b 00 00       	call   c002a423 <bitmap_all>
c00238d5:	83 c4 10             	add    $0x10,%esp
c00238d8:	84 c0                	test   %al,%al
c00238da:	0f 84 8e 00 00 00    	je     c002396e <palloc_free_multiple+0x133>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c00238e0:	6a 00                	push   $0x0
c00238e2:	ff 74 24 28          	pushl  0x28(%esp)
c00238e6:	57                   	push   %edi
c00238e7:	ff 75 24             	pushl  0x24(%ebp)
c00238ea:	e8 16 67 00 00       	call   c002a005 <bitmap_set_multiple>
c00238ef:	83 c4 10             	add    $0x10,%esp
}
c00238f2:	83 c4 0c             	add    $0xc,%esp
c00238f5:	5b                   	pop    %ebx
c00238f6:	5e                   	pop    %esi
c00238f7:	5f                   	pop    %edi
c00238f8:	5d                   	pop    %ebp
c00238f9:	c3                   	ret    
  ASSERT (pg_ofs (pages) == 0);
c00238fa:	83 ec 0c             	sub    $0xc,%esp
c00238fd:	8d 83 c1 5f ff ff    	lea    -0xa03f(%ebx),%eax
c0023903:	50                   	push   %eax
c0023904:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002390a:	50                   	push   %eax
c002390b:	8d 83 94 47 ff ff    	lea    -0xb86c(%ebx),%eax
c0023911:	50                   	push   %eax
c0023912:	6a 7b                	push   $0x7b
c0023914:	8d 83 44 5f ff ff    	lea    -0xa0bc(%ebx),%eax
c002391a:	50                   	push   %eax
c002391b:	e8 6f 56 00 00       	call   c0028f8f <debug_panic>
c0023920:	8b ab dc 1c 00 00    	mov    0x1cdc(%ebx),%ebp
c0023926:	c1 ed 0c             	shr    $0xc,%ebp
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023929:	83 ec 0c             	sub    $0xc,%esp
c002392c:	ff b3 d8 1c 00 00    	pushl  0x1cd8(%ebx)
c0023932:	e8 49 65 00 00       	call   c0029e80 <bitmap_size>
c0023937:	01 e8                	add    %ebp,%eax
  return page_no >= start_page && page_no < end_page;
c0023939:	83 c4 10             	add    $0x10,%esp
  else if (page_from_pool (&user_pool, pages))
c002393c:	39 c7                	cmp    %eax,%edi
c002393e:	73 0f                	jae    c002394f <palloc_free_multiple+0x114>
c0023940:	39 ef                	cmp    %ebp,%edi
c0023942:	72 0b                	jb     c002394f <palloc_free_multiple+0x114>
    pool = &user_pool;
c0023944:	8d ab b4 1c 00 00    	lea    0x1cb4(%ebx),%ebp
c002394a:	e9 58 ff ff ff       	jmp    c00238a7 <palloc_free_multiple+0x6c>
    NOT_REACHED ();
c002394f:	8d 83 78 5a ff ff    	lea    -0xa588(%ebx),%eax
c0023955:	50                   	push   %eax
c0023956:	8d 83 94 47 ff ff    	lea    -0xb86c(%ebx),%eax
c002395c:	50                   	push   %eax
c002395d:	68 84 00 00 00       	push   $0x84
c0023962:	8d 83 44 5f ff ff    	lea    -0xa0bc(%ebx),%eax
c0023968:	50                   	push   %eax
c0023969:	e8 21 56 00 00       	call   c0028f8f <debug_panic>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c002396e:	83 ec 0c             	sub    $0xc,%esp
c0023971:	8d 83 14 5f ff ff    	lea    -0xa0ec(%ebx),%eax
c0023977:	50                   	push   %eax
c0023978:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002397e:	50                   	push   %eax
c002397f:	8d 83 94 47 ff ff    	lea    -0xb86c(%ebx),%eax
c0023985:	50                   	push   %eax
c0023986:	68 8c 00 00 00       	push   $0x8c
c002398b:	8d 83 44 5f ff ff    	lea    -0xa0bc(%ebx),%eax
c0023991:	50                   	push   %eax
c0023992:	e8 f8 55 00 00       	call   c0028f8f <debug_panic>

c0023997 <palloc_free_page>:
{
c0023997:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple (page, 1);
c002399a:	6a 01                	push   $0x1
c002399c:	ff 74 24 1c          	pushl  0x1c(%esp)
c00239a0:	e8 96 fe ff ff       	call   c002383b <palloc_free_multiple>
}
c00239a5:	83 c4 1c             	add    $0x1c,%esp
c00239a8:	c3                   	ret    

c00239a9 <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c00239a9:	53                   	push   %ebx
c00239aa:	83 ec 08             	sub    $0x8,%esp
c00239ad:	e8 89 9f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00239b2:	81 c3 1a 5b 01 00    	add    $0x15b1a,%ebx
  ASSERT (a != NULL);
c00239b8:	85 c0                	test   %eax,%eax
c00239ba:	74 1c                	je     c00239d8 <arena_to_block+0x2f>
  ASSERT (a->magic == ARENA_MAGIC);
c00239bc:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c00239c2:	75 3d                	jne    c0023a01 <arena_to_block+0x58>
  ASSERT (idx < a->desc->blocks_per_arena);
c00239c4:	8b 48 04             	mov    0x4(%eax),%ecx
c00239c7:	39 51 04             	cmp    %edx,0x4(%ecx)
c00239ca:	76 5e                	jbe    c0023a2a <arena_to_block+0x81>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c00239cc:	0f af 11             	imul   (%ecx),%edx
  return (struct block *) ((uint8_t *) a
c00239cf:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c00239d3:	83 c4 08             	add    $0x8,%esp
c00239d6:	5b                   	pop    %ebx
c00239d7:	c3                   	ret    
  ASSERT (a != NULL);
c00239d8:	83 ec 0c             	sub    $0xc,%esp
c00239db:	8d 83 45 5e ff ff    	lea    -0xa1bb(%ebx),%eax
c00239e1:	50                   	push   %eax
c00239e2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00239e8:	50                   	push   %eax
c00239e9:	8d 83 ec 47 ff ff    	lea    -0xb814(%ebx),%eax
c00239ef:	50                   	push   %eax
c00239f0:	68 20 01 00 00       	push   $0x120
c00239f5:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c00239fb:	50                   	push   %eax
c00239fc:	e8 8e 55 00 00       	call   c0028f8f <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023a01:	83 ec 0c             	sub    $0xc,%esp
c0023a04:	8d 83 ec 5f ff ff    	lea    -0xa014(%ebx),%eax
c0023a0a:	50                   	push   %eax
c0023a0b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023a11:	50                   	push   %eax
c0023a12:	8d 83 ec 47 ff ff    	lea    -0xb814(%ebx),%eax
c0023a18:	50                   	push   %eax
c0023a19:	68 21 01 00 00       	push   $0x121
c0023a1e:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023a24:	50                   	push   %eax
c0023a25:	e8 65 55 00 00       	call   c0028f8f <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023a2a:	83 ec 0c             	sub    $0xc,%esp
c0023a2d:	8d 83 04 60 ff ff    	lea    -0x9ffc(%ebx),%eax
c0023a33:	50                   	push   %eax
c0023a34:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023a3a:	50                   	push   %eax
c0023a3b:	8d 83 ec 47 ff ff    	lea    -0xb814(%ebx),%eax
c0023a41:	50                   	push   %eax
c0023a42:	68 22 01 00 00       	push   $0x122
c0023a47:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023a4d:	50                   	push   %eax
c0023a4e:	e8 3c 55 00 00       	call   c0028f8f <debug_panic>

c0023a53 <block_to_arena>:
{
c0023a53:	56                   	push   %esi
c0023a54:	53                   	push   %ebx
c0023a55:	83 ec 04             	sub    $0x4,%esp
c0023a58:	e8 de 9e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023a5d:	81 c3 6f 5a 01 00    	add    $0x15a6f,%ebx
  ASSERT (a != NULL);
c0023a63:	89 c1                	mov    %eax,%ecx
c0023a65:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0023a6b:	74 2e                	je     c0023a9b <block_to_arena+0x48>
  ASSERT (a->magic == ARENA_MAGIC);
c0023a6d:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023a73:	75 4f                	jne    c0023ac4 <block_to_arena+0x71>
  ASSERT (a->desc == NULL
c0023a75:	8b 71 04             	mov    0x4(%ecx),%esi
c0023a78:	85 f6                	test   %esi,%esi
c0023a7a:	0f 84 96 00 00 00    	je     c0023b16 <block_to_arena+0xc3>
  return (uintptr_t) va & PGMASK;
c0023a80:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023a85:	83 e8 0c             	sub    $0xc,%eax
c0023a88:	ba 00 00 00 00       	mov    $0x0,%edx
c0023a8d:	f7 36                	divl   (%esi)
c0023a8f:	85 d2                	test   %edx,%edx
c0023a91:	75 5a                	jne    c0023aed <block_to_arena+0x9a>
}
c0023a93:	89 c8                	mov    %ecx,%eax
c0023a95:	83 c4 04             	add    $0x4,%esp
c0023a98:	5b                   	pop    %ebx
c0023a99:	5e                   	pop    %esi
c0023a9a:	c3                   	ret    
  ASSERT (a != NULL);
c0023a9b:	83 ec 0c             	sub    $0xc,%esp
c0023a9e:	8d 83 45 5e ff ff    	lea    -0xa1bb(%ebx),%eax
c0023aa4:	50                   	push   %eax
c0023aa5:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023aab:	50                   	push   %eax
c0023aac:	8d 83 dc 47 ff ff    	lea    -0xb824(%ebx),%eax
c0023ab2:	50                   	push   %eax
c0023ab3:	68 11 01 00 00       	push   $0x111
c0023ab8:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023abe:	50                   	push   %eax
c0023abf:	e8 cb 54 00 00       	call   c0028f8f <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023ac4:	83 ec 0c             	sub    $0xc,%esp
c0023ac7:	8d 83 ec 5f ff ff    	lea    -0xa014(%ebx),%eax
c0023acd:	50                   	push   %eax
c0023ace:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023ad4:	50                   	push   %eax
c0023ad5:	8d 83 dc 47 ff ff    	lea    -0xb824(%ebx),%eax
c0023adb:	50                   	push   %eax
c0023adc:	68 12 01 00 00       	push   $0x112
c0023ae1:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023ae7:	50                   	push   %eax
c0023ae8:	e8 a2 54 00 00       	call   c0028f8f <debug_panic>
  ASSERT (a->desc == NULL
c0023aed:	83 ec 0c             	sub    $0xc,%esp
c0023af0:	8d 83 24 60 ff ff    	lea    -0x9fdc(%ebx),%eax
c0023af6:	50                   	push   %eax
c0023af7:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023afd:	50                   	push   %eax
c0023afe:	8d 83 dc 47 ff ff    	lea    -0xb824(%ebx),%eax
c0023b04:	50                   	push   %eax
c0023b05:	68 16 01 00 00       	push   $0x116
c0023b0a:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023b10:	50                   	push   %eax
c0023b11:	e8 79 54 00 00       	call   c0028f8f <debug_panic>
c0023b16:	25 ff 0f 00 00       	and    $0xfff,%eax
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023b1b:	83 f8 0c             	cmp    $0xc,%eax
c0023b1e:	0f 84 6f ff ff ff    	je     c0023a93 <block_to_arena+0x40>
c0023b24:	83 ec 0c             	sub    $0xc,%esp
c0023b27:	8d 83 6c 60 ff ff    	lea    -0x9f94(%ebx),%eax
c0023b2d:	50                   	push   %eax
c0023b2e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023b34:	50                   	push   %eax
c0023b35:	8d 83 dc 47 ff ff    	lea    -0xb824(%ebx),%eax
c0023b3b:	50                   	push   %eax
c0023b3c:	68 17 01 00 00       	push   $0x117
c0023b41:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023b47:	50                   	push   %eax
c0023b48:	e8 42 54 00 00       	call   c0028f8f <debug_panic>

c0023b4d <malloc_init>:
{
c0023b4d:	55                   	push   %ebp
c0023b4e:	57                   	push   %edi
c0023b4f:	56                   	push   %esi
c0023b50:	53                   	push   %ebx
c0023b51:	83 ec 0c             	sub    $0xc,%esp
c0023b54:	e8 e2 9d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023b59:	81 c3 73 59 01 00    	add    $0x15973,%ebx
      struct desc *d = &descs[desc_cnt++];
c0023b5f:	8b b3 34 1d 00 00    	mov    0x1d34(%ebx),%esi
c0023b65:	8d 46 01             	lea    0x1(%esi),%eax
c0023b68:	89 83 34 1d 00 00    	mov    %eax,0x1d34(%ebx)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023b6e:	83 f8 0a             	cmp    $0xa,%eax
c0023b71:	0f 87 a1 00 00 00    	ja     c0023c18 <malloc_init+0xcb>
      d->block_size = block_size;
c0023b77:	8d bb 54 1d 00 00    	lea    0x1d54(%ebx),%edi
c0023b7d:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023b80:	c7 84 33 54 1d 00 00 	movl   $0x10,0x1d54(%ebx,%esi,1)
c0023b87:	10 00 00 00 
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023b8b:	c7 84 33 58 1d 00 00 	movl   $0xff,0x1d58(%ebx,%esi,1)
c0023b92:	ff 00 00 00 
      list_init (&d->free_list);
c0023b96:	83 ec 0c             	sub    $0xc,%esp
c0023b99:	8d 44 37 08          	lea    0x8(%edi,%esi,1),%eax
c0023b9d:	50                   	push   %eax
c0023b9e:	e8 b9 54 00 00       	call   c002905c <list_init>
      lock_init (&d->lock);
c0023ba3:	8d 44 37 18          	lea    0x18(%edi,%esi,1),%eax
c0023ba7:	89 04 24             	mov    %eax,(%esp)
c0023baa:	e8 e2 f3 ff ff       	call   c0022f91 <lock_init>
c0023baf:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023bb2:	bf 20 00 00 00       	mov    $0x20,%edi
      d->block_size = block_size;
c0023bb7:	8d ab 54 1d 00 00    	lea    0x1d54(%ebx),%ebp
      struct desc *d = &descs[desc_cnt++];
c0023bbd:	8b b3 34 1d 00 00    	mov    0x1d34(%ebx),%esi
c0023bc3:	8d 46 01             	lea    0x1(%esi),%eax
c0023bc6:	89 83 34 1d 00 00    	mov    %eax,0x1d34(%ebx)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023bcc:	83 f8 0a             	cmp    $0xa,%eax
c0023bcf:	77 47                	ja     c0023c18 <malloc_init+0xcb>
      d->block_size = block_size;
c0023bd1:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023bd4:	89 3c 2e             	mov    %edi,(%esi,%ebp,1)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023bd7:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023bdc:	ba 00 00 00 00       	mov    $0x0,%edx
c0023be1:	f7 f7                	div    %edi
c0023be3:	89 84 33 58 1d 00 00 	mov    %eax,0x1d58(%ebx,%esi,1)
      list_init (&d->free_list);
c0023bea:	83 ec 0c             	sub    $0xc,%esp
c0023bed:	8d 44 2e 08          	lea    0x8(%esi,%ebp,1),%eax
c0023bf1:	50                   	push   %eax
c0023bf2:	e8 65 54 00 00       	call   c002905c <list_init>
      lock_init (&d->lock);
c0023bf7:	8d 44 2e 18          	lea    0x18(%esi,%ebp,1),%eax
c0023bfb:	89 04 24             	mov    %eax,(%esp)
c0023bfe:	e8 8e f3 ff ff       	call   c0022f91 <lock_init>
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023c03:	01 ff                	add    %edi,%edi
c0023c05:	83 c4 10             	add    $0x10,%esp
c0023c08:	81 ff ff 07 00 00    	cmp    $0x7ff,%edi
c0023c0e:	76 ad                	jbe    c0023bbd <malloc_init+0x70>
}
c0023c10:	83 c4 0c             	add    $0xc,%esp
c0023c13:	5b                   	pop    %ebx
c0023c14:	5e                   	pop    %esi
c0023c15:	5f                   	pop    %edi
c0023c16:	5d                   	pop    %ebp
c0023c17:	c3                   	ret    
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023c18:	83 ec 0c             	sub    $0xc,%esp
c0023c1b:	8d 83 98 60 ff ff    	lea    -0x9f68(%ebx),%eax
c0023c21:	50                   	push   %eax
c0023c22:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023c28:	50                   	push   %eax
c0023c29:	8d 83 fc 47 ff ff    	lea    -0xb804(%ebx),%eax
c0023c2f:	50                   	push   %eax
c0023c30:	6a 4f                	push   $0x4f
c0023c32:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023c38:	50                   	push   %eax
c0023c39:	e8 51 53 00 00       	call   c0028f8f <debug_panic>

c0023c3e <malloc>:
{
c0023c3e:	55                   	push   %ebp
c0023c3f:	57                   	push   %edi
c0023c40:	56                   	push   %esi
c0023c41:	53                   	push   %ebx
c0023c42:	83 ec 1c             	sub    $0x1c,%esp
c0023c45:	e8 f1 9c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023c4a:	81 c3 82 58 01 00    	add    $0x15882,%ebx
c0023c50:	8b 54 24 30          	mov    0x30(%esp),%edx
  if (size == 0)
c0023c54:	85 d2                	test   %edx,%edx
c0023c56:	0f 84 2e 01 00 00    	je     c0023d8a <malloc+0x14c>
  for (d = descs; d < descs + desc_cnt; d++)
c0023c5c:	6b 83 34 1d 00 00 3c 	imul   $0x3c,0x1d34(%ebx),%eax
c0023c63:	8d 8b 54 1d 00 00    	lea    0x1d54(%ebx),%ecx
c0023c69:	01 c8                	add    %ecx,%eax
c0023c6b:	39 c8                	cmp    %ecx,%eax
c0023c6d:	0f 86 c3 00 00 00    	jbe    c0023d36 <malloc+0xf8>
    if (d->block_size >= size)
c0023c73:	3b 93 54 1d 00 00    	cmp    0x1d54(%ebx),%edx
c0023c79:	0f 86 19 01 00 00    	jbe    c0023d98 <malloc+0x15a>
  for (d = descs; d < descs + desc_cnt; d++)
c0023c7f:	89 ce                	mov    %ecx,%esi
c0023c81:	83 c6 3c             	add    $0x3c,%esi
c0023c84:	39 c6                	cmp    %eax,%esi
c0023c86:	0f 83 b0 00 00 00    	jae    c0023d3c <malloc+0xfe>
    if (d->block_size >= size)
c0023c8c:	39 16                	cmp    %edx,(%esi)
c0023c8e:	72 f1                	jb     c0023c81 <malloc+0x43>
  lock_acquire (&d->lock);
c0023c90:	8d 46 18             	lea    0x18(%esi),%eax
c0023c93:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023c97:	83 ec 0c             	sub    $0xc,%esp
c0023c9a:	50                   	push   %eax
c0023c9b:	e8 9d f3 ff ff       	call   c002303d <lock_acquire>
  if (list_empty (&d->free_list))
c0023ca0:	8d 6e 08             	lea    0x8(%esi),%ebp
c0023ca3:	89 2c 24             	mov    %ebp,(%esp)
c0023ca6:	e8 56 5a 00 00       	call   c0029701 <list_empty>
c0023cab:	83 c4 10             	add    $0x10,%esp
c0023cae:	84 c0                	test   %al,%al
c0023cb0:	74 57                	je     c0023d09 <malloc+0xcb>
      a = palloc_get_page (0);
c0023cb2:	83 ec 0c             	sub    $0xc,%esp
c0023cb5:	6a 00                	push   $0x0
c0023cb7:	e8 6d fb ff ff       	call   c0023829 <palloc_get_page>
c0023cbc:	89 44 24 18          	mov    %eax,0x18(%esp)
      if (a == NULL) 
c0023cc0:	83 c4 10             	add    $0x10,%esp
c0023cc3:	85 c0                	test   %eax,%eax
c0023cc5:	0f 84 a9 00 00 00    	je     c0023d74 <malloc+0x136>
      a->magic = ARENA_MAGIC;
c0023ccb:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0023ccf:	c7 01 ed 8e 54 9a    	movl   $0x9a548eed,(%ecx)
      a->desc = d;
c0023cd5:	89 71 04             	mov    %esi,0x4(%ecx)
      a->free_cnt = d->blocks_per_arena;
c0023cd8:	8b 46 04             	mov    0x4(%esi),%eax
c0023cdb:	89 41 08             	mov    %eax,0x8(%ecx)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023cde:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0023ce2:	74 25                	je     c0023d09 <malloc+0xcb>
c0023ce4:	bf 00 00 00 00       	mov    $0x0,%edi
          struct block *b = arena_to_block (a, i);
c0023ce9:	89 fa                	mov    %edi,%edx
c0023ceb:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023cef:	e8 b5 fc ff ff       	call   c00239a9 <arena_to_block>
          list_push_back (&d->free_list, &b->free_elem);
c0023cf4:	83 ec 08             	sub    $0x8,%esp
c0023cf7:	50                   	push   %eax
c0023cf8:	55                   	push   %ebp
c0023cf9:	e8 44 59 00 00       	call   c0029642 <list_push_back>
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023cfe:	83 c7 01             	add    $0x1,%edi
c0023d01:	83 c4 10             	add    $0x10,%esp
c0023d04:	39 7e 04             	cmp    %edi,0x4(%esi)
c0023d07:	77 e0                	ja     c0023ce9 <malloc+0xab>
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023d09:	83 ec 0c             	sub    $0xc,%esp
c0023d0c:	55                   	push   %ebp
c0023d0d:	e8 66 5a 00 00       	call   c0029778 <list_pop_front>
c0023d12:	89 c6                	mov    %eax,%esi
  a = block_to_arena (b);
c0023d14:	e8 3a fd ff ff       	call   c0023a53 <block_to_arena>
  a->free_cnt--;
c0023d19:	83 68 08 01          	subl   $0x1,0x8(%eax)
  lock_release (&d->lock);
c0023d1d:	83 c4 04             	add    $0x4,%esp
c0023d20:	ff 74 24 18          	pushl  0x18(%esp)
c0023d24:	e8 0c f5 ff ff       	call   c0023235 <lock_release>
  return b;
c0023d29:	83 c4 10             	add    $0x10,%esp
}
c0023d2c:	89 f0                	mov    %esi,%eax
c0023d2e:	83 c4 1c             	add    $0x1c,%esp
c0023d31:	5b                   	pop    %ebx
c0023d32:	5e                   	pop    %esi
c0023d33:	5f                   	pop    %edi
c0023d34:	5d                   	pop    %ebp
c0023d35:	c3                   	ret    
  for (d = descs; d < descs + desc_cnt; d++)
c0023d36:	8d b3 54 1d 00 00    	lea    0x1d54(%ebx),%esi
  if (d == descs + desc_cnt) 
c0023d3c:	39 f0                	cmp    %esi,%eax
c0023d3e:	0f 85 4c ff ff ff    	jne    c0023c90 <malloc+0x52>
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023d44:	8d b2 0b 10 00 00    	lea    0x100b(%edx),%esi
c0023d4a:	c1 ee 0c             	shr    $0xc,%esi
      a = palloc_get_multiple (0, page_cnt);
c0023d4d:	83 ec 08             	sub    $0x8,%esp
c0023d50:	56                   	push   %esi
c0023d51:	6a 00                	push   $0x0
c0023d53:	e8 1c fa ff ff       	call   c0023774 <palloc_get_multiple>
      if (a == NULL)
c0023d58:	83 c4 10             	add    $0x10,%esp
c0023d5b:	85 c0                	test   %eax,%eax
c0023d5d:	74 32                	je     c0023d91 <malloc+0x153>
      a->magic = ARENA_MAGIC;
c0023d5f:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023d65:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023d6c:	89 70 08             	mov    %esi,0x8(%eax)
      return a + 1;
c0023d6f:	8d 70 0c             	lea    0xc(%eax),%esi
c0023d72:	eb b8                	jmp    c0023d2c <malloc+0xee>
          lock_release (&d->lock);
c0023d74:	83 ec 0c             	sub    $0xc,%esp
c0023d77:	ff 74 24 18          	pushl  0x18(%esp)
c0023d7b:	e8 b5 f4 ff ff       	call   c0023235 <lock_release>
          return NULL; 
c0023d80:	83 c4 10             	add    $0x10,%esp
c0023d83:	be 00 00 00 00       	mov    $0x0,%esi
c0023d88:	eb a2                	jmp    c0023d2c <malloc+0xee>
    return NULL;
c0023d8a:	be 00 00 00 00       	mov    $0x0,%esi
c0023d8f:	eb 9b                	jmp    c0023d2c <malloc+0xee>
        return NULL;
c0023d91:	be 00 00 00 00       	mov    $0x0,%esi
c0023d96:	eb 94                	jmp    c0023d2c <malloc+0xee>
  for (d = descs; d < descs + desc_cnt; d++)
c0023d98:	8d b3 54 1d 00 00    	lea    0x1d54(%ebx),%esi
c0023d9e:	e9 ed fe ff ff       	jmp    c0023c90 <malloc+0x52>

c0023da3 <calloc>:
{
c0023da3:	57                   	push   %edi
c0023da4:	56                   	push   %esi
c0023da5:	53                   	push   %ebx
c0023da6:	e8 90 9b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023dab:	81 c3 21 57 01 00    	add    $0x15721,%ebx
c0023db1:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023db5:	8b 54 24 14          	mov    0x14(%esp),%edx
  size = a * b;
c0023db9:	89 c6                	mov    %eax,%esi
c0023dbb:	0f af f2             	imul   %edx,%esi
  if (size < a || size < b)
c0023dbe:	39 f0                	cmp    %esi,%eax
c0023dc0:	77 2b                	ja     c0023ded <calloc+0x4a>
c0023dc2:	39 f2                	cmp    %esi,%edx
c0023dc4:	77 27                	ja     c0023ded <calloc+0x4a>
  p = malloc (size);
c0023dc6:	83 ec 0c             	sub    $0xc,%esp
c0023dc9:	56                   	push   %esi
c0023dca:	e8 6f fe ff ff       	call   c0023c3e <malloc>
c0023dcf:	89 c7                	mov    %eax,%edi
  if (p != NULL)
c0023dd1:	83 c4 10             	add    $0x10,%esp
c0023dd4:	85 c0                	test   %eax,%eax
c0023dd6:	74 0f                	je     c0023de7 <calloc+0x44>
    memset (p, 0, size);
c0023dd8:	83 ec 04             	sub    $0x4,%esp
c0023ddb:	56                   	push   %esi
c0023ddc:	6a 00                	push   $0x0
c0023dde:	50                   	push   %eax
c0023ddf:	e8 2a 47 00 00       	call   c002850e <memset>
c0023de4:	83 c4 10             	add    $0x10,%esp
}
c0023de7:	89 f8                	mov    %edi,%eax
c0023de9:	5b                   	pop    %ebx
c0023dea:	5e                   	pop    %esi
c0023deb:	5f                   	pop    %edi
c0023dec:	c3                   	ret    
    return NULL;
c0023ded:	bf 00 00 00 00       	mov    $0x0,%edi
c0023df2:	eb f3                	jmp    c0023de7 <calloc+0x44>

c0023df4 <free>:
{
c0023df4:	55                   	push   %ebp
c0023df5:	57                   	push   %edi
c0023df6:	56                   	push   %esi
c0023df7:	53                   	push   %ebx
c0023df8:	83 ec 1c             	sub    $0x1c,%esp
c0023dfb:	e8 3b 9b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023e00:	81 c3 cc 56 01 00    	add    $0x156cc,%ebx
c0023e06:	8b 74 24 30          	mov    0x30(%esp),%esi
  if (p != NULL)
c0023e0a:	85 f6                	test   %esi,%esi
c0023e0c:	0f 84 98 00 00 00    	je     c0023eaa <free+0xb6>
      struct arena *a = block_to_arena (b);
c0023e12:	89 f0                	mov    %esi,%eax
c0023e14:	e8 3a fc ff ff       	call   c0023a53 <block_to_arena>
c0023e19:	89 c5                	mov    %eax,%ebp
      struct desc *d = a->desc;
c0023e1b:	8b 78 04             	mov    0x4(%eax),%edi
      if (d != NULL) 
c0023e1e:	85 ff                	test   %edi,%edi
c0023e20:	0f 84 b5 00 00 00    	je     c0023edb <free+0xe7>
          memset (b, 0xcc, d->block_size);
c0023e26:	83 ec 04             	sub    $0x4,%esp
c0023e29:	ff 37                	pushl  (%edi)
c0023e2b:	68 cc 00 00 00       	push   $0xcc
c0023e30:	56                   	push   %esi
c0023e31:	e8 d8 46 00 00       	call   c002850e <memset>
          lock_acquire (&d->lock);
c0023e36:	8d 47 18             	lea    0x18(%edi),%eax
c0023e39:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0023e3d:	89 04 24             	mov    %eax,(%esp)
c0023e40:	e8 f8 f1 ff ff       	call   c002303d <lock_acquire>
          list_push_front (&d->free_list, &b->free_elem);
c0023e45:	83 c4 08             	add    $0x8,%esp
c0023e48:	56                   	push   %esi
c0023e49:	8d 47 08             	lea    0x8(%edi),%eax
c0023e4c:	50                   	push   %eax
c0023e4d:	e8 d3 57 00 00       	call   c0029625 <list_push_front>
          if (++a->free_cnt >= d->blocks_per_arena) 
c0023e52:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e55:	83 c0 01             	add    $0x1,%eax
c0023e58:	89 45 08             	mov    %eax,0x8(%ebp)
c0023e5b:	8b 57 04             	mov    0x4(%edi),%edx
c0023e5e:	83 c4 10             	add    $0x10,%esp
c0023e61:	39 d0                	cmp    %edx,%eax
c0023e63:	72 36                	jb     c0023e9b <free+0xa7>
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023e65:	39 d0                	cmp    %edx,%eax
c0023e67:	75 49                	jne    c0023eb2 <free+0xbe>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023e69:	be 00 00 00 00       	mov    $0x0,%esi
c0023e6e:	85 c0                	test   %eax,%eax
c0023e70:	74 1d                	je     c0023e8f <free+0x9b>
                  struct block *b = arena_to_block (a, i);
c0023e72:	89 f2                	mov    %esi,%edx
c0023e74:	89 e8                	mov    %ebp,%eax
c0023e76:	e8 2e fb ff ff       	call   c00239a9 <arena_to_block>
                  list_remove (&b->free_elem);
c0023e7b:	83 ec 0c             	sub    $0xc,%esp
c0023e7e:	50                   	push   %eax
c0023e7f:	e8 db 57 00 00       	call   c002965f <list_remove>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023e84:	83 c6 01             	add    $0x1,%esi
c0023e87:	83 c4 10             	add    $0x10,%esp
c0023e8a:	39 77 04             	cmp    %esi,0x4(%edi)
c0023e8d:	77 e3                	ja     c0023e72 <free+0x7e>
              palloc_free_page (a);
c0023e8f:	83 ec 0c             	sub    $0xc,%esp
c0023e92:	55                   	push   %ebp
c0023e93:	e8 ff fa ff ff       	call   c0023997 <palloc_free_page>
c0023e98:	83 c4 10             	add    $0x10,%esp
          lock_release (&d->lock);
c0023e9b:	83 ec 0c             	sub    $0xc,%esp
c0023e9e:	ff 74 24 18          	pushl  0x18(%esp)
c0023ea2:	e8 8e f3 ff ff       	call   c0023235 <lock_release>
c0023ea7:	83 c4 10             	add    $0x10,%esp
}
c0023eaa:	83 c4 1c             	add    $0x1c,%esp
c0023ead:	5b                   	pop    %ebx
c0023eae:	5e                   	pop    %esi
c0023eaf:	5f                   	pop    %edi
c0023eb0:	5d                   	pop    %ebp
c0023eb1:	c3                   	ret    
              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023eb2:	83 ec 0c             	sub    $0xc,%esp
c0023eb5:	8d 83 c4 60 ff ff    	lea    -0x9f3c(%ebx),%eax
c0023ebb:	50                   	push   %eax
c0023ebc:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0023ec2:	50                   	push   %eax
c0023ec3:	8d 83 d4 47 ff ff    	lea    -0xb82c(%ebx),%eax
c0023ec9:	50                   	push   %eax
c0023eca:	68 f6 00 00 00       	push   $0xf6
c0023ecf:	8d 83 d5 5f ff ff    	lea    -0xa02b(%ebx),%eax
c0023ed5:	50                   	push   %eax
c0023ed6:	e8 b4 50 00 00       	call   c0028f8f <debug_panic>
          palloc_free_multiple (a, a->free_cnt);
c0023edb:	83 ec 08             	sub    $0x8,%esp
c0023ede:	ff 70 08             	pushl  0x8(%eax)
c0023ee1:	50                   	push   %eax
c0023ee2:	e8 54 f9 ff ff       	call   c002383b <palloc_free_multiple>
          return;
c0023ee7:	83 c4 10             	add    $0x10,%esp
c0023eea:	eb be                	jmp    c0023eaa <free+0xb6>

c0023eec <realloc>:
{
c0023eec:	55                   	push   %ebp
c0023eed:	57                   	push   %edi
c0023eee:	56                   	push   %esi
c0023eef:	53                   	push   %ebx
c0023ef0:	83 ec 0c             	sub    $0xc,%esp
c0023ef3:	e8 43 9a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023ef8:	81 c3 d4 55 01 00    	add    $0x155d4,%ebx
c0023efe:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0023f02:	8b 74 24 24          	mov    0x24(%esp),%esi
  if (new_size == 0) 
c0023f06:	85 f6                	test   %esi,%esi
c0023f08:	74 4b                	je     c0023f55 <realloc+0x69>
      void *new_block = malloc (new_size);
c0023f0a:	83 ec 0c             	sub    $0xc,%esp
c0023f0d:	56                   	push   %esi
c0023f0e:	e8 2b fd ff ff       	call   c0023c3e <malloc>
c0023f13:	89 c5                	mov    %eax,%ebp
      if (old_block != NULL && new_block != NULL)
c0023f15:	83 c4 10             	add    $0x10,%esp
c0023f18:	85 ff                	test   %edi,%edi
c0023f1a:	74 2f                	je     c0023f4b <realloc+0x5f>
c0023f1c:	85 c0                	test   %eax,%eax
c0023f1e:	74 2b                	je     c0023f4b <realloc+0x5f>
  struct arena *a = block_to_arena (b);
c0023f20:	89 f8                	mov    %edi,%eax
c0023f22:	e8 2c fb ff ff       	call   c0023a53 <block_to_arena>
  struct desc *d = a->desc;
c0023f27:	8b 50 04             	mov    0x4(%eax),%edx
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023f2a:	85 d2                	test   %edx,%edx
c0023f2c:	74 3a                	je     c0023f68 <realloc+0x7c>
c0023f2e:	8b 02                	mov    (%edx),%eax
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023f30:	39 c6                	cmp    %eax,%esi
c0023f32:	0f 47 f0             	cmova  %eax,%esi
          memcpy (new_block, old_block, min_size);
c0023f35:	83 ec 04             	sub    $0x4,%esp
c0023f38:	56                   	push   %esi
c0023f39:	57                   	push   %edi
c0023f3a:	55                   	push   %ebp
c0023f3b:	e8 4b 42 00 00       	call   c002818b <memcpy>
          free (old_block);
c0023f40:	89 3c 24             	mov    %edi,(%esp)
c0023f43:	e8 ac fe ff ff       	call   c0023df4 <free>
c0023f48:	83 c4 10             	add    $0x10,%esp
}
c0023f4b:	89 e8                	mov    %ebp,%eax
c0023f4d:	83 c4 0c             	add    $0xc,%esp
c0023f50:	5b                   	pop    %ebx
c0023f51:	5e                   	pop    %esi
c0023f52:	5f                   	pop    %edi
c0023f53:	5d                   	pop    %ebp
c0023f54:	c3                   	ret    
      free (old_block);
c0023f55:	83 ec 0c             	sub    $0xc,%esp
c0023f58:	57                   	push   %edi
c0023f59:	e8 96 fe ff ff       	call   c0023df4 <free>
      return NULL;
c0023f5e:	83 c4 10             	add    $0x10,%esp
c0023f61:	bd 00 00 00 00       	mov    $0x0,%ebp
c0023f66:	eb e3                	jmp    c0023f4b <realloc+0x5f>
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023f68:	8b 40 08             	mov    0x8(%eax),%eax
c0023f6b:	c1 e0 0c             	shl    $0xc,%eax
c0023f6e:	89 fa                	mov    %edi,%edx
c0023f70:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0023f76:	29 d0                	sub    %edx,%eax
c0023f78:	eb b6                	jmp    c0023f30 <realloc+0x44>

c0023f7a <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023f7a:	55                   	push   %ebp
c0023f7b:	57                   	push   %edi
c0023f7c:	56                   	push   %esi
c0023f7d:	53                   	push   %ebx
c0023f7e:	83 ec 0c             	sub    $0xc,%esp
c0023f81:	e8 b5 99 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0023f86:	81 c3 46 55 01 00    	add    $0x15546,%ebx
c0023f8c:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0023f90:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0023f94:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023f98:	f7 c5 fd ff ff ff    	test   $0xfffffffd,%ebp
c0023f9e:	75 6a                	jne    c002400a <pit_configure_channel+0x90>
  ASSERT (mode == 2 || mode == 3);
c0023fa0:	8d 47 fe             	lea    -0x2(%edi),%eax
c0023fa3:	83 f8 01             	cmp    $0x1,%eax
c0023fa6:	0f 87 84 00 00 00    	ja     c0024030 <pit_configure_channel+0xb6>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023fac:	be 00 00 00 00       	mov    $0x0,%esi
  if (frequency < 19)
c0023fb1:	83 f9 12             	cmp    $0x12,%ecx
c0023fb4:	7e 20                	jle    c0023fd6 <pit_configure_channel+0x5c>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023fb6:	be 02 00 00 00       	mov    $0x2,%esi
  else if (frequency > PIT_HZ)
c0023fbb:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c0023fc1:	7f 13                	jg     c0023fd6 <pit_configure_channel+0x5c>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023fc3:	89 c8                	mov    %ecx,%eax
c0023fc5:	c1 e8 1f             	shr    $0x1f,%eax
c0023fc8:	01 c8                	add    %ecx,%eax
c0023fca:	d1 f8                	sar    %eax
c0023fcc:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023fd1:	99                   	cltd   
c0023fd2:	f7 f9                	idiv   %ecx
c0023fd4:	89 c6                	mov    %eax,%esi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023fd6:	e8 6b db ff ff       	call   c0021b46 <intr_disable>
c0023fdb:	89 c1                	mov    %eax,%ecx
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023fdd:	8d 04 3f             	lea    (%edi,%edi,1),%eax
c0023fe0:	83 c8 30             	or     $0x30,%eax
c0023fe3:	89 ef                	mov    %ebp,%edi
c0023fe5:	c1 e7 06             	shl    $0x6,%edi
c0023fe8:	09 f8                	or     %edi,%eax
c0023fea:	e6 43                	out    %al,$0x43
  outb (PIT_PORT_COUNTER (channel), count);
c0023fec:	8d 55 40             	lea    0x40(%ebp),%edx
c0023fef:	89 f0                	mov    %esi,%eax
c0023ff1:	ee                   	out    %al,(%dx)
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023ff2:	89 f0                	mov    %esi,%eax
c0023ff4:	66 c1 e8 08          	shr    $0x8,%ax
c0023ff8:	ee                   	out    %al,(%dx)
  intr_set_level (old_level);
c0023ff9:	83 ec 0c             	sub    $0xc,%esp
c0023ffc:	51                   	push   %ecx
c0023ffd:	e8 4b db ff ff       	call   c0021b4d <intr_set_level>
}
c0024002:	83 c4 1c             	add    $0x1c,%esp
c0024005:	5b                   	pop    %ebx
c0024006:	5e                   	pop    %esi
c0024007:	5f                   	pop    %edi
c0024008:	5d                   	pop    %ebp
c0024009:	c3                   	ret    
  ASSERT (channel == 0 || channel == 2);
c002400a:	83 ec 0c             	sub    $0xc,%esp
c002400d:	8d 83 e7 60 ff ff    	lea    -0x9f19(%ebx),%eax
c0024013:	50                   	push   %eax
c0024014:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002401a:	50                   	push   %eax
c002401b:	8d 83 08 48 ff ff    	lea    -0xb7f8(%ebx),%eax
c0024021:	50                   	push   %eax
c0024022:	6a 33                	push   $0x33
c0024024:	8d 83 04 61 ff ff    	lea    -0x9efc(%ebx),%eax
c002402a:	50                   	push   %eax
c002402b:	e8 5f 4f 00 00       	call   c0028f8f <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0024030:	83 ec 0c             	sub    $0xc,%esp
c0024033:	8d 83 18 61 ff ff    	lea    -0x9ee8(%ebx),%eax
c0024039:	50                   	push   %eax
c002403a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024040:	50                   	push   %eax
c0024041:	8d 83 08 48 ff ff    	lea    -0xb7f8(%ebx),%eax
c0024047:	50                   	push   %eax
c0024048:	6a 34                	push   $0x34
c002404a:	8d 83 04 61 ff ff    	lea    -0x9efc(%ebx),%eax
c0024050:	50                   	push   %eax
c0024051:	e8 39 4f 00 00       	call   c0028f8f <debug_panic>

c0024056 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0024056:	53                   	push   %ebx
  while (loops-- > 0)
c0024057:	89 c1                	mov    %eax,%ecx
c0024059:	89 d3                	mov    %edx,%ebx
c002405b:	83 c1 ff             	add    $0xffffffff,%ecx
c002405e:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024061:	85 d2                	test   %edx,%edx
c0024063:	78 13                	js     c0024078 <busy_wait+0x22>
c0024065:	85 d2                	test   %edx,%edx
c0024067:	7e 11                	jle    c002407a <busy_wait+0x24>
c0024069:	83 c1 ff             	add    $0xffffffff,%ecx
c002406c:	83 d3 ff             	adc    $0xffffffff,%ebx
c002406f:	89 d8                	mov    %ebx,%eax
c0024071:	21 c8                	and    %ecx,%eax
c0024073:	83 f8 ff             	cmp    $0xffffffff,%eax
c0024076:	75 f1                	jne    c0024069 <busy_wait+0x13>
    barrier ();
}
c0024078:	5b                   	pop    %ebx
c0024079:	c3                   	ret    
  while (loops-- > 0)
c002407a:	83 f8 00             	cmp    $0x0,%eax
c002407d:	76 f9                	jbe    c0024078 <busy_wait+0x22>
c002407f:	eb e8                	jmp    c0024069 <busy_wait+0x13>

c0024081 <too_many_loops>:
{
c0024081:	55                   	push   %ebp
c0024082:	57                   	push   %edi
c0024083:	56                   	push   %esi
c0024084:	53                   	push   %ebx
c0024085:	83 ec 0c             	sub    $0xc,%esp
c0024088:	e8 ae 98 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002408d:	81 c3 3f 54 01 00    	add    $0x1543f,%ebx
c0024093:	89 44 24 04          	mov    %eax,0x4(%esp)
  int64_t start = ticks;
c0024097:	8b ab b4 1f 00 00    	mov    0x1fb4(%ebx),%ebp
c002409d:	8b 8b b8 1f 00 00    	mov    0x1fb8(%ebx),%ecx
  while (ticks == start)
c00240a3:	8b bb b4 1f 00 00    	mov    0x1fb4(%ebx),%edi
c00240a9:	8b b3 b8 1f 00 00    	mov    0x1fb8(%ebx),%esi
c00240af:	89 f8                	mov    %edi,%eax
c00240b1:	31 e8                	xor    %ebp,%eax
c00240b3:	89 f2                	mov    %esi,%edx
c00240b5:	31 ca                	xor    %ecx,%edx
c00240b7:	09 c2                	or     %eax,%edx
c00240b9:	74 e8                	je     c00240a3 <too_many_loops+0x22>
  busy_wait (loops);
c00240bb:	8b 44 24 04          	mov    0x4(%esp),%eax
c00240bf:	ba 00 00 00 00       	mov    $0x0,%edx
c00240c4:	e8 8d ff ff ff       	call   c0024056 <busy_wait>
  return start != ticks;
c00240c9:	33 bb b4 1f 00 00    	xor    0x1fb4(%ebx),%edi
c00240cf:	33 b3 b8 1f 00 00    	xor    0x1fb8(%ebx),%esi
c00240d5:	09 f7                	or     %esi,%edi
c00240d7:	0f 95 c0             	setne  %al
}
c00240da:	83 c4 0c             	add    $0xc,%esp
c00240dd:	5b                   	pop    %ebx
c00240de:	5e                   	pop    %esi
c00240df:	5f                   	pop    %edi
c00240e0:	5d                   	pop    %ebp
c00240e1:	c3                   	ret    

c00240e2 <timer_interrupt>:
{
c00240e2:	55                   	push   %ebp
c00240e3:	57                   	push   %edi
c00240e4:	56                   	push   %esi
c00240e5:	53                   	push   %ebx
c00240e6:	83 ec 0c             	sub    $0xc,%esp
c00240e9:	e8 4d 98 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00240ee:	81 c3 de 53 01 00    	add    $0x153de,%ebx
  ticks++;
c00240f4:	83 83 b4 1f 00 00 01 	addl   $0x1,0x1fb4(%ebx)
c00240fb:	83 93 b8 1f 00 00 00 	adcl   $0x0,0x1fb8(%ebx)
  enum intr_level old_level = intr_disable();
c0024102:	e8 3f da ff ff       	call   c0021b46 <intr_disable>
c0024107:	89 c5                	mov    %eax,%ebp
  if (thread_mlfqs) {
c0024109:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002410f:	80 38 00             	cmpb   $0x0,(%eax)
c0024112:	75 25                	jne    c0024139 <timer_interrupt+0x57>
  thread_tick ();
c0024114:	e8 e8 ca ff ff       	call   c0020c01 <thread_tick>
  thread_foreach(blocked_thread_check, NULL);
c0024119:	83 ec 08             	sub    $0x8,%esp
c002411c:	6a 00                	push   $0x0
c002411e:	ff b3 f4 ff ff ff    	pushl  -0xc(%ebx)
c0024124:	e8 4f cb ff ff       	call   c0020c78 <thread_foreach>
  intr_set_level (old_level);
c0024129:	89 2c 24             	mov    %ebp,(%esp)
c002412c:	e8 1c da ff ff       	call   c0021b4d <intr_set_level>
}
c0024131:	83 c4 1c             	add    $0x1c,%esp
c0024134:	5b                   	pop    %ebx
c0024135:	5e                   	pop    %esi
c0024136:	5f                   	pop    %edi
c0024137:	5d                   	pop    %ebp
c0024138:	c3                   	ret    
    thread_mlfqs_increase_recent_cpu_by_one();
c0024139:	e8 01 d4 ff ff       	call   c002153f <thread_mlfqs_increase_recent_cpu_by_one>
    if (ticks % TIMER_FREQ == 0)
c002413e:	8b b3 b4 1f 00 00    	mov    0x1fb4(%ebx),%esi
c0024144:	8b bb b8 1f 00 00    	mov    0x1fb8(%ebx),%edi
c002414a:	6a 00                	push   $0x0
c002414c:	6a 64                	push   $0x64
c002414e:	57                   	push   %edi
c002414f:	56                   	push   %esi
c0024150:	e8 19 48 00 00       	call   c002896e <__moddi3>
c0024155:	83 c4 10             	add    $0x10,%esp
c0024158:	09 c2                	or     %eax,%edx
c002415a:	74 1a                	je     c0024176 <timer_interrupt+0x94>
    else if (ticks % 4 == 0)
c002415c:	83 e6 03             	and    $0x3,%esi
c002415f:	85 f6                	test   %esi,%esi
c0024161:	75 b1                	jne    c0024114 <timer_interrupt+0x32>
      thread_mlfqs_update_priority (thread_current());
c0024163:	e8 1b ca ff ff       	call   c0020b83 <thread_current>
c0024168:	83 ec 0c             	sub    $0xc,%esp
c002416b:	50                   	push   %eax
c002416c:	e8 5c d4 ff ff       	call   c00215cd <thread_mlfqs_update_priority>
c0024171:	83 c4 10             	add    $0x10,%esp
c0024174:	eb 9e                	jmp    c0024114 <timer_interrupt+0x32>
      thread_mlfqs_update_load_avg_and_recent_cpu();
c0024176:	e8 06 d5 ff ff       	call   c0021681 <thread_mlfqs_update_load_avg_and_recent_cpu>
c002417b:	eb 97                	jmp    c0024114 <timer_interrupt+0x32>

c002417d <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c002417d:	55                   	push   %ebp
c002417e:	57                   	push   %edi
c002417f:	56                   	push   %esi
c0024180:	53                   	push   %ebx
c0024181:	83 ec 0c             	sub    $0xc,%esp
c0024184:	e8 ba 97 00 00       	call   c002d943 <__x86.get_pc_thunk.di>
c0024189:	81 c7 43 53 01 00    	add    $0x15343,%edi
c002418f:	89 c5                	mov    %eax,%ebp
c0024191:	89 d3                	mov    %edx,%ebx
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0024193:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0024198:	89 c8                	mov    %ecx,%eax
c002419a:	f7 ea                	imul   %edx
c002419c:	c1 fa 06             	sar    $0x6,%edx
c002419f:	89 c8                	mov    %ecx,%eax
c00241a1:	c1 f8 1f             	sar    $0x1f,%eax
c00241a4:	29 c2                	sub    %eax,%edx
c00241a6:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c00241ac:	39 d1                	cmp    %edx,%ecx
c00241ae:	75 61                	jne    c0024211 <real_time_delay+0x94>
c00241b0:	89 ce                	mov    %ecx,%esi
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c00241b2:	8b 87 ac 1f 00 00    	mov    0x1fac(%edi),%eax
c00241b8:	0f af d8             	imul   %eax,%ebx
c00241bb:	f7 e5                	mul    %ebp
c00241bd:	01 da                	add    %ebx,%edx
c00241bf:	6a 00                	push   $0x0
c00241c1:	68 e8 03 00 00       	push   $0x3e8
c00241c6:	52                   	push   %edx
c00241c7:	50                   	push   %eax
c00241c8:	89 fb                	mov    %edi,%ebx
c00241ca:	e8 83 47 00 00       	call   c0028952 <__divdi3>
c00241cf:	83 c4 10             	add    $0x10,%esp
c00241d2:	6b ea 64             	imul   $0x64,%edx,%ebp
c00241d5:	b9 64 00 00 00       	mov    $0x64,%ecx
c00241da:	f7 e1                	mul    %ecx
c00241dc:	89 c1                	mov    %eax,%ecx
c00241de:	89 d3                	mov    %edx,%ebx
c00241e0:	01 eb                	add    %ebp,%ebx
c00241e2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00241e7:	89 f0                	mov    %esi,%eax
c00241e9:	f7 ea                	imul   %edx
c00241eb:	c1 fa 06             	sar    $0x6,%edx
c00241ee:	c1 fe 1f             	sar    $0x1f,%esi
c00241f1:	29 f2                	sub    %esi,%edx
c00241f3:	89 d0                	mov    %edx,%eax
c00241f5:	99                   	cltd   
c00241f6:	52                   	push   %edx
c00241f7:	50                   	push   %eax
c00241f8:	53                   	push   %ebx
c00241f9:	51                   	push   %ecx
c00241fa:	89 fb                	mov    %edi,%ebx
c00241fc:	e8 51 47 00 00       	call   c0028952 <__divdi3>
c0024201:	83 c4 10             	add    $0x10,%esp
c0024204:	e8 4d fe ff ff       	call   c0024056 <busy_wait>
}
c0024209:	83 c4 0c             	add    $0xc,%esp
c002420c:	5b                   	pop    %ebx
c002420d:	5e                   	pop    %esi
c002420e:	5f                   	pop    %edi
c002420f:	5d                   	pop    %ebp
c0024210:	c3                   	ret    
  ASSERT (denom % 1000 == 0);
c0024211:	83 ec 0c             	sub    $0xc,%esp
c0024214:	8d 87 2f 61 ff ff    	lea    -0x9ed1(%edi),%eax
c002421a:	50                   	push   %eax
c002421b:	8d 87 eb 55 ff ff    	lea    -0xaa15(%edi),%eax
c0024221:	50                   	push   %eax
c0024222:	8d 87 20 48 ff ff    	lea    -0xb7e0(%edi),%eax
c0024228:	50                   	push   %eax
c0024229:	68 04 01 00 00       	push   $0x104
c002422e:	8d 87 41 61 ff ff    	lea    -0x9ebf(%edi),%eax
c0024234:	50                   	push   %eax
c0024235:	89 fb                	mov    %edi,%ebx
c0024237:	e8 53 4d 00 00       	call   c0028f8f <debug_panic>

c002423c <timer_init>:
{
c002423c:	53                   	push   %ebx
c002423d:	83 ec 0c             	sub    $0xc,%esp
c0024240:	e8 f6 96 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024245:	81 c3 87 52 01 00    	add    $0x15287,%ebx
  pit_configure_channel (0, 2, TIMER_FREQ);
c002424b:	6a 64                	push   $0x64
c002424d:	6a 02                	push   $0x2
c002424f:	6a 00                	push   $0x0
c0024251:	e8 24 fd ff ff       	call   c0023f7a <pit_configure_channel>
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0024256:	83 c4 0c             	add    $0xc,%esp
c0024259:	8d 83 57 61 ff ff    	lea    -0x9ea9(%ebx),%eax
c002425f:	50                   	push   %eax
c0024260:	8d 83 16 ac fe ff    	lea    -0x153ea(%ebx),%eax
c0024266:	50                   	push   %eax
c0024267:	6a 20                	push   $0x20
c0024269:	e8 b2 da ff ff       	call   c0021d20 <intr_register_ext>
}
c002426e:	83 c4 18             	add    $0x18,%esp
c0024271:	5b                   	pop    %ebx
c0024272:	c3                   	ret    

c0024273 <timer_calibrate>:
{
c0024273:	55                   	push   %ebp
c0024274:	57                   	push   %edi
c0024275:	56                   	push   %esi
c0024276:	53                   	push   %ebx
c0024277:	83 ec 0c             	sub    $0xc,%esp
c002427a:	e8 bc 96 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002427f:	81 c3 4d 52 01 00    	add    $0x1524d,%ebx
  ASSERT (intr_get_level () == INTR_ON);
c0024285:	e8 6a d8 ff ff       	call   c0021af4 <intr_get_level>
c002428a:	83 f8 01             	cmp    $0x1,%eax
c002428d:	75 60                	jne    c00242ef <timer_calibrate+0x7c>
  printf ("Calibrating timer...  ");
c002428f:	83 ec 0c             	sub    $0xc,%esp
c0024292:	8d 83 7f 61 ff ff    	lea    -0x9e81(%ebx),%eax
c0024298:	50                   	push   %eax
c0024299:	e8 5a 2f 00 00       	call   c00271f8 <printf>
  loops_per_tick = 1u << 10;
c002429e:	c7 83 ac 1f 00 00 00 	movl   $0x400,0x1fac(%ebx)
c00242a5:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c00242a8:	83 c4 10             	add    $0x10,%esp
c00242ab:	8b bb ac 1f 00 00    	mov    0x1fac(%ebx),%edi
c00242b1:	8d 34 3f             	lea    (%edi,%edi,1),%esi
c00242b4:	89 f0                	mov    %esi,%eax
c00242b6:	e8 c6 fd ff ff       	call   c0024081 <too_many_loops>
c00242bb:	84 c0                	test   %al,%al
c00242bd:	75 56                	jne    c0024315 <timer_calibrate+0xa2>
      loops_per_tick <<= 1;
c00242bf:	89 b3 ac 1f 00 00    	mov    %esi,0x1fac(%ebx)
      ASSERT (loops_per_tick != 0);
c00242c5:	85 f6                	test   %esi,%esi
c00242c7:	75 e2                	jne    c00242ab <timer_calibrate+0x38>
c00242c9:	83 ec 0c             	sub    $0xc,%esp
c00242cc:	8d 83 96 61 ff ff    	lea    -0x9e6a(%ebx),%eax
c00242d2:	50                   	push   %eax
c00242d3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00242d9:	50                   	push   %eax
c00242da:	8d 83 4c 48 ff ff    	lea    -0xb7b4(%ebx),%eax
c00242e0:	50                   	push   %eax
c00242e1:	6a 39                	push   $0x39
c00242e3:	8d 83 41 61 ff ff    	lea    -0x9ebf(%ebx),%eax
c00242e9:	50                   	push   %eax
c00242ea:	e8 a0 4c 00 00       	call   c0028f8f <debug_panic>
  ASSERT (intr_get_level () == INTR_ON);
c00242ef:	83 ec 0c             	sub    $0xc,%esp
c00242f2:	8d 83 62 61 ff ff    	lea    -0x9e9e(%ebx),%eax
c00242f8:	50                   	push   %eax
c00242f9:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00242ff:	50                   	push   %eax
c0024300:	8d 83 4c 48 ff ff    	lea    -0xb7b4(%ebx),%eax
c0024306:	50                   	push   %eax
c0024307:	6a 30                	push   $0x30
c0024309:	8d 83 41 61 ff ff    	lea    -0x9ebf(%ebx),%eax
c002430f:	50                   	push   %eax
c0024310:	e8 7a 4c 00 00       	call   c0028f8f <debug_panic>
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024315:	89 fe                	mov    %edi,%esi
c0024317:	d1 ee                	shr    %esi
c0024319:	89 fd                	mov    %edi,%ebp
c002431b:	c1 ed 0a             	shr    $0xa,%ebp
c002431e:	39 f5                	cmp    %esi,%ebp
c0024320:	75 2a                	jne    c002434c <timer_calibrate+0xd9>
  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0024322:	83 ec 04             	sub    $0x4,%esp
c0024325:	b8 64 00 00 00       	mov    $0x64,%eax
c002432a:	f7 a3 ac 1f 00 00    	mull   0x1fac(%ebx)
c0024330:	52                   	push   %edx
c0024331:	50                   	push   %eax
c0024332:	8d 83 aa 61 ff ff    	lea    -0x9e56(%ebx),%eax
c0024338:	50                   	push   %eax
c0024339:	e8 ba 2e 00 00       	call   c00271f8 <printf>
}
c002433e:	83 c4 1c             	add    $0x1c,%esp
c0024341:	5b                   	pop    %ebx
c0024342:	5e                   	pop    %esi
c0024343:	5f                   	pop    %edi
c0024344:	5d                   	pop    %ebp
c0024345:	c3                   	ret    
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024346:	d1 ee                	shr    %esi
c0024348:	39 f5                	cmp    %esi,%ebp
c002434a:	74 d6                	je     c0024322 <timer_calibrate+0xaf>
    if (!too_many_loops (high_bit | test_bit))
c002434c:	89 f8                	mov    %edi,%eax
c002434e:	09 f0                	or     %esi,%eax
c0024350:	e8 2c fd ff ff       	call   c0024081 <too_many_loops>
c0024355:	84 c0                	test   %al,%al
c0024357:	75 ed                	jne    c0024346 <timer_calibrate+0xd3>
      loops_per_tick |= test_bit;
c0024359:	09 b3 ac 1f 00 00    	or     %esi,0x1fac(%ebx)
c002435f:	eb e5                	jmp    c0024346 <timer_calibrate+0xd3>

c0024361 <timer_ticks>:
{
c0024361:	57                   	push   %edi
c0024362:	56                   	push   %esi
c0024363:	53                   	push   %ebx
c0024364:	e8 d2 95 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024369:	81 c3 63 51 01 00    	add    $0x15163,%ebx
  enum intr_level old_level = intr_disable ();
c002436f:	e8 d2 d7 ff ff       	call   c0021b46 <intr_disable>
  int64_t t = ticks;
c0024374:	8b b3 b4 1f 00 00    	mov    0x1fb4(%ebx),%esi
c002437a:	8b bb b8 1f 00 00    	mov    0x1fb8(%ebx),%edi
  intr_set_level (old_level);
c0024380:	83 ec 0c             	sub    $0xc,%esp
c0024383:	50                   	push   %eax
c0024384:	e8 c4 d7 ff ff       	call   c0021b4d <intr_set_level>
  return t;
c0024389:	83 c4 10             	add    $0x10,%esp
}
c002438c:	89 f0                	mov    %esi,%eax
c002438e:	89 fa                	mov    %edi,%edx
c0024390:	5b                   	pop    %ebx
c0024391:	5e                   	pop    %esi
c0024392:	5f                   	pop    %edi
c0024393:	c3                   	ret    

c0024394 <timer_elapsed>:
{
c0024394:	57                   	push   %edi
c0024395:	56                   	push   %esi
c0024396:	83 ec 04             	sub    $0x4,%esp
c0024399:	8b 74 24 10          	mov    0x10(%esp),%esi
c002439d:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks () - then;
c00243a1:	e8 bb ff ff ff       	call   c0024361 <timer_ticks>
c00243a6:	29 f0                	sub    %esi,%eax
c00243a8:	19 fa                	sbb    %edi,%edx
}
c00243aa:	83 c4 04             	add    $0x4,%esp
c00243ad:	5e                   	pop    %esi
c00243ae:	5f                   	pop    %edi
c00243af:	c3                   	ret    

c00243b0 <timer_sleep>:
{
c00243b0:	57                   	push   %edi
c00243b1:	56                   	push   %esi
c00243b2:	53                   	push   %ebx
c00243b3:	e8 83 95 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00243b8:	81 c3 14 51 01 00    	add    $0x15114,%ebx
c00243be:	8b 7c 24 10          	mov    0x10(%esp),%edi
c00243c2:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (intr_get_level () == INTR_ON);
c00243c6:	e8 29 d7 ff ff       	call   c0021af4 <intr_get_level>
c00243cb:	83 f8 01             	cmp    $0x1,%eax
c00243ce:	75 2f                	jne    c00243ff <timer_sleep+0x4f>
  if (ticks <= 0)
c00243d0:	85 f6                	test   %esi,%esi
c00243d2:	78 27                	js     c00243fb <timer_sleep+0x4b>
c00243d4:	85 f6                	test   %esi,%esi
c00243d6:	7e 4d                	jle    c0024425 <timer_sleep+0x75>
  struct thread *current_thread = thread_current();
c00243d8:	e8 a6 c7 ff ff       	call   c0020b83 <thread_current>
  current_thread->ticks_blocked = ticks;
c00243dd:	89 78 34             	mov    %edi,0x34(%eax)
c00243e0:	89 70 38             	mov    %esi,0x38(%eax)
  enum intr_level old_level = intr_disable();
c00243e3:	e8 5e d7 ff ff       	call   c0021b46 <intr_disable>
c00243e8:	89 c6                	mov    %eax,%esi
  thread_block();
c00243ea:	e8 43 cb ff ff       	call   c0020f32 <thread_block>
  intr_set_level(old_level);
c00243ef:	83 ec 0c             	sub    $0xc,%esp
c00243f2:	56                   	push   %esi
c00243f3:	e8 55 d7 ff ff       	call   c0021b4d <intr_set_level>
c00243f8:	83 c4 10             	add    $0x10,%esp
}
c00243fb:	5b                   	pop    %ebx
c00243fc:	5e                   	pop    %esi
c00243fd:	5f                   	pop    %edi
c00243fe:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c00243ff:	83 ec 0c             	sub    $0xc,%esp
c0024402:	8d 83 62 61 ff ff    	lea    -0x9e9e(%ebx),%eax
c0024408:	50                   	push   %eax
c0024409:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002440f:	50                   	push   %eax
c0024410:	8d 83 40 48 ff ff    	lea    -0xb7c0(%ebx),%eax
c0024416:	50                   	push   %eax
c0024417:	6a 5c                	push   $0x5c
c0024419:	8d 83 41 61 ff ff    	lea    -0x9ebf(%ebx),%eax
c002441f:	50                   	push   %eax
c0024420:	e8 6a 4b 00 00       	call   c0028f8f <debug_panic>
  if (ticks <= 0)
c0024425:	83 ff 00             	cmp    $0x0,%edi
c0024428:	76 d1                	jbe    c00243fb <timer_sleep+0x4b>
c002442a:	eb ac                	jmp    c00243d8 <timer_sleep+0x28>

c002442c <real_time_sleep>:
{
c002442c:	55                   	push   %ebp
c002442d:	57                   	push   %edi
c002442e:	56                   	push   %esi
c002442f:	53                   	push   %ebx
c0024430:	83 ec 1c             	sub    $0x1c,%esp
c0024433:	e8 03 95 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024438:	81 c3 94 50 01 00    	add    $0x15094,%ebx
c002443e:	89 c6                	mov    %eax,%esi
c0024440:	89 44 24 08          	mov    %eax,0x8(%esp)
c0024444:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0024448:	89 cd                	mov    %ecx,%ebp
  int64_t ticks = num * TIMER_FREQ / denom;
c002444a:	6b ca 64             	imul   $0x64,%edx,%ecx
c002444d:	b8 64 00 00 00       	mov    $0x64,%eax
c0024452:	f7 e6                	mul    %esi
c0024454:	01 ca                	add    %ecx,%edx
c0024456:	89 ef                	mov    %ebp,%edi
c0024458:	c1 ff 1f             	sar    $0x1f,%edi
c002445b:	57                   	push   %edi
c002445c:	55                   	push   %ebp
c002445d:	52                   	push   %edx
c002445e:	50                   	push   %eax
c002445f:	e8 ee 44 00 00       	call   c0028952 <__divdi3>
c0024464:	83 c4 10             	add    $0x10,%esp
c0024467:	89 c6                	mov    %eax,%esi
c0024469:	89 d7                	mov    %edx,%edi
  ASSERT (intr_get_level () == INTR_ON);
c002446b:	e8 84 d6 ff ff       	call   c0021af4 <intr_get_level>
c0024470:	83 f8 01             	cmp    $0x1,%eax
c0024473:	75 1d                	jne    c0024492 <real_time_sleep+0x66>
  if (ticks > 0)
c0024475:	85 ff                	test   %edi,%edi
c0024477:	78 47                	js     c00244c0 <real_time_sleep+0x94>
c0024479:	85 ff                	test   %edi,%edi
c002447b:	7e 3e                	jle    c00244bb <real_time_sleep+0x8f>
      timer_sleep (ticks); 
c002447d:	83 ec 08             	sub    $0x8,%esp
c0024480:	57                   	push   %edi
c0024481:	56                   	push   %esi
c0024482:	e8 29 ff ff ff       	call   c00243b0 <timer_sleep>
c0024487:	83 c4 10             	add    $0x10,%esp
}
c002448a:	83 c4 1c             	add    $0x1c,%esp
c002448d:	5b                   	pop    %ebx
c002448e:	5e                   	pop    %esi
c002448f:	5f                   	pop    %edi
c0024490:	5d                   	pop    %ebp
c0024491:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c0024492:	83 ec 0c             	sub    $0xc,%esp
c0024495:	8d 83 62 61 ff ff    	lea    -0x9e9e(%ebx),%eax
c002449b:	50                   	push   %eax
c002449c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00244a2:	50                   	push   %eax
c00244a3:	8d 83 30 48 ff ff    	lea    -0xb7d0(%ebx),%eax
c00244a9:	50                   	push   %eax
c00244aa:	68 ee 00 00 00       	push   $0xee
c00244af:	8d 83 41 61 ff ff    	lea    -0x9ebf(%ebx),%eax
c00244b5:	50                   	push   %eax
c00244b6:	e8 d4 4a 00 00       	call   c0028f8f <debug_panic>
  if (ticks > 0)
c00244bb:	83 fe 00             	cmp    $0x0,%esi
c00244be:	77 bd                	ja     c002447d <real_time_sleep+0x51>
      real_time_delay (num, denom); 
c00244c0:	89 e9                	mov    %ebp,%ecx
c00244c2:	8b 44 24 08          	mov    0x8(%esp),%eax
c00244c6:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00244ca:	e8 ae fc ff ff       	call   c002417d <real_time_delay>
}
c00244cf:	eb b9                	jmp    c002448a <real_time_sleep+0x5e>

c00244d1 <timer_msleep>:
{
c00244d1:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ms, 1000);
c00244d4:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c00244d9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00244dd:	8b 54 24 14          	mov    0x14(%esp),%edx
c00244e1:	e8 46 ff ff ff       	call   c002442c <real_time_sleep>
}
c00244e6:	83 c4 0c             	add    $0xc,%esp
c00244e9:	c3                   	ret    

c00244ea <timer_usleep>:
{
c00244ea:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (us, 1000 * 1000);
c00244ed:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c00244f2:	8b 44 24 10          	mov    0x10(%esp),%eax
c00244f6:	8b 54 24 14          	mov    0x14(%esp),%edx
c00244fa:	e8 2d ff ff ff       	call   c002442c <real_time_sleep>
}
c00244ff:	83 c4 0c             	add    $0xc,%esp
c0024502:	c3                   	ret    

c0024503 <timer_nsleep>:
{
c0024503:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0024506:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c002450b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002450f:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024513:	e8 14 ff ff ff       	call   c002442c <real_time_sleep>
}
c0024518:	83 c4 0c             	add    $0xc,%esp
c002451b:	c3                   	ret    

c002451c <timer_mdelay>:
{
c002451c:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ms, 1000);
c002451f:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024524:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024528:	8b 54 24 14          	mov    0x14(%esp),%edx
c002452c:	e8 4c fc ff ff       	call   c002417d <real_time_delay>
}
c0024531:	83 c4 0c             	add    $0xc,%esp
c0024534:	c3                   	ret    

c0024535 <timer_udelay>:
{
c0024535:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (us, 1000 * 1000);
c0024538:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c002453d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024541:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024545:	e8 33 fc ff ff       	call   c002417d <real_time_delay>
}
c002454a:	83 c4 0c             	add    $0xc,%esp
c002454d:	c3                   	ret    

c002454e <timer_ndelay>:
{
c002454e:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ns, 1000 * 1000 * 1000);
c0024551:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024556:	8b 44 24 10          	mov    0x10(%esp),%eax
c002455a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002455e:	e8 1a fc ff ff       	call   c002417d <real_time_delay>
}
c0024563:	83 c4 0c             	add    $0xc,%esp
c0024566:	c3                   	ret    

c0024567 <timer_print_stats>:
{
c0024567:	53                   	push   %ebx
c0024568:	83 ec 08             	sub    $0x8,%esp
c002456b:	e8 cb 93 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024570:	81 c3 5c 4f 01 00    	add    $0x14f5c,%ebx
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0024576:	e8 e6 fd ff ff       	call   c0024361 <timer_ticks>
c002457b:	83 ec 04             	sub    $0x4,%esp
c002457e:	52                   	push   %edx
c002457f:	50                   	push   %eax
c0024580:	8d 83 ba 61 ff ff    	lea    -0x9e46(%ebx),%eax
c0024586:	50                   	push   %eax
c0024587:	e8 6c 2c 00 00       	call   c00271f8 <printf>
}
c002458c:	83 c4 18             	add    $0x18,%esp
c002458f:	5b                   	pop    %ebx
c0024590:	c3                   	ret    

c0024591 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0024591:	55                   	push   %ebp
c0024592:	57                   	push   %edi
c0024593:	56                   	push   %esi
c0024594:	53                   	push   %ebx
c0024595:	83 ec 04             	sub    $0x4,%esp
c0024598:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c002459b:	0f b6 18             	movzbl (%eax),%ebx
c002459e:	84 db                	test   %bl,%bl
c00245a0:	74 50                	je     c00245f2 <map_key+0x61>
c00245a2:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode
        && scancode < k->first_scancode + strlen (k->chars)) 
c00245a4:	b8 00 00 00 00       	mov    $0x0,%eax
c00245a9:	eb 0a                	jmp    c00245b5 <map_key+0x24>
  for (; k->first_scancode != 0; k++)
c00245ab:	83 c6 08             	add    $0x8,%esi
c00245ae:	0f b6 1e             	movzbl (%esi),%ebx
c00245b1:	84 db                	test   %bl,%bl
c00245b3:	74 30                	je     c00245e5 <map_key+0x54>
    if (scancode >= k->first_scancode
c00245b5:	0f b6 db             	movzbl %bl,%ebx
c00245b8:	39 d3                	cmp    %edx,%ebx
c00245ba:	77 ef                	ja     c00245ab <map_key+0x1a>
        && scancode < k->first_scancode + strlen (k->chars)) 
c00245bc:	8b 6e 04             	mov    0x4(%esi),%ebp
c00245bf:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00245c4:	89 ef                	mov    %ebp,%edi
c00245c6:	f2 ae                	repnz scas %es:(%edi),%al
c00245c8:	f7 d1                	not    %ecx
c00245ca:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c00245ce:	39 d1                	cmp    %edx,%ecx
c00245d0:	76 d9                	jbe    c00245ab <map_key+0x1a>
      {
        *c = k->chars[scancode - k->first_scancode];
c00245d2:	29 da                	sub    %ebx,%edx
c00245d4:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c00245d9:	8b 3c 24             	mov    (%esp),%edi
c00245dc:	88 07                	mov    %al,(%edi)
        return true; 
c00245de:	b8 01 00 00 00       	mov    $0x1,%eax
c00245e3:	eb 05                	jmp    c00245ea <map_key+0x59>
      }

  return false;
c00245e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00245ea:	83 c4 04             	add    $0x4,%esp
c00245ed:	5b                   	pop    %ebx
c00245ee:	5e                   	pop    %esi
c00245ef:	5f                   	pop    %edi
c00245f0:	5d                   	pop    %ebp
c00245f1:	c3                   	ret    
  return false;
c00245f2:	b8 00 00 00 00       	mov    $0x0,%eax
c00245f7:	eb f1                	jmp    c00245ea <map_key+0x59>

c00245f9 <keyboard_interrupt>:
{
c00245f9:	55                   	push   %ebp
c00245fa:	57                   	push   %edi
c00245fb:	56                   	push   %esi
c00245fc:	53                   	push   %ebx
c00245fd:	83 ec 2c             	sub    $0x2c,%esp
c0024600:	e8 36 93 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024605:	81 c3 c7 4e 01 00    	add    $0x14ec7,%ebx
  bool shift = left_shift || right_shift;
c002460b:	ba 01 00 00 00       	mov    $0x1,%edx
c0024610:	80 bb ca 1f 00 00 00 	cmpb   $0x0,0x1fca(%ebx)
c0024617:	75 07                	jne    c0024620 <keyboard_interrupt+0x27>
c0024619:	0f b6 93 c9 1f 00 00 	movzbl 0x1fc9(%ebx),%edx
  bool alt = left_alt || right_alt;
c0024620:	bd 01 00 00 00       	mov    $0x1,%ebp
c0024625:	80 bb c8 1f 00 00 00 	cmpb   $0x0,0x1fc8(%ebx)
c002462c:	75 07                	jne    c0024635 <keyboard_interrupt+0x3c>
c002462e:	0f b6 ab c7 1f 00 00 	movzbl 0x1fc7(%ebx),%ebp
  bool ctrl = left_ctrl || right_ctrl;
c0024635:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c002463c:	00 
c002463d:	80 bb c6 1f 00 00 00 	cmpb   $0x0,0x1fc6(%ebx)
c0024644:	75 0b                	jne    c0024651 <keyboard_interrupt+0x58>
c0024646:	0f b6 83 c5 1f 00 00 	movzbl 0x1fc5(%ebx),%eax
c002464d:	89 44 24 08          	mov    %eax,0x8(%esp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024651:	e4 60                	in     $0x60,%al
  code = inb (DATA_REG);
c0024653:	0f b6 f0             	movzbl %al,%esi
  if (code == 0xe0)
c0024656:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
c002465c:	74 26                	je     c0024684 <keyboard_interrupt+0x8b>
  release = (code & 0x80) != 0;
c002465e:	89 f7                	mov    %esi,%edi
c0024660:	81 e7 80 00 00 00    	and    $0x80,%edi
  code &= ~0x80u;
c0024666:	81 e6 7f ff ff ff    	and    $0xffffff7f,%esi
  if (code == 0x3a) 
c002466c:	83 fe 3a             	cmp    $0x3a,%esi
c002466f:	75 20                	jne    c0024691 <keyboard_interrupt+0x98>
      if (!release)
c0024671:	85 ff                	test   %edi,%edi
c0024673:	75 07                	jne    c002467c <keyboard_interrupt+0x83>
        caps_lock = !caps_lock;
c0024675:	80 b3 c4 1f 00 00 01 	xorb   $0x1,0x1fc4(%ebx)
}
c002467c:	83 c4 2c             	add    $0x2c,%esp
c002467f:	5b                   	pop    %ebx
c0024680:	5e                   	pop    %esi
c0024681:	5f                   	pop    %edi
c0024682:	5d                   	pop    %ebp
c0024683:	c3                   	ret    
c0024684:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb (DATA_REG);
c0024686:	0f b6 f0             	movzbl %al,%esi
c0024689:	81 ce 00 e0 00 00    	or     $0xe000,%esi
c002468f:	eb cd                	jmp    c002465e <keyboard_interrupt+0x65>
  bool shift = left_shift || right_shift;
c0024691:	89 d0                	mov    %edx,%eax
c0024693:	83 e0 01             	and    $0x1,%eax
c0024696:	88 44 24 0f          	mov    %al,0xf(%esp)
  else if (map_key (invariant_keymap, code, &c)
c002469a:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c002469e:	89 f2                	mov    %esi,%edx
c00246a0:	8d 83 f4 00 00 00    	lea    0xf4(%ebx),%eax
c00246a6:	e8 e6 fe ff ff       	call   c0024591 <map_key>
c00246ab:	84 c0                	test   %al,%al
c00246ad:	75 57                	jne    c0024706 <keyboard_interrupt+0x10d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00246af:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00246b4:	74 3b                	je     c00246f1 <keyboard_interrupt+0xf8>
           || (shift && map_key (shifted_keymap, code, &c)))
c00246b6:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00246ba:	89 f2                	mov    %esi,%edx
c00246bc:	8d 83 74 00 00 00    	lea    0x74(%ebx),%eax
c00246c2:	e8 ca fe ff ff       	call   c0024591 <map_key>
c00246c7:	84 c0                	test   %al,%al
c00246c9:	75 3b                	jne    c0024706 <keyboard_interrupt+0x10d>
        if (key->scancode == code)
c00246cb:	83 fe 2a             	cmp    $0x2a,%esi
c00246ce:	0f 84 da 00 00 00    	je     c00247ae <keyboard_interrupt+0x1b5>
      for (key = shift_keys; key->scancode != 0; key++) 
c00246d4:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c00246da:	83 c0 08             	add    $0x8,%eax
c00246dd:	8b 10                	mov    (%eax),%edx
c00246df:	85 d2                	test   %edx,%edx
c00246e1:	74 99                	je     c002467c <keyboard_interrupt+0x83>
        if (key->scancode == code)
c00246e3:	39 f2                	cmp    %esi,%edx
c00246e5:	75 f3                	jne    c00246da <keyboard_interrupt+0xe1>
            *key->state_var = !release;
c00246e7:	8b 40 04             	mov    0x4(%eax),%eax
c00246ea:	85 ff                	test   %edi,%edi
c00246ec:	0f 94 00             	sete   (%eax)
            break;
c00246ef:	eb 8b                	jmp    c002467c <keyboard_interrupt+0x83>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00246f1:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00246f5:	89 f2                	mov    %esi,%edx
c00246f7:	8d 83 b4 00 00 00    	lea    0xb4(%ebx),%eax
c00246fd:	e8 8f fe ff ff       	call   c0024591 <map_key>
c0024702:	84 c0                	test   %al,%al
c0024704:	74 c5                	je     c00246cb <keyboard_interrupt+0xd2>
      if (!release) 
c0024706:	85 ff                	test   %edi,%edi
c0024708:	0f 85 6e ff ff ff    	jne    c002467c <keyboard_interrupt+0x83>
          if (c == 0177 && ctrl && alt)
c002470e:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c0024713:	3c 7f                	cmp    $0x7f,%al
c0024715:	74 5a                	je     c0024771 <keyboard_interrupt+0x178>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024717:	8d 50 c0             	lea    -0x40(%eax),%edx
c002471a:	80 fa 1f             	cmp    $0x1f,%dl
c002471d:	77 07                	ja     c0024726 <keyboard_interrupt+0x12d>
c002471f:	f6 44 24 08 01       	testb  $0x1,0x8(%esp)
c0024724:	75 6d                	jne    c0024793 <keyboard_interrupt+0x19a>
          else if (shift == caps_lock)
c0024726:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c002472b:	38 8b c4 1f 00 00    	cmp    %cl,0x1fc4(%ebx)
c0024731:	74 66                	je     c0024799 <keyboard_interrupt+0x1a0>
          if (alt)
c0024733:	f7 c5 01 00 00 00    	test   $0x1,%ebp
c0024739:	74 05                	je     c0024740 <keyboard_interrupt+0x147>
            c += 0x80;
c002473b:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
          if (!input_full ())
c0024740:	e8 9e 1c 00 00       	call   c00263e3 <input_full>
c0024745:	84 c0                	test   %al,%al
c0024747:	0f 85 2f ff ff ff    	jne    c002467c <keyboard_interrupt+0x83>
              key_cnt++;
c002474d:	83 83 bc 1f 00 00 01 	addl   $0x1,0x1fbc(%ebx)
c0024754:	83 93 c0 1f 00 00 00 	adcl   $0x0,0x1fc0(%ebx)
              input_putc (c);
c002475b:	83 ec 0c             	sub    $0xc,%esp
c002475e:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024763:	50                   	push   %eax
c0024764:	e8 9f 1b 00 00       	call   c0026308 <input_putc>
c0024769:	83 c4 10             	add    $0x10,%esp
c002476c:	e9 0b ff ff ff       	jmp    c002467c <keyboard_interrupt+0x83>
          if (c == 0177 && ctrl && alt)
c0024771:	8b 54 24 08          	mov    0x8(%esp),%edx
c0024775:	21 ea                	and    %ebp,%edx
c0024777:	f6 c2 01             	test   $0x1,%dl
c002477a:	75 12                	jne    c002478e <keyboard_interrupt+0x195>
          else if (shift == caps_lock)
c002477c:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024781:	3a 8b c4 1f 00 00    	cmp    0x1fc4(%ebx),%cl
c0024787:	75 aa                	jne    c0024733 <keyboard_interrupt+0x13a>
            c = tolower (c);
c0024789:	0f b6 c0             	movzbl %al,%eax
c002478c:	eb 1a                	jmp    c00247a8 <keyboard_interrupt+0x1af>
            shutdown_reboot ();
c002478e:	e8 4d 22 00 00       	call   c00269e0 <shutdown_reboot>
              c -= 0x40; 
c0024793:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0024797:	eb 9a                	jmp    c0024733 <keyboard_interrupt+0x13a>
            c = tolower (c);
c0024799:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c002479c:	8d 48 bf             	lea    -0x41(%eax),%ecx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c002479f:	8d 50 20             	lea    0x20(%eax),%edx
c00247a2:	83 f9 1a             	cmp    $0x1a,%ecx
c00247a5:	0f 42 c2             	cmovb  %edx,%eax
c00247a8:	88 44 24 1f          	mov    %al,0x1f(%esp)
c00247ac:	eb 85                	jmp    c0024733 <keyboard_interrupt+0x13a>
      for (key = shift_keys; key->scancode != 0; key++) 
c00247ae:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c00247b4:	e9 2e ff ff ff       	jmp    c00246e7 <keyboard_interrupt+0xee>

c00247b9 <kbd_init>:
{
c00247b9:	53                   	push   %ebx
c00247ba:	83 ec 0c             	sub    $0xc,%esp
c00247bd:	e8 79 91 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00247c2:	81 c3 0a 4d 01 00    	add    $0x14d0a,%ebx
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c00247c8:	8d 83 cd 61 ff ff    	lea    -0x9e33(%ebx),%eax
c00247ce:	50                   	push   %eax
c00247cf:	8d 83 2d b1 fe ff    	lea    -0x14ed3(%ebx),%eax
c00247d5:	50                   	push   %eax
c00247d6:	6a 21                	push   $0x21
c00247d8:	e8 43 d5 ff ff       	call   c0021d20 <intr_register_ext>
}
c00247dd:	83 c4 18             	add    $0x18,%esp
c00247e0:	5b                   	pop    %ebx
c00247e1:	c3                   	ret    

c00247e2 <kbd_print_stats>:
{
c00247e2:	53                   	push   %ebx
c00247e3:	83 ec 0c             	sub    $0xc,%esp
c00247e6:	e8 50 91 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00247eb:	81 c3 e1 4c 01 00    	add    $0x14ce1,%ebx
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c00247f1:	ff b3 c0 1f 00 00    	pushl  0x1fc0(%ebx)
c00247f7:	ff b3 bc 1f 00 00    	pushl  0x1fbc(%ebx)
c00247fd:	8d 83 db 61 ff ff    	lea    -0x9e25(%ebx),%eax
c0024803:	50                   	push   %eax
c0024804:	e8 ef 29 00 00       	call   c00271f8 <printf>
}
c0024809:	83 c4 18             	add    $0x18,%esp
c002480c:	5b                   	pop    %ebx
c002480d:	c3                   	ret    

c002480e <move_cursor>:
}

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c002480e:	e8 2c 91 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0024813:	05 b9 4c 01 00       	add    $0x14cb9,%eax
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024818:	8b 88 d4 1f 00 00    	mov    0x1fd4(%eax),%ecx
c002481e:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0024821:	c1 e1 04             	shl    $0x4,%ecx
c0024824:	66 03 88 d8 1f 00 00 	add    0x1fd8(%eax),%cx
  outw (0x3d4, 0x0e | (cp & 0xff00));
c002482b:	89 c8                	mov    %ecx,%eax
c002482d:	b0 00                	mov    $0x0,%al
c002482f:	83 c8 0e             	or     $0xe,%eax
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024832:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024837:	66 ef                	out    %ax,(%dx)
  outw (0x3d4, 0x0f | (cp << 8));
c0024839:	89 c8                	mov    %ecx,%eax
c002483b:	c1 e0 08             	shl    $0x8,%eax
c002483e:	83 c8 0f             	or     $0xf,%eax
c0024841:	66 ef                	out    %ax,(%dx)
}
c0024843:	c3                   	ret    

c0024844 <newline>:
{
c0024844:	56                   	push   %esi
c0024845:	53                   	push   %ebx
c0024846:	83 ec 04             	sub    $0x4,%esp
c0024849:	e8 ed 90 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002484e:	81 c3 7e 4c 01 00    	add    $0x14c7e,%ebx
  cx = 0;
c0024854:	c7 83 d8 1f 00 00 00 	movl   $0x0,0x1fd8(%ebx)
c002485b:	00 00 00 
  cy++;
c002485e:	8b 83 d4 1f 00 00    	mov    0x1fd4(%ebx),%eax
c0024864:	83 c0 01             	add    $0x1,%eax
  if (cy >= ROW_CNT)
c0024867:	83 f8 18             	cmp    $0x18,%eax
c002486a:	77 0c                	ja     c0024878 <newline+0x34>
  cy++;
c002486c:	89 83 d4 1f 00 00    	mov    %eax,0x1fd4(%ebx)
}
c0024872:	83 c4 04             	add    $0x4,%esp
c0024875:	5b                   	pop    %ebx
c0024876:	5e                   	pop    %esi
c0024877:	c3                   	ret    
      cy = ROW_CNT - 1;
c0024878:	c7 83 d4 1f 00 00 18 	movl   $0x18,0x1fd4(%ebx)
c002487f:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024882:	8b b3 d0 1f 00 00    	mov    0x1fd0(%ebx),%esi
c0024888:	83 ec 04             	sub    $0x4,%esp
c002488b:	68 00 0f 00 00       	push   $0xf00
c0024890:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0024896:	50                   	push   %eax
c0024897:	56                   	push   %esi
c0024898:	e8 16 39 00 00       	call   c00281b3 <memmove>
c002489d:	8d 86 00 0f 00 00    	lea    0xf00(%esi),%eax
c00248a3:	8d 96 a0 0f 00 00    	lea    0xfa0(%esi),%edx
c00248a9:	83 c4 10             	add    $0x10,%esp
      fb[y][x][0] = ' ';
c00248ac:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c00248af:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c00248b3:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c00248b6:	39 d0                	cmp    %edx,%eax
c00248b8:	75 f2                	jne    c00248ac <newline+0x68>
c00248ba:	eb b6                	jmp    c0024872 <newline+0x2e>

c00248bc <vga_putc>:
{
c00248bc:	55                   	push   %ebp
c00248bd:	57                   	push   %edi
c00248be:	56                   	push   %esi
c00248bf:	53                   	push   %ebx
c00248c0:	83 ec 0c             	sub    $0xc,%esp
c00248c3:	e8 73 90 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00248c8:	81 c3 04 4c 01 00    	add    $0x14c04,%ebx
  enum intr_level old_level = intr_disable ();
c00248ce:	e8 73 d2 ff ff       	call   c0021b46 <intr_disable>
c00248d3:	89 c6                	mov    %eax,%esi
  if (!inited)
c00248d5:	80 bb cc 1f 00 00 00 	cmpb   $0x0,0x1fcc(%ebx)
c00248dc:	74 1b                	je     c00248f9 <vga_putc+0x3d>
  switch (c) 
c00248de:	8b 44 24 20          	mov    0x20(%esp),%eax
c00248e2:	83 e8 07             	sub    $0x7,%eax
c00248e5:	83 f8 06             	cmp    $0x6,%eax
c00248e8:	0f 87 1f 01 00 00    	ja     c0024a0d <.L11>
c00248ee:	89 df                	mov    %ebx,%edi
c00248f0:	03 bc 83 5c 48 ff ff 	add    -0xb7a4(%ebx,%eax,4),%edi
c00248f7:	ff e7                	jmp    *%edi
      fb = ptov (0xb8000);
c00248f9:	c7 83 d0 1f 00 00 00 	movl   $0xc00b8000,0x1fd0(%ebx)
c0024900:	80 0b c0 
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024903:	bf d4 03 00 00       	mov    $0x3d4,%edi
c0024908:	b8 0e 00 00 00       	mov    $0xe,%eax
c002490d:	89 fa                	mov    %edi,%edx
c002490f:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024910:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0024915:	89 ca                	mov    %ecx,%edx
c0024917:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
  cp = inb (0x3d5) << 8;
c0024918:	89 c5                	mov    %eax,%ebp
c002491a:	c1 e5 08             	shl    $0x8,%ebp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002491d:	b8 0f 00 00 00       	mov    $0xf,%eax
c0024922:	89 fa                	mov    %edi,%edx
c0024924:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024925:	89 ca                	mov    %ecx,%edx
c0024927:	ec                   	in     (%dx),%al

  outb (0x3d4, 0x0f);
  cp |= inb (0x3d5);
c0024928:	0f b6 c0             	movzbl %al,%eax
c002492b:	09 e8                	or     %ebp,%eax

  *x = cp % COL_CNT;
c002492d:	0f b7 d0             	movzwl %ax,%edx
c0024930:	69 d2 cd cc 00 00    	imul   $0xcccd,%edx,%edx
c0024936:	c1 ea 16             	shr    $0x16,%edx
c0024939:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c002493c:	c1 e1 04             	shl    $0x4,%ecx
c002493f:	29 c8                	sub    %ecx,%eax
c0024941:	0f b7 c0             	movzwl %ax,%eax
c0024944:	89 83 d8 1f 00 00    	mov    %eax,0x1fd8(%ebx)
  *y = cp / COL_CNT;
c002494a:	0f b7 d2             	movzwl %dx,%edx
c002494d:	89 93 d4 1f 00 00    	mov    %edx,0x1fd4(%ebx)
      inited = true; 
c0024953:	c6 83 cc 1f 00 00 01 	movb   $0x1,0x1fcc(%ebx)
c002495a:	eb 82                	jmp    c00248de <vga_putc+0x22>

c002495c <.L17>:
c002495c:	8b 83 d0 1f 00 00    	mov    0x1fd0(%ebx),%eax
c0024962:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c0024968:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
      fb[y][x][0] = ' ';
c002496e:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024971:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024975:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024978:	39 c2                	cmp    %eax,%edx
c002497a:	75 f2                	jne    c002496e <.L17+0x12>
  for (y = 0; y < ROW_CNT; y++)
c002497c:	39 c8                	cmp    %ecx,%eax
c002497e:	75 e8                	jne    c0024968 <.L17+0xc>
  cx = cy = 0;
c0024980:	c7 83 d4 1f 00 00 00 	movl   $0x0,0x1fd4(%ebx)
c0024987:	00 00 00 
c002498a:	c7 83 d8 1f 00 00 00 	movl   $0x0,0x1fd8(%ebx)
c0024991:	00 00 00 
  move_cursor ();
c0024994:	e8 75 fe ff ff       	call   c002480e <move_cursor>
c0024999:	eb 05                	jmp    c00249a0 <.L16+0x5>

c002499b <.L16>:
      newline ();
c002499b:	e8 a4 fe ff ff       	call   c0024844 <newline>
  move_cursor ();
c00249a0:	e8 69 fe ff ff       	call   c002480e <move_cursor>
  intr_set_level (old_level);
c00249a5:	83 ec 0c             	sub    $0xc,%esp
c00249a8:	56                   	push   %esi
c00249a9:	e8 9f d1 ff ff       	call   c0021b4d <intr_set_level>
}
c00249ae:	83 c4 1c             	add    $0x1c,%esp
c00249b1:	5b                   	pop    %ebx
c00249b2:	5e                   	pop    %esi
c00249b3:	5f                   	pop    %edi
c00249b4:	5d                   	pop    %ebp
c00249b5:	c3                   	ret    

c00249b6 <.L14>:
      if (cx > 0)
c00249b6:	8b 83 d8 1f 00 00    	mov    0x1fd8(%ebx),%eax
c00249bc:	85 c0                	test   %eax,%eax
c00249be:	74 e0                	je     c00249a0 <.L16+0x5>
        cx--;
c00249c0:	83 e8 01             	sub    $0x1,%eax
c00249c3:	89 83 d8 1f 00 00    	mov    %eax,0x1fd8(%ebx)
c00249c9:	eb d5                	jmp    c00249a0 <.L16+0x5>

c00249cb <.L18>:
      cx = 0;
c00249cb:	c7 83 d8 1f 00 00 00 	movl   $0x0,0x1fd8(%ebx)
c00249d2:	00 00 00 
      break;
c00249d5:	eb c9                	jmp    c00249a0 <.L16+0x5>

c00249d7 <.L15>:
      cx = ROUND_UP (cx + 1, 8);
c00249d7:	8b 83 d8 1f 00 00    	mov    0x1fd8(%ebx),%eax
c00249dd:	83 c0 08             	add    $0x8,%eax
c00249e0:	83 e0 f8             	and    $0xfffffff8,%eax
c00249e3:	89 83 d8 1f 00 00    	mov    %eax,0x1fd8(%ebx)
      if (cx >= COL_CNT)
c00249e9:	83 f8 4f             	cmp    $0x4f,%eax
c00249ec:	76 b2                	jbe    c00249a0 <.L16+0x5>
        newline ();
c00249ee:	e8 51 fe ff ff       	call   c0024844 <newline>
c00249f3:	eb ab                	jmp    c00249a0 <.L16+0x5>

c00249f5 <.L12>:
      intr_set_level (old_level);
c00249f5:	83 ec 0c             	sub    $0xc,%esp
c00249f8:	56                   	push   %esi
c00249f9:	e8 4f d1 ff ff       	call   c0021b4d <intr_set_level>
      speaker_beep ();
c00249fe:	e8 95 21 00 00       	call   c0026b98 <speaker_beep>
      intr_disable ();
c0024a03:	e8 3e d1 ff ff       	call   c0021b46 <intr_disable>
      break;
c0024a08:	83 c4 10             	add    $0x10,%esp
c0024a0b:	eb 93                	jmp    c00249a0 <.L16+0x5>

c0024a0d <.L11>:
      fb[cy][cx][0] = c;
c0024a0d:	8b bb d0 1f 00 00    	mov    0x1fd0(%ebx),%edi
c0024a13:	8b 83 d4 1f 00 00    	mov    0x1fd4(%ebx),%eax
c0024a19:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024a1c:	c1 e0 05             	shl    $0x5,%eax
c0024a1f:	01 f8                	add    %edi,%eax
c0024a21:	8b 8b d8 1f 00 00    	mov    0x1fd8(%ebx),%ecx
c0024a27:	0f b6 54 24 20       	movzbl 0x20(%esp),%edx
c0024a2c:	88 14 48             	mov    %dl,(%eax,%ecx,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024a2f:	8b 83 d4 1f 00 00    	mov    0x1fd4(%ebx),%eax
c0024a35:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024a38:	c1 e0 05             	shl    $0x5,%eax
c0024a3b:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0024a3e:	8b 83 d8 1f 00 00    	mov    0x1fd8(%ebx),%eax
c0024a44:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c0024a49:	8b 83 d8 1f 00 00    	mov    0x1fd8(%ebx),%eax
c0024a4f:	83 c0 01             	add    $0x1,%eax
c0024a52:	89 83 d8 1f 00 00    	mov    %eax,0x1fd8(%ebx)
c0024a58:	83 f8 4f             	cmp    $0x4f,%eax
c0024a5b:	0f 86 3f ff ff ff    	jbe    c00249a0 <.L16+0x5>
        newline ();
c0024a61:	e8 de fd ff ff       	call   c0024844 <newline>
c0024a66:	e9 35 ff ff ff       	jmp    c00249a0 <.L16+0x5>

c0024a6b <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024a6b:	57                   	push   %edi
c0024a6c:	56                   	push   %esi
c0024a6d:	53                   	push   %ebx
c0024a6e:	e8 c8 8e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024a73:	81 c3 59 4a 01 00    	add    $0x14a59,%ebx
  ASSERT (mode == UNINIT);
c0024a79:	83 bb 68 20 00 00 00 	cmpl   $0x0,0x2068(%ebx)
c0024a80:	75 65                	jne    c0024ae7 <init_poll+0x7c>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024a82:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024a87:	bf f9 03 00 00       	mov    $0x3f9,%edi
c0024a8c:	89 c8                	mov    %ecx,%eax
c0024a8e:	89 fa                	mov    %edi,%edx
c0024a90:	ee                   	out    %al,(%dx)
c0024a91:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024a96:	ee                   	out    %al,(%dx)
c0024a97:	be fb 03 00 00       	mov    $0x3fb,%esi
c0024a9c:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c0024aa1:	89 f2                	mov    %esi,%edx
c0024aa3:	ee                   	out    %al,(%dx)
c0024aa4:	b8 0c 00 00 00       	mov    $0xc,%eax
c0024aa9:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024aae:	ee                   	out    %al,(%dx)
c0024aaf:	89 c8                	mov    %ecx,%eax
c0024ab1:	89 fa                	mov    %edi,%edx
c0024ab3:	ee                   	out    %al,(%dx)
c0024ab4:	b8 03 00 00 00       	mov    $0x3,%eax
c0024ab9:	89 f2                	mov    %esi,%edx
c0024abb:	ee                   	out    %al,(%dx)
c0024abc:	b8 08 00 00 00       	mov    $0x8,%eax
c0024ac1:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024ac6:	ee                   	out    %al,(%dx)
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
  outb (FCR_REG, 0);                    /* Disable FIFO. */
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
  intq_init (&txq);
c0024ac7:	83 ec 0c             	sub    $0xc,%esp
c0024aca:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c0024ad0:	50                   	push   %eax
c0024ad1:	e8 5f 19 00 00       	call   c0026435 <intq_init>
  mode = POLL;
c0024ad6:	c7 83 68 20 00 00 01 	movl   $0x1,0x2068(%ebx)
c0024add:	00 00 00 
} 
c0024ae0:	83 c4 10             	add    $0x10,%esp
c0024ae3:	5b                   	pop    %ebx
c0024ae4:	5e                   	pop    %esi
c0024ae5:	5f                   	pop    %edi
c0024ae6:	c3                   	ret    
  ASSERT (mode == UNINIT);
c0024ae7:	83 ec 0c             	sub    $0xc,%esp
c0024aea:	8d 83 54 62 ff ff    	lea    -0x9dac(%ebx),%eax
c0024af0:	50                   	push   %eax
c0024af1:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024af7:	50                   	push   %eax
c0024af8:	8d 83 a0 48 ff ff    	lea    -0xb760(%ebx),%eax
c0024afe:	50                   	push   %eax
c0024aff:	6a 45                	push   $0x45
c0024b01:	8d 83 63 62 ff ff    	lea    -0x9d9d(%ebx),%eax
c0024b07:	50                   	push   %eax
c0024b08:	e8 82 44 00 00       	call   c0028f8f <debug_panic>

c0024b0d <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024b0d:	56                   	push   %esi
c0024b0e:	53                   	push   %ebx
c0024b0f:	83 ec 04             	sub    $0x4,%esp
c0024b12:	e8 24 8e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024b17:	81 c3 b5 49 01 00    	add    $0x149b5,%ebx
  uint8_t ier = 0;

  ASSERT (intr_get_level () == INTR_OFF);
c0024b1d:	e8 d2 cf ff ff       	call   c0021af4 <intr_get_level>
c0024b22:	85 c0                	test   %eax,%eax
c0024b24:	75 37                	jne    c0024b5d <write_ier+0x50>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024b26:	83 ec 0c             	sub    $0xc,%esp
c0024b29:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c0024b2f:	50                   	push   %eax
c0024b30:	e8 3c 19 00 00       	call   c0026471 <intq_empty>
c0024b35:	83 c4 10             	add    $0x10,%esp
    ier |= IER_XMIT;
c0024b38:	84 c0                	test   %al,%al
c0024b3a:	0f 94 c0             	sete   %al
c0024b3d:	8d 34 00             	lea    (%eax,%eax,1),%esi

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024b40:	e8 9e 18 00 00       	call   c00263e3 <input_full>
    ier |= IER_RECV;
c0024b45:	89 f2                	mov    %esi,%edx
c0024b47:	83 ca 01             	or     $0x1,%edx
c0024b4a:	84 c0                	test   %al,%al
c0024b4c:	0f 44 f2             	cmove  %edx,%esi
c0024b4f:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024b54:	89 f0                	mov    %esi,%eax
c0024b56:	ee                   	out    %al,(%dx)
  
  outb (IER_REG, ier);
}
c0024b57:	83 c4 04             	add    $0x4,%esp
c0024b5a:	5b                   	pop    %ebx
c0024b5b:	5e                   	pop    %esi
c0024b5c:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024b5d:	83 ec 0c             	sub    $0xc,%esp
c0024b60:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0024b66:	50                   	push   %eax
c0024b67:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024b6d:	50                   	push   %eax
c0024b6e:	8d 83 94 48 ff ff    	lea    -0xb76c(%ebx),%eax
c0024b74:	50                   	push   %eax
c0024b75:	68 b5 00 00 00       	push   $0xb5
c0024b7a:	8d 83 63 62 ff ff    	lea    -0x9d9d(%ebx),%eax
c0024b80:	50                   	push   %eax
c0024b81:	e8 09 44 00 00       	call   c0028f8f <debug_panic>

c0024b86 <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024b86:	57                   	push   %edi
c0024b87:	56                   	push   %esi
c0024b88:	53                   	push   %ebx
c0024b89:	e8 ad 8d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024b8e:	81 c3 3e 49 01 00    	add    $0x1493e,%ebx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b94:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024b99:	ec                   	in     (%dx),%al
c0024b9a:	be fd 03 00 00       	mov    $0x3fd,%esi
c0024b9f:	bf f8 03 00 00       	mov    $0x3f8,%edi
c0024ba4:	eb 12                	jmp    c0024bb8 <serial_interrupt+0x32>
c0024ba6:	89 fa                	mov    %edi,%edx
c0024ba8:	ec                   	in     (%dx),%al
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));
c0024ba9:	83 ec 0c             	sub    $0xc,%esp
c0024bac:	0f b6 c0             	movzbl %al,%eax
c0024baf:	50                   	push   %eax
c0024bb0:	e8 53 17 00 00       	call   c0026308 <input_putc>
c0024bb5:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024bb8:	e8 26 18 00 00       	call   c00263e3 <input_full>
c0024bbd:	84 c0                	test   %al,%al
c0024bbf:	75 07                	jne    c0024bc8 <serial_interrupt+0x42>
c0024bc1:	89 f2                	mov    %esi,%edx
c0024bc3:	ec                   	in     (%dx),%al
c0024bc4:	a8 01                	test   $0x1,%al
c0024bc6:	75 de                	jne    c0024ba6 <serial_interrupt+0x20>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024bc8:	8d b3 f4 1f 00 00    	lea    0x1ff4(%ebx),%esi
c0024bce:	bf fd 03 00 00       	mov    $0x3fd,%edi
c0024bd3:	eb 12                	jmp    c0024be7 <serial_interrupt+0x61>
    outb (THR_REG, intq_getc (&txq));
c0024bd5:	83 ec 0c             	sub    $0xc,%esp
c0024bd8:	56                   	push   %esi
c0024bd9:	e8 d6 1a 00 00       	call   c00266b4 <intq_getc>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024bde:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024be3:	ee                   	out    %al,(%dx)
c0024be4:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024be7:	83 ec 0c             	sub    $0xc,%esp
c0024bea:	56                   	push   %esi
c0024beb:	e8 81 18 00 00       	call   c0026471 <intq_empty>
c0024bf0:	83 c4 10             	add    $0x10,%esp
c0024bf3:	84 c0                	test   %al,%al
c0024bf5:	75 07                	jne    c0024bfe <serial_interrupt+0x78>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024bf7:	89 fa                	mov    %edi,%edx
c0024bf9:	ec                   	in     (%dx),%al
c0024bfa:	a8 20                	test   $0x20,%al
c0024bfc:	75 d7                	jne    c0024bd5 <serial_interrupt+0x4f>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024bfe:	e8 0a ff ff ff       	call   c0024b0d <write_ier>
}
c0024c03:	5b                   	pop    %ebx
c0024c04:	5e                   	pop    %esi
c0024c05:	5f                   	pop    %edi
c0024c06:	c3                   	ret    

c0024c07 <putc_poll>:
{
c0024c07:	56                   	push   %esi
c0024c08:	53                   	push   %ebx
c0024c09:	83 ec 04             	sub    $0x4,%esp
c0024c0c:	e8 2a 8d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024c11:	81 c3 bb 48 01 00    	add    $0x148bb,%ebx
c0024c17:	89 c6                	mov    %eax,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0024c19:	e8 d6 ce ff ff       	call   c0021af4 <intr_get_level>
c0024c1e:	85 c0                	test   %eax,%eax
c0024c20:	75 18                	jne    c0024c3a <putc_poll+0x33>
c0024c22:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024c27:	ec                   	in     (%dx),%al
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024c28:	a8 20                	test   $0x20,%al
c0024c2a:	74 fb                	je     c0024c27 <putc_poll+0x20>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024c2c:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024c31:	89 f0                	mov    %esi,%eax
c0024c33:	ee                   	out    %al,(%dx)
}
c0024c34:	83 c4 04             	add    $0x4,%esp
c0024c37:	5b                   	pop    %ebx
c0024c38:	5e                   	pop    %esi
c0024c39:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024c3a:	83 ec 0c             	sub    $0xc,%esp
c0024c3d:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0024c43:	50                   	push   %eax
c0024c44:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024c4a:	50                   	push   %eax
c0024c4b:	8d 83 88 48 ff ff    	lea    -0xb778(%ebx),%eax
c0024c51:	50                   	push   %eax
c0024c52:	68 c9 00 00 00       	push   $0xc9
c0024c57:	8d 83 63 62 ff ff    	lea    -0x9d9d(%ebx),%eax
c0024c5d:	50                   	push   %eax
c0024c5e:	e8 2c 43 00 00       	call   c0028f8f <debug_panic>

c0024c63 <serial_init_queue>:
{
c0024c63:	56                   	push   %esi
c0024c64:	53                   	push   %ebx
c0024c65:	83 ec 04             	sub    $0x4,%esp
c0024c68:	e8 ce 8c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024c6d:	81 c3 5f 48 01 00    	add    $0x1485f,%ebx
  if (mode == UNINIT)
c0024c73:	83 bb 68 20 00 00 00 	cmpl   $0x0,0x2068(%ebx)
c0024c7a:	74 45                	je     c0024cc1 <serial_init_queue+0x5e>
  ASSERT (mode == POLL);
c0024c7c:	83 bb 68 20 00 00 01 	cmpl   $0x1,0x2068(%ebx)
c0024c83:	75 43                	jne    c0024cc8 <serial_init_queue+0x65>
  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024c85:	83 ec 04             	sub    $0x4,%esp
c0024c88:	8d 83 87 62 ff ff    	lea    -0x9d79(%ebx),%eax
c0024c8e:	50                   	push   %eax
c0024c8f:	8d 83 ba b6 fe ff    	lea    -0x14946(%ebx),%eax
c0024c95:	50                   	push   %eax
c0024c96:	6a 24                	push   $0x24
c0024c98:	e8 83 d0 ff ff       	call   c0021d20 <intr_register_ext>
  mode = QUEUE;
c0024c9d:	c7 83 68 20 00 00 02 	movl   $0x2,0x2068(%ebx)
c0024ca4:	00 00 00 
  old_level = intr_disable ();
c0024ca7:	e8 9a ce ff ff       	call   c0021b46 <intr_disable>
c0024cac:	89 c6                	mov    %eax,%esi
  write_ier ();
c0024cae:	e8 5a fe ff ff       	call   c0024b0d <write_ier>
  intr_set_level (old_level);
c0024cb3:	89 34 24             	mov    %esi,(%esp)
c0024cb6:	e8 92 ce ff ff       	call   c0021b4d <intr_set_level>
}
c0024cbb:	83 c4 14             	add    $0x14,%esp
c0024cbe:	5b                   	pop    %ebx
c0024cbf:	5e                   	pop    %esi
c0024cc0:	c3                   	ret    
    init_poll ();
c0024cc1:	e8 a5 fd ff ff       	call   c0024a6b <init_poll>
c0024cc6:	eb b4                	jmp    c0024c7c <serial_init_queue+0x19>
  ASSERT (mode == POLL);
c0024cc8:	83 ec 0c             	sub    $0xc,%esp
c0024ccb:	8d 83 7a 62 ff ff    	lea    -0x9d86(%ebx),%eax
c0024cd1:	50                   	push   %eax
c0024cd2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024cd8:	50                   	push   %eax
c0024cd9:	8d 83 ac 48 ff ff    	lea    -0xb754(%ebx),%eax
c0024cdf:	50                   	push   %eax
c0024ce0:	6a 58                	push   $0x58
c0024ce2:	8d 83 63 62 ff ff    	lea    -0x9d9d(%ebx),%eax
c0024ce8:	50                   	push   %eax
c0024ce9:	e8 a1 42 00 00       	call   c0028f8f <debug_panic>

c0024cee <serial_putc>:
{
c0024cee:	57                   	push   %edi
c0024cef:	56                   	push   %esi
c0024cf0:	53                   	push   %ebx
c0024cf1:	e8 45 8c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024cf6:	81 c3 d6 47 01 00    	add    $0x147d6,%ebx
c0024cfc:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable ();
c0024d00:	e8 41 ce ff ff       	call   c0021b46 <intr_disable>
c0024d05:	89 c7                	mov    %eax,%edi
  if (mode != QUEUE)
c0024d07:	8b 83 68 20 00 00    	mov    0x2068(%ebx),%eax
c0024d0d:	83 f8 02             	cmp    $0x2,%eax
c0024d10:	74 25                	je     c0024d37 <serial_putc+0x49>
      if (mode == UNINIT)
c0024d12:	85 c0                	test   %eax,%eax
c0024d14:	74 1a                	je     c0024d30 <serial_putc+0x42>
      putc_poll (byte); 
c0024d16:	89 f0                	mov    %esi,%eax
c0024d18:	0f b6 c0             	movzbl %al,%eax
c0024d1b:	e8 e7 fe ff ff       	call   c0024c07 <putc_poll>
  intr_set_level (old_level);
c0024d20:	83 ec 0c             	sub    $0xc,%esp
c0024d23:	57                   	push   %edi
c0024d24:	e8 24 ce ff ff       	call   c0021b4d <intr_set_level>
}
c0024d29:	83 c4 10             	add    $0x10,%esp
c0024d2c:	5b                   	pop    %ebx
c0024d2d:	5e                   	pop    %esi
c0024d2e:	5f                   	pop    %edi
c0024d2f:	c3                   	ret    
        init_poll ();
c0024d30:	e8 36 fd ff ff       	call   c0024a6b <init_poll>
c0024d35:	eb df                	jmp    c0024d16 <serial_putc+0x28>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024d37:	85 ff                	test   %edi,%edi
c0024d39:	74 1f                	je     c0024d5a <serial_putc+0x6c>
      intq_putc (&txq, byte); 
c0024d3b:	83 ec 08             	sub    $0x8,%esp
c0024d3e:	89 f0                	mov    %esi,%eax
c0024d40:	0f b6 f0             	movzbl %al,%esi
c0024d43:	56                   	push   %esi
c0024d44:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c0024d4a:	50                   	push   %eax
c0024d4b:	e8 2f 1a 00 00       	call   c002677f <intq_putc>
      write_ier ();
c0024d50:	e8 b8 fd ff ff       	call   c0024b0d <write_ier>
c0024d55:	83 c4 10             	add    $0x10,%esp
c0024d58:	eb c6                	jmp    c0024d20 <serial_putc+0x32>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024d5a:	83 ec 0c             	sub    $0xc,%esp
c0024d5d:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c0024d63:	50                   	push   %eax
c0024d64:	e8 5a 17 00 00       	call   c00264c3 <intq_full>
c0024d69:	83 c4 10             	add    $0x10,%esp
c0024d6c:	84 c0                	test   %al,%al
c0024d6e:	74 cb                	je     c0024d3b <serial_putc+0x4d>
          putc_poll (intq_getc (&txq)); 
c0024d70:	83 ec 0c             	sub    $0xc,%esp
c0024d73:	8d 83 f4 1f 00 00    	lea    0x1ff4(%ebx),%eax
c0024d79:	50                   	push   %eax
c0024d7a:	e8 35 19 00 00       	call   c00266b4 <intq_getc>
c0024d7f:	0f b6 c0             	movzbl %al,%eax
c0024d82:	e8 80 fe ff ff       	call   c0024c07 <putc_poll>
c0024d87:	83 c4 10             	add    $0x10,%esp
c0024d8a:	eb af                	jmp    c0024d3b <serial_putc+0x4d>

c0024d8c <serial_flush>:
{
c0024d8c:	57                   	push   %edi
c0024d8d:	56                   	push   %esi
c0024d8e:	53                   	push   %ebx
c0024d8f:	e8 a7 8b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024d94:	81 c3 38 47 01 00    	add    $0x14738,%ebx
  enum intr_level old_level = intr_disable ();
c0024d9a:	e8 a7 cd ff ff       	call   c0021b46 <intr_disable>
c0024d9f:	89 c7                	mov    %eax,%edi
  while (!intq_empty (&txq))
c0024da1:	8d b3 f4 1f 00 00    	lea    0x1ff4(%ebx),%esi
c0024da7:	eb 14                	jmp    c0024dbd <serial_flush+0x31>
    putc_poll (intq_getc (&txq));
c0024da9:	83 ec 0c             	sub    $0xc,%esp
c0024dac:	56                   	push   %esi
c0024dad:	e8 02 19 00 00       	call   c00266b4 <intq_getc>
c0024db2:	0f b6 c0             	movzbl %al,%eax
c0024db5:	e8 4d fe ff ff       	call   c0024c07 <putc_poll>
c0024dba:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0024dbd:	83 ec 0c             	sub    $0xc,%esp
c0024dc0:	56                   	push   %esi
c0024dc1:	e8 ab 16 00 00       	call   c0026471 <intq_empty>
c0024dc6:	83 c4 10             	add    $0x10,%esp
c0024dc9:	84 c0                	test   %al,%al
c0024dcb:	74 dc                	je     c0024da9 <serial_flush+0x1d>
  intr_set_level (old_level);
c0024dcd:	83 ec 0c             	sub    $0xc,%esp
c0024dd0:	57                   	push   %edi
c0024dd1:	e8 77 cd ff ff       	call   c0021b4d <intr_set_level>
}
c0024dd6:	83 c4 10             	add    $0x10,%esp
c0024dd9:	5b                   	pop    %ebx
c0024dda:	5e                   	pop    %esi
c0024ddb:	5f                   	pop    %edi
c0024ddc:	c3                   	ret    

c0024ddd <serial_notify>:
{
c0024ddd:	53                   	push   %ebx
c0024dde:	83 ec 08             	sub    $0x8,%esp
c0024de1:	e8 55 8b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024de6:	81 c3 e6 46 01 00    	add    $0x146e6,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0024dec:	e8 03 cd ff ff       	call   c0021af4 <intr_get_level>
c0024df1:	85 c0                	test   %eax,%eax
c0024df3:	75 0e                	jne    c0024e03 <serial_notify+0x26>
  if (mode == QUEUE)
c0024df5:	83 bb 68 20 00 00 02 	cmpl   $0x2,0x2068(%ebx)
c0024dfc:	74 2e                	je     c0024e2c <serial_notify+0x4f>
}
c0024dfe:	83 c4 08             	add    $0x8,%esp
c0024e01:	5b                   	pop    %ebx
c0024e02:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024e03:	83 ec 0c             	sub    $0xc,%esp
c0024e06:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0024e0c:	50                   	push   %eax
c0024e0d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024e13:	50                   	push   %eax
c0024e14:	8d 83 78 48 ff ff    	lea    -0xb788(%ebx),%eax
c0024e1a:	50                   	push   %eax
c0024e1b:	68 96 00 00 00       	push   $0x96
c0024e20:	8d 83 63 62 ff ff    	lea    -0x9d9d(%ebx),%eax
c0024e26:	50                   	push   %eax
c0024e27:	e8 63 41 00 00       	call   c0028f8f <debug_panic>
    write_ier ();
c0024e2c:	e8 dc fc ff ff       	call   c0024b0d <write_ier>
}
c0024e31:	eb cb                	jmp    c0024dfe <serial_notify+0x21>

c0024e33 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c0024e33:	53                   	push   %ebx
c0024e34:	83 ec 08             	sub    $0x8,%esp
c0024e37:	e8 0f 8b 00 00       	call   c002d94b <__x86.get_pc_thunk.cx>
c0024e3c:	81 c1 90 46 01 00    	add    $0x14690,%ecx
  if (sector >= block->size)
c0024e42:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0024e45:	39 d3                	cmp    %edx,%ebx
c0024e47:	76 05                	jbe    c0024e4e <check_sector+0x1b>
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0024e49:	83 c4 08             	add    $0x8,%esp
c0024e4c:	5b                   	pop    %ebx
c0024e4d:	c3                   	ret    
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024e4e:	83 ec 04             	sub    $0x4,%esp
c0024e51:	53                   	push   %ebx
c0024e52:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c0024e53:	83 c0 08             	add    $0x8,%eax
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024e56:	50                   	push   %eax
c0024e57:	8d 81 90 62 ff ff    	lea    -0x9d70(%ecx),%eax
c0024e5d:	50                   	push   %eax
c0024e5e:	8d 81 dc 48 ff ff    	lea    -0xb724(%ecx),%eax
c0024e64:	50                   	push   %eax
c0024e65:	6a 70                	push   $0x70
c0024e67:	8d 81 1e 63 ff ff    	lea    -0x9ce2(%ecx),%eax
c0024e6d:	50                   	push   %eax
c0024e6e:	89 cb                	mov    %ecx,%ebx
c0024e70:	e8 1a 41 00 00       	call   c0028f8f <debug_panic>

c0024e75 <block_type_name>:
{
c0024e75:	53                   	push   %ebx
c0024e76:	83 ec 08             	sub    $0x8,%esp
c0024e79:	e8 bd 8a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024e7e:	81 c3 4e 46 01 00    	add    $0x1464e,%ebx
c0024e84:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (type < BLOCK_CNT);
c0024e88:	83 f8 05             	cmp    $0x5,%eax
c0024e8b:	77 0c                	ja     c0024e99 <block_type_name+0x24>
  return block_type_names[type];
c0024e8d:	8b 84 83 44 01 00 00 	mov    0x144(%ebx,%eax,4),%eax
}
c0024e94:	83 c4 08             	add    $0x8,%esp
c0024e97:	5b                   	pop    %ebx
c0024e98:	c3                   	ret    
  ASSERT (type < BLOCK_CNT);
c0024e99:	83 ec 0c             	sub    $0xc,%esp
c0024e9c:	8d 83 34 63 ff ff    	lea    -0x9ccc(%ebx),%eax
c0024ea2:	50                   	push   %eax
c0024ea3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024ea9:	50                   	push   %eax
c0024eaa:	8d 83 0c 49 ff ff    	lea    -0xb6f4(%ebx),%eax
c0024eb0:	50                   	push   %eax
c0024eb1:	6a 2f                	push   $0x2f
c0024eb3:	8d 83 1e 63 ff ff    	lea    -0x9ce2(%ebx),%eax
c0024eb9:	50                   	push   %eax
c0024eba:	e8 d0 40 00 00       	call   c0028f8f <debug_panic>

c0024ebf <block_get_role>:
{
c0024ebf:	53                   	push   %ebx
c0024ec0:	83 ec 08             	sub    $0x8,%esp
c0024ec3:	e8 73 8a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024ec8:	81 c3 04 46 01 00    	add    $0x14604,%ebx
c0024ece:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024ed2:	83 f8 03             	cmp    $0x3,%eax
c0024ed5:	77 0c                	ja     c0024ee3 <block_get_role+0x24>
  return block_by_role[role];
c0024ed7:	8b 84 83 6c 20 00 00 	mov    0x206c(%ebx,%eax,4),%eax
}
c0024ede:	83 c4 08             	add    $0x8,%esp
c0024ee1:	5b                   	pop    %ebx
c0024ee2:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024ee3:	83 ec 0c             	sub    $0xc,%esp
c0024ee6:	8d 83 45 63 ff ff    	lea    -0x9cbb(%ebx),%eax
c0024eec:	50                   	push   %eax
c0024eed:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024ef3:	50                   	push   %eax
c0024ef4:	8d 83 fc 48 ff ff    	lea    -0xb704(%ebx),%eax
c0024efa:	50                   	push   %eax
c0024efb:	6a 38                	push   $0x38
c0024efd:	8d 83 1e 63 ff ff    	lea    -0x9ce2(%ebx),%eax
c0024f03:	50                   	push   %eax
c0024f04:	e8 86 40 00 00       	call   c0028f8f <debug_panic>

c0024f09 <block_set_role>:
{
c0024f09:	53                   	push   %ebx
c0024f0a:	83 ec 08             	sub    $0x8,%esp
c0024f0d:	e8 29 8a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024f12:	81 c3 ba 45 01 00    	add    $0x145ba,%ebx
c0024f18:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0024f1c:	83 f8 03             	cmp    $0x3,%eax
c0024f1f:	77 10                	ja     c0024f31 <block_set_role+0x28>
  block_by_role[role] = block;
c0024f21:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0024f25:	89 8c 83 6c 20 00 00 	mov    %ecx,0x206c(%ebx,%eax,4)
}
c0024f2c:	83 c4 08             	add    $0x8,%esp
c0024f2f:	5b                   	pop    %ebx
c0024f30:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c0024f31:	83 ec 0c             	sub    $0xc,%esp
c0024f34:	8d 83 45 63 ff ff    	lea    -0x9cbb(%ebx),%eax
c0024f3a:	50                   	push   %eax
c0024f3b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0024f41:	50                   	push   %eax
c0024f42:	8d 83 ec 48 ff ff    	lea    -0xb714(%ebx),%eax
c0024f48:	50                   	push   %eax
c0024f49:	6a 40                	push   $0x40
c0024f4b:	8d 83 1e 63 ff ff    	lea    -0x9ce2(%ebx),%eax
c0024f51:	50                   	push   %eax
c0024f52:	e8 38 40 00 00       	call   c0028f8f <debug_panic>

c0024f57 <block_first>:
{
c0024f57:	57                   	push   %edi
c0024f58:	56                   	push   %esi
c0024f59:	53                   	push   %ebx
c0024f5a:	e8 dc 89 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024f5f:	81 c3 6d 45 01 00    	add    $0x1456d,%ebx
  return list_elem_to_block (list_begin (&all_blocks));
c0024f65:	83 ec 0c             	sub    $0xc,%esp
c0024f68:	8d bb b4 05 00 00    	lea    0x5b4(%ebx),%edi
c0024f6e:	57                   	push   %edi
c0024f6f:	e8 40 41 00 00       	call   c00290b4 <list_begin>
c0024f74:	89 c6                	mov    %eax,%esi
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c0024f76:	89 3c 24             	mov    %edi,(%esp)
c0024f79:	e8 d8 41 00 00       	call   c0029156 <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0024f7e:	83 c4 10             	add    $0x10,%esp
c0024f81:	39 c6                	cmp    %eax,%esi
c0024f83:	b8 00 00 00 00       	mov    $0x0,%eax
c0024f88:	0f 44 f0             	cmove  %eax,%esi
}
c0024f8b:	89 f0                	mov    %esi,%eax
c0024f8d:	5b                   	pop    %ebx
c0024f8e:	5e                   	pop    %esi
c0024f8f:	5f                   	pop    %edi
c0024f90:	c3                   	ret    

c0024f91 <block_next>:
{
c0024f91:	56                   	push   %esi
c0024f92:	53                   	push   %ebx
c0024f93:	83 ec 10             	sub    $0x10,%esp
c0024f96:	e8 a0 89 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024f9b:	81 c3 31 45 01 00    	add    $0x14531,%ebx
  return list_elem_to_block (list_next (&block->list_elem));
c0024fa1:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024fa5:	e8 4f 41 00 00       	call   c00290f9 <list_next>
c0024faa:	89 c6                	mov    %eax,%esi
  return (list_elem != list_end (&all_blocks)
c0024fac:	8d 83 b4 05 00 00    	lea    0x5b4(%ebx),%eax
c0024fb2:	89 04 24             	mov    %eax,(%esp)
c0024fb5:	e8 9c 41 00 00       	call   c0029156 <list_end>
          : NULL);
c0024fba:	39 c6                	cmp    %eax,%esi
c0024fbc:	b8 00 00 00 00       	mov    $0x0,%eax
c0024fc1:	0f 44 f0             	cmove  %eax,%esi
}
c0024fc4:	89 f0                	mov    %esi,%eax
c0024fc6:	83 c4 14             	add    $0x14,%esp
c0024fc9:	5b                   	pop    %ebx
c0024fca:	5e                   	pop    %esi
c0024fcb:	c3                   	ret    

c0024fcc <block_get_by_name>:
{
c0024fcc:	55                   	push   %ebp
c0024fcd:	57                   	push   %edi
c0024fce:	56                   	push   %esi
c0024fcf:	53                   	push   %ebx
c0024fd0:	83 ec 18             	sub    $0x18,%esp
c0024fd3:	e8 63 89 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0024fd8:	81 c3 f4 44 01 00    	add    $0x144f4,%ebx
c0024fde:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024fe2:	8d 83 b4 05 00 00    	lea    0x5b4(%ebx),%eax
c0024fe8:	50                   	push   %eax
c0024fe9:	e8 c6 40 00 00       	call   c00290b4 <list_begin>
c0024fee:	89 c6                	mov    %eax,%esi
c0024ff0:	83 c4 10             	add    $0x10,%esp
c0024ff3:	8d bb b4 05 00 00    	lea    0x5b4(%ebx),%edi
c0024ff9:	83 ec 0c             	sub    $0xc,%esp
c0024ffc:	57                   	push   %edi
c0024ffd:	e8 54 41 00 00       	call   c0029156 <list_end>
c0025002:	83 c4 10             	add    $0x10,%esp
c0025005:	39 f0                	cmp    %esi,%eax
c0025007:	74 24                	je     c002502d <block_get_by_name+0x61>
      if (!strcmp (name, block->name))
c0025009:	8d 46 08             	lea    0x8(%esi),%eax
c002500c:	83 ec 08             	sub    $0x8,%esp
c002500f:	50                   	push   %eax
c0025010:	55                   	push   %ebp
c0025011:	e8 3e 32 00 00       	call   c0028254 <strcmp>
c0025016:	83 c4 10             	add    $0x10,%esp
c0025019:	85 c0                	test   %eax,%eax
c002501b:	74 15                	je     c0025032 <block_get_by_name+0x66>
       e = list_next (e))
c002501d:	83 ec 0c             	sub    $0xc,%esp
c0025020:	56                   	push   %esi
c0025021:	e8 d3 40 00 00       	call   c00290f9 <list_next>
c0025026:	89 c6                	mov    %eax,%esi
c0025028:	83 c4 10             	add    $0x10,%esp
c002502b:	eb cc                	jmp    c0024ff9 <block_get_by_name+0x2d>
  return NULL;
c002502d:	be 00 00 00 00       	mov    $0x0,%esi
}
c0025032:	89 f0                	mov    %esi,%eax
c0025034:	83 c4 0c             	add    $0xc,%esp
c0025037:	5b                   	pop    %ebx
c0025038:	5e                   	pop    %esi
c0025039:	5f                   	pop    %edi
c002503a:	5d                   	pop    %ebp
c002503b:	c3                   	ret    

c002503c <block_read>:
{
c002503c:	56                   	push   %esi
c002503d:	53                   	push   %ebx
c002503e:	83 ec 04             	sub    $0x4,%esp
c0025041:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0025045:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0025049:	89 f2                	mov    %esi,%edx
c002504b:	89 d8                	mov    %ebx,%eax
c002504d:	e8 e1 fd ff ff       	call   c0024e33 <check_sector>
  block->ops->read (block->aux, sector, buffer);
c0025052:	83 ec 04             	sub    $0x4,%esp
c0025055:	8b 43 20             	mov    0x20(%ebx),%eax
c0025058:	ff 74 24 1c          	pushl  0x1c(%esp)
c002505c:	56                   	push   %esi
c002505d:	ff 73 24             	pushl  0x24(%ebx)
c0025060:	ff 10                	call   *(%eax)
  block->read_cnt++;
c0025062:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c0025066:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c002506a:	83 c4 14             	add    $0x14,%esp
c002506d:	5b                   	pop    %ebx
c002506e:	5e                   	pop    %esi
c002506f:	c3                   	ret    

c0025070 <block_write>:
{
c0025070:	57                   	push   %edi
c0025071:	56                   	push   %esi
c0025072:	53                   	push   %ebx
c0025073:	e8 c3 88 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025078:	81 c3 54 44 01 00    	add    $0x14454,%ebx
c002507e:	8b 74 24 10          	mov    0x10(%esp),%esi
c0025082:	8b 7c 24 14          	mov    0x14(%esp),%edi
  check_sector (block, sector);
c0025086:	89 fa                	mov    %edi,%edx
c0025088:	89 f0                	mov    %esi,%eax
c002508a:	e8 a4 fd ff ff       	call   c0024e33 <check_sector>
  ASSERT (block->type != BLOCK_FOREIGN);
c002508f:	83 7e 18 05          	cmpl   $0x5,0x18(%esi)
c0025093:	74 20                	je     c00250b5 <block_write+0x45>
  block->ops->write (block->aux, sector, buffer);
c0025095:	83 ec 04             	sub    $0x4,%esp
c0025098:	8b 46 20             	mov    0x20(%esi),%eax
c002509b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002509f:	57                   	push   %edi
c00250a0:	ff 76 24             	pushl  0x24(%esi)
c00250a3:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c00250a6:	83 46 30 01          	addl   $0x1,0x30(%esi)
c00250aa:	83 56 34 00          	adcl   $0x0,0x34(%esi)
}
c00250ae:	83 c4 10             	add    $0x10,%esp
c00250b1:	5b                   	pop    %ebx
c00250b2:	5e                   	pop    %esi
c00250b3:	5f                   	pop    %edi
c00250b4:	c3                   	ret    
  ASSERT (block->type != BLOCK_FOREIGN);
c00250b5:	83 ec 0c             	sub    $0xc,%esp
c00250b8:	8d 83 5b 63 ff ff    	lea    -0x9ca5(%ebx),%eax
c00250be:	50                   	push   %eax
c00250bf:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00250c5:	50                   	push   %eax
c00250c6:	8d 83 d0 48 ff ff    	lea    -0xb730(%ebx),%eax
c00250cc:	50                   	push   %eax
c00250cd:	68 89 00 00 00       	push   $0x89
c00250d2:	8d 83 1e 63 ff ff    	lea    -0x9ce2(%ebx),%eax
c00250d8:	50                   	push   %eax
c00250d9:	e8 b1 3e 00 00       	call   c0028f8f <debug_panic>

c00250de <block_size>:
  return block->size;
c00250de:	8b 44 24 04          	mov    0x4(%esp),%eax
c00250e2:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00250e5:	c3                   	ret    

c00250e6 <block_name>:
  return block->name;
c00250e6:	8b 44 24 04          	mov    0x4(%esp),%eax
c00250ea:	83 c0 08             	add    $0x8,%eax
}
c00250ed:	c3                   	ret    

c00250ee <block_type>:
  return block->type;
c00250ee:	8b 44 24 04          	mov    0x4(%esp),%eax
c00250f2:	8b 40 18             	mov    0x18(%eax),%eax
}
c00250f5:	c3                   	ret    

c00250f6 <block_print_stats>:
{
c00250f6:	55                   	push   %ebp
c00250f7:	57                   	push   %edi
c00250f8:	56                   	push   %esi
c00250f9:	53                   	push   %ebx
c00250fa:	83 ec 1c             	sub    $0x1c,%esp
c00250fd:	e8 39 88 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025102:	81 c3 ca 43 01 00    	add    $0x143ca,%ebx
c0025108:	8d bb 6c 20 00 00    	lea    0x206c(%ebx),%edi
c002510e:	8d 6f 10             	lea    0x10(%edi),%ebp
          printf ("%s (%s): %llu reads, %llu writes\n",
c0025111:	8d 83 c4 62 ff ff    	lea    -0x9d3c(%ebx),%eax
c0025117:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002511b:	eb 07                	jmp    c0025124 <block_print_stats+0x2e>
c002511d:	83 c7 04             	add    $0x4,%edi
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025120:	39 ef                	cmp    %ebp,%edi
c0025122:	74 33                	je     c0025157 <block_print_stats+0x61>
      struct block *block = block_by_role[i];
c0025124:	8b 37                	mov    (%edi),%esi
      if (block != NULL)
c0025126:	85 f6                	test   %esi,%esi
c0025128:	74 f3                	je     c002511d <block_print_stats+0x27>
          printf ("%s (%s): %llu reads, %llu writes\n",
c002512a:	83 ec 0c             	sub    $0xc,%esp
c002512d:	ff 76 18             	pushl  0x18(%esi)
c0025130:	e8 40 fd ff ff       	call   c0024e75 <block_type_name>
c0025135:	83 c4 0c             	add    $0xc,%esp
c0025138:	ff 76 34             	pushl  0x34(%esi)
c002513b:	ff 76 30             	pushl  0x30(%esi)
c002513e:	ff 76 2c             	pushl  0x2c(%esi)
c0025141:	ff 76 28             	pushl  0x28(%esi)
c0025144:	50                   	push   %eax
c0025145:	83 c6 08             	add    $0x8,%esi
c0025148:	56                   	push   %esi
c0025149:	ff 74 24 28          	pushl  0x28(%esp)
c002514d:	e8 a6 20 00 00       	call   c00271f8 <printf>
c0025152:	83 c4 20             	add    $0x20,%esp
c0025155:	eb c6                	jmp    c002511d <block_print_stats+0x27>
}
c0025157:	83 c4 1c             	add    $0x1c,%esp
c002515a:	5b                   	pop    %ebx
c002515b:	5e                   	pop    %esi
c002515c:	5f                   	pop    %edi
c002515d:	5d                   	pop    %ebp
c002515e:	c3                   	ret    

c002515f <block_register>:
{
c002515f:	55                   	push   %ebp
c0025160:	57                   	push   %edi
c0025161:	56                   	push   %esi
c0025162:	53                   	push   %ebx
c0025163:	83 ec 18             	sub    $0x18,%esp
c0025166:	e8 d0 87 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002516b:	81 c3 61 43 01 00    	add    $0x14361,%ebx
c0025171:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc (sizeof *block);
c0025175:	6a 38                	push   $0x38
c0025177:	e8 c2 ea ff ff       	call   c0023c3e <malloc>
  if (block == NULL)
c002517c:	83 c4 10             	add    $0x10,%esp
c002517f:	85 c0                	test   %eax,%eax
c0025181:	0f 84 c6 00 00 00    	je     c002524d <block_register+0xee>
c0025187:	89 c6                	mov    %eax,%esi
  list_push_back (&all_blocks, &block->list_elem);
c0025189:	83 ec 08             	sub    $0x8,%esp
c002518c:	50                   	push   %eax
c002518d:	8d 83 b4 05 00 00    	lea    0x5b4(%ebx),%eax
c0025193:	50                   	push   %eax
c0025194:	e8 a9 44 00 00       	call   c0029642 <list_push_back>
  strlcpy (block->name, name, sizeof block->name);
c0025199:	8d 6e 08             	lea    0x8(%esi),%ebp
c002519c:	83 c4 0c             	add    $0xc,%esp
c002519f:	6a 10                	push   $0x10
c00251a1:	ff 74 24 28          	pushl  0x28(%esp)
c00251a5:	55                   	push   %ebp
c00251a6:	e8 39 34 00 00       	call   c00285e4 <strlcpy>
  block->type = type;
c00251ab:	8b 44 24 34          	mov    0x34(%esp),%eax
c00251af:	89 46 18             	mov    %eax,0x18(%esi)
  block->size = size;
c00251b2:	89 7e 1c             	mov    %edi,0x1c(%esi)
  block->ops = ops;
c00251b5:	8b 44 24 40          	mov    0x40(%esp),%eax
c00251b9:	89 46 20             	mov    %eax,0x20(%esi)
  block->aux = aux;
c00251bc:	8b 44 24 44          	mov    0x44(%esp),%eax
c00251c0:	89 46 24             	mov    %eax,0x24(%esi)
  block->read_cnt = 0;
c00251c3:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c00251ca:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  block->write_cnt = 0;
c00251d1:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
c00251d8:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00251df:	83 c4 0c             	add    $0xc,%esp
c00251e2:	57                   	push   %edi
c00251e3:	55                   	push   %ebp
c00251e4:	8d 83 78 63 ff ff    	lea    -0x9c88(%ebx),%eax
c00251ea:	50                   	push   %eax
c00251eb:	e8 08 20 00 00       	call   c00271f8 <printf>
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c00251f0:	83 c4 08             	add    $0x8,%esp
c00251f3:	8b 7e 1c             	mov    0x1c(%esi),%edi
c00251f6:	bd 00 00 00 00       	mov    $0x0,%ebp
c00251fb:	89 f8                	mov    %edi,%eax
c00251fd:	89 ea                	mov    %ebp,%edx
c00251ff:	0f a4 fa 09          	shld   $0x9,%edi,%edx
c0025203:	c1 e0 09             	shl    $0x9,%eax
c0025206:	52                   	push   %edx
c0025207:	50                   	push   %eax
c0025208:	e8 1d 2b 00 00       	call   c0027d2a <print_human_readable_size>
  printf (")");
c002520d:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0025214:	e8 0c 5d 00 00       	call   c002af25 <putchar>
  if (extra_info != NULL)
c0025219:	83 c4 10             	add    $0x10,%esp
c002521c:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0025221:	74 16                	je     c0025239 <block_register+0xda>
    printf (", %s", extra_info);
c0025223:	83 ec 08             	sub    $0x8,%esp
c0025226:	ff 74 24 30          	pushl  0x30(%esp)
c002522a:	8d 83 8a 63 ff ff    	lea    -0x9c76(%ebx),%eax
c0025230:	50                   	push   %eax
c0025231:	e8 c2 1f 00 00       	call   c00271f8 <printf>
c0025236:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025239:	83 ec 0c             	sub    $0xc,%esp
c002523c:	6a 0a                	push   $0xa
c002523e:	e8 e2 5c 00 00       	call   c002af25 <putchar>
}
c0025243:	89 f0                	mov    %esi,%eax
c0025245:	83 c4 1c             	add    $0x1c,%esp
c0025248:	5b                   	pop    %ebx
c0025249:	5e                   	pop    %esi
c002524a:	5f                   	pop    %edi
c002524b:	5d                   	pop    %ebp
c002524c:	c3                   	ret    
    PANIC ("Failed to allocate memory for block device descriptor");
c002524d:	8d 83 e8 62 ff ff    	lea    -0x9d18(%ebx),%eax
c0025253:	50                   	push   %eax
c0025254:	8d 83 c0 48 ff ff    	lea    -0xb740(%ebx),%eax
c002525a:	50                   	push   %eax
c002525b:	68 c1 00 00 00       	push   $0xc1
c0025260:	8d 83 1e 63 ff ff    	lea    -0x9ce2(%ebx),%eax
c0025266:	50                   	push   %eax
c0025267:	e8 23 3d 00 00       	call   c0028f8f <debug_panic>

c002526c <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c002526c:	53                   	push   %ebx
c002526d:	83 ec 0c             	sub    $0xc,%esp
c0025270:	e8 c6 86 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025275:	81 c3 57 42 01 00    	add    $0x14257,%ebx
c002527b:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read (p->block, p->start + sector, buffer);
c002527f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025283:	8b 42 04             	mov    0x4(%edx),%eax
c0025286:	03 44 24 1c          	add    0x1c(%esp),%eax
c002528a:	50                   	push   %eax
c002528b:	ff 32                	pushl  (%edx)
c002528d:	e8 aa fd ff ff       	call   c002503c <block_read>
}
c0025292:	83 c4 18             	add    $0x18,%esp
c0025295:	5b                   	pop    %ebx
c0025296:	c3                   	ret    

c0025297 <read_partition_table>:
{
c0025297:	55                   	push   %ebp
c0025298:	57                   	push   %edi
c0025299:	56                   	push   %esi
c002529a:	53                   	push   %ebx
c002529b:	81 ec d8 00 00 00    	sub    $0xd8,%esp
c00252a1:	e8 95 86 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00252a6:	81 c3 26 42 01 00    	add    $0x14226,%ebx
c00252ac:	89 c6                	mov    %eax,%esi
c00252ae:	89 d7                	mov    %edx,%edi
c00252b0:	89 54 24 14          	mov    %edx,0x14(%esp)
c00252b4:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  if (sector >= block_size (block))
c00252b8:	50                   	push   %eax
c00252b9:	e8 20 fe ff ff       	call   c00250de <block_size>
c00252be:	83 c4 10             	add    $0x10,%esp
c00252c1:	39 f8                	cmp    %edi,%eax
c00252c3:	76 65                	jbe    c002532a <read_partition_table+0x93>
  pt = malloc (sizeof *pt);
c00252c5:	83 ec 0c             	sub    $0xc,%esp
c00252c8:	68 00 02 00 00       	push   $0x200
c00252cd:	e8 6c e9 ff ff       	call   c0023c3e <malloc>
c00252d2:	89 c5                	mov    %eax,%ebp
  if (pt == NULL)
c00252d4:	83 c4 10             	add    $0x10,%esp
c00252d7:	85 c0                	test   %eax,%eax
c00252d9:	74 77                	je     c0025352 <read_partition_table+0xbb>
  block_read (block, 0, pt);
c00252db:	83 ec 04             	sub    $0x4,%esp
c00252de:	50                   	push   %eax
c00252df:	6a 00                	push   $0x0
c00252e1:	56                   	push   %esi
c00252e2:	e8 55 fd ff ff       	call   c002503c <block_read>
  if (pt->signature != 0xaa55)
c00252e7:	83 c4 10             	add    $0x10,%esp
c00252ea:	66 81 bd fe 01 00 00 	cmpw   $0xaa55,0x1fe(%ebp)
c00252f1:	55 aa 
c00252f3:	0f 84 97 00 00 00    	je     c0025390 <read_partition_table+0xf9>
      if (primary_extended_sector == 0)
c00252f9:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c00252fe:	75 6e                	jne    c002536e <read_partition_table+0xd7>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0025300:	83 ec 0c             	sub    $0xc,%esp
c0025303:	56                   	push   %esi
c0025304:	e8 dd fd ff ff       	call   c00250e6 <block_name>
c0025309:	83 c4 08             	add    $0x8,%esp
c002530c:	50                   	push   %eax
c002530d:	8d 83 a4 68 ff ff    	lea    -0x975c(%ebx),%eax
c0025313:	50                   	push   %eax
c0025314:	e8 df 1e 00 00       	call   c00271f8 <printf>
c0025319:	83 c4 10             	add    $0x10,%esp
      free (pt);
c002531c:	83 ec 0c             	sub    $0xc,%esp
c002531f:	55                   	push   %ebp
c0025320:	e8 cf ea ff ff       	call   c0023df4 <free>
      return;
c0025325:	83 c4 10             	add    $0x10,%esp
c0025328:	eb 1d                	jmp    c0025347 <read_partition_table+0xb0>
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c002532a:	83 ec 0c             	sub    $0xc,%esp
c002532d:	56                   	push   %esi
c002532e:	e8 b3 fd ff ff       	call   c00250e6 <block_name>
c0025333:	83 c4 0c             	add    $0xc,%esp
c0025336:	57                   	push   %edi
c0025337:	50                   	push   %eax
c0025338:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c002533e:	50                   	push   %eax
c002533f:	e8 b4 1e 00 00       	call   c00271f8 <printf>
      return;
c0025344:	83 c4 10             	add    $0x10,%esp
}
c0025347:	81 c4 cc 00 00 00    	add    $0xcc,%esp
c002534d:	5b                   	pop    %ebx
c002534e:	5e                   	pop    %esi
c002534f:	5f                   	pop    %edi
c0025350:	5d                   	pop    %ebp
c0025351:	c3                   	ret    
    PANIC ("Failed to allocate memory for partition table.");
c0025352:	8d 83 74 68 ff ff    	lea    -0x978c(%ebx),%eax
c0025358:	50                   	push   %eax
c0025359:	8d 83 2c 49 ff ff    	lea    -0xb6d4(%ebx),%eax
c002535f:	50                   	push   %eax
c0025360:	6a 5a                	push   $0x5a
c0025362:	8d 83 ab 63 ff ff    	lea    -0x9c55(%ebx),%eax
c0025368:	50                   	push   %eax
c0025369:	e8 21 3c 00 00       	call   c0028f8f <debug_panic>
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c002536e:	83 ec 0c             	sub    $0xc,%esp
c0025371:	56                   	push   %esi
c0025372:	e8 6f fd ff ff       	call   c00250e6 <block_name>
c0025377:	83 c4 0c             	add    $0xc,%esp
c002537a:	ff 74 24 0c          	pushl  0xc(%esp)
c002537e:	50                   	push   %eax
c002537f:	8d 83 cc 68 ff ff    	lea    -0x9734(%ebx),%eax
c0025385:	50                   	push   %eax
c0025386:	e8 6d 1e 00 00       	call   c00271f8 <printf>
c002538b:	83 c4 10             	add    $0x10,%esp
c002538e:	eb 8c                	jmp    c002531c <read_partition_table+0x85>
c0025390:	8d bd c2 01 00 00    	lea    0x1c2(%ebp),%edi
c0025396:	8d 85 02 02 00 00    	lea    0x202(%ebp),%eax
c002539c:	89 44 24 0c          	mov    %eax,0xc(%esp)
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c00253a0:	8d 83 00 69 ff ff    	lea    -0x9700(%ebx),%eax
c00253a6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c00253aa:	8d 83 60 69 ff ff    	lea    -0x96a0(%ebx),%eax
c00253b0:	89 44 24 20          	mov    %eax,0x20(%esp)
c00253b4:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c00253b8:	89 74 24 14          	mov    %esi,0x14(%esp)
c00253bc:	eb 30                	jmp    c00253ee <read_partition_table+0x157>
            read_partition_table (block, e->offset + primary_extended_sector,
c00253be:	8b 44 24 10          	mov    0x10(%esp),%eax
c00253c2:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00253c6:	89 ca                	mov    %ecx,%edx
c00253c8:	03 50 04             	add    0x4(%eax),%edx
c00253cb:	83 ec 0c             	sub    $0xc,%esp
c00253ce:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c00253d5:	8b 44 24 24          	mov    0x24(%esp),%eax
c00253d9:	e8 b9 fe ff ff       	call   c0025297 <read_partition_table>
c00253de:	83 c4 10             	add    $0x10,%esp
c00253e1:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00253e4:	3b 7c 24 0c          	cmp    0xc(%esp),%edi
c00253e8:	0f 84 04 02 00 00    	je     c00255f2 <read_partition_table+0x35b>
c00253ee:	89 7c 24 10          	mov    %edi,0x10(%esp)
      if (e->size == 0 || e->type == 0)
c00253f2:	8b 77 08             	mov    0x8(%edi),%esi
c00253f5:	85 f6                	test   %esi,%esi
c00253f7:	74 e8                	je     c00253e1 <read_partition_table+0x14a>
c00253f9:	0f b6 2f             	movzbl (%edi),%ebp
c00253fc:	89 e8                	mov    %ebp,%eax
c00253fe:	84 c0                	test   %al,%al
c0025400:	74 df                	je     c00253e1 <read_partition_table+0x14a>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0025402:	3c 0f                	cmp    $0xf,%al
c0025404:	0f 94 c2             	sete   %dl
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025407:	3c c5                	cmp    $0xc5,%al
c0025409:	0f 94 c0             	sete   %al
c002540c:	08 c2                	or     %al,%dl
c002540e:	75 09                	jne    c0025419 <read_partition_table+0x182>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0025410:	89 e8                	mov    %ebp,%eax
c0025412:	83 e0 7f             	and    $0x7f,%eax
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025415:	3c 05                	cmp    $0x5,%al
c0025417:	75 4c                	jne    c0025465 <read_partition_table+0x1ce>
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025419:	83 ec 0c             	sub    $0xc,%esp
c002541c:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025420:	55                   	push   %ebp
c0025421:	e8 c0 fc ff ff       	call   c00250e6 <block_name>
c0025426:	83 c4 0c             	add    $0xc,%esp
c0025429:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002542d:	56                   	push   %esi
c002542e:	50                   	push   %eax
c002542f:	ff 74 24 28          	pushl  0x28(%esp)
c0025433:	e8 c0 1d 00 00       	call   c00271f8 <printf>
          if (sector == 0)
c0025438:	83 c4 10             	add    $0x10,%esp
c002543b:	85 f6                	test   %esi,%esi
c002543d:	0f 85 7b ff ff ff    	jne    c00253be <read_partition_table+0x127>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0025443:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025447:	8b 50 04             	mov    0x4(%eax),%edx
c002544a:	83 ec 0c             	sub    $0xc,%esp
c002544d:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c0025454:	89 d1                	mov    %edx,%ecx
c0025456:	89 e8                	mov    %ebp,%eax
c0025458:	e8 3a fe ff ff       	call   c0025297 <read_partition_table>
c002545d:	83 c4 10             	add    $0x10,%esp
c0025460:	e9 7c ff ff ff       	jmp    c00253e1 <read_partition_table+0x14a>
          ++*part_nr;
c0025465:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
c002546c:	8b 00                	mov    (%eax),%eax
c002546e:	83 c0 01             	add    $0x1,%eax
c0025471:	89 44 24 24          	mov    %eax,0x24(%esp)
c0025475:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
c002547c:	89 01                	mov    %eax,(%ecx)
          found_partition (block, e->type, e->offset + sector,
c002547e:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025482:	8b 44 24 08          	mov    0x8(%esp),%eax
c0025486:	03 41 04             	add    0x4(%ecx),%eax
c0025489:	89 44 24 10          	mov    %eax,0x10(%esp)
  if (start >= block_size (block))
c002548d:	83 ec 0c             	sub    $0xc,%esp
c0025490:	ff 74 24 20          	pushl  0x20(%esp)
c0025494:	e8 45 fc ff ff       	call   c00250de <block_size>
c0025499:	83 c4 10             	add    $0x10,%esp
c002549c:	39 44 24 10          	cmp    %eax,0x10(%esp)
c00254a0:	0f 83 c6 00 00 00    	jae    c002556c <read_partition_table+0x2d5>
  else if (start + size < start || start + size > block_size (block))
c00254a6:	8b 44 24 10          	mov    0x10(%esp),%eax
c00254aa:	01 f0                	add    %esi,%eax
c00254ac:	89 44 24 28          	mov    %eax,0x28(%esp)
c00254b0:	0f 82 df 00 00 00    	jb     c0025595 <read_partition_table+0x2fe>
c00254b6:	83 ec 0c             	sub    $0xc,%esp
c00254b9:	ff 74 24 20          	pushl  0x20(%esp)
c00254bd:	e8 1c fc ff ff       	call   c00250de <block_size>
c00254c2:	83 c4 10             	add    $0x10,%esp
c00254c5:	39 44 24 28          	cmp    %eax,0x28(%esp)
c00254c9:	0f 87 c6 00 00 00    	ja     c0025595 <read_partition_table+0x2fe>
          found_partition (block, e->type, e->offset + sector,
c00254cf:	89 e8                	mov    %ebp,%eax
c00254d1:	0f b6 c0             	movzbl %al,%eax
c00254d4:	89 44 24 28          	mov    %eax,0x28(%esp)
                              : part_type == 0x21 ? BLOCK_FILESYS
c00254d8:	89 e8                	mov    %ebp,%eax
c00254da:	3c 20                	cmp    $0x20,%al
c00254dc:	0f 84 25 01 00 00    	je     c0025607 <read_partition_table+0x370>
c00254e2:	3c 21                	cmp    $0x21,%al
c00254e4:	0f 84 c0 01 00 00    	je     c00256aa <read_partition_table+0x413>
c00254ea:	3c 22                	cmp    $0x22,%al
c00254ec:	0f 84 c5 01 00 00    	je     c00256b7 <read_partition_table+0x420>
c00254f2:	3c 23                	cmp    $0x23,%al
c00254f4:	0f 84 ca 01 00 00    	je     c00256c4 <read_partition_table+0x42d>
      p = malloc (sizeof *p);
c00254fa:	83 ec 0c             	sub    $0xc,%esp
c00254fd:	6a 08                	push   $0x8
c00254ff:	e8 3a e7 ff ff       	call   c0023c3e <malloc>
c0025504:	89 c5                	mov    %eax,%ebp
      if (p == NULL)
c0025506:	83 c4 10             	add    $0x10,%esp
c0025509:	85 c0                	test   %eax,%eax
c002550b:	0f 84 b8 00 00 00    	je     c00255c9 <read_partition_table+0x332>
      p->block = block;
c0025511:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025515:	89 45 00             	mov    %eax,0x0(%ebp)
      p->start = start;
c0025518:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002551c:	89 4d 04             	mov    %ecx,0x4(%ebp)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c002551f:	83 ec 0c             	sub    $0xc,%esp
c0025522:	50                   	push   %eax
c0025523:	e8 be fb ff ff       	call   c00250e6 <block_name>
c0025528:	83 c4 04             	add    $0x4,%esp
c002552b:	ff 74 24 30          	pushl  0x30(%esp)
c002552f:	50                   	push   %eax
c0025530:	8d 83 c5 63 ff ff    	lea    -0x9c3b(%ebx),%eax
c0025536:	50                   	push   %eax
c0025537:	6a 10                	push   $0x10
c0025539:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c002553d:	50                   	push   %eax
c002553e:	e8 d6 25 00 00       	call   c0027b19 <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025543:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025547:	8b 84 83 74 01 00 00 	mov    0x174(%ebx,%eax,4),%eax
c002554e:	83 c4 20             	add    $0x20,%esp
c0025551:	85 c0                	test   %eax,%eax
c0025553:	0f 85 8f 00 00 00    	jne    c00255e8 <read_partition_table+0x351>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025559:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0025560:	00 
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025561:	8d 83 a3 63 ff ff    	lea    -0x9c5d(%ebx),%eax
c0025567:	e9 f6 00 00 00       	jmp    c0025662 <read_partition_table+0x3cb>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c002556c:	83 ec 0c             	sub    $0xc,%esp
c002556f:	ff 74 24 20          	pushl  0x20(%esp)
c0025573:	e8 6e fb ff ff       	call   c00250e6 <block_name>
c0025578:	ff 74 24 20          	pushl  0x20(%esp)
c002557c:	ff 74 24 38          	pushl  0x38(%esp)
c0025580:	50                   	push   %eax
c0025581:	8d 83 28 69 ff ff    	lea    -0x96d8(%ebx),%eax
c0025587:	50                   	push   %eax
c0025588:	e8 6b 1c 00 00       	call   c00271f8 <printf>
c002558d:	83 c4 20             	add    $0x20,%esp
c0025590:	e9 4c fe ff ff       	jmp    c00253e1 <read_partition_table+0x14a>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025595:	83 ec 0c             	sub    $0xc,%esp
c0025598:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002559c:	55                   	push   %ebp
c002559d:	e8 3c fb ff ff       	call   c00250de <block_size>
c00255a2:	89 c6                	mov    %eax,%esi
c00255a4:	89 2c 24             	mov    %ebp,(%esp)
c00255a7:	e8 3a fb ff ff       	call   c00250e6 <block_name>
c00255ac:	89 34 24             	mov    %esi,(%esp)
c00255af:	ff 74 24 38          	pushl  0x38(%esp)
c00255b3:	ff 74 24 38          	pushl  0x38(%esp)
c00255b7:	50                   	push   %eax
c00255b8:	ff 74 24 3c          	pushl  0x3c(%esp)
c00255bc:	e8 37 1c 00 00       	call   c00271f8 <printf>
c00255c1:	83 c4 20             	add    $0x20,%esp
c00255c4:	e9 18 fe ff ff       	jmp    c00253e1 <read_partition_table+0x14a>
        PANIC ("Failed to allocate memory for partition descriptor");
c00255c9:	8d 83 94 69 ff ff    	lea    -0x966c(%ebx),%eax
c00255cf:	50                   	push   %eax
c00255d0:	8d 83 1c 49 ff ff    	lea    -0xb6e4(%ebx),%eax
c00255d6:	50                   	push   %eax
c00255d7:	68 b1 00 00 00       	push   $0xb1
c00255dc:	8d 83 ab 63 ff ff    	lea    -0x9c55(%ebx),%eax
c00255e2:	50                   	push   %eax
c00255e3:	e8 a7 39 00 00       	call   c0028f8f <debug_panic>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00255e8:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c00255ef:	00 
c00255f0:	eb 70                	jmp    c0025662 <read_partition_table+0x3cb>
c00255f2:	8b 6c 24 18          	mov    0x18(%esp),%ebp
  free (pt);
c00255f6:	83 ec 0c             	sub    $0xc,%esp
c00255f9:	55                   	push   %ebp
c00255fa:	e8 f5 e7 ff ff       	call   c0023df4 <free>
c00255ff:	83 c4 10             	add    $0x10,%esp
c0025602:	e9 40 fd ff ff       	jmp    c0025347 <read_partition_table+0xb0>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025607:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c002560e:	00 
      p = malloc (sizeof *p);
c002560f:	83 ec 0c             	sub    $0xc,%esp
c0025612:	6a 08                	push   $0x8
c0025614:	e8 25 e6 ff ff       	call   c0023c3e <malloc>
c0025619:	89 c5                	mov    %eax,%ebp
      if (p == NULL)
c002561b:	83 c4 10             	add    $0x10,%esp
c002561e:	85 c0                	test   %eax,%eax
c0025620:	74 a7                	je     c00255c9 <read_partition_table+0x332>
      p->block = block;
c0025622:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025626:	89 45 00             	mov    %eax,0x0(%ebp)
      p->start = start;
c0025629:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002562d:	89 4d 04             	mov    %ecx,0x4(%ebp)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025630:	83 ec 0c             	sub    $0xc,%esp
c0025633:	50                   	push   %eax
c0025634:	e8 ad fa ff ff       	call   c00250e6 <block_name>
c0025639:	83 c4 04             	add    $0x4,%esp
c002563c:	ff 74 24 30          	pushl  0x30(%esp)
c0025640:	50                   	push   %eax
c0025641:	8d 83 c5 63 ff ff    	lea    -0x9c3b(%ebx),%eax
c0025647:	50                   	push   %eax
c0025648:	6a 10                	push   $0x10
c002564a:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c002564e:	50                   	push   %eax
c002564f:	e8 c5 24 00 00       	call   c0027b19 <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025654:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025658:	8b 84 83 74 01 00 00 	mov    0x174(%ebx,%eax,4),%eax
c002565f:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025662:	83 ec 0c             	sub    $0xc,%esp
c0025665:	ff 74 24 34          	pushl  0x34(%esp)
c0025669:	50                   	push   %eax
c002566a:	8d 83 ca 63 ff ff    	lea    -0x9c36(%ebx),%eax
c0025670:	50                   	push   %eax
c0025671:	68 80 00 00 00       	push   $0x80
c0025676:	8d 44 24 5c          	lea    0x5c(%esp),%eax
c002567a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c002567e:	50                   	push   %eax
c002567f:	e8 95 24 00 00       	call   c0027b19 <snprintf>
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025684:	83 c4 18             	add    $0x18,%esp
c0025687:	55                   	push   %ebp
c0025688:	8d 83 c4 05 00 00    	lea    0x5c4(%ebx),%eax
c002568e:	50                   	push   %eax
c002568f:	56                   	push   %esi
c0025690:	ff 74 24 24          	pushl  0x24(%esp)
c0025694:	ff 74 24 44          	pushl  0x44(%esp)
c0025698:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c002569c:	50                   	push   %eax
c002569d:	e8 bd fa ff ff       	call   c002515f <block_register>
c00256a2:	83 c4 20             	add    $0x20,%esp
c00256a5:	e9 37 fd ff ff       	jmp    c00253e1 <read_partition_table+0x14a>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00256aa:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c00256b1:	00 
c00256b2:	e9 58 ff ff ff       	jmp    c002560f <read_partition_table+0x378>
c00256b7:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c00256be:	00 
c00256bf:	e9 4b ff ff ff       	jmp    c002560f <read_partition_table+0x378>
c00256c4:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c00256cb:	00 
c00256cc:	e9 3e ff ff ff       	jmp    c002560f <read_partition_table+0x378>

c00256d1 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c00256d1:	53                   	push   %ebx
c00256d2:	83 ec 0c             	sub    $0xc,%esp
c00256d5:	e8 61 82 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00256da:	81 c3 f2 3d 01 00    	add    $0x13df2,%ebx
c00256e0:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write (p->block, p->start + sector, buffer);
c00256e4:	ff 74 24 1c          	pushl  0x1c(%esp)
c00256e8:	8b 42 04             	mov    0x4(%edx),%eax
c00256eb:	03 44 24 1c          	add    0x1c(%esp),%eax
c00256ef:	50                   	push   %eax
c00256f0:	ff 32                	pushl  (%edx)
c00256f2:	e8 79 f9 ff ff       	call   c0025070 <block_write>
}
c00256f7:	83 c4 18             	add    $0x18,%esp
c00256fa:	5b                   	pop    %ebx
c00256fb:	c3                   	ret    

c00256fc <partition_scan>:
{
c00256fc:	56                   	push   %esi
c00256fd:	53                   	push   %ebx
c00256fe:	83 ec 20             	sub    $0x20,%esp
c0025701:	e8 35 82 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025706:	81 c3 c6 3d 01 00    	add    $0x13dc6,%ebx
c002570c:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  int part_nr = 0;
c0025710:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0025717:	00 
  read_partition_table (block, 0, 0, &part_nr);
c0025718:	8d 44 24 18          	lea    0x18(%esp),%eax
c002571c:	50                   	push   %eax
c002571d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0025722:	ba 00 00 00 00       	mov    $0x0,%edx
c0025727:	89 f0                	mov    %esi,%eax
c0025729:	e8 69 fb ff ff       	call   c0025297 <read_partition_table>
  if (part_nr == 0)
c002572e:	83 c4 10             	add    $0x10,%esp
c0025731:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0025736:	74 06                	je     c002573e <partition_scan+0x42>
}
c0025738:	83 c4 14             	add    $0x14,%esp
c002573b:	5b                   	pop    %ebx
c002573c:	5e                   	pop    %esi
c002573d:	c3                   	ret    
    printf ("%s: Device contains no partitions\n", block_name (block));
c002573e:	83 ec 0c             	sub    $0xc,%esp
c0025741:	56                   	push   %esi
c0025742:	e8 9f f9 ff ff       	call   c00250e6 <block_name>
c0025747:	83 c4 08             	add    $0x8,%esp
c002574a:	50                   	push   %eax
c002574b:	8d 83 c8 69 ff ff    	lea    -0x9638(%ebx),%eax
c0025751:	50                   	push   %eax
c0025752:	e8 a1 1a 00 00       	call   c00271f8 <printf>
c0025757:	83 c4 10             	add    $0x10,%esp
}
c002575a:	eb dc                	jmp    c0025738 <partition_scan+0x3c>

c002575c <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c002575c:	57                   	push   %edi
c002575d:	56                   	push   %esi
c002575e:	53                   	push   %ebx
c002575f:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025761:	83 fa 01             	cmp    $0x1,%edx
c0025764:	7e 1f                	jle    c0025785 <descramble_ata_string+0x29>
c0025766:	89 c1                	mov    %eax,%ecx
c0025768:	8d 5a fe             	lea    -0x2(%edx),%ebx
c002576b:	83 e3 fe             	and    $0xfffffffe,%ebx
c002576e:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
    {
      char tmp = string[i];
c0025772:	0f b6 19             	movzbl (%ecx),%ebx
      string[i] = string[i + 1];
c0025775:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c0025779:	88 11                	mov    %dl,(%ecx)
      string[i + 1] = tmp;
c002577b:	88 59 01             	mov    %bl,0x1(%ecx)
c002577e:	83 c1 02             	add    $0x2,%ecx
  for (i = 0; i + 1 < size; i += 2)
c0025781:	39 f1                	cmp    %esi,%ecx
c0025783:	75 ed                	jne    c0025772 <descramble_ata_string+0x16>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025785:	8d 57 ff             	lea    -0x1(%edi),%edx
c0025788:	85 d2                	test   %edx,%edx
c002578a:	7f 07                	jg     c0025793 <descramble_ata_string+0x37>
c002578c:	eb 17                	jmp    c00257a5 <descramble_ata_string+0x49>
c002578e:	83 ea 01             	sub    $0x1,%edx
c0025791:	74 12                	je     c00257a5 <descramble_ata_string+0x49>
    {
      int c = string[size - 1];
c0025793:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
      if (c != '\0' && !isspace (c))
c0025798:	f6 c1 df             	test   $0xdf,%cl
c002579b:	74 f1                	je     c002578e <descramble_ata_string+0x32>
          || c == '\r' || c == '\t' || c == '\v');
c002579d:	83 e9 09             	sub    $0x9,%ecx
c00257a0:	80 f9 04             	cmp    $0x4,%cl
c00257a3:	76 e9                	jbe    c002578e <descramble_ata_string+0x32>
        break; 
    }
  string[size] = '\0';
c00257a5:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c00257a9:	5b                   	pop    %ebx
c00257aa:	5e                   	pop    %esi
c00257ab:	5f                   	pop    %edi
c00257ac:	c3                   	ret    

c00257ad <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c00257ad:	53                   	push   %ebx
c00257ae:	83 ec 08             	sub    $0x8,%esp
c00257b1:	e8 85 81 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00257b6:	81 c3 16 3d 01 00    	add    $0x13d16,%ebx
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c00257bc:	8b 44 24 10          	mov    0x10(%esp),%eax
c00257c0:	8b 40 30             	mov    0x30(%eax),%eax
c00257c3:	0f b6 93 9e 20 00 00 	movzbl 0x209e(%ebx),%edx
c00257ca:	39 d0                	cmp    %edx,%eax
c00257cc:	74 30                	je     c00257fe <interrupt_handler+0x51>
c00257ce:	0f b6 93 0e 21 00 00 	movzbl 0x210e(%ebx),%edx
c00257d5:	8d 8b 04 21 00 00    	lea    0x2104(%ebx),%ecx
c00257db:	39 c2                	cmp    %eax,%edx
c00257dd:	74 25                	je     c0025804 <interrupt_handler+0x57>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c00257df:	8d 83 78 5a ff ff    	lea    -0xa588(%ebx),%eax
c00257e5:	50                   	push   %eax
c00257e6:	8d 83 94 49 ff ff    	lea    -0xb66c(%ebx),%eax
c00257ec:	50                   	push   %eax
c00257ed:	68 0c 02 00 00       	push   $0x20c
c00257f2:	8d 83 05 6a ff ff    	lea    -0x95fb(%ebx),%eax
c00257f8:	50                   	push   %eax
c00257f9:	e8 91 37 00 00       	call   c0028f8f <debug_panic>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00257fe:	8d 8b 94 20 00 00    	lea    0x2094(%ebx),%ecx
        if (c->expecting_interrupt) 
c0025804:	80 79 30 00          	cmpb   $0x0,0x30(%ecx)
c0025808:	74 1c                	je     c0025826 <interrupt_handler+0x79>
            inb (reg_status (c));               /* Acknowledge interrupt. */
c002580a:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c002580e:	8d 50 07             	lea    0x7(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025811:	ec                   	in     (%dx),%al
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0025812:	83 ec 0c             	sub    $0xc,%esp
c0025815:	83 c1 34             	add    $0x34,%ecx
c0025818:	51                   	push   %ecx
c0025819:	e8 19 d6 ff ff       	call   c0022e37 <sema_up>
c002581e:	83 c4 10             	add    $0x10,%esp
}
c0025821:	83 c4 08             	add    $0x8,%esp
c0025824:	5b                   	pop    %ebx
c0025825:	c3                   	ret    
          printf ("%s: unexpected interrupt\n", c->name);
c0025826:	83 ec 08             	sub    $0x8,%esp
c0025829:	51                   	push   %ecx
c002582a:	8d 83 eb 69 ff ff    	lea    -0x9615(%ebx),%eax
c0025830:	50                   	push   %eax
c0025831:	e8 c2 19 00 00       	call   c00271f8 <printf>
c0025836:	83 c4 10             	add    $0x10,%esp
c0025839:	eb e6                	jmp    c0025821 <interrupt_handler+0x74>

c002583b <wait_until_idle>:
{
c002583b:	57                   	push   %edi
c002583c:	56                   	push   %esi
c002583d:	53                   	push   %ebx
c002583e:	e8 f8 80 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025843:	81 c3 89 3c 01 00    	add    $0x13c89,%ebx
c0025849:	89 c7                	mov    %eax,%edi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002584b:	8b 40 08             	mov    0x8(%eax),%eax
c002584e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025852:	8d 50 07             	lea    0x7(%eax),%edx
c0025855:	ec                   	in     (%dx),%al
c0025856:	a8 88                	test   $0x88,%al
c0025858:	74 4a                	je     c00258a4 <wait_until_idle+0x69>
      timer_usleep (10);
c002585a:	83 ec 08             	sub    $0x8,%esp
c002585d:	6a 00                	push   $0x0
c002585f:	6a 0a                	push   $0xa
c0025861:	e8 84 ec ff ff       	call   c00244ea <timer_usleep>
c0025866:	83 c4 10             	add    $0x10,%esp
c0025869:	be e7 03 00 00       	mov    $0x3e7,%esi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002586e:	8b 47 08             	mov    0x8(%edi),%eax
c0025871:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025875:	8d 50 07             	lea    0x7(%eax),%edx
c0025878:	ec                   	in     (%dx),%al
c0025879:	a8 88                	test   $0x88,%al
c002587b:	74 27                	je     c00258a4 <wait_until_idle+0x69>
      timer_usleep (10);
c002587d:	83 ec 08             	sub    $0x8,%esp
c0025880:	6a 00                	push   $0x0
c0025882:	6a 0a                	push   $0xa
c0025884:	e8 61 ec ff ff       	call   c00244ea <timer_usleep>
  for (i = 0; i < 1000; i++) 
c0025889:	83 c4 10             	add    $0x10,%esp
c002588c:	83 ee 01             	sub    $0x1,%esi
c002588f:	75 dd                	jne    c002586e <wait_until_idle+0x33>
  printf ("%s: idle timeout\n", d->name);
c0025891:	83 ec 08             	sub    $0x8,%esp
c0025894:	57                   	push   %edi
c0025895:	8d 83 19 6a ff ff    	lea    -0x95e7(%ebx),%eax
c002589b:	50                   	push   %eax
c002589c:	e8 57 19 00 00       	call   c00271f8 <printf>
c00258a1:	83 c4 10             	add    $0x10,%esp
}
c00258a4:	5b                   	pop    %ebx
c00258a5:	5e                   	pop    %esi
c00258a6:	5f                   	pop    %edi
c00258a7:	c3                   	ret    

c00258a8 <select_device>:
{
c00258a8:	53                   	push   %ebx
c00258a9:	83 ec 10             	sub    $0x10,%esp
c00258ac:	e8 8a 80 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00258b1:	81 c3 1b 3c 01 00    	add    $0x13c1b,%ebx
  struct channel *c = d->channel;
c00258b7:	8b 50 08             	mov    0x8(%eax),%edx
  if (d->dev_no == 1)
c00258ba:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
    dev |= DEV_DEV;
c00258be:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c00258c3:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c00258c8:	0f 44 c1             	cmove  %ecx,%eax
  outb (reg_device (c), dev);
c00258cb:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c00258cf:	8d 51 06             	lea    0x6(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00258d2:	ee                   	out    %al,(%dx)
  inb (reg_alt_status (c));
c00258d3:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00258d9:	ec                   	in     (%dx),%al
  timer_nsleep (400);
c00258da:	6a 00                	push   $0x0
c00258dc:	68 90 01 00 00       	push   $0x190
c00258e1:	e8 1d ec ff ff       	call   c0024503 <timer_nsleep>
}
c00258e6:	83 c4 18             	add    $0x18,%esp
c00258e9:	5b                   	pop    %ebx
c00258ea:	c3                   	ret    

c00258eb <check_device_type>:
{
c00258eb:	55                   	push   %ebp
c00258ec:	57                   	push   %edi
c00258ed:	56                   	push   %esi
c00258ee:	53                   	push   %ebx
c00258ef:	83 ec 0c             	sub    $0xc,%esp
c00258f2:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c00258f4:	8b 58 08             	mov    0x8(%eax),%ebx
  select_device (d);
c00258f7:	e8 ac ff ff ff       	call   c00258a8 <select_device>
  error = inb (reg_error (c));
c00258fc:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0025900:	8d 51 01             	lea    0x1(%ecx),%edx
c0025903:	ec                   	in     (%dx),%al
c0025904:	89 c3                	mov    %eax,%ebx
  lbam = inb (reg_lbam (c));
c0025906:	8d 51 04             	lea    0x4(%ecx),%edx
c0025909:	ec                   	in     (%dx),%al
c002590a:	89 c5                	mov    %eax,%ebp
  lbah = inb (reg_lbah (c));
c002590c:	8d 51 05             	lea    0x5(%ecx),%edx
c002590f:	ec                   	in     (%dx),%al
c0025910:	89 c7                	mov    %eax,%edi
  status = inb (reg_status (c));
c0025912:	8d 51 07             	lea    0x7(%ecx),%edx
c0025915:	ec                   	in     (%dx),%al
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025916:	80 fb 01             	cmp    $0x1,%bl
c0025919:	74 1d                	je     c0025938 <check_device_type+0x4d>
c002591b:	80 fb 81             	cmp    $0x81,%bl
c002591e:	74 12                	je     c0025932 <check_device_type+0x47>
      d->is_ata = false;
c0025920:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return error != 0x81;      
c0025924:	80 fb 81             	cmp    $0x81,%bl
c0025927:	0f 95 c0             	setne  %al
}
c002592a:	83 c4 0c             	add    $0xc,%esp
c002592d:	5b                   	pop    %ebx
c002592e:	5e                   	pop    %esi
c002592f:	5f                   	pop    %edi
c0025930:	5d                   	pop    %ebp
c0025931:	c3                   	ret    
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025932:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0025936:	74 e8                	je     c0025920 <check_device_type+0x35>
      || (status & STA_DRDY) == 0
c0025938:	a8 40                	test   $0x40,%al
c002593a:	74 e4                	je     c0025920 <check_device_type+0x35>
      || (status & STA_BSY) != 0)
c002593c:	84 c0                	test   %al,%al
c002593e:	78 e0                	js     c0025920 <check_device_type+0x35>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025940:	b8 01 00 00 00       	mov    $0x1,%eax
c0025945:	89 f9                	mov    %edi,%ecx
c0025947:	89 eb                	mov    %ebp,%ebx
c0025949:	08 d9                	or     %bl,%cl
c002594b:	74 12                	je     c002595f <check_device_type+0x74>
c002594d:	80 fb 3c             	cmp    $0x3c,%bl
c0025950:	0f 94 c2             	sete   %dl
c0025953:	89 f8                	mov    %edi,%eax
c0025955:	3c c3                	cmp    $0xc3,%al
c0025957:	0f 94 c0             	sete   %al
c002595a:	0f b6 c0             	movzbl %al,%eax
c002595d:	21 d0                	and    %edx,%eax
c002595f:	88 46 10             	mov    %al,0x10(%esi)
c0025962:	80 66 10 01          	andb   $0x1,0x10(%esi)
      return true; 
c0025966:	b8 01 00 00 00       	mov    $0x1,%eax
c002596b:	eb bd                	jmp    c002592a <check_device_type+0x3f>

c002596d <select_sector>:
{
c002596d:	55                   	push   %ebp
c002596e:	57                   	push   %edi
c002596f:	56                   	push   %esi
c0025970:	53                   	push   %ebx
c0025971:	83 ec 0c             	sub    $0xc,%esp
c0025974:	e8 c2 7f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025979:	81 c3 53 3b 01 00    	add    $0x13b53,%ebx
  struct channel *c = d->channel;
c002597f:	8b 68 08             	mov    0x8(%eax),%ebp
  ASSERT (sec_no < (1UL << 28));
c0025982:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0025988:	77 5e                	ja     c00259e8 <select_sector+0x7b>
c002598a:	89 c7                	mov    %eax,%edi
c002598c:	89 d6                	mov    %edx,%esi
  wait_until_idle (d);
c002598e:	e8 a8 fe ff ff       	call   c002583b <wait_until_idle>
  select_device (d);
c0025993:	89 f8                	mov    %edi,%eax
c0025995:	e8 0e ff ff ff       	call   c00258a8 <select_device>
  wait_until_idle (d);
c002599a:	89 f8                	mov    %edi,%eax
c002599c:	e8 9a fe ff ff       	call   c002583b <wait_until_idle>
  outb (reg_nsect (c), 1);
c00259a1:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
c00259a5:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00259a8:	b8 01 00 00 00       	mov    $0x1,%eax
c00259ad:	ee                   	out    %al,(%dx)
  outb (reg_lbal (c), sec_no);
c00259ae:	8d 51 03             	lea    0x3(%ecx),%edx
c00259b1:	89 f0                	mov    %esi,%eax
c00259b3:	ee                   	out    %al,(%dx)
  outb (reg_lbam (c), sec_no >> 8);
c00259b4:	89 f0                	mov    %esi,%eax
c00259b6:	c1 e8 08             	shr    $0x8,%eax
c00259b9:	8d 51 04             	lea    0x4(%ecx),%edx
c00259bc:	ee                   	out    %al,(%dx)
  outb (reg_lbah (c), (sec_no >> 16));
c00259bd:	89 f0                	mov    %esi,%eax
c00259bf:	c1 e8 10             	shr    $0x10,%eax
c00259c2:	8d 51 05             	lea    0x5(%ecx),%edx
c00259c5:	ee                   	out    %al,(%dx)
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00259c6:	83 7f 0c 01          	cmpl   $0x1,0xc(%edi)
c00259ca:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c00259cf:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c00259d4:	0f 45 c2             	cmovne %edx,%eax
c00259d7:	c1 ee 18             	shr    $0x18,%esi
c00259da:	09 f0                	or     %esi,%eax
  outb (reg_device (c),
c00259dc:	8d 51 06             	lea    0x6(%ecx),%edx
c00259df:	ee                   	out    %al,(%dx)
}
c00259e0:	83 c4 0c             	add    $0xc,%esp
c00259e3:	5b                   	pop    %ebx
c00259e4:	5e                   	pop    %esi
c00259e5:	5f                   	pop    %edi
c00259e6:	5d                   	pop    %ebp
c00259e7:	c3                   	ret    
  ASSERT (sec_no < (1UL << 28));
c00259e8:	83 ec 0c             	sub    $0xc,%esp
c00259eb:	8d 83 2b 6a ff ff    	lea    -0x95d5(%ebx),%eax
c00259f1:	50                   	push   %eax
c00259f2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00259f8:	50                   	push   %eax
c00259f9:	8d 83 64 49 ff ff    	lea    -0xb69c(%ebx),%eax
c00259ff:	50                   	push   %eax
c0025a00:	68 89 01 00 00       	push   $0x189
c0025a05:	8d 83 05 6a ff ff    	lea    -0x95fb(%ebx),%eax
c0025a0b:	50                   	push   %eax
c0025a0c:	e8 7e 35 00 00       	call   c0028f8f <debug_panic>

c0025a11 <wait_while_busy>:
{
c0025a11:	55                   	push   %ebp
c0025a12:	57                   	push   %edi
c0025a13:	56                   	push   %esi
c0025a14:	53                   	push   %ebx
c0025a15:	83 ec 1c             	sub    $0x1c,%esp
c0025a18:	e8 1e 7f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025a1d:	81 c3 af 3a 01 00    	add    $0x13aaf,%ebx
c0025a23:	89 c5                	mov    %eax,%ebp
  struct channel *c = d->channel;
c0025a25:	8b 78 08             	mov    0x8(%eax),%edi
  for (i = 0; i < 3000; i++)
c0025a28:	be 00 00 00 00       	mov    $0x0,%esi
        printf ("%s: busy, waiting...", d->name);
c0025a2d:	8d 83 40 6a ff ff    	lea    -0x95c0(%ebx),%eax
c0025a33:	89 44 24 0c          	mov    %eax,0xc(%esp)
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0025a37:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025a3b:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a41:	ec                   	in     (%dx),%al
c0025a42:	84 c0                	test   %al,%al
c0025a44:	79 34                	jns    c0025a7a <wait_while_busy+0x69>
      timer_msleep (10);
c0025a46:	83 ec 08             	sub    $0x8,%esp
c0025a49:	6a 00                	push   $0x0
c0025a4b:	6a 0a                	push   $0xa
c0025a4d:	e8 7f ea ff ff       	call   c00244d1 <timer_msleep>
  for (i = 0; i < 3000; i++)
c0025a52:	83 c6 01             	add    $0x1,%esi
c0025a55:	83 c4 10             	add    $0x10,%esp
c0025a58:	81 fe b8 0b 00 00    	cmp    $0xbb8,%esi
c0025a5e:	74 4f                	je     c0025aaf <wait_while_busy+0x9e>
      if (i == 700)
c0025a60:	81 fe bc 02 00 00    	cmp    $0x2bc,%esi
c0025a66:	75 cf                	jne    c0025a37 <wait_while_busy+0x26>
        printf ("%s: busy, waiting...", d->name);
c0025a68:	83 ec 08             	sub    $0x8,%esp
c0025a6b:	55                   	push   %ebp
c0025a6c:	ff 74 24 18          	pushl  0x18(%esp)
c0025a70:	e8 83 17 00 00       	call   c00271f8 <printf>
c0025a75:	83 c4 10             	add    $0x10,%esp
c0025a78:	eb bd                	jmp    c0025a37 <wait_while_busy+0x26>
          if (i >= 700)
c0025a7a:	81 fe bb 02 00 00    	cmp    $0x2bb,%esi
c0025a80:	7f 19                	jg     c0025a9b <wait_while_busy+0x8a>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0025a82:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025a86:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025a8c:	ec                   	in     (%dx),%al
c0025a8d:	c0 e8 03             	shr    $0x3,%al
c0025a90:	83 e0 01             	and    $0x1,%eax
}
c0025a93:	83 c4 1c             	add    $0x1c,%esp
c0025a96:	5b                   	pop    %ebx
c0025a97:	5e                   	pop    %esi
c0025a98:	5f                   	pop    %edi
c0025a99:	5d                   	pop    %ebp
c0025a9a:	c3                   	ret    
            printf ("ok\n");
c0025a9b:	83 ec 0c             	sub    $0xc,%esp
c0025a9e:	8d 83 55 6a ff ff    	lea    -0x95ab(%ebx),%eax
c0025aa4:	50                   	push   %eax
c0025aa5:	e8 09 54 00 00       	call   c002aeb3 <puts>
c0025aaa:	83 c4 10             	add    $0x10,%esp
c0025aad:	eb d3                	jmp    c0025a82 <wait_while_busy+0x71>
  printf ("failed\n");
c0025aaf:	83 ec 0c             	sub    $0xc,%esp
c0025ab2:	8d 83 e8 72 ff ff    	lea    -0x8d18(%ebx),%eax
c0025ab8:	50                   	push   %eax
c0025ab9:	e8 f5 53 00 00       	call   c002aeb3 <puts>
  return false;
c0025abe:	83 c4 10             	add    $0x10,%esp
c0025ac1:	b8 00 00 00 00       	mov    $0x0,%eax
c0025ac6:	eb cb                	jmp    c0025a93 <wait_while_busy+0x82>

c0025ac8 <issue_pio_command>:
{
c0025ac8:	57                   	push   %edi
c0025ac9:	56                   	push   %esi
c0025aca:	53                   	push   %ebx
c0025acb:	e8 6b 7e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025ad0:	81 c3 fc 39 01 00    	add    $0x139fc,%ebx
c0025ad6:	89 c7                	mov    %eax,%edi
c0025ad8:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_ON);
c0025ada:	e8 15 c0 ff ff       	call   c0021af4 <intr_get_level>
c0025adf:	83 f8 01             	cmp    $0x1,%eax
c0025ae2:	75 12                	jne    c0025af6 <issue_pio_command+0x2e>
  c->expecting_interrupt = true;
c0025ae4:	c6 47 30 01          	movb   $0x1,0x30(%edi)
  outb (reg_command (c), command);
c0025ae8:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025aec:	83 c2 07             	add    $0x7,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025aef:	89 f0                	mov    %esi,%eax
c0025af1:	ee                   	out    %al,(%dx)
}
c0025af2:	5b                   	pop    %ebx
c0025af3:	5e                   	pop    %esi
c0025af4:	5f                   	pop    %edi
c0025af5:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c0025af6:	83 ec 0c             	sub    $0xc,%esp
c0025af9:	8d 83 62 61 ff ff    	lea    -0x9e9e(%ebx),%eax
c0025aff:	50                   	push   %eax
c0025b00:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0025b06:	50                   	push   %eax
c0025b07:	8d 83 44 49 ff ff    	lea    -0xb6bc(%ebx),%eax
c0025b0d:	50                   	push   %eax
c0025b0e:	68 9b 01 00 00       	push   $0x19b
c0025b13:	8d 83 05 6a ff ff    	lea    -0x95fb(%ebx),%eax
c0025b19:	50                   	push   %eax
c0025b1a:	e8 70 34 00 00       	call   c0028f8f <debug_panic>

c0025b1f <ide_write>:
{
c0025b1f:	55                   	push   %ebp
c0025b20:	57                   	push   %edi
c0025b21:	56                   	push   %esi
c0025b22:	53                   	push   %ebx
c0025b23:	83 ec 18             	sub    $0x18,%esp
c0025b26:	e8 10 7e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025b2b:	81 c3 a1 39 01 00    	add    $0x139a1,%ebx
c0025b31:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct channel *c = d->channel;
c0025b35:	8b 7e 08             	mov    0x8(%esi),%edi
  lock_acquire (&c->lock);
c0025b38:	8d 6f 0c             	lea    0xc(%edi),%ebp
c0025b3b:	55                   	push   %ebp
c0025b3c:	e8 fc d4 ff ff       	call   c002303d <lock_acquire>
  select_sector (d, sec_no);
c0025b41:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025b45:	89 f0                	mov    %esi,%eax
c0025b47:	e8 21 fe ff ff       	call   c002596d <select_sector>
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0025b4c:	ba 30 00 00 00       	mov    $0x30,%edx
c0025b51:	89 f8                	mov    %edi,%eax
c0025b53:	e8 70 ff ff ff       	call   c0025ac8 <issue_pio_command>
  if (!wait_while_busy (d))
c0025b58:	89 f0                	mov    %esi,%eax
c0025b5a:	e8 b2 fe ff ff       	call   c0025a11 <wait_while_busy>
c0025b5f:	83 c4 10             	add    $0x10,%esp
c0025b62:	84 c0                	test   %al,%al
c0025b64:	74 2c                	je     c0025b92 <ide_write+0x73>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025b66:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025b6a:	8b 74 24 28          	mov    0x28(%esp),%esi
c0025b6e:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025b73:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  sema_down (&c->completion_wait);
c0025b76:	83 ec 0c             	sub    $0xc,%esp
c0025b79:	83 c7 34             	add    $0x34,%edi
c0025b7c:	57                   	push   %edi
c0025b7d:	e8 8d d1 ff ff       	call   c0022d0f <sema_down>
  lock_release (&c->lock);
c0025b82:	89 2c 24             	mov    %ebp,(%esp)
c0025b85:	e8 ab d6 ff ff       	call   c0023235 <lock_release>
}
c0025b8a:	83 c4 1c             	add    $0x1c,%esp
c0025b8d:	5b                   	pop    %ebx
c0025b8e:	5e                   	pop    %esi
c0025b8f:	5f                   	pop    %edi
c0025b90:	5d                   	pop    %ebp
c0025b91:	c3                   	ret    
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0025b92:	83 ec 08             	sub    $0x8,%esp
c0025b95:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025b99:	56                   	push   %esi
c0025b9a:	8d 83 a4 6a ff ff    	lea    -0x955c(%ebx),%eax
c0025ba0:	50                   	push   %eax
c0025ba1:	8d 83 74 49 ff ff    	lea    -0xb68c(%ebx),%eax
c0025ba7:	50                   	push   %eax
c0025ba8:	68 75 01 00 00       	push   $0x175
c0025bad:	8d 83 05 6a ff ff    	lea    -0x95fb(%ebx),%eax
c0025bb3:	50                   	push   %eax
c0025bb4:	e8 d6 33 00 00       	call   c0028f8f <debug_panic>

c0025bb9 <identify_ata_device>:
{
c0025bb9:	55                   	push   %ebp
c0025bba:	57                   	push   %edi
c0025bbb:	56                   	push   %esi
c0025bbc:	53                   	push   %ebx
c0025bbd:	81 ec 8c 02 00 00    	sub    $0x28c,%esp
c0025bc3:	e8 73 7d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025bc8:	81 c3 04 39 01 00    	add    $0x13904,%ebx
  struct channel *c = d->channel;
c0025bce:	8b 78 08             	mov    0x8(%eax),%edi
  ASSERT (d->is_ata);
c0025bd1:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c0025bd5:	74 4a                	je     c0025c21 <identify_ata_device+0x68>
c0025bd7:	89 c6                	mov    %eax,%esi
  wait_until_idle (d);
c0025bd9:	e8 5d fc ff ff       	call   c002583b <wait_until_idle>
  select_device (d);
c0025bde:	89 f0                	mov    %esi,%eax
c0025be0:	e8 c3 fc ff ff       	call   c00258a8 <select_device>
  wait_until_idle (d);
c0025be5:	89 f0                	mov    %esi,%eax
c0025be7:	e8 4f fc ff ff       	call   c002583b <wait_until_idle>
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025bec:	ba ec 00 00 00       	mov    $0xec,%edx
c0025bf1:	89 f8                	mov    %edi,%eax
c0025bf3:	e8 d0 fe ff ff       	call   c0025ac8 <issue_pio_command>
  sema_down (&c->completion_wait);
c0025bf8:	83 ec 0c             	sub    $0xc,%esp
c0025bfb:	8d 47 34             	lea    0x34(%edi),%eax
c0025bfe:	50                   	push   %eax
c0025bff:	e8 0b d1 ff ff       	call   c0022d0f <sema_down>
  if (!wait_while_busy (d))
c0025c04:	89 f0                	mov    %esi,%eax
c0025c06:	e8 06 fe ff ff       	call   c0025a11 <wait_while_busy>
c0025c0b:	83 c4 10             	add    $0x10,%esp
c0025c0e:	84 c0                	test   %al,%al
c0025c10:	75 38                	jne    c0025c4a <identify_ata_device+0x91>
      d->is_ata = false;
c0025c12:	c6 46 10 00          	movb   $0x0,0x10(%esi)
}
c0025c16:	81 c4 8c 02 00 00    	add    $0x28c,%esp
c0025c1c:	5b                   	pop    %ebx
c0025c1d:	5e                   	pop    %esi
c0025c1e:	5f                   	pop    %edi
c0025c1f:	5d                   	pop    %ebp
c0025c20:	c3                   	ret    
  ASSERT (d->is_ata);
c0025c21:	83 ec 0c             	sub    $0xc,%esp
c0025c24:	8d 83 58 6a ff ff    	lea    -0x95a8(%ebx),%eax
c0025c2a:	50                   	push   %eax
c0025c2b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0025c31:	50                   	push   %eax
c0025c32:	8d 83 80 49 ff ff    	lea    -0xb680(%ebx),%eax
c0025c38:	50                   	push   %eax
c0025c39:	68 0d 01 00 00       	push   $0x10d
c0025c3e:	8d 83 05 6a ff ff    	lea    -0x95fb(%ebx),%eax
c0025c44:	50                   	push   %eax
c0025c45:	e8 45 33 00 00       	call   c0028f8f <debug_panic>
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025c4a:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025c4e:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025c55:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025c5a:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  capacity = *(uint32_t *) &id[60 * 2];
c0025c5d:	8b bc 24 f8 00 00 00 	mov    0xf8(%esp),%edi
  model = descramble_ata_string (&id[10 * 2], 20);
c0025c64:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025c6b:	ba 14 00 00 00       	mov    $0x14,%edx
c0025c70:	e8 e7 fa ff ff       	call   c002575c <descramble_ata_string>
c0025c75:	89 c5                	mov    %eax,%ebp
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025c77:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025c7e:	ba 28 00 00 00       	mov    $0x28,%edx
c0025c83:	e8 d4 fa ff ff       	call   c002575c <descramble_ata_string>
  snprintf (extra_info, sizeof extra_info,
c0025c88:	83 ec 0c             	sub    $0xc,%esp
c0025c8b:	50                   	push   %eax
c0025c8c:	55                   	push   %ebp
c0025c8d:	8d 83 62 6a ff ff    	lea    -0x959e(%ebx),%eax
c0025c93:	50                   	push   %eax
c0025c94:	68 80 00 00 00       	push   $0x80
c0025c99:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0025c9d:	50                   	push   %eax
c0025c9e:	e8 76 1e 00 00       	call   c0027b19 <snprintf>
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025ca3:	83 c4 20             	add    $0x20,%esp
c0025ca6:	81 ff ff ff 1f 00    	cmp    $0x1fffff,%edi
c0025cac:	76 3c                	jbe    c0025cea <identify_ata_device+0x131>
      printf ("%s: ignoring ", d->name);
c0025cae:	83 ec 08             	sub    $0x8,%esp
c0025cb1:	56                   	push   %esi
c0025cb2:	8d 83 7a 6a ff ff    	lea    -0x9586(%ebx),%eax
c0025cb8:	50                   	push   %eax
c0025cb9:	e8 3a 15 00 00       	call   c00271f8 <printf>
      print_human_readable_size (capacity * 512);
c0025cbe:	83 c4 08             	add    $0x8,%esp
c0025cc1:	c1 e7 09             	shl    $0x9,%edi
c0025cc4:	ba 00 00 00 00       	mov    $0x0,%edx
c0025cc9:	52                   	push   %edx
c0025cca:	57                   	push   %edi
c0025ccb:	e8 5a 20 00 00       	call   c0027d2a <print_human_readable_size>
      printf ("disk for safety\n");
c0025cd0:	8d 83 88 6a ff ff    	lea    -0x9578(%ebx),%eax
c0025cd6:	89 04 24             	mov    %eax,(%esp)
c0025cd9:	e8 d5 51 00 00       	call   c002aeb3 <puts>
      d->is_ata = false;
c0025cde:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return;
c0025ce2:	83 c4 10             	add    $0x10,%esp
c0025ce5:	e9 2c ff ff ff       	jmp    c0025c16 <identify_ata_device+0x5d>
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025cea:	83 ec 08             	sub    $0x8,%esp
c0025ced:	56                   	push   %esi
c0025cee:	8d 83 cc 05 00 00    	lea    0x5cc(%ebx),%eax
c0025cf4:	50                   	push   %eax
c0025cf5:	57                   	push   %edi
c0025cf6:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025cfa:	50                   	push   %eax
c0025cfb:	6a 04                	push   $0x4
c0025cfd:	56                   	push   %esi
c0025cfe:	e8 5c f4 ff ff       	call   c002515f <block_register>
  partition_scan (block);
c0025d03:	83 c4 14             	add    $0x14,%esp
c0025d06:	50                   	push   %eax
c0025d07:	e8 f0 f9 ff ff       	call   c00256fc <partition_scan>
c0025d0c:	83 c4 10             	add    $0x10,%esp
c0025d0f:	e9 02 ff ff ff       	jmp    c0025c16 <identify_ata_device+0x5d>

c0025d14 <ide_read>:
{
c0025d14:	55                   	push   %ebp
c0025d15:	57                   	push   %edi
c0025d16:	56                   	push   %esi
c0025d17:	53                   	push   %ebx
c0025d18:	83 ec 18             	sub    $0x18,%esp
c0025d1b:	e8 1b 7c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025d20:	81 c3 ac 37 01 00    	add    $0x137ac,%ebx
c0025d26:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  struct channel *c = d->channel;
c0025d2a:	8b 77 08             	mov    0x8(%edi),%esi
  lock_acquire (&c->lock);
c0025d2d:	8d 6e 0c             	lea    0xc(%esi),%ebp
c0025d30:	55                   	push   %ebp
c0025d31:	e8 07 d3 ff ff       	call   c002303d <lock_acquire>
  select_sector (d, sec_no);
c0025d36:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025d3a:	89 f8                	mov    %edi,%eax
c0025d3c:	e8 2c fc ff ff       	call   c002596d <select_sector>
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0025d41:	ba 20 00 00 00       	mov    $0x20,%edx
c0025d46:	89 f0                	mov    %esi,%eax
c0025d48:	e8 7b fd ff ff       	call   c0025ac8 <issue_pio_command>
  sema_down (&c->completion_wait);
c0025d4d:	8d 46 34             	lea    0x34(%esi),%eax
c0025d50:	89 04 24             	mov    %eax,(%esp)
c0025d53:	e8 b7 cf ff ff       	call   c0022d0f <sema_down>
  if (!wait_while_busy (d))
c0025d58:	89 f8                	mov    %edi,%eax
c0025d5a:	e8 b2 fc ff ff       	call   c0025a11 <wait_while_busy>
c0025d5f:	83 c4 10             	add    $0x10,%esp
c0025d62:	84 c0                	test   %al,%al
c0025d64:	74 21                	je     c0025d87 <ide_read+0x73>
c0025d66:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0025d6a:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0025d6e:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025d73:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  lock_release (&c->lock);
c0025d76:	83 ec 0c             	sub    $0xc,%esp
c0025d79:	55                   	push   %ebp
c0025d7a:	e8 b6 d4 ff ff       	call   c0023235 <lock_release>
}
c0025d7f:	83 c4 1c             	add    $0x1c,%esp
c0025d82:	5b                   	pop    %ebx
c0025d83:	5e                   	pop    %esi
c0025d84:	5f                   	pop    %edi
c0025d85:	5d                   	pop    %ebp
c0025d86:	c3                   	ret    
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025d87:	83 ec 08             	sub    $0x8,%esp
c0025d8a:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025d8e:	57                   	push   %edi
c0025d8f:	8d 83 c8 6a ff ff    	lea    -0x9538(%ebx),%eax
c0025d95:	50                   	push   %eax
c0025d96:	8d 83 58 49 ff ff    	lea    -0xb6a8(%ebx),%eax
c0025d9c:	50                   	push   %eax
c0025d9d:	68 62 01 00 00       	push   $0x162
c0025da2:	8d 83 05 6a ff ff    	lea    -0x95fb(%ebx),%eax
c0025da8:	50                   	push   %eax
c0025da9:	e8 e1 31 00 00       	call   c0028f8f <debug_panic>

c0025dae <ide_init>:
{
c0025dae:	55                   	push   %ebp
c0025daf:	57                   	push   %edi
c0025db0:	56                   	push   %esi
c0025db1:	53                   	push   %ebx
c0025db2:	83 ec 2c             	sub    $0x2c,%esp
c0025db5:	e8 81 7b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0025dba:	81 c3 12 37 01 00    	add    $0x13712,%ebx
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025dc0:	6a 00                	push   $0x0
c0025dc2:	8d 83 98 6a ff ff    	lea    -0x9568(%ebx),%eax
c0025dc8:	50                   	push   %eax
c0025dc9:	6a 08                	push   $0x8
c0025dcb:	8d b3 94 20 00 00    	lea    0x2094(%ebx),%esi
c0025dd1:	56                   	push   %esi
c0025dd2:	e8 42 1d 00 00       	call   c0027b19 <snprintf>
          c->reg_base = 0x1f0;
c0025dd7:	66 c7 83 9c 20 00 00 	movw   $0x1f0,0x209c(%ebx)
c0025dde:	f0 01 
          c->irq = 14 + 0x20;
c0025de0:	c6 83 9e 20 00 00 2e 	movb   $0x2e,0x209e(%ebx)
      lock_init (&c->lock);
c0025de7:	8d 83 a0 20 00 00    	lea    0x20a0(%ebx),%eax
c0025ded:	89 04 24             	mov    %eax,(%esp)
c0025df0:	e8 9c d1 ff ff       	call   c0022f91 <lock_init>
      c->expecting_interrupt = false;
c0025df5:	c6 83 c4 20 00 00 00 	movb   $0x0,0x20c4(%ebx)
      sema_init (&c->completion_wait, 0);
c0025dfc:	83 c4 08             	add    $0x8,%esp
c0025dff:	6a 00                	push   $0x0
c0025e01:	8d 83 c8 20 00 00    	lea    0x20c8(%ebx),%eax
c0025e07:	50                   	push   %eax
c0025e08:	e8 ae ce ff ff       	call   c0022cbb <sema_init>
          snprintf (d->name, sizeof d->name,
c0025e0d:	6a 61                	push   $0x61
c0025e0f:	8d bb 9f 6a ff ff    	lea    -0x9561(%ebx),%edi
c0025e15:	57                   	push   %edi
c0025e16:	6a 08                	push   $0x8
c0025e18:	8d ab dc 20 00 00    	lea    0x20dc(%ebx),%ebp
c0025e1e:	55                   	push   %ebp
c0025e1f:	e8 f5 1c 00 00       	call   c0027b19 <snprintf>
          d->channel = c;
c0025e24:	89 b3 e4 20 00 00    	mov    %esi,0x20e4(%ebx)
          d->dev_no = dev_no;
c0025e2a:	c7 83 e8 20 00 00 00 	movl   $0x0,0x20e8(%ebx)
c0025e31:	00 00 00 
          d->is_ata = false;
c0025e34:	c6 83 ec 20 00 00 00 	movb   $0x0,0x20ec(%ebx)
          snprintf (d->name, sizeof d->name,
c0025e3b:	83 c4 20             	add    $0x20,%esp
c0025e3e:	6a 62                	push   $0x62
c0025e40:	57                   	push   %edi
c0025e41:	6a 08                	push   $0x8
c0025e43:	8d 83 f0 20 00 00    	lea    0x20f0(%ebx),%eax
c0025e49:	50                   	push   %eax
c0025e4a:	e8 ca 1c 00 00       	call   c0027b19 <snprintf>
          d->channel = c;
c0025e4f:	89 b3 f8 20 00 00    	mov    %esi,0x20f8(%ebx)
          d->dev_no = dev_no;
c0025e55:	c7 83 fc 20 00 00 01 	movl   $0x1,0x20fc(%ebx)
c0025e5c:	00 00 00 
          d->is_ata = false;
c0025e5f:	c6 83 00 21 00 00 00 	movb   $0x0,0x2100(%ebx)
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025e66:	83 c4 0c             	add    $0xc,%esp
c0025e69:	56                   	push   %esi
c0025e6a:	8d 83 e1 c2 fe ff    	lea    -0x13d1f(%ebx),%eax
c0025e70:	50                   	push   %eax
c0025e71:	0f b6 83 9e 20 00 00 	movzbl 0x209e(%ebx),%eax
c0025e78:	50                   	push   %eax
c0025e79:	e8 a2 be ff ff       	call   c0021d20 <intr_register_ext>
      select_device (d);
c0025e7e:	89 e8                	mov    %ebp,%eax
c0025e80:	e8 23 fa ff ff       	call   c00258a8 <select_device>
      outb (reg_nsect (c), 0x55);
c0025e85:	0f b7 8b 9c 20 00 00 	movzwl 0x209c(%ebx),%ecx
c0025e8c:	8d 71 02             	lea    0x2(%ecx),%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025e8f:	bd 55 00 00 00       	mov    $0x55,%ebp
c0025e94:	89 e8                	mov    %ebp,%eax
c0025e96:	89 f2                	mov    %esi,%edx
c0025e98:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025e99:	83 c1 03             	add    $0x3,%ecx
c0025e9c:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c0025ea1:	89 f8                	mov    %edi,%eax
c0025ea3:	89 ca                	mov    %ecx,%edx
c0025ea5:	ee                   	out    %al,(%dx)
c0025ea6:	89 f2                	mov    %esi,%edx
c0025ea8:	ee                   	out    %al,(%dx)
c0025ea9:	89 e8                	mov    %ebp,%eax
c0025eab:	89 ca                	mov    %ecx,%edx
c0025ead:	ee                   	out    %al,(%dx)
c0025eae:	89 f2                	mov    %esi,%edx
c0025eb0:	ee                   	out    %al,(%dx)
c0025eb1:	89 f8                	mov    %edi,%eax
c0025eb3:	89 ca                	mov    %ecx,%edx
c0025eb5:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025eb6:	89 f2                	mov    %esi,%edx
c0025eb8:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025eb9:	83 c4 10             	add    $0x10,%esp
c0025ebc:	ba 00 00 00 00       	mov    $0x0,%edx
c0025ec1:	3c 55                	cmp    $0x55,%al
c0025ec3:	0f 84 cf 01 00 00    	je     c0026098 <ide_init+0x2ea>
c0025ec9:	89 d0                	mov    %edx,%eax
c0025ecb:	83 e0 01             	and    $0x1,%eax
c0025ece:	88 44 24 0c          	mov    %al,0xc(%esp)
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025ed2:	88 44 24 1e          	mov    %al,0x1e(%esp)
      select_device (d);
c0025ed6:	8d 83 f0 20 00 00    	lea    0x20f0(%ebx),%eax
c0025edc:	e8 c7 f9 ff ff       	call   c00258a8 <select_device>
      outb (reg_nsect (c), 0x55);
c0025ee1:	0f b7 ab 9c 20 00 00 	movzwl 0x209c(%ebx),%ebp
c0025ee8:	8d 4d 02             	lea    0x2(%ebp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025eeb:	b8 55 00 00 00       	mov    $0x55,%eax
c0025ef0:	89 ca                	mov    %ecx,%edx
c0025ef2:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0025ef3:	8d 75 03             	lea    0x3(%ebp),%esi
c0025ef6:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c0025efb:	89 f8                	mov    %edi,%eax
c0025efd:	89 f2                	mov    %esi,%edx
c0025eff:	ee                   	out    %al,(%dx)
c0025f00:	89 ca                	mov    %ecx,%edx
c0025f02:	ee                   	out    %al,(%dx)
c0025f03:	b8 55 00 00 00       	mov    $0x55,%eax
c0025f08:	89 f2                	mov    %esi,%edx
c0025f0a:	ee                   	out    %al,(%dx)
c0025f0b:	89 ca                	mov    %ecx,%edx
c0025f0d:	ee                   	out    %al,(%dx)
c0025f0e:	89 f8                	mov    %edi,%eax
c0025f10:	89 f2                	mov    %esi,%edx
c0025f12:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f13:	89 ca                	mov    %ecx,%edx
c0025f15:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0025f16:	ba 00 00 00 00       	mov    $0x0,%edx
c0025f1b:	3c 55                	cmp    $0x55,%al
c0025f1d:	0f 84 85 01 00 00    	je     c00260a8 <ide_init+0x2fa>
c0025f23:	89 d6                	mov    %edx,%esi
c0025f25:	83 e6 01             	and    $0x1,%esi
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025f28:	89 f0                	mov    %esi,%eax
c0025f2a:	88 44 24 1f          	mov    %al,0x1f(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f2e:	bf 00 00 00 00       	mov    $0x0,%edi
  outb (reg_ctl (c), 0);
c0025f33:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c0025f39:	89 f8                	mov    %edi,%eax
c0025f3b:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025f3c:	83 ec 08             	sub    $0x8,%esp
c0025f3f:	6a 00                	push   $0x0
c0025f41:	6a 0a                	push   $0xa
c0025f43:	e8 a2 e5 ff ff       	call   c00244ea <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c0025f48:	0f b7 93 9c 20 00 00 	movzwl 0x209c(%ebx),%edx
c0025f4f:	66 81 c2 06 02       	add    $0x206,%dx
c0025f54:	b8 04 00 00 00       	mov    $0x4,%eax
c0025f59:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0025f5a:	83 c4 08             	add    $0x8,%esp
c0025f5d:	6a 00                	push   $0x0
c0025f5f:	6a 0a                	push   $0xa
c0025f61:	e8 84 e5 ff ff       	call   c00244ea <timer_usleep>
  outb (reg_ctl (c), 0);
c0025f66:	0f b7 93 9c 20 00 00 	movzwl 0x209c(%ebx),%edx
c0025f6d:	66 81 c2 06 02       	add    $0x206,%dx
c0025f72:	89 f8                	mov    %edi,%eax
c0025f74:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c0025f75:	83 c4 08             	add    $0x8,%esp
c0025f78:	6a 00                	push   $0x0
c0025f7a:	68 96 00 00 00       	push   $0x96
c0025f7f:	e8 4d e5 ff ff       	call   c00244d1 <timer_msleep>
  if (present[0]) 
c0025f84:	83 c4 10             	add    $0x10,%esp
c0025f87:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%esp)
c0025f8c:	0f 85 26 01 00 00    	jne    c00260b8 <ide_init+0x30a>
  if (present[1])
c0025f92:	89 f0                	mov    %esi,%eax
c0025f94:	84 c0                	test   %al,%al
c0025f96:	0f 85 37 01 00 00    	jne    c00260d3 <ide_init+0x325>
      if (check_device_type (&c->devices[0]))
c0025f9c:	8d 83 dc 20 00 00    	lea    0x20dc(%ebx),%eax
c0025fa2:	e8 44 f9 ff ff       	call   c00258eb <check_device_type>
c0025fa7:	84 c0                	test   %al,%al
c0025fa9:	0f 85 71 01 00 00    	jne    c0026120 <ide_init+0x372>
        if (c->devices[dev_no].is_ata)
c0025faf:	80 bb ec 20 00 00 00 	cmpb   $0x0,0x20ec(%ebx)
c0025fb6:	0f 85 74 01 00 00    	jne    c0026130 <ide_init+0x382>
c0025fbc:	80 bb 00 21 00 00 00 	cmpb   $0x0,0x2100(%ebx)
c0025fc3:	0f 85 77 01 00 00    	jne    c0026140 <ide_init+0x392>
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025fc9:	6a 01                	push   $0x1
c0025fcb:	8d 83 98 6a ff ff    	lea    -0x9568(%ebx),%eax
c0025fd1:	50                   	push   %eax
c0025fd2:	6a 08                	push   $0x8
c0025fd4:	8d b3 04 21 00 00    	lea    0x2104(%ebx),%esi
c0025fda:	56                   	push   %esi
c0025fdb:	e8 39 1b 00 00       	call   c0027b19 <snprintf>
          c->reg_base = 0x170;
c0025fe0:	66 c7 83 0c 21 00 00 	movw   $0x170,0x210c(%ebx)
c0025fe7:	70 01 
          c->irq = 15 + 0x20;
c0025fe9:	c6 83 0e 21 00 00 2f 	movb   $0x2f,0x210e(%ebx)
      lock_init (&c->lock);
c0025ff0:	8d 83 10 21 00 00    	lea    0x2110(%ebx),%eax
c0025ff6:	89 04 24             	mov    %eax,(%esp)
c0025ff9:	e8 93 cf ff ff       	call   c0022f91 <lock_init>
      c->expecting_interrupt = false;
c0025ffe:	c6 83 34 21 00 00 00 	movb   $0x0,0x2134(%ebx)
      sema_init (&c->completion_wait, 0);
c0026005:	83 c4 08             	add    $0x8,%esp
c0026008:	6a 00                	push   $0x0
c002600a:	8d 83 38 21 00 00    	lea    0x2138(%ebx),%eax
c0026010:	50                   	push   %eax
c0026011:	e8 a5 cc ff ff       	call   c0022cbb <sema_init>
          snprintf (d->name, sizeof d->name,
c0026016:	6a 63                	push   $0x63
c0026018:	8d bb 9f 6a ff ff    	lea    -0x9561(%ebx),%edi
c002601e:	57                   	push   %edi
c002601f:	6a 08                	push   $0x8
c0026021:	8d ab 4c 21 00 00    	lea    0x214c(%ebx),%ebp
c0026027:	55                   	push   %ebp
c0026028:	e8 ec 1a 00 00       	call   c0027b19 <snprintf>
          d->channel = c;
c002602d:	89 b3 54 21 00 00    	mov    %esi,0x2154(%ebx)
          d->dev_no = dev_no;
c0026033:	c7 83 58 21 00 00 00 	movl   $0x0,0x2158(%ebx)
c002603a:	00 00 00 
          d->is_ata = false;
c002603d:	c6 83 5c 21 00 00 00 	movb   $0x0,0x215c(%ebx)
          snprintf (d->name, sizeof d->name,
c0026044:	83 c4 20             	add    $0x20,%esp
c0026047:	6a 64                	push   $0x64
c0026049:	57                   	push   %edi
c002604a:	6a 08                	push   $0x8
c002604c:	8d 83 60 21 00 00    	lea    0x2160(%ebx),%eax
c0026052:	50                   	push   %eax
c0026053:	e8 c1 1a 00 00       	call   c0027b19 <snprintf>
          d->channel = c;
c0026058:	89 b3 68 21 00 00    	mov    %esi,0x2168(%ebx)
          d->dev_no = dev_no;
c002605e:	c7 83 6c 21 00 00 01 	movl   $0x1,0x216c(%ebx)
c0026065:	00 00 00 
          d->is_ata = false;
c0026068:	c6 83 70 21 00 00 00 	movb   $0x0,0x2170(%ebx)
      intr_register_ext (c->irq, interrupt_handler, c->name);
c002606f:	83 c4 0c             	add    $0xc,%esp
c0026072:	56                   	push   %esi
c0026073:	8d 83 e1 c2 fe ff    	lea    -0x13d1f(%ebx),%eax
c0026079:	50                   	push   %eax
c002607a:	0f b6 83 0e 21 00 00 	movzbl 0x210e(%ebx),%eax
c0026081:	50                   	push   %eax
c0026082:	e8 99 bc ff ff       	call   c0021d20 <intr_register_ext>
c0026087:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c002608b:	83 c4 10             	add    $0x10,%esp
  for (dev_no = 0; dev_no < 2; dev_no++)
c002608e:	be 00 00 00 00       	mov    $0x0,%esi
c0026093:	e9 ce 00 00 00       	jmp    c0026166 <ide_init+0x3b8>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026098:	89 ca                	mov    %ecx,%edx
c002609a:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002609b:	3c aa                	cmp    $0xaa,%al
c002609d:	0f 94 c2             	sete   %dl
c00260a0:	0f b6 d2             	movzbl %dl,%edx
c00260a3:	e9 21 fe ff ff       	jmp    c0025ec9 <ide_init+0x11b>
c00260a8:	89 f2                	mov    %esi,%edx
c00260aa:	ec                   	in     (%dx),%al
c00260ab:	3c aa                	cmp    $0xaa,%al
c00260ad:	0f 94 c2             	sete   %dl
c00260b0:	0f b6 d2             	movzbl %dl,%edx
c00260b3:	e9 6b fe ff ff       	jmp    c0025f23 <ide_init+0x175>
      select_device (&c->devices[0]);
c00260b8:	8d 83 dc 20 00 00    	lea    0x20dc(%ebx),%eax
c00260be:	e8 e5 f7 ff ff       	call   c00258a8 <select_device>
      wait_while_busy (&c->devices[0]); 
c00260c3:	8d 83 dc 20 00 00    	lea    0x20dc(%ebx),%eax
c00260c9:	e8 43 f9 ff ff       	call   c0025a11 <wait_while_busy>
c00260ce:	e9 bf fe ff ff       	jmp    c0025f92 <ide_init+0x1e4>
      select_device (&c->devices[1]);
c00260d3:	8d 83 f0 20 00 00    	lea    0x20f0(%ebx),%eax
c00260d9:	e8 ca f7 ff ff       	call   c00258a8 <select_device>
c00260de:	be b8 0b 00 00       	mov    $0xbb8,%esi
c00260e3:	eb 14                	jmp    c00260f9 <ide_init+0x34b>
          timer_msleep (10);
c00260e5:	83 ec 08             	sub    $0x8,%esp
c00260e8:	6a 00                	push   $0x0
c00260ea:	6a 0a                	push   $0xa
c00260ec:	e8 e0 e3 ff ff       	call   c00244d1 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c00260f1:	83 c4 10             	add    $0x10,%esp
c00260f4:	83 ee 01             	sub    $0x1,%esi
c00260f7:	74 17                	je     c0026110 <ide_init+0x362>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c00260f9:	0f b7 8b 9c 20 00 00 	movzwl 0x209c(%ebx),%ecx
c0026100:	8d 51 02             	lea    0x2(%ecx),%edx
c0026103:	ec                   	in     (%dx),%al
c0026104:	3c 01                	cmp    $0x1,%al
c0026106:	75 dd                	jne    c00260e5 <ide_init+0x337>
c0026108:	8d 51 03             	lea    0x3(%ecx),%edx
c002610b:	ec                   	in     (%dx),%al
c002610c:	3c 01                	cmp    $0x1,%al
c002610e:	75 d5                	jne    c00260e5 <ide_init+0x337>
      wait_while_busy (&c->devices[1]);
c0026110:	8d 83 f0 20 00 00    	lea    0x20f0(%ebx),%eax
c0026116:	e8 f6 f8 ff ff       	call   c0025a11 <wait_while_busy>
c002611b:	e9 7c fe ff ff       	jmp    c0025f9c <ide_init+0x1ee>
        check_device_type (&c->devices[1]);
c0026120:	8d 83 f0 20 00 00    	lea    0x20f0(%ebx),%eax
c0026126:	e8 c0 f7 ff ff       	call   c00258eb <check_device_type>
c002612b:	e9 7f fe ff ff       	jmp    c0025faf <ide_init+0x201>
          identify_ata_device (&c->devices[dev_no]);
c0026130:	8d 83 dc 20 00 00    	lea    0x20dc(%ebx),%eax
c0026136:	e8 7e fa ff ff       	call   c0025bb9 <identify_ata_device>
c002613b:	e9 7c fe ff ff       	jmp    c0025fbc <ide_init+0x20e>
c0026140:	8d 83 f0 20 00 00    	lea    0x20f0(%ebx),%eax
c0026146:	e8 6e fa ff ff       	call   c0025bb9 <identify_ata_device>
c002614b:	e9 79 fe ff ff       	jmp    c0025fc9 <ide_init+0x21b>
                         && inb (reg_lbal (c)) == 0xaa);
c0026150:	88 54 34 1e          	mov    %dl,0x1e(%esp,%esi,1)
c0026154:	80 64 34 1e 01       	andb   $0x1,0x1e(%esp,%esi,1)
  for (dev_no = 0; dev_no < 2; dev_no++)
c0026159:	83 c6 01             	add    $0x1,%esi
c002615c:	83 44 24 0c 14       	addl   $0x14,0xc(%esp)
c0026161:	83 fe 02             	cmp    $0x2,%esi
c0026164:	74 55                	je     c00261bb <ide_init+0x40d>
      select_device (d);
c0026166:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002616a:	e8 39 f7 ff ff       	call   c00258a8 <select_device>
      outb (reg_nsect (c), 0x55);
c002616f:	0f b7 ab 0c 21 00 00 	movzwl 0x210c(%ebx),%ebp
c0026176:	8d 4d 02             	lea    0x2(%ebp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026179:	b8 55 00 00 00       	mov    $0x55,%eax
c002617e:	89 ca                	mov    %ecx,%edx
c0026180:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0026181:	8d 7d 03             	lea    0x3(%ebp),%edi
c0026184:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c0026189:	89 fa                	mov    %edi,%edx
c002618b:	ee                   	out    %al,(%dx)
c002618c:	89 ca                	mov    %ecx,%edx
c002618e:	ee                   	out    %al,(%dx)
c002618f:	b8 55 00 00 00       	mov    $0x55,%eax
c0026194:	89 fa                	mov    %edi,%edx
c0026196:	ee                   	out    %al,(%dx)
c0026197:	89 ca                	mov    %ecx,%edx
c0026199:	ee                   	out    %al,(%dx)
c002619a:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c002619f:	89 fa                	mov    %edi,%edx
c00261a1:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00261a2:	89 ca                	mov    %ecx,%edx
c00261a4:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c00261a5:	ba 00 00 00 00       	mov    $0x0,%edx
c00261aa:	3c 55                	cmp    $0x55,%al
c00261ac:	75 a2                	jne    c0026150 <ide_init+0x3a2>
c00261ae:	89 fa                	mov    %edi,%edx
c00261b0:	ec                   	in     (%dx),%al
c00261b1:	3c aa                	cmp    $0xaa,%al
c00261b3:	0f 94 c2             	sete   %dl
c00261b6:	0f b6 d2             	movzbl %dl,%edx
c00261b9:	eb 95                	jmp    c0026150 <ide_init+0x3a2>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00261bb:	be 00 00 00 00       	mov    $0x0,%esi
  outb (reg_ctl (c), 0);
c00261c0:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c00261c6:	89 f0                	mov    %esi,%eax
c00261c8:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00261c9:	83 ec 08             	sub    $0x8,%esp
c00261cc:	6a 00                	push   $0x0
c00261ce:	6a 0a                	push   $0xa
c00261d0:	e8 15 e3 ff ff       	call   c00244ea <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c00261d5:	0f b7 93 0c 21 00 00 	movzwl 0x210c(%ebx),%edx
c00261dc:	66 81 c2 06 02       	add    $0x206,%dx
c00261e1:	b8 04 00 00 00       	mov    $0x4,%eax
c00261e6:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00261e7:	83 c4 08             	add    $0x8,%esp
c00261ea:	6a 00                	push   $0x0
c00261ec:	6a 0a                	push   $0xa
c00261ee:	e8 f7 e2 ff ff       	call   c00244ea <timer_usleep>
  outb (reg_ctl (c), 0);
c00261f3:	0f b7 93 0c 21 00 00 	movzwl 0x210c(%ebx),%edx
c00261fa:	66 81 c2 06 02       	add    $0x206,%dx
c00261ff:	89 f0                	mov    %esi,%eax
c0026201:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c0026202:	83 c4 08             	add    $0x8,%esp
c0026205:	6a 00                	push   $0x0
c0026207:	68 96 00 00 00       	push   $0x96
c002620c:	e8 c0 e2 ff ff       	call   c00244d1 <timer_msleep>
  if (present[0]) 
c0026211:	83 c4 10             	add    $0x10,%esp
c0026214:	80 7c 24 1e 00       	cmpb   $0x0,0x1e(%esp)
c0026219:	75 38                	jne    c0026253 <ide_init+0x4a5>
  if (present[1])
c002621b:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026220:	75 49                	jne    c002626b <ide_init+0x4bd>
      if (check_device_type (&c->devices[0]))
c0026222:	8d 83 4c 21 00 00    	lea    0x214c(%ebx),%eax
c0026228:	e8 be f6 ff ff       	call   c00258eb <check_device_type>
c002622d:	84 c0                	test   %al,%al
c002622f:	0f 85 83 00 00 00    	jne    c00262b8 <ide_init+0x50a>
        if (c->devices[dev_no].is_ata)
c0026235:	80 bb 5c 21 00 00 00 	cmpb   $0x0,0x215c(%ebx)
c002623c:	0f 85 96 00 00 00    	jne    c00262d8 <ide_init+0x52a>
c0026242:	80 bb 70 21 00 00 00 	cmpb   $0x0,0x2170(%ebx)
c0026249:	75 7d                	jne    c00262c8 <ide_init+0x51a>
}
c002624b:	83 c4 2c             	add    $0x2c,%esp
c002624e:	5b                   	pop    %ebx
c002624f:	5e                   	pop    %esi
c0026250:	5f                   	pop    %edi
c0026251:	5d                   	pop    %ebp
c0026252:	c3                   	ret    
      select_device (&c->devices[0]);
c0026253:	8d 83 4c 21 00 00    	lea    0x214c(%ebx),%eax
c0026259:	e8 4a f6 ff ff       	call   c00258a8 <select_device>
      wait_while_busy (&c->devices[0]); 
c002625e:	8d 83 4c 21 00 00    	lea    0x214c(%ebx),%eax
c0026264:	e8 a8 f7 ff ff       	call   c0025a11 <wait_while_busy>
c0026269:	eb b0                	jmp    c002621b <ide_init+0x46d>
      select_device (&c->devices[1]);
c002626b:	8d 83 60 21 00 00    	lea    0x2160(%ebx),%eax
c0026271:	e8 32 f6 ff ff       	call   c00258a8 <select_device>
c0026276:	be b8 0b 00 00       	mov    $0xbb8,%esi
c002627b:	eb 14                	jmp    c0026291 <ide_init+0x4e3>
          timer_msleep (10);
c002627d:	83 ec 08             	sub    $0x8,%esp
c0026280:	6a 00                	push   $0x0
c0026282:	6a 0a                	push   $0xa
c0026284:	e8 48 e2 ff ff       	call   c00244d1 <timer_msleep>
      for (i = 0; i < 3000; i++) 
c0026289:	83 c4 10             	add    $0x10,%esp
c002628c:	83 ee 01             	sub    $0x1,%esi
c002628f:	74 17                	je     c00262a8 <ide_init+0x4fa>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0026291:	0f b7 8b 0c 21 00 00 	movzwl 0x210c(%ebx),%ecx
c0026298:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002629b:	ec                   	in     (%dx),%al
c002629c:	3c 01                	cmp    $0x1,%al
c002629e:	75 dd                	jne    c002627d <ide_init+0x4cf>
c00262a0:	8d 51 03             	lea    0x3(%ecx),%edx
c00262a3:	ec                   	in     (%dx),%al
c00262a4:	3c 01                	cmp    $0x1,%al
c00262a6:	75 d5                	jne    c002627d <ide_init+0x4cf>
      wait_while_busy (&c->devices[1]);
c00262a8:	8d 83 60 21 00 00    	lea    0x2160(%ebx),%eax
c00262ae:	e8 5e f7 ff ff       	call   c0025a11 <wait_while_busy>
c00262b3:	e9 6a ff ff ff       	jmp    c0026222 <ide_init+0x474>
        check_device_type (&c->devices[1]);
c00262b8:	8d 83 60 21 00 00    	lea    0x2160(%ebx),%eax
c00262be:	e8 28 f6 ff ff       	call   c00258eb <check_device_type>
c00262c3:	e9 6d ff ff ff       	jmp    c0026235 <ide_init+0x487>
          identify_ata_device (&c->devices[dev_no]);
c00262c8:	8d 83 60 21 00 00    	lea    0x2160(%ebx),%eax
c00262ce:	e8 e6 f8 ff ff       	call   c0025bb9 <identify_ata_device>
}
c00262d3:	e9 73 ff ff ff       	jmp    c002624b <ide_init+0x49d>
          identify_ata_device (&c->devices[dev_no]);
c00262d8:	8d 83 4c 21 00 00    	lea    0x214c(%ebx),%eax
c00262de:	e8 d6 f8 ff ff       	call   c0025bb9 <identify_ata_device>
c00262e3:	e9 5a ff ff ff       	jmp    c0026242 <ide_init+0x494>

c00262e8 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c00262e8:	53                   	push   %ebx
c00262e9:	83 ec 14             	sub    $0x14,%esp
c00262ec:	e8 4a 76 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00262f1:	81 c3 db 31 01 00    	add    $0x131db,%ebx
  intq_init (&buffer);
c00262f7:	8d 83 74 21 00 00    	lea    0x2174(%ebx),%eax
c00262fd:	50                   	push   %eax
c00262fe:	e8 32 01 00 00       	call   c0026435 <intq_init>
}
c0026303:	83 c4 18             	add    $0x18,%esp
c0026306:	5b                   	pop    %ebx
c0026307:	c3                   	ret    

c0026308 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0026308:	56                   	push   %esi
c0026309:	53                   	push   %ebx
c002630a:	83 ec 04             	sub    $0x4,%esp
c002630d:	e8 29 76 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026312:	81 c3 ba 31 01 00    	add    $0x131ba,%ebx
c0026318:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c002631c:	e8 d3 b7 ff ff       	call   c0021af4 <intr_get_level>
c0026321:	85 c0                	test   %eax,%eax
c0026323:	75 36                	jne    c002635b <input_putc+0x53>
  ASSERT (!intq_full (&buffer));
c0026325:	83 ec 0c             	sub    $0xc,%esp
c0026328:	8d 83 74 21 00 00    	lea    0x2174(%ebx),%eax
c002632e:	50                   	push   %eax
c002632f:	e8 8f 01 00 00       	call   c00264c3 <intq_full>
c0026334:	83 c4 10             	add    $0x10,%esp
c0026337:	84 c0                	test   %al,%al
c0026339:	75 46                	jne    c0026381 <input_putc+0x79>

  intq_putc (&buffer, key);
c002633b:	83 ec 08             	sub    $0x8,%esp
c002633e:	89 f0                	mov    %esi,%eax
c0026340:	0f b6 f0             	movzbl %al,%esi
c0026343:	56                   	push   %esi
c0026344:	8d 83 74 21 00 00    	lea    0x2174(%ebx),%eax
c002634a:	50                   	push   %eax
c002634b:	e8 2f 04 00 00       	call   c002677f <intq_putc>
  serial_notify ();
c0026350:	e8 88 ea ff ff       	call   c0024ddd <serial_notify>
}
c0026355:	83 c4 14             	add    $0x14,%esp
c0026358:	5b                   	pop    %ebx
c0026359:	5e                   	pop    %esi
c002635a:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c002635b:	83 ec 0c             	sub    $0xc,%esp
c002635e:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0026364:	50                   	push   %eax
c0026365:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002636b:	50                   	push   %eax
c002636c:	8d 83 b4 49 ff ff    	lea    -0xb64c(%ebx),%eax
c0026372:	50                   	push   %eax
c0026373:	6a 15                	push   $0x15
c0026375:	8d 83 e8 6a ff ff    	lea    -0x9518(%ebx),%eax
c002637b:	50                   	push   %eax
c002637c:	e8 0e 2c 00 00       	call   c0028f8f <debug_panic>
  ASSERT (!intq_full (&buffer));
c0026381:	83 ec 0c             	sub    $0xc,%esp
c0026384:	8d 83 fe 6a ff ff    	lea    -0x9502(%ebx),%eax
c002638a:	50                   	push   %eax
c002638b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0026391:	50                   	push   %eax
c0026392:	8d 83 b4 49 ff ff    	lea    -0xb64c(%ebx),%eax
c0026398:	50                   	push   %eax
c0026399:	6a 16                	push   $0x16
c002639b:	8d 83 e8 6a ff ff    	lea    -0x9518(%ebx),%eax
c00263a1:	50                   	push   %eax
c00263a2:	e8 e8 2b 00 00       	call   c0028f8f <debug_panic>

c00263a7 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c00263a7:	57                   	push   %edi
c00263a8:	56                   	push   %esi
c00263a9:	53                   	push   %ebx
c00263aa:	e8 8c 75 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00263af:	81 c3 1d 31 01 00    	add    $0x1311d,%ebx
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c00263b5:	e8 8c b7 ff ff       	call   c0021b46 <intr_disable>
c00263ba:	89 c7                	mov    %eax,%edi
  key = intq_getc (&buffer);
c00263bc:	83 ec 0c             	sub    $0xc,%esp
c00263bf:	8d 83 74 21 00 00    	lea    0x2174(%ebx),%eax
c00263c5:	50                   	push   %eax
c00263c6:	e8 e9 02 00 00       	call   c00266b4 <intq_getc>
c00263cb:	89 c6                	mov    %eax,%esi
  serial_notify ();
c00263cd:	e8 0b ea ff ff       	call   c0024ddd <serial_notify>
  intr_set_level (old_level);
c00263d2:	89 3c 24             	mov    %edi,(%esp)
c00263d5:	e8 73 b7 ff ff       	call   c0021b4d <intr_set_level>
  
  return key;
c00263da:	83 c4 10             	add    $0x10,%esp
}
c00263dd:	89 f0                	mov    %esi,%eax
c00263df:	5b                   	pop    %ebx
c00263e0:	5e                   	pop    %esi
c00263e1:	5f                   	pop    %edi
c00263e2:	c3                   	ret    

c00263e3 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c00263e3:	53                   	push   %ebx
c00263e4:	83 ec 08             	sub    $0x8,%esp
c00263e7:	e8 4f 75 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00263ec:	81 c3 e0 30 01 00    	add    $0x130e0,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00263f2:	e8 fd b6 ff ff       	call   c0021af4 <intr_get_level>
c00263f7:	85 c0                	test   %eax,%eax
c00263f9:	75 14                	jne    c002640f <input_full+0x2c>
  return intq_full (&buffer);
c00263fb:	83 ec 0c             	sub    $0xc,%esp
c00263fe:	8d 83 74 21 00 00    	lea    0x2174(%ebx),%eax
c0026404:	50                   	push   %eax
c0026405:	e8 b9 00 00 00       	call   c00264c3 <intq_full>
}
c002640a:	83 c4 18             	add    $0x18,%esp
c002640d:	5b                   	pop    %ebx
c002640e:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c002640f:	83 ec 0c             	sub    $0xc,%esp
c0026412:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0026418:	50                   	push   %eax
c0026419:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002641f:	50                   	push   %eax
c0026420:	8d 83 a8 49 ff ff    	lea    -0xb658(%ebx),%eax
c0026426:	50                   	push   %eax
c0026427:	6a 32                	push   $0x32
c0026429:	8d 83 e8 6a ff ff    	lea    -0x9518(%ebx),%eax
c002642f:	50                   	push   %eax
c0026430:	e8 5a 2b 00 00       	call   c0028f8f <debug_panic>

c0026435 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0026435:	56                   	push   %esi
c0026436:	53                   	push   %ebx
c0026437:	83 ec 10             	sub    $0x10,%esp
c002643a:	e8 fc 74 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002643f:	81 c3 8d 30 01 00    	add    $0x1308d,%ebx
c0026445:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_init (&q->lock);
c0026449:	56                   	push   %esi
c002644a:	e8 42 cb ff ff       	call   c0022f91 <lock_init>
  q->not_full = q->not_empty = NULL;
c002644f:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c0026456:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
  q->head = q->tail = 0;
c002645d:	c7 46 70 00 00 00 00 	movl   $0x0,0x70(%esi)
c0026464:	c7 46 6c 00 00 00 00 	movl   $0x0,0x6c(%esi)
}
c002646b:	83 c4 14             	add    $0x14,%esp
c002646e:	5b                   	pop    %ebx
c002646f:	5e                   	pop    %esi
c0026470:	c3                   	ret    

c0026471 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0026471:	56                   	push   %esi
c0026472:	53                   	push   %ebx
c0026473:	83 ec 04             	sub    $0x4,%esp
c0026476:	e8 c0 74 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002647b:	81 c3 51 30 01 00    	add    $0x13051,%ebx
c0026481:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0026485:	e8 6a b6 ff ff       	call   c0021af4 <intr_get_level>
c002648a:	85 c0                	test   %eax,%eax
c002648c:	75 0f                	jne    c002649d <intq_empty+0x2c>
  return q->head == q->tail;
c002648e:	8b 46 70             	mov    0x70(%esi),%eax
c0026491:	39 46 6c             	cmp    %eax,0x6c(%esi)
c0026494:	0f 94 c0             	sete   %al
}
c0026497:	83 c4 04             	add    $0x4,%esp
c002649a:	5b                   	pop    %ebx
c002649b:	5e                   	pop    %esi
c002649c:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c002649d:	83 ec 0c             	sub    $0xc,%esp
c00264a0:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c00264a6:	50                   	push   %eax
c00264a7:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00264ad:	50                   	push   %eax
c00264ae:	8d 83 f4 49 ff ff    	lea    -0xb60c(%ebx),%eax
c00264b4:	50                   	push   %eax
c00264b5:	6a 16                	push   $0x16
c00264b7:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c00264bd:	50                   	push   %eax
c00264be:	e8 cc 2a 00 00       	call   c0028f8f <debug_panic>

c00264c3 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c00264c3:	56                   	push   %esi
c00264c4:	53                   	push   %ebx
c00264c5:	83 ec 04             	sub    $0x4,%esp
c00264c8:	e8 6e 74 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00264cd:	81 c3 ff 2f 01 00    	add    $0x12fff,%ebx
c00264d3:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c00264d7:	e8 18 b6 ff ff       	call   c0021af4 <intr_get_level>
c00264dc:	85 c0                	test   %eax,%eax
c00264de:	75 1d                	jne    c00264fd <intq_full+0x3a>

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
  return (pos + 1) % INTQ_BUFSIZE;
c00264e0:	8b 46 6c             	mov    0x6c(%esi),%eax
c00264e3:	83 c0 01             	add    $0x1,%eax
c00264e6:	99                   	cltd   
c00264e7:	c1 ea 1a             	shr    $0x1a,%edx
c00264ea:	01 d0                	add    %edx,%eax
c00264ec:	83 e0 3f             	and    $0x3f,%eax
c00264ef:	29 d0                	sub    %edx,%eax
  return next (q->head) == q->tail;
c00264f1:	3b 46 70             	cmp    0x70(%esi),%eax
c00264f4:	0f 94 c0             	sete   %al
}
c00264f7:	83 c4 04             	add    $0x4,%esp
c00264fa:	5b                   	pop    %ebx
c00264fb:	5e                   	pop    %esi
c00264fc:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00264fd:	83 ec 0c             	sub    $0xc,%esp
c0026500:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0026506:	50                   	push   %eax
c0026507:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002650d:	50                   	push   %eax
c002650e:	8d 83 e8 49 ff ff    	lea    -0xb618(%ebx),%eax
c0026514:	50                   	push   %eax
c0026515:	6a 1e                	push   $0x1e
c0026517:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c002651d:	50                   	push   %eax
c002651e:	e8 6c 2a 00 00       	call   c0028f8f <debug_panic>

c0026523 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0026523:	57                   	push   %edi
c0026524:	56                   	push   %esi
c0026525:	53                   	push   %ebx
c0026526:	e8 10 74 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002652b:	81 c3 a1 2f 01 00    	add    $0x12fa1,%ebx
c0026531:	89 c6                	mov    %eax,%esi
c0026533:	89 d7                	mov    %edx,%edi
  ASSERT (!intr_context ());
c0026535:	e8 b0 b8 ff ff       	call   c0021dea <intr_context>
c002653a:	84 c0                	test   %al,%al
c002653c:	75 3b                	jne    c0026579 <wait+0x56>
  ASSERT (intr_get_level () == INTR_OFF);
c002653e:	e8 b1 b5 ff ff       	call   c0021af4 <intr_get_level>
c0026543:	85 c0                	test   %eax,%eax
c0026545:	75 58                	jne    c002659f <wait+0x7c>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0026547:	8d 46 28             	lea    0x28(%esi),%eax
c002654a:	39 c7                	cmp    %eax,%edi
c002654c:	74 77                	je     c00265c5 <wait+0xa2>
c002654e:	8d 46 24             	lea    0x24(%esi),%eax
c0026551:	39 c7                	cmp    %eax,%edi
c0026553:	0f 85 82 00 00 00    	jne    c00265db <wait+0xb8>
c0026559:	83 ec 0c             	sub    $0xc,%esp
c002655c:	56                   	push   %esi
c002655d:	e8 61 ff ff ff       	call   c00264c3 <intq_full>
c0026562:	83 c4 10             	add    $0x10,%esp
c0026565:	84 c0                	test   %al,%al
c0026567:	74 72                	je     c00265db <wait+0xb8>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0026569:	e8 15 a6 ff ff       	call   c0020b83 <thread_current>
c002656e:	89 07                	mov    %eax,(%edi)
  thread_block ();
c0026570:	e8 bd a9 ff ff       	call   c0020f32 <thread_block>
}
c0026575:	5b                   	pop    %ebx
c0026576:	5e                   	pop    %esi
c0026577:	5f                   	pop    %edi
c0026578:	c3                   	ret    
  ASSERT (!intr_context ());
c0026579:	83 ec 0c             	sub    $0xc,%esp
c002657c:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0026582:	50                   	push   %eax
c0026583:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0026589:	50                   	push   %eax
c002658a:	8d 83 d4 49 ff ff    	lea    -0xb62c(%ebx),%eax
c0026590:	50                   	push   %eax
c0026591:	6a 59                	push   $0x59
c0026593:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c0026599:	50                   	push   %eax
c002659a:	e8 f0 29 00 00       	call   c0028f8f <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c002659f:	83 ec 0c             	sub    $0xc,%esp
c00265a2:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c00265a8:	50                   	push   %eax
c00265a9:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00265af:	50                   	push   %eax
c00265b0:	8d 83 d4 49 ff ff    	lea    -0xb62c(%ebx),%eax
c00265b6:	50                   	push   %eax
c00265b7:	6a 5a                	push   $0x5a
c00265b9:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c00265bf:	50                   	push   %eax
c00265c0:	e8 ca 29 00 00       	call   c0028f8f <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00265c5:	83 ec 0c             	sub    $0xc,%esp
c00265c8:	56                   	push   %esi
c00265c9:	e8 a3 fe ff ff       	call   c0026471 <intq_empty>
c00265ce:	83 c4 10             	add    $0x10,%esp
c00265d1:	84 c0                	test   %al,%al
c00265d3:	0f 84 75 ff ff ff    	je     c002654e <wait+0x2b>
c00265d9:	eb 8e                	jmp    c0026569 <wait+0x46>
c00265db:	83 ec 0c             	sub    $0xc,%esp
c00265de:	8d 83 28 6b ff ff    	lea    -0x94d8(%ebx),%eax
c00265e4:	50                   	push   %eax
c00265e5:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00265eb:	50                   	push   %eax
c00265ec:	8d 83 d4 49 ff ff    	lea    -0xb62c(%ebx),%eax
c00265f2:	50                   	push   %eax
c00265f3:	6a 5c                	push   $0x5c
c00265f5:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c00265fb:	50                   	push   %eax
c00265fc:	e8 8e 29 00 00       	call   c0028f8f <debug_panic>

c0026601 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026601:	57                   	push   %edi
c0026602:	56                   	push   %esi
c0026603:	53                   	push   %ebx
c0026604:	e8 32 73 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026609:	81 c3 c3 2e 01 00    	add    $0x12ec3,%ebx
c002660f:	89 c7                	mov    %eax,%edi
c0026611:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0026613:	e8 dc b4 ff ff       	call   c0021af4 <intr_get_level>
c0026618:	85 c0                	test   %eax,%eax
c002661a:	75 3a                	jne    c0026656 <signal+0x55>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c002661c:	8d 47 28             	lea    0x28(%edi),%eax
c002661f:	39 c6                	cmp    %eax,%esi
c0026621:	74 59                	je     c002667c <signal+0x7b>
c0026623:	8d 47 24             	lea    0x24(%edi),%eax
c0026626:	39 c6                	cmp    %eax,%esi
c0026628:	75 64                	jne    c002668e <signal+0x8d>
c002662a:	83 ec 0c             	sub    $0xc,%esp
c002662d:	57                   	push   %edi
c002662e:	e8 90 fe ff ff       	call   c00264c3 <intq_full>
c0026633:	83 c4 10             	add    $0x10,%esp
c0026636:	84 c0                	test   %al,%al
c0026638:	75 54                	jne    c002668e <signal+0x8d>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c002663a:	8b 06                	mov    (%esi),%eax
c002663c:	85 c0                	test   %eax,%eax
c002663e:	74 12                	je     c0026652 <signal+0x51>
    {
      thread_unblock (*waiter);
c0026640:	83 ec 0c             	sub    $0xc,%esp
c0026643:	50                   	push   %eax
c0026644:	e8 8d a4 ff ff       	call   c0020ad6 <thread_unblock>
      *waiter = NULL;
c0026649:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c002664f:	83 c4 10             	add    $0x10,%esp
    }
}
c0026652:	5b                   	pop    %ebx
c0026653:	5e                   	pop    %esi
c0026654:	5f                   	pop    %edi
c0026655:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0026656:	83 ec 0c             	sub    $0xc,%esp
c0026659:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c002665f:	50                   	push   %eax
c0026660:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0026666:	50                   	push   %eax
c0026667:	8d 83 cc 49 ff ff    	lea    -0xb634(%ebx),%eax
c002666d:	50                   	push   %eax
c002666e:	6a 69                	push   $0x69
c0026670:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c0026676:	50                   	push   %eax
c0026677:	e8 13 29 00 00       	call   c0028f8f <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c002667c:	83 ec 0c             	sub    $0xc,%esp
c002667f:	57                   	push   %edi
c0026680:	e8 ec fd ff ff       	call   c0026471 <intq_empty>
c0026685:	83 c4 10             	add    $0x10,%esp
c0026688:	84 c0                	test   %al,%al
c002668a:	74 ae                	je     c002663a <signal+0x39>
c002668c:	eb 95                	jmp    c0026623 <signal+0x22>
c002668e:	83 ec 0c             	sub    $0xc,%esp
c0026691:	8d 83 84 6b ff ff    	lea    -0x947c(%ebx),%eax
c0026697:	50                   	push   %eax
c0026698:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002669e:	50                   	push   %eax
c002669f:	8d 83 cc 49 ff ff    	lea    -0xb634(%ebx),%eax
c00266a5:	50                   	push   %eax
c00266a6:	6a 6b                	push   $0x6b
c00266a8:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c00266ae:	50                   	push   %eax
c00266af:	e8 db 28 00 00       	call   c0028f8f <debug_panic>

c00266b4 <intq_getc>:
{
c00266b4:	57                   	push   %edi
c00266b5:	56                   	push   %esi
c00266b6:	53                   	push   %ebx
c00266b7:	e8 7f 72 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00266bc:	81 c3 10 2e 01 00    	add    $0x12e10,%ebx
c00266c2:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c00266c6:	e8 29 b4 ff ff       	call   c0021af4 <intr_get_level>
c00266cb:	85 c0                	test   %eax,%eax
c00266cd:	75 3b                	jne    c002670a <intq_getc+0x56>
      wait (q, &q->not_empty);
c00266cf:	8d 7e 28             	lea    0x28(%esi),%edi
  while (intq_empty (q)) 
c00266d2:	83 ec 0c             	sub    $0xc,%esp
c00266d5:	56                   	push   %esi
c00266d6:	e8 96 fd ff ff       	call   c0026471 <intq_empty>
c00266db:	83 c4 10             	add    $0x10,%esp
c00266de:	84 c0                	test   %al,%al
c00266e0:	74 74                	je     c0026756 <intq_getc+0xa2>
      ASSERT (!intr_context ());
c00266e2:	e8 03 b7 ff ff       	call   c0021dea <intr_context>
c00266e7:	84 c0                	test   %al,%al
c00266e9:	75 45                	jne    c0026730 <intq_getc+0x7c>
      lock_acquire (&q->lock);
c00266eb:	83 ec 0c             	sub    $0xc,%esp
c00266ee:	56                   	push   %esi
c00266ef:	e8 49 c9 ff ff       	call   c002303d <lock_acquire>
      wait (q, &q->not_empty);
c00266f4:	89 fa                	mov    %edi,%edx
c00266f6:	89 f0                	mov    %esi,%eax
c00266f8:	e8 26 fe ff ff       	call   c0026523 <wait>
      lock_release (&q->lock);
c00266fd:	89 34 24             	mov    %esi,(%esp)
c0026700:	e8 30 cb ff ff       	call   c0023235 <lock_release>
c0026705:	83 c4 10             	add    $0x10,%esp
c0026708:	eb c8                	jmp    c00266d2 <intq_getc+0x1e>
  ASSERT (intr_get_level () == INTR_OFF);
c002670a:	83 ec 0c             	sub    $0xc,%esp
c002670d:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c0026713:	50                   	push   %eax
c0026714:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002671a:	50                   	push   %eax
c002671b:	8d 83 dc 49 ff ff    	lea    -0xb624(%ebx),%eax
c0026721:	50                   	push   %eax
c0026722:	6a 2a                	push   $0x2a
c0026724:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c002672a:	50                   	push   %eax
c002672b:	e8 5f 28 00 00       	call   c0028f8f <debug_panic>
      ASSERT (!intr_context ());
c0026730:	83 ec 0c             	sub    $0xc,%esp
c0026733:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c0026739:	50                   	push   %eax
c002673a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0026740:	50                   	push   %eax
c0026741:	8d 83 dc 49 ff ff    	lea    -0xb624(%ebx),%eax
c0026747:	50                   	push   %eax
c0026748:	6a 2d                	push   $0x2d
c002674a:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c0026750:	50                   	push   %eax
c0026751:	e8 39 28 00 00       	call   c0028f8f <debug_panic>
  byte = q->buf[q->tail];
c0026756:	8b 46 70             	mov    0x70(%esi),%eax
c0026759:	0f b6 5c 06 2c       	movzbl 0x2c(%esi,%eax,1),%ebx
  return (pos + 1) % INTQ_BUFSIZE;
c002675e:	83 c0 01             	add    $0x1,%eax
c0026761:	99                   	cltd   
c0026762:	c1 ea 1a             	shr    $0x1a,%edx
c0026765:	01 d0                	add    %edx,%eax
c0026767:	83 e0 3f             	and    $0x3f,%eax
c002676a:	29 d0                	sub    %edx,%eax
  q->tail = next (q->tail);
c002676c:	89 46 70             	mov    %eax,0x70(%esi)
  signal (q, &q->not_full);
c002676f:	8d 56 24             	lea    0x24(%esi),%edx
c0026772:	89 f0                	mov    %esi,%eax
c0026774:	e8 88 fe ff ff       	call   c0026601 <signal>
}
c0026779:	89 d8                	mov    %ebx,%eax
c002677b:	5b                   	pop    %ebx
c002677c:	5e                   	pop    %esi
c002677d:	5f                   	pop    %edi
c002677e:	c3                   	ret    

c002677f <intq_putc>:
{
c002677f:	55                   	push   %ebp
c0026780:	57                   	push   %edi
c0026781:	56                   	push   %esi
c0026782:	53                   	push   %ebx
c0026783:	83 ec 0c             	sub    $0xc,%esp
c0026786:	e8 b0 71 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002678b:	81 c3 41 2d 01 00    	add    $0x12d41,%ebx
c0026791:	8b 74 24 20          	mov    0x20(%esp),%esi
c0026795:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  ASSERT (intr_get_level () == INTR_OFF);
c0026799:	e8 56 b3 ff ff       	call   c0021af4 <intr_get_level>
c002679e:	85 c0                	test   %eax,%eax
c00267a0:	75 3b                	jne    c00267dd <intq_putc+0x5e>
      wait (q, &q->not_full);
c00267a2:	8d 7e 24             	lea    0x24(%esi),%edi
  while (intq_full (q))
c00267a5:	83 ec 0c             	sub    $0xc,%esp
c00267a8:	56                   	push   %esi
c00267a9:	e8 15 fd ff ff       	call   c00264c3 <intq_full>
c00267ae:	83 c4 10             	add    $0x10,%esp
c00267b1:	84 c0                	test   %al,%al
c00267b3:	74 74                	je     c0026829 <intq_putc+0xaa>
      ASSERT (!intr_context ());
c00267b5:	e8 30 b6 ff ff       	call   c0021dea <intr_context>
c00267ba:	84 c0                	test   %al,%al
c00267bc:	75 45                	jne    c0026803 <intq_putc+0x84>
      lock_acquire (&q->lock);
c00267be:	83 ec 0c             	sub    $0xc,%esp
c00267c1:	56                   	push   %esi
c00267c2:	e8 76 c8 ff ff       	call   c002303d <lock_acquire>
      wait (q, &q->not_full);
c00267c7:	89 fa                	mov    %edi,%edx
c00267c9:	89 f0                	mov    %esi,%eax
c00267cb:	e8 53 fd ff ff       	call   c0026523 <wait>
      lock_release (&q->lock);
c00267d0:	89 34 24             	mov    %esi,(%esp)
c00267d3:	e8 5d ca ff ff       	call   c0023235 <lock_release>
c00267d8:	83 c4 10             	add    $0x10,%esp
c00267db:	eb c8                	jmp    c00267a5 <intq_putc+0x26>
  ASSERT (intr_get_level () == INTR_OFF);
c00267dd:	83 ec 0c             	sub    $0xc,%esp
c00267e0:	8d 83 40 59 ff ff    	lea    -0xa6c0(%ebx),%eax
c00267e6:	50                   	push   %eax
c00267e7:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00267ed:	50                   	push   %eax
c00267ee:	8d 83 c0 49 ff ff    	lea    -0xb640(%ebx),%eax
c00267f4:	50                   	push   %eax
c00267f5:	6a 3f                	push   $0x3f
c00267f7:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c00267fd:	50                   	push   %eax
c00267fe:	e8 8c 27 00 00       	call   c0028f8f <debug_panic>
      ASSERT (!intr_context ());
c0026803:	83 ec 0c             	sub    $0xc,%esp
c0026806:	8d 83 d6 59 ff ff    	lea    -0xa62a(%ebx),%eax
c002680c:	50                   	push   %eax
c002680d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0026813:	50                   	push   %eax
c0026814:	8d 83 c0 49 ff ff    	lea    -0xb640(%ebx),%eax
c002681a:	50                   	push   %eax
c002681b:	6a 42                	push   $0x42
c002681d:	8d 83 13 6b ff ff    	lea    -0x94ed(%ebx),%eax
c0026823:	50                   	push   %eax
c0026824:	e8 66 27 00 00       	call   c0028f8f <debug_panic>
  q->buf[q->head] = byte;
c0026829:	8b 46 6c             	mov    0x6c(%esi),%eax
c002682c:	89 e9                	mov    %ebp,%ecx
c002682e:	88 4c 06 2c          	mov    %cl,0x2c(%esi,%eax,1)
  return (pos + 1) % INTQ_BUFSIZE;
c0026832:	83 c0 01             	add    $0x1,%eax
c0026835:	99                   	cltd   
c0026836:	c1 ea 1a             	shr    $0x1a,%edx
c0026839:	01 d0                	add    %edx,%eax
c002683b:	83 e0 3f             	and    $0x3f,%eax
c002683e:	29 d0                	sub    %edx,%eax
  q->head = next (q->head);
c0026840:	89 46 6c             	mov    %eax,0x6c(%esi)
  signal (q, &q->not_empty);
c0026843:	8d 56 28             	lea    0x28(%esi),%edx
c0026846:	89 f0                	mov    %esi,%eax
c0026848:	e8 b4 fd ff ff       	call   c0026601 <signal>
}
c002684d:	83 c4 0c             	add    $0xc,%esp
c0026850:	5b                   	pop    %ebx
c0026851:	5e                   	pop    %esi
c0026852:	5f                   	pop    %edi
c0026853:	5d                   	pop    %ebp
c0026854:	c3                   	ret    

c0026855 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026855:	55                   	push   %ebp
c0026856:	57                   	push   %edi
c0026857:	56                   	push   %esi
c0026858:	53                   	push   %ebx
c0026859:	83 ec 0c             	sub    $0xc,%esp
c002685c:	e8 de 70 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0026861:	05 6b 2c 01 00       	add    $0x12c6b,%eax
c0026866:	89 44 24 08          	mov    %eax,0x8(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002686a:	bf 00 00 00 00       	mov    $0x0,%edi
c002686f:	bd 02 00 00 00       	mov    $0x2,%ebp
c0026874:	89 f8                	mov    %edi,%eax
c0026876:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026878:	e4 71                	in     $0x71,%al
c002687a:	89 c2                	mov    %eax,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002687c:	89 e8                	mov    %ebp,%eax
c002687e:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026880:	e4 71                	in     $0x71,%al
c0026882:	88 04 24             	mov    %al,(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026885:	b8 04 00 00 00       	mov    $0x4,%eax
c002688a:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002688c:	e4 71                	in     $0x71,%al
c002688e:	88 44 24 07          	mov    %al,0x7(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026892:	b8 07 00 00 00       	mov    $0x7,%eax
c0026897:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026899:	e4 71                	in     $0x71,%al
c002689b:	88 44 24 06          	mov    %al,0x6(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002689f:	b8 08 00 00 00       	mov    $0x8,%eax
c00268a4:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268a6:	e4 71                	in     $0x71,%al
c00268a8:	88 44 24 05          	mov    %al,0x5(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268ac:	b8 09 00 00 00       	mov    $0x9,%eax
c00268b1:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268b3:	e4 71                	in     $0x71,%al
c00268b5:	89 c3                	mov    %eax,%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00268b7:	89 f8                	mov    %edi,%eax
c00268b9:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00268bb:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c00268bd:	89 c1                	mov    %eax,%ecx
c00268bf:	c0 e9 04             	shr    $0x4,%cl
c00268c2:	0f b6 c9             	movzbl %cl,%ecx
c00268c5:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c00268c8:	83 e0 0f             	and    $0xf,%eax
c00268cb:	8d 34 48             	lea    (%eax,%ecx,2),%esi
c00268ce:	89 d1                	mov    %edx,%ecx
c00268d0:	c0 e9 04             	shr    $0x4,%cl
c00268d3:	0f b6 c9             	movzbl %cl,%ecx
c00268d6:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
c00268d9:	83 e2 0f             	and    $0xf,%edx
c00268dc:	8d 04 42             	lea    (%edx,%eax,2),%eax
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c00268df:	39 c6                	cmp    %eax,%esi
c00268e1:	75 91                	jne    c0026874 <rtc_get_time+0x1f>
  return (x & 0x0f) + ((x >> 4) * 10);
c00268e3:	89 d8                	mov    %ebx,%eax
c00268e5:	c0 e8 04             	shr    $0x4,%al
c00268e8:	0f b6 c0             	movzbl %al,%eax
c00268eb:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00268ee:	83 e3 0f             	and    $0xf,%ebx
c00268f1:	8d 04 43             	lea    (%ebx,%eax,2),%eax
    year += 100;
c00268f4:	8d 50 64             	lea    0x64(%eax),%edx
c00268f7:	83 f8 46             	cmp    $0x46,%eax
c00268fa:	0f 4c c2             	cmovl  %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c00268fd:	0f b6 5c 24 05       	movzbl 0x5(%esp),%ebx
c0026902:	89 da                	mov    %ebx,%edx
c0026904:	c0 ea 04             	shr    $0x4,%dl
c0026907:	0f b6 d2             	movzbl %dl,%edx
c002690a:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002690d:	89 d9                	mov    %ebx,%ecx
c002690f:	83 e1 0f             	and    $0xf,%ecx
c0026912:	8d 2c 51             	lea    (%ecx,%edx,2),%ebp
  year -= 70;
c0026915:	8d 78 ba             	lea    -0x46(%eax),%edi
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026918:	8d 50 bc             	lea    -0x44(%eax),%edx
c002691b:	83 e8 47             	sub    $0x47,%eax
c002691e:	0f 48 c2             	cmovs  %edx,%eax
c0026921:	c1 f8 02             	sar    $0x2,%eax
c0026924:	69 d7 6d 01 00 00    	imul   $0x16d,%edi,%edx
c002692a:	01 d0                	add    %edx,%eax
c002692c:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
  for (i = 1; i <= mon; i++)
c0026932:	85 ed                	test   %ebp,%ebp
c0026934:	7e 1c                	jle    c0026952 <rtc_get_time+0xfd>
c0026936:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c002693a:	8d 93 14 4a ff ff    	lea    -0xb5ec(%ebx),%edx
c0026940:	8d 1c aa             	lea    (%edx,%ebp,4),%ebx
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026943:	69 0a 80 51 01 00    	imul   $0x15180,(%edx),%ecx
c0026949:	01 c8                	add    %ecx,%eax
c002694b:	83 c2 04             	add    $0x4,%edx
  for (i = 1; i <= mon; i++)
c002694e:	39 da                	cmp    %ebx,%edx
c0026950:	75 f1                	jne    c0026943 <rtc_get_time+0xee>
  if (mon > 2 && year % 4 == 0)
c0026952:	83 fd 02             	cmp    $0x2,%ebp
c0026955:	7e 0e                	jle    c0026965 <rtc_get_time+0x110>
c0026957:	83 e7 03             	and    $0x3,%edi
    time += 24 * 60 * 60;
c002695a:	8d 90 80 51 01 00    	lea    0x15180(%eax),%edx
c0026960:	85 ff                	test   %edi,%edi
c0026962:	0f 44 c2             	cmove  %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c0026965:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
c002696a:	89 da                	mov    %ebx,%edx
c002696c:	c0 ea 04             	shr    $0x4,%dl
c002696f:	0f b6 d2             	movzbl %dl,%edx
c0026972:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026975:	89 da                	mov    %ebx,%edx
c0026977:	83 e2 0f             	and    $0xf,%edx
c002697a:	8d 0c 4a             	lea    (%edx,%ecx,2),%ecx
  time += hour * 60 * 60;
c002697d:	69 c9 10 0e 00 00    	imul   $0xe10,%ecx,%ecx
  return (x & 0x0f) + ((x >> 4) * 10);
c0026983:	0f b6 14 24          	movzbl (%esp),%edx
c0026987:	c0 ea 04             	shr    $0x4,%dl
c002698a:	0f b6 d2             	movzbl %dl,%edx
c002698d:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
c0026990:	8b 14 24             	mov    (%esp),%edx
c0026993:	83 e2 0f             	and    $0xf,%edx
c0026996:	8d 14 5a             	lea    (%edx,%ebx,2),%edx
  time += min * 60;
c0026999:	6b d2 3c             	imul   $0x3c,%edx,%edx
  time += sec;
c002699c:	01 d1                	add    %edx,%ecx
c002699e:	01 ce                	add    %ecx,%esi
  return (x & 0x0f) + ((x >> 4) * 10);
c00269a0:	0f b6 5c 24 06       	movzbl 0x6(%esp),%ebx
c00269a5:	89 da                	mov    %ebx,%edx
c00269a7:	c0 ea 04             	shr    $0x4,%dl
c00269aa:	0f b6 d2             	movzbl %dl,%edx
c00269ad:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c00269b0:	89 da                	mov    %ebx,%edx
c00269b2:	83 e2 0f             	and    $0xf,%edx
  time += (mday - 1) * 24 * 60 * 60;
c00269b5:	8d 54 4a ff          	lea    -0x1(%edx,%ecx,2),%edx
c00269b9:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
  time += sec;
c00269bf:	01 d6                	add    %edx,%esi
c00269c1:	01 f0                	add    %esi,%eax
}
c00269c3:	83 c4 0c             	add    $0xc,%esp
c00269c6:	5b                   	pop    %ebx
c00269c7:	5e                   	pop    %esi
c00269c8:	5f                   	pop    %edi
c00269c9:	5d                   	pop    %ebp
c00269ca:	c3                   	ret    

c00269cb <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c00269cb:	e8 6f 6f 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c00269d0:	05 fc 2a 01 00       	add    $0x12afc,%eax
  how = type;
c00269d5:	8b 54 24 04          	mov    0x4(%esp),%edx
c00269d9:	89 90 e8 21 00 00    	mov    %edx,0x21e8(%eax)
}
c00269df:	c3                   	ret    

c00269e0 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c00269e0:	57                   	push   %edi
c00269e1:	56                   	push   %esi
c00269e2:	53                   	push   %ebx
c00269e3:	e8 53 6f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00269e8:	81 c3 e4 2a 01 00    	add    $0x12ae4,%ebx
  printf ("Rebooting...\n");
c00269ee:	83 ec 0c             	sub    $0xc,%esp
c00269f1:	8d 83 df 6b ff ff    	lea    -0x9421(%ebx),%eax
c00269f7:	50                   	push   %eax
c00269f8:	e8 b6 44 00 00       	call   c002aeb3 <puts>
c00269fd:	83 c4 10             	add    $0x10,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026a00:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
c0026a05:	eb 1f                	jmp    c0026a26 <shutdown_reboot+0x46>
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
        }

      timer_udelay (50);
c0026a07:	83 ec 08             	sub    $0x8,%esp
c0026a0a:	6a 00                	push   $0x0
c0026a0c:	6a 32                	push   $0x32
c0026a0e:	e8 22 db ff ff       	call   c0024535 <timer_udelay>
c0026a13:	89 f8                	mov    %edi,%eax
c0026a15:	e6 64                	out    %al,$0x64

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
      timer_udelay (50);
c0026a17:	83 c4 08             	add    $0x8,%esp
c0026a1a:	6a 00                	push   $0x0
c0026a1c:	6a 32                	push   $0x32
c0026a1e:	e8 12 db ff ff       	call   c0024535 <timer_udelay>
    {
c0026a23:	83 c4 10             	add    $0x10,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026a26:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026a28:	a8 02                	test   $0x2,%al
c0026a2a:	74 db                	je     c0026a07 <shutdown_reboot+0x27>
          timer_udelay (2);
c0026a2c:	83 ec 08             	sub    $0x8,%esp
c0026a2f:	6a 00                	push   $0x0
c0026a31:	6a 02                	push   $0x2
c0026a33:	e8 fd da ff ff       	call   c0024535 <timer_udelay>
c0026a38:	83 c4 10             	add    $0x10,%esp
c0026a3b:	be ff ff 00 00       	mov    $0xffff,%esi
c0026a40:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026a42:	a8 02                	test   $0x2,%al
c0026a44:	74 c1                	je     c0026a07 <shutdown_reboot+0x27>
          timer_udelay (2);
c0026a46:	83 ec 08             	sub    $0x8,%esp
c0026a49:	6a 00                	push   $0x0
c0026a4b:	6a 02                	push   $0x2
c0026a4d:	e8 e3 da ff ff       	call   c0024535 <timer_udelay>
      for (i = 0; i < 0x10000; i++)
c0026a52:	83 c4 10             	add    $0x10,%esp
c0026a55:	83 ee 01             	sub    $0x1,%esi
c0026a58:	75 e6                	jne    c0026a40 <shutdown_reboot+0x60>
c0026a5a:	eb ab                	jmp    c0026a07 <shutdown_reboot+0x27>

c0026a5c <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026a5c:	53                   	push   %ebx
c0026a5d:	83 ec 18             	sub    $0x18,%esp
c0026a60:	e8 d6 6e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026a65:	81 c3 67 2a 01 00    	add    $0x12a67,%ebx
  const char s[] = "Shutdown";
c0026a6b:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0026a72:	74 
c0026a73:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c0026a7a:	6e 
c0026a7b:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
  timer_print_stats ();
c0026a80:	e8 e2 da ff ff       	call   c0024567 <timer_print_stats>
  thread_print_stats ();
c0026a85:	e8 10 a0 ff ff       	call   c0020a9a <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0026a8a:	e8 b5 43 00 00       	call   c002ae44 <console_print_stats>
  kbd_print_stats ();
c0026a8f:	e8 4e dd ff ff       	call   c00247e2 <kbd_print_stats>
  printf ("Powering off...\n");
c0026a94:	83 ec 0c             	sub    $0xc,%esp
c0026a97:	8d 83 ec 6b ff ff    	lea    -0x9414(%ebx),%eax
c0026a9d:	50                   	push   %eax
c0026a9e:	e8 10 44 00 00       	call   c002aeb3 <puts>
  serial_flush ();
c0026aa3:	e8 e4 e2 ff ff       	call   c0024d8c <serial_flush>
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026aa8:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026aad:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c0026ab2:	66 ef                	out    %ax,(%dx)
  for (p = s; *p != '\0'; p++)
c0026ab4:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c0026ab9:	83 c4 10             	add    $0x10,%esp
c0026abc:	84 c0                	test   %al,%al
c0026abe:	74 14                	je     c0026ad4 <shutdown_power_off+0x78>
c0026ac0:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ac4:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c0026ac9:	ee                   	out    %al,(%dx)
c0026aca:	83 c1 01             	add    $0x1,%ecx
c0026acd:	0f b6 01             	movzbl (%ecx),%eax
c0026ad0:	84 c0                	test   %al,%al
c0026ad2:	75 f5                	jne    c0026ac9 <shutdown_power_off+0x6d>
c0026ad4:	b8 31 00 00 00       	mov    $0x31,%eax
c0026ad9:	ba 01 05 00 00       	mov    $0x501,%edx
c0026ade:	ee                   	out    %al,(%dx)
  asm volatile ("cli; hlt" : : : "memory");
c0026adf:	fa                   	cli    
c0026ae0:	f4                   	hlt    
  printf ("still running...\n");
c0026ae1:	83 ec 0c             	sub    $0xc,%esp
c0026ae4:	8d 83 fc 6b ff ff    	lea    -0x9404(%ebx),%eax
c0026aea:	50                   	push   %eax
c0026aeb:	e8 c3 43 00 00       	call   c002aeb3 <puts>
c0026af0:	83 c4 10             	add    $0x10,%esp
c0026af3:	eb fe                	jmp    c0026af3 <shutdown_power_off+0x97>

c0026af5 <shutdown>:
{
c0026af5:	83 ec 0c             	sub    $0xc,%esp
c0026af8:	e8 42 6e 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0026afd:	05 cf 29 01 00       	add    $0x129cf,%eax
  switch (how)
c0026b02:	8b 80 e8 21 00 00    	mov    0x21e8(%eax),%eax
c0026b08:	83 f8 01             	cmp    $0x1,%eax
c0026b0b:	74 09                	je     c0026b16 <shutdown+0x21>
c0026b0d:	83 f8 02             	cmp    $0x2,%eax
c0026b10:	74 09                	je     c0026b1b <shutdown+0x26>
}
c0026b12:	83 c4 0c             	add    $0xc,%esp
c0026b15:	c3                   	ret    
      shutdown_power_off ();
c0026b16:	e8 41 ff ff ff       	call   c0026a5c <shutdown_power_off>
      shutdown_reboot ();
c0026b1b:	e8 c0 fe ff ff       	call   c00269e0 <shutdown_reboot>

c0026b20 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026b20:	53                   	push   %ebx
c0026b21:	83 ec 08             	sub    $0x8,%esp
c0026b24:	e8 12 6e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026b29:	81 c3 a3 29 01 00    	add    $0x129a3,%ebx
  enum intr_level old_level = intr_disable ();
c0026b2f:	e8 12 b0 ff ff       	call   c0021b46 <intr_disable>
c0026b34:	89 c2                	mov    %eax,%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b36:	e4 61                	in     $0x61,%al
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b38:	83 e0 fc             	and    $0xfffffffc,%eax
c0026b3b:	e6 61                	out    %al,$0x61
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level (old_level);
c0026b3d:	83 ec 0c             	sub    $0xc,%esp
c0026b40:	52                   	push   %edx
c0026b41:	e8 07 b0 ff ff       	call   c0021b4d <intr_set_level>
}
c0026b46:	83 c4 18             	add    $0x18,%esp
c0026b49:	5b                   	pop    %ebx
c0026b4a:	c3                   	ret    

c0026b4b <speaker_on>:
{
c0026b4b:	57                   	push   %edi
c0026b4c:	56                   	push   %esi
c0026b4d:	53                   	push   %ebx
c0026b4e:	e8 e8 6d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026b53:	81 c3 79 29 01 00    	add    $0x12979,%ebx
c0026b59:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (frequency >= 20 && frequency <= 20000)
c0026b5d:	8d 46 ec             	lea    -0x14(%esi),%eax
c0026b60:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0026b65:	76 09                	jbe    c0026b70 <speaker_on+0x25>
      speaker_off ();
c0026b67:	e8 b4 ff ff ff       	call   c0026b20 <speaker_off>
}
c0026b6c:	5b                   	pop    %ebx
c0026b6d:	5e                   	pop    %esi
c0026b6e:	5f                   	pop    %edi
c0026b6f:	c3                   	ret    
      enum intr_level old_level = intr_disable ();
c0026b70:	e8 d1 af ff ff       	call   c0021b46 <intr_disable>
c0026b75:	89 c7                	mov    %eax,%edi
      pit_configure_channel (2, 3, frequency);
c0026b77:	83 ec 04             	sub    $0x4,%esp
c0026b7a:	56                   	push   %esi
c0026b7b:	6a 03                	push   $0x3
c0026b7d:	6a 02                	push   $0x2
c0026b7f:	e8 f6 d3 ff ff       	call   c0023f7a <pit_configure_channel>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b84:	e4 61                	in     $0x61,%al
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026b86:	83 c8 03             	or     $0x3,%eax
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b89:	e6 61                	out    %al,$0x61
      intr_set_level (old_level);
c0026b8b:	89 3c 24             	mov    %edi,(%esp)
c0026b8e:	e8 ba af ff ff       	call   c0021b4d <intr_set_level>
c0026b93:	83 c4 10             	add    $0x10,%esp
c0026b96:	eb d4                	jmp    c0026b6c <speaker_on+0x21>

c0026b98 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026b98:	53                   	push   %ebx
c0026b99:	83 ec 08             	sub    $0x8,%esp
c0026b9c:	e8 9a 6d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026ba1:	81 c3 2b 29 01 00    	add    $0x1292b,%ebx

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026ba7:	e8 48 af ff ff       	call   c0021af4 <intr_get_level>
c0026bac:	83 f8 01             	cmp    $0x1,%eax
c0026baf:	74 05                	je     c0026bb6 <speaker_beep+0x1e>
    {
      speaker_on (440);
      timer_msleep (250);
      speaker_off ();
    }
}
c0026bb1:	83 c4 08             	add    $0x8,%esp
c0026bb4:	5b                   	pop    %ebx
c0026bb5:	c3                   	ret    
      speaker_on (440);
c0026bb6:	83 ec 0c             	sub    $0xc,%esp
c0026bb9:	68 b8 01 00 00       	push   $0x1b8
c0026bbe:	e8 88 ff ff ff       	call   c0026b4b <speaker_on>
      timer_msleep (250);
c0026bc3:	83 c4 08             	add    $0x8,%esp
c0026bc6:	6a 00                	push   $0x0
c0026bc8:	68 fa 00 00 00       	push   $0xfa
c0026bcd:	e8 ff d8 ff ff       	call   c00244d1 <timer_msleep>
      speaker_off ();
c0026bd2:	e8 49 ff ff ff       	call   c0026b20 <speaker_off>
c0026bd7:	83 c4 10             	add    $0x10,%esp
}
c0026bda:	eb d5                	jmp    c0026bb1 <speaker_beep+0x19>

c0026bdc <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026bdc:	55                   	push   %ebp
c0026bdd:	89 e5                	mov    %esp,%ebp
c0026bdf:	57                   	push   %edi
c0026be0:	56                   	push   %esi
c0026be1:	53                   	push   %ebx
c0026be2:	83 ec 14             	sub    $0x14,%esp
c0026be5:	e8 51 6d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026bea:	81 c3 e2 28 01 00    	add    $0x128e2,%ebx
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026bf0:	ff 75 04             	pushl  0x4(%ebp)
c0026bf3:	8d 83 0d 6c ff ff    	lea    -0x93f3(%ebx),%eax
c0026bf9:	50                   	push   %eax
c0026bfa:	e8 f9 05 00 00       	call   c00271f8 <printf>
  for (frame = __builtin_frame_address (1);
c0026bff:	8b 75 00             	mov    0x0(%ebp),%esi
c0026c02:	83 c4 10             	add    $0x10,%esp
c0026c05:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026c0b:	76 29                	jbe    c0026c36 <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026c0d:	83 3e 00             	cmpl   $0x0,(%esi)
c0026c10:	74 24                	je     c0026c36 <debug_backtrace+0x5a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026c12:	8d bb 18 6c ff ff    	lea    -0x93e8(%ebx),%edi
c0026c18:	83 ec 08             	sub    $0x8,%esp
c0026c1b:	ff 76 04             	pushl  0x4(%esi)
c0026c1e:	57                   	push   %edi
c0026c1f:	e8 d4 05 00 00       	call   c00271f8 <printf>
       frame = frame[0]) 
c0026c24:	8b 36                	mov    (%esi),%esi
  for (frame = __builtin_frame_address (1);
c0026c26:	83 c4 10             	add    $0x10,%esp
c0026c29:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026c2f:	76 05                	jbe    c0026c36 <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026c31:	83 3e 00             	cmpl   $0x0,(%esi)
c0026c34:	75 e2                	jne    c0026c18 <debug_backtrace+0x3c>
  printf (".\n");
c0026c36:	83 ec 0c             	sub    $0xc,%esp
c0026c39:	8d 83 af 67 ff ff    	lea    -0x9851(%ebx),%eax
c0026c3f:	50                   	push   %eax
c0026c40:	e8 6e 42 00 00       	call   c002aeb3 <puts>

  if (!explained) 
c0026c45:	83 c4 10             	add    $0x10,%esp
c0026c48:	80 bb ec 21 00 00 00 	cmpb   $0x0,0x21ec(%ebx)
c0026c4f:	74 08                	je     c0026c59 <debug_backtrace+0x7d>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026c51:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0026c54:	5b                   	pop    %ebx
c0026c55:	5e                   	pop    %esi
c0026c56:	5f                   	pop    %edi
c0026c57:	5d                   	pop    %ebp
c0026c58:	c3                   	ret    
      explained = true;
c0026c59:	c6 83 ec 21 00 00 01 	movb   $0x1,0x21ec(%ebx)
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026c60:	83 ec 0c             	sub    $0xc,%esp
c0026c63:	8d 83 1c 6c ff ff    	lea    -0x93e4(%ebx),%eax
c0026c69:	50                   	push   %eax
c0026c6a:	e8 44 42 00 00       	call   c002aeb3 <puts>
c0026c6f:	83 c4 10             	add    $0x10,%esp
}
c0026c72:	eb dd                	jmp    c0026c51 <debug_backtrace+0x75>

c0026c74 <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026c74:	55                   	push   %ebp
c0026c75:	57                   	push   %edi
c0026c76:	56                   	push   %esi
c0026c77:	53                   	push   %ebx
c0026c78:	e8 ce 6c 00 00       	call   c002d94b <__x86.get_pc_thunk.cx>
c0026c7d:	81 c1 4f 28 01 00    	add    $0x1284f,%ecx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026c83:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0026c88:	88 84 08 14 22 00 00 	mov    %al,0x2214(%eax,%ecx,1)
  for (i = 0; i < 256; i++) 
c0026c8f:	83 c0 01             	add    $0x1,%eax
c0026c92:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026c97:	75 ef                	jne    c0026c88 <random_init+0x14>
  for (i = j = 0; i < 256; i++) 
c0026c99:	bd 00 00 00 00       	mov    $0x0,%ebp
c0026c9e:	b8 00 00 00 00       	mov    $0x0,%eax
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
c0026ca3:	8d b9 14 22 00 00    	lea    0x2214(%ecx),%edi
      j += s[i] + seedp[i % sizeof seed];
c0026ca9:	89 c2                	mov    %eax,%edx
c0026cab:	83 e2 03             	and    $0x3,%edx
c0026cae:	0f b6 b4 08 14 22 00 	movzbl 0x2214(%eax,%ecx,1),%esi
c0026cb5:	00 
c0026cb6:	89 f3                	mov    %esi,%ebx
c0026cb8:	02 5c 14 14          	add    0x14(%esp,%edx,1),%bl
c0026cbc:	89 da                	mov    %ebx,%edx
c0026cbe:	01 d5                	add    %edx,%ebp
      swap_byte (s + i, s + j);
c0026cc0:	89 eb                	mov    %ebp,%ebx
c0026cc2:	0f b6 d3             	movzbl %bl,%edx
c0026cc5:	01 fa                	add    %edi,%edx
  *a = *b;
c0026cc7:	0f b6 1a             	movzbl (%edx),%ebx
c0026cca:	88 9c 08 14 22 00 00 	mov    %bl,0x2214(%eax,%ecx,1)
  *b = t;
c0026cd1:	89 f3                	mov    %esi,%ebx
c0026cd3:	88 1a                	mov    %bl,(%edx)
  for (i = j = 0; i < 256; i++) 
c0026cd5:	83 c0 01             	add    $0x1,%eax
c0026cd8:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026cdd:	75 ca                	jne    c0026ca9 <random_init+0x35>
    }

  s_i = s_j = 0;
c0026cdf:	c6 81 f5 21 00 00 00 	movb   $0x0,0x21f5(%ecx)
c0026ce6:	c6 81 f6 21 00 00 00 	movb   $0x0,0x21f6(%ecx)
  inited = true;
c0026ced:	c6 81 f4 21 00 00 01 	movb   $0x1,0x21f4(%ecx)
}
c0026cf4:	5b                   	pop    %ebx
c0026cf5:	5e                   	pop    %esi
c0026cf6:	5f                   	pop    %edi
c0026cf7:	5d                   	pop    %ebp
c0026cf8:	c3                   	ret    

c0026cf9 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026cf9:	55                   	push   %ebp
c0026cfa:	57                   	push   %edi
c0026cfb:	56                   	push   %esi
c0026cfc:	53                   	push   %ebx
c0026cfd:	83 ec 10             	sub    $0x10,%esp
c0026d00:	e8 3a 6c 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0026d05:	05 c7 27 01 00       	add    $0x127c7,%eax
c0026d0a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  uint8_t *buf;

  if (!inited)
c0026d0e:	80 b8 f4 21 00 00 00 	cmpb   $0x0,0x21f4(%eax)
c0026d15:	74 31                	je     c0026d48 <random_bytes+0x4f>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c0026d17:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0026d1c:	0f 84 95 00 00 00    	je     c0026db7 <random_bytes+0xbe>
c0026d22:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0026d26:	0f b6 87 f5 21 00 00 	movzbl 0x21f5(%edi),%eax
c0026d2d:	88 44 24 03          	mov    %al,0x3(%esp)
c0026d31:	bb 00 00 00 00       	mov    $0x0,%ebx
c0026d36:	0f b6 87 f6 21 00 00 	movzbl 0x21f6(%edi),%eax
c0026d3d:	8d 68 01             	lea    0x1(%eax),%ebp
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c0026d40:	8d 87 14 22 00 00    	lea    0x2214(%edi),%eax
c0026d46:	eb 0e                	jmp    c0026d56 <random_bytes+0x5d>
    random_init (0);
c0026d48:	6a 00                	push   $0x0
c0026d4a:	e8 25 ff ff ff       	call   c0026c74 <random_init>
c0026d4f:	83 c4 04             	add    $0x4,%esp
c0026d52:	eb c3                	jmp    c0026d17 <random_bytes+0x1e>
c0026d54:	89 d3                	mov    %edx,%ebx
c0026d56:	8d 54 1d 00          	lea    0x0(%ebp,%ebx,1),%edx
      s_j += s[s_i];
c0026d5a:	0f b6 fa             	movzbl %dl,%edi
c0026d5d:	0f b6 4c 24 03       	movzbl 0x3(%esp),%ecx
c0026d62:	02 0c 38             	add    (%eax,%edi,1),%cl
c0026d65:	88 4c 24 03          	mov    %cl,0x3(%esp)
      swap_byte (s + s_i, s + s_j);
c0026d69:	0f b6 f1             	movzbl %cl,%esi
c0026d6c:	89 74 24 08          	mov    %esi,0x8(%esp)
c0026d70:	01 c6                	add    %eax,%esi
c0026d72:	89 7c 24 04          	mov    %edi,0x4(%esp)
c0026d76:	01 c7                	add    %eax,%edi
  uint8_t t = *a;
c0026d78:	0f b6 0f             	movzbl (%edi),%ecx
  *a = *b;
c0026d7b:	0f b6 16             	movzbl (%esi),%edx
c0026d7e:	88 17                	mov    %dl,(%edi)
  *b = t;
c0026d80:	88 0e                	mov    %cl,(%esi)

      s_k = s[s_i] + s[s_j];
c0026d82:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0026d86:	02 0c 38             	add    (%eax,%edi,1),%cl
      *buf = s[s_k];
c0026d89:	0f b6 c9             	movzbl %cl,%ecx
c0026d8c:	0f b6 14 08          	movzbl (%eax,%ecx,1),%edx
c0026d90:	8b 74 24 24          	mov    0x24(%esp),%esi
c0026d94:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
c0026d97:	8d 53 01             	lea    0x1(%ebx),%edx
  for (buf = buf_; size-- > 0; buf++)
c0026d9a:	3b 54 24 28          	cmp    0x28(%esp),%edx
c0026d9e:	75 b4                	jne    c0026d54 <random_bytes+0x5b>
c0026da0:	01 eb                	add    %ebp,%ebx
c0026da2:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0026da6:	88 9f f6 21 00 00    	mov    %bl,0x21f6(%edi)
c0026dac:	0f b6 44 24 03       	movzbl 0x3(%esp),%eax
c0026db1:	88 87 f5 21 00 00    	mov    %al,0x21f5(%edi)
    }
}
c0026db7:	83 c4 10             	add    $0x10,%esp
c0026dba:	5b                   	pop    %ebx
c0026dbb:	5e                   	pop    %esi
c0026dbc:	5f                   	pop    %edi
c0026dbd:	5d                   	pop    %ebp
c0026dbe:	c3                   	ret    

c0026dbf <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0026dbf:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0026dc2:	6a 04                	push   $0x4
c0026dc4:	8d 44 24 10          	lea    0x10(%esp),%eax
c0026dc8:	50                   	push   %eax
c0026dc9:	e8 2b ff ff ff       	call   c0026cf9 <random_bytes>
  return ul;
}
c0026dce:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026dd2:	83 c4 18             	add    $0x18,%esp
c0026dd5:	c3                   	ret    

c0026dd6 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0026dd6:	53                   	push   %ebx
c0026dd7:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026ddb:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c0026ddf:	8b 50 04             	mov    0x4(%eax),%edx
c0026de2:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026de5:	89 48 04             	mov    %ecx,0x4(%eax)
c0026de8:	3b 50 08             	cmp    0x8(%eax),%edx
c0026deb:	7d 09                	jge    c0026df6 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0026ded:	8b 10                	mov    (%eax),%edx
c0026def:	8d 4a 01             	lea    0x1(%edx),%ecx
c0026df2:	89 08                	mov    %ecx,(%eax)
c0026df4:	88 1a                	mov    %bl,(%edx)
}
c0026df6:	5b                   	pop    %ebx
c0026df7:	c3                   	ret    

c0026df8 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0026df8:	55                   	push   %ebp
c0026df9:	57                   	push   %edi
c0026dfa:	56                   	push   %esi
c0026dfb:	53                   	push   %ebx
c0026dfc:	83 ec 0c             	sub    $0xc,%esp
c0026dff:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0026e03:	85 d2                	test   %edx,%edx
c0026e05:	74 1a                	je     c0026e21 <output_dup+0x29>
c0026e07:	8d 5a ff             	lea    -0x1(%edx),%ebx
c0026e0a:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c0026e0c:	0f be f0             	movsbl %al,%esi
c0026e0f:	83 ec 08             	sub    $0x8,%esp
c0026e12:	57                   	push   %edi
c0026e13:	56                   	push   %esi
c0026e14:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c0026e16:	83 eb 01             	sub    $0x1,%ebx
c0026e19:	83 c4 10             	add    $0x10,%esp
c0026e1c:	83 fb ff             	cmp    $0xffffffff,%ebx
c0026e1f:	75 ee                	jne    c0026e0f <output_dup+0x17>
}
c0026e21:	83 c4 0c             	add    $0xc,%esp
c0026e24:	5b                   	pop    %ebx
c0026e25:	5e                   	pop    %esi
c0026e26:	5f                   	pop    %edi
c0026e27:	5d                   	pop    %ebp
c0026e28:	c3                   	ret    

c0026e29 <format_integer>:
{
c0026e29:	55                   	push   %ebp
c0026e2a:	57                   	push   %edi
c0026e2b:	56                   	push   %esi
c0026e2c:	53                   	push   %ebx
c0026e2d:	83 ec 7c             	sub    $0x7c,%esp
c0026e30:	e8 06 6b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0026e35:	81 c3 97 26 01 00    	add    $0x12697,%ebx
c0026e3b:	89 c6                	mov    %eax,%esi
c0026e3d:	89 d7                	mov    %edx,%edi
c0026e3f:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  sign = 0;
c0026e46:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0026e4d:	00 
  if (is_signed) 
c0026e4e:	84 c9                	test   %cl,%cl
c0026e50:	74 1c                	je     c0026e6e <format_integer+0x45>
      if (c->flags & PLUS)
c0026e52:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0026e59:	8b 11                	mov    (%ecx),%edx
c0026e5b:	f6 c2 02             	test   $0x2,%dl
c0026e5e:	74 7e                	je     c0026ede <format_integer+0xb5>
        sign = negative ? '-' : '+';
c0026e60:	3c 01                	cmp    $0x1,%al
c0026e62:	19 c0                	sbb    %eax,%eax
c0026e64:	83 e0 fe             	and    $0xfffffffe,%eax
c0026e67:	83 c0 2d             	add    $0x2d,%eax
c0026e6a:	89 44 24 20          	mov    %eax,0x20(%esp)
  x = (c->flags & POUND) && value ? b->x : 0;
c0026e6e:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026e75:	8b 00                	mov    (%eax),%eax
c0026e77:	89 44 24 28          	mov    %eax,0x28(%esp)
c0026e7b:	83 e0 08             	and    $0x8,%eax
c0026e7e:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0026e82:	89 f1                	mov    %esi,%ecx
c0026e84:	09 f9                	or     %edi,%ecx
c0026e86:	74 04                	je     c0026e8c <format_integer+0x63>
c0026e88:	85 c0                	test   %eax,%eax
c0026e8a:	75 7c                	jne    c0026f08 <format_integer+0xdf>
c0026e8c:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0026e93:	00 
  while (value > 0) 
c0026e94:	89 fa                	mov    %edi,%edx
c0026e96:	09 f2                	or     %esi,%edx
c0026e98:	0f 84 32 02 00 00    	je     c00270d0 <format_integer+0x2a7>
      *cp++ = b->digits[value % b->base];
c0026e9e:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026ea5:	8b 40 04             	mov    0x4(%eax),%eax
c0026ea8:	89 44 24 18          	mov    %eax,0x18(%esp)
c0026eac:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026eb3:	8b 00                	mov    (%eax),%eax
c0026eb5:	89 44 24 08          	mov    %eax,0x8(%esp)
c0026eb9:	89 c1                	mov    %eax,%ecx
c0026ebb:	c1 f9 1f             	sar    $0x1f,%ecx
c0026ebe:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  digit_cnt = 0;
c0026ec2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0026ec9:	00 
  cp = buf;
c0026eca:	8d 6c 24 30          	lea    0x30(%esp),%ebp
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0026ece:	8b 44 24 28          	mov    0x28(%esp),%eax
c0026ed2:	c1 e8 05             	shr    $0x5,%eax
c0026ed5:	83 e0 01             	and    $0x1,%eax
c0026ed8:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0026edc:	eb 41                	jmp    c0026f1f <format_integer+0xf6>
      else if (c->flags & SPACE)
c0026ede:	f6 c2 04             	test   $0x4,%dl
c0026ee1:	74 13                	je     c0026ef6 <format_integer+0xcd>
        sign = negative ? '-' : ' ';
c0026ee3:	3c 01                	cmp    $0x1,%al
c0026ee5:	19 c0                	sbb    %eax,%eax
c0026ee7:	83 e0 f3             	and    $0xfffffff3,%eax
c0026eea:	83 c0 2d             	add    $0x2d,%eax
c0026eed:	89 44 24 20          	mov    %eax,0x20(%esp)
c0026ef1:	e9 78 ff ff ff       	jmp    c0026e6e <format_integer+0x45>
        sign = '-';
c0026ef6:	3c 01                	cmp    $0x1,%al
c0026ef8:	19 c0                	sbb    %eax,%eax
c0026efa:	f7 d0                	not    %eax
c0026efc:	83 e0 2d             	and    $0x2d,%eax
c0026eff:	89 44 24 20          	mov    %eax,0x20(%esp)
c0026f03:	e9 66 ff ff ff       	jmp    c0026e6e <format_integer+0x45>
  x = (c->flags & POUND) && value ? b->x : 0;
c0026f08:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0026f0f:	8b 40 08             	mov    0x8(%eax),%eax
c0026f12:	89 44 24 24          	mov    %eax,0x24(%esp)
c0026f16:	e9 79 ff ff ff       	jmp    c0026e94 <format_integer+0x6b>
c0026f1b:	8b 6c 24 10          	mov    0x10(%esp),%ebp
      *cp++ = b->digits[value % b->base];
c0026f1f:	8d 45 01             	lea    0x1(%ebp),%eax
c0026f22:	89 44 24 10          	mov    %eax,0x10(%esp)
c0026f26:	ff 74 24 0c          	pushl  0xc(%esp)
c0026f2a:	ff 74 24 0c          	pushl  0xc(%esp)
c0026f2e:	57                   	push   %edi
c0026f2f:	56                   	push   %esi
c0026f30:	e8 80 1a 00 00       	call   c00289b5 <__umoddi3>
c0026f35:	83 c4 10             	add    $0x10,%esp
c0026f38:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0026f3c:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
c0026f40:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
c0026f43:	ff 74 24 0c          	pushl  0xc(%esp)
c0026f47:	ff 74 24 0c          	pushl  0xc(%esp)
c0026f4b:	57                   	push   %edi
c0026f4c:	56                   	push   %esi
c0026f4d:	e8 47 1a 00 00       	call   c0028999 <__udivdi3>
c0026f52:	83 c4 10             	add    $0x10,%esp
c0026f55:	89 c6                	mov    %eax,%esi
c0026f57:	89 d7                	mov    %edx,%edi
      digit_cnt++;
c0026f59:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
  while (value > 0) 
c0026f5e:	09 c2                	or     %eax,%edx
c0026f60:	74 2b                	je     c0026f8d <format_integer+0x164>
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0026f62:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026f67:	74 b2                	je     c0026f1b <format_integer+0xf2>
c0026f69:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026f6d:	85 c0                	test   %eax,%eax
c0026f6f:	7e aa                	jle    c0026f1b <format_integer+0xf2>
c0026f71:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0026f78:	99                   	cltd   
c0026f79:	f7 79 0c             	idivl  0xc(%ecx)
c0026f7c:	85 d2                	test   %edx,%edx
c0026f7e:	75 9b                	jne    c0026f1b <format_integer+0xf2>
        *cp++ = ',';
c0026f80:	8d 45 02             	lea    0x2(%ebp),%eax
c0026f83:	89 44 24 10          	mov    %eax,0x10(%esp)
c0026f87:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
c0026f8b:	eb 8e                	jmp    c0026f1b <format_integer+0xf2>
c0026f8d:	8b 6c 24 10          	mov    0x10(%esp),%ebp
  precision = c->precision < 0 ? 1 : c->precision;
c0026f91:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0026f98:	8b 48 08             	mov    0x8(%eax),%ecx
c0026f9b:	85 c9                	test   %ecx,%ecx
c0026f9d:	b8 01 00 00 00       	mov    $0x1,%eax
c0026fa2:	0f 48 c8             	cmovs  %eax,%ecx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0026fa5:	8d 44 24 30          	lea    0x30(%esp),%eax
c0026fa9:	89 ea                	mov    %ebp,%edx
c0026fab:	29 c2                	sub    %eax,%edx
c0026fad:	39 d1                	cmp    %edx,%ecx
c0026faf:	7e 1f                	jle    c0026fd0 <format_integer+0x1a7>
c0026fb1:	8d 54 24 6f          	lea    0x6f(%esp),%edx
c0026fb5:	39 d5                	cmp    %edx,%ebp
c0026fb7:	73 17                	jae    c0026fd0 <format_integer+0x1a7>
c0026fb9:	89 c6                	mov    %eax,%esi
c0026fbb:	89 d7                	mov    %edx,%edi
    *cp++ = '0';
c0026fbd:	83 c5 01             	add    $0x1,%ebp
c0026fc0:	c6 45 ff 30          	movb   $0x30,-0x1(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0026fc4:	89 ea                	mov    %ebp,%edx
c0026fc6:	29 f2                	sub    %esi,%edx
c0026fc8:	39 d1                	cmp    %edx,%ecx
c0026fca:	7e 04                	jle    c0026fd0 <format_integer+0x1a7>
c0026fcc:	39 fd                	cmp    %edi,%ebp
c0026fce:	72 ed                	jb     c0026fbd <format_integer+0x194>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0026fd0:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0026fd5:	74 10                	je     c0026fe7 <format_integer+0x1be>
c0026fd7:	8b 9c 24 94 00 00 00 	mov    0x94(%esp),%ebx
c0026fde:	83 3b 08             	cmpl   $0x8,(%ebx)
c0026fe1:	0f 84 f2 00 00 00    	je     c00270d9 <format_integer+0x2b0>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0026fe7:	29 e8                	sub    %ebp,%eax
c0026fe9:	8b bc 24 98 00 00 00 	mov    0x98(%esp),%edi
c0026ff0:	03 47 04             	add    0x4(%edi),%eax
c0026ff3:	89 c6                	mov    %eax,%esi
c0026ff5:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0026ff9:	85 ff                	test   %edi,%edi
c0026ffb:	b8 02 00 00 00       	mov    $0x2,%eax
c0027000:	0f 44 c7             	cmove  %edi,%eax
c0027003:	29 c6                	sub    %eax,%esi
c0027005:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002700a:	0f 95 c0             	setne  %al
c002700d:	0f b6 c0             	movzbl %al,%eax
c0027010:	29 c6                	sub    %eax,%esi
c0027012:	b8 00 00 00 00       	mov    $0x0,%eax
c0027017:	0f 48 f0             	cmovs  %eax,%esi
  if ((c->flags & (MINUS | ZERO)) == 0)
c002701a:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c002701f:	0f 84 d2 00 00 00    	je     c00270f7 <format_integer+0x2ce>
  if (sign)
c0027025:	8b 44 24 20          	mov    0x20(%esp),%eax
c0027029:	85 c0                	test   %eax,%eax
c002702b:	74 15                	je     c0027042 <format_integer+0x219>
    output (sign, aux);
c002702d:	83 ec 08             	sub    $0x8,%esp
c0027030:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0027037:	50                   	push   %eax
c0027038:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c002703f:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0027042:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0027046:	85 ff                	test   %edi,%edi
c0027048:	74 2d                	je     c0027077 <format_integer+0x24e>
      output ('0', aux);
c002704a:	83 ec 08             	sub    $0x8,%esp
c002704d:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0027054:	6a 30                	push   $0x30
c0027056:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c002705d:	83 c4 08             	add    $0x8,%esp
c0027060:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0027067:	89 f8                	mov    %edi,%eax
c0027069:	0f be c0             	movsbl %al,%eax
c002706c:	50                   	push   %eax
c002706d:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0027074:	83 c4 10             	add    $0x10,%esp
  if (c->flags & ZERO)
c0027077:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002707e:	f6 00 10             	testb  $0x10,(%eax)
c0027081:	0f 85 95 00 00 00    	jne    c002711c <format_integer+0x2f3>
  while (cp > buf)
c0027087:	8d 44 24 30          	lea    0x30(%esp),%eax
c002708b:	89 c7                	mov    %eax,%edi
c002708d:	39 c5                	cmp    %eax,%ebp
c002708f:	76 2b                	jbe    c00270bc <format_integer+0x293>
c0027091:	89 74 24 10          	mov    %esi,0x10(%esp)
c0027095:	8b 9c 24 9c 00 00 00 	mov    0x9c(%esp),%ebx
c002709c:	8b b4 24 a0 00 00 00 	mov    0xa0(%esp),%esi
    output (*--cp, aux);
c00270a3:	83 ed 01             	sub    $0x1,%ebp
c00270a6:	83 ec 08             	sub    $0x8,%esp
c00270a9:	56                   	push   %esi
c00270aa:	0f be 45 00          	movsbl 0x0(%ebp),%eax
c00270ae:	50                   	push   %eax
c00270af:	ff d3                	call   *%ebx
  while (cp > buf)
c00270b1:	83 c4 10             	add    $0x10,%esp
c00270b4:	39 fd                	cmp    %edi,%ebp
c00270b6:	75 eb                	jne    c00270a3 <format_integer+0x27a>
c00270b8:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (c->flags & MINUS)
c00270bc:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00270c3:	f6 00 01             	testb  $0x1,(%eax)
c00270c6:	75 79                	jne    c0027141 <format_integer+0x318>
}
c00270c8:	83 c4 7c             	add    $0x7c,%esp
c00270cb:	5b                   	pop    %ebx
c00270cc:	5e                   	pop    %esi
c00270cd:	5f                   	pop    %edi
c00270ce:	5d                   	pop    %ebp
c00270cf:	c3                   	ret    
  cp = buf;
c00270d0:	8d 6c 24 30          	lea    0x30(%esp),%ebp
c00270d4:	e9 b8 fe ff ff       	jmp    c0026f91 <format_integer+0x168>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00270d9:	8d 54 24 30          	lea    0x30(%esp),%edx
c00270dd:	39 d5                	cmp    %edx,%ebp
c00270df:	74 0a                	je     c00270eb <format_integer+0x2c2>
c00270e1:	80 7d ff 30          	cmpb   $0x30,-0x1(%ebp)
c00270e5:	0f 84 fc fe ff ff    	je     c0026fe7 <format_integer+0x1be>
    *cp++ = '0';
c00270eb:	c6 45 00 30          	movb   $0x30,0x0(%ebp)
c00270ef:	8d 6d 01             	lea    0x1(%ebp),%ebp
c00270f2:	e9 f0 fe ff ff       	jmp    c0026fe7 <format_integer+0x1be>
    output_dup (' ', pad_cnt, output, aux);
c00270f7:	83 ec 0c             	sub    $0xc,%esp
c00270fa:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027101:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027108:	89 f2                	mov    %esi,%edx
c002710a:	b8 20 00 00 00       	mov    $0x20,%eax
c002710f:	e8 e4 fc ff ff       	call   c0026df8 <output_dup>
c0027114:	83 c4 10             	add    $0x10,%esp
c0027117:	e9 09 ff ff ff       	jmp    c0027025 <format_integer+0x1fc>
    output_dup ('0', pad_cnt, output, aux);
c002711c:	83 ec 0c             	sub    $0xc,%esp
c002711f:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027126:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c002712d:	89 f2                	mov    %esi,%edx
c002712f:	b8 30 00 00 00       	mov    $0x30,%eax
c0027134:	e8 bf fc ff ff       	call   c0026df8 <output_dup>
c0027139:	83 c4 10             	add    $0x10,%esp
c002713c:	e9 46 ff ff ff       	jmp    c0027087 <format_integer+0x25e>
    output_dup (' ', pad_cnt, output, aux);
c0027141:	83 ec 0c             	sub    $0xc,%esp
c0027144:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c002714b:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027152:	89 f2                	mov    %esi,%edx
c0027154:	b8 20 00 00 00       	mov    $0x20,%eax
c0027159:	e8 9a fc ff ff       	call   c0026df8 <output_dup>
c002715e:	83 c4 10             	add    $0x10,%esp
}
c0027161:	e9 62 ff ff ff       	jmp    c00270c8 <format_integer+0x29f>

c0027166 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0027166:	55                   	push   %ebp
c0027167:	57                   	push   %edi
c0027168:	56                   	push   %esi
c0027169:	53                   	push   %ebx
c002716a:	83 ec 1c             	sub    $0x1c,%esp
c002716d:	89 c5                	mov    %eax,%ebp
c002716f:	89 d6                	mov    %edx,%esi
c0027171:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0027175:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027179:	8b 51 04             	mov    0x4(%ecx),%edx
c002717c:	39 f2                	cmp    %esi,%edx
c002717e:	7e 3f                	jle    c00271bf <format_string+0x59>
c0027180:	f6 01 01             	testb  $0x1,(%ecx)
c0027183:	74 1d                	je     c00271a2 <format_string+0x3c>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0027185:	85 f6                	test   %esi,%esi
c0027187:	7f 3a                	jg     c00271c3 <format_string+0x5d>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c0027189:	29 f2                	sub    %esi,%edx
c002718b:	83 ec 0c             	sub    $0xc,%esp
c002718e:	57                   	push   %edi
c002718f:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027193:	b8 20 00 00 00       	mov    $0x20,%eax
c0027198:	e8 5b fc ff ff       	call   c0026df8 <output_dup>
c002719d:	83 c4 10             	add    $0x10,%esp
}
c00271a0:	eb 4e                	jmp    c00271f0 <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
c00271a2:	29 f2                	sub    %esi,%edx
c00271a4:	83 ec 0c             	sub    $0xc,%esp
c00271a7:	57                   	push   %edi
c00271a8:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c00271ac:	b8 20 00 00 00       	mov    $0x20,%eax
c00271b1:	e8 42 fc ff ff       	call   c0026df8 <output_dup>
  for (i = 0; i < length; i++)
c00271b6:	83 c4 10             	add    $0x10,%esp
c00271b9:	85 f6                	test   %esi,%esi
c00271bb:	7f 06                	jg     c00271c3 <format_string+0x5d>
c00271bd:	eb 21                	jmp    c00271e0 <format_string+0x7a>
c00271bf:	85 f6                	test   %esi,%esi
c00271c1:	7e 2d                	jle    c00271f0 <format_string+0x8a>
{
c00271c3:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c00271c8:	83 ec 08             	sub    $0x8,%esp
c00271cb:	57                   	push   %edi
c00271cc:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c00271d1:	50                   	push   %eax
c00271d2:	ff 54 24 40          	call   *0x40(%esp)
  for (i = 0; i < length; i++)
c00271d6:	83 c3 01             	add    $0x1,%ebx
c00271d9:	83 c4 10             	add    $0x10,%esp
c00271dc:	39 de                	cmp    %ebx,%esi
c00271de:	7f e8                	jg     c00271c8 <format_string+0x62>
  if (c->width > length && (c->flags & MINUS) != 0)
c00271e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00271e4:	8b 50 04             	mov    0x4(%eax),%edx
c00271e7:	39 f2                	cmp    %esi,%edx
c00271e9:	7e 05                	jle    c00271f0 <format_string+0x8a>
c00271eb:	f6 00 01             	testb  $0x1,(%eax)
c00271ee:	75 99                	jne    c0027189 <format_string+0x23>
}
c00271f0:	83 c4 1c             	add    $0x1c,%esp
c00271f3:	5b                   	pop    %ebx
c00271f4:	5e                   	pop    %esi
c00271f5:	5f                   	pop    %edi
c00271f6:	5d                   	pop    %ebp
c00271f7:	c3                   	ret    

c00271f8 <printf>:
{
c00271f8:	53                   	push   %ebx
c00271f9:	83 ec 08             	sub    $0x8,%esp
c00271fc:	e8 3a 67 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0027201:	81 c3 cb 22 01 00    	add    $0x122cb,%ebx
  va_start (args, format);
c0027207:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c002720b:	83 ec 08             	sub    $0x8,%esp
c002720e:	50                   	push   %eax
c002720f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027213:	e8 58 3c 00 00       	call   c002ae70 <vprintf>
}
c0027218:	83 c4 18             	add    $0x18,%esp
c002721b:	5b                   	pop    %ebx
c002721c:	c3                   	ret    

c002721d <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c002721d:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c0027220:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c0027224:	ff 74 24 18          	pushl  0x18(%esp)
c0027228:	ff 74 24 18          	pushl  0x18(%esp)
c002722c:	50                   	push   %eax
c002722d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027231:	e8 04 00 00 00       	call   c002723a <__vprintf>
  va_end (args);
}
c0027236:	83 c4 1c             	add    $0x1c,%esp
c0027239:	c3                   	ret    

c002723a <__vprintf>:
{
c002723a:	55                   	push   %ebp
c002723b:	57                   	push   %edi
c002723c:	56                   	push   %esi
c002723d:	53                   	push   %ebx
c002723e:	83 ec 5c             	sub    $0x5c,%esp
c0027241:	e8 f9 66 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0027246:	05 86 22 01 00       	add    $0x12286,%eax
c002724b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002724f:	8b 74 24 70          	mov    0x70(%esp),%esi
c0027253:	8b 7c 24 78          	mov    0x78(%esp),%edi
c0027257:	8b 6c 24 7c          	mov    0x7c(%esp),%ebp
  for (; *format != '\0'; format++)
c002725b:	0f b6 06             	movzbl (%esi),%eax
c002725e:	84 c0                	test   %al,%al
c0027260:	75 27                	jne    c0027289 <__vprintf+0x4f>
}
c0027262:	83 c4 5c             	add    $0x5c,%esp
c0027265:	5b                   	pop    %ebx
c0027266:	5e                   	pop    %esi
c0027267:	5f                   	pop    %edi
c0027268:	5d                   	pop    %ebp
c0027269:	c3                   	ret    
      format++;
c002726a:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c002726d:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0027271:	75 2b                	jne    c002729e <__vprintf+0x64>
          output ('%', aux);
c0027273:	83 ec 08             	sub    $0x8,%esp
c0027276:	55                   	push   %ebp
c0027277:	6a 25                	push   $0x25
c0027279:	ff d7                	call   *%edi
          continue;
c002727b:	83 c4 10             	add    $0x10,%esp
  for (; *format != '\0'; format++)
c002727e:	8d 73 01             	lea    0x1(%ebx),%esi
c0027281:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027285:	84 c0                	test   %al,%al
c0027287:	74 d9                	je     c0027262 <__vprintf+0x28>
      if (*format != '%') 
c0027289:	3c 25                	cmp    $0x25,%al
c002728b:	74 dd                	je     c002726a <__vprintf+0x30>
          output (*format, aux);
c002728d:	83 ec 08             	sub    $0x8,%esp
c0027290:	55                   	push   %ebp
c0027291:	0f be c0             	movsbl %al,%eax
c0027294:	50                   	push   %eax
c0027295:	ff d7                	call   *%edi
          continue;
c0027297:	83 c4 10             	add    $0x10,%esp
c002729a:	89 f3                	mov    %esi,%ebx
c002729c:	eb e0                	jmp    c002727e <__vprintf+0x44>
  c->flags = 0;
c002729e:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
c00272a5:	00 
c00272a6:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
c00272ab:	be 00 00 00 00       	mov    $0x0,%esi
c00272b0:	89 7c 24 78          	mov    %edi,0x78(%esp)
c00272b4:	89 6c 24 7c          	mov    %ebp,0x7c(%esp)
c00272b8:	eb 0a                	jmp    c00272c4 <.L79+0xa>

c00272ba <.L79>:
          c->flags |= MINUS;
c00272ba:	83 ce 01             	or     $0x1,%esi
c00272bd:	c6 44 24 18 01       	movb   $0x1,0x18(%esp)
      switch (*format++) 
c00272c2:	89 cb                	mov    %ecx,%ebx
c00272c4:	8d 4b 01             	lea    0x1(%ebx),%ecx
c00272c7:	0f b6 51 ff          	movzbl -0x1(%ecx),%edx
c00272cb:	8d 42 e0             	lea    -0x20(%edx),%eax
c00272ce:	3c 10                	cmp    $0x10,%al
c00272d0:	77 2b                	ja     c00272fd <.L73>
c00272d2:	0f b6 c0             	movzbl %al,%eax
c00272d5:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c00272d9:	89 fd                	mov    %edi,%ebp
c00272db:	03 ac 87 44 4a ff ff 	add    -0xb5bc(%edi,%eax,4),%ebp
c00272e2:	ff e5                	jmp    *%ebp

c00272e4 <.L78>:
          c->flags |= PLUS;
c00272e4:	83 ce 02             	or     $0x2,%esi
c00272e7:	eb d4                	jmp    c00272bd <.L79+0x3>

c00272e9 <.L74>:
          c->flags |= SPACE;
c00272e9:	83 ce 04             	or     $0x4,%esi
c00272ec:	eb cf                	jmp    c00272bd <.L79+0x3>

c00272ee <.L76>:
          c->flags |= POUND;
c00272ee:	83 ce 08             	or     $0x8,%esi
c00272f1:	eb ca                	jmp    c00272bd <.L79+0x3>

c00272f3 <.L80>:
          c->flags |= ZERO;
c00272f3:	83 ce 10             	or     $0x10,%esi
c00272f6:	eb c5                	jmp    c00272bd <.L79+0x3>

c00272f8 <.L77>:
          c->flags |= GROUP;
c00272f8:	83 ce 20             	or     $0x20,%esi
c00272fb:	eb c0                	jmp    c00272bd <.L79+0x3>

c00272fd <.L73>:
c00272fd:	8b 7c 24 78          	mov    0x78(%esp),%edi
c0027301:	8b 6c 24 7c          	mov    0x7c(%esp),%ebp
c0027305:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
c002730a:	0f 85 9e 00 00 00    	jne    c00273ae <.L73+0xb1>
  if (c->flags & PLUS)
c0027310:	8b 44 24 40          	mov    0x40(%esp),%eax
c0027314:	a8 02                	test   $0x2,%al
c0027316:	74 07                	je     c002731f <.L73+0x22>
    c->flags &= ~SPACE;
c0027318:	83 e0 fb             	and    $0xfffffffb,%eax
c002731b:	89 44 24 40          	mov    %eax,0x40(%esp)
  c->width = 0;
c002731f:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
c0027326:	00 
  if (*format == '*')
c0027327:	80 fa 2a             	cmp    $0x2a,%dl
c002732a:	0f 84 9a 00 00 00    	je     c00273ca <.L73+0xcd>
      for (; isdigit (*format); format++)
c0027330:	0f be d2             	movsbl %dl,%edx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027333:	8d 4a d0             	lea    -0x30(%edx),%ecx
c0027336:	b8 00 00 00 00       	mov    $0x0,%eax
c002733b:	83 f9 09             	cmp    $0x9,%ecx
c002733e:	77 25                	ja     c0027365 <.L73+0x68>
        c->width = c->width * 10 + *format - '0';
c0027340:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0027343:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
      for (; isdigit (*format); format++)
c0027347:	83 c3 01             	add    $0x1,%ebx
c002734a:	0f be 13             	movsbl (%ebx),%edx
c002734d:	8d 4a d0             	lea    -0x30(%edx),%ecx
c0027350:	83 f9 09             	cmp    $0x9,%ecx
c0027353:	76 eb                	jbe    c0027340 <.L73+0x43>
c0027355:	89 44 24 44          	mov    %eax,0x44(%esp)
  if (c->width < 0) 
c0027359:	8b 44 24 44          	mov    0x44(%esp),%eax
c002735d:	85 c0                	test   %eax,%eax
c002735f:	0f 88 81 00 00 00    	js     c00273e6 <.L73+0xe9>
  c->precision = -1;
c0027365:	c7 44 24 48 ff ff ff 	movl   $0xffffffff,0x48(%esp)
c002736c:	ff 
  if (*format == '.') 
c002736d:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c0027370:	0f 84 80 00 00 00    	je     c00273f6 <.L73+0xf9>
  if (c->precision >= 0)
c0027376:	8b 44 24 48          	mov    0x48(%esp),%eax
c002737a:	89 44 24 10          	mov    %eax,0x10(%esp)
  c->type = INT;
c002737e:	c7 44 24 4c 03 00 00 	movl   $0x3,0x4c(%esp)
c0027385:	00 
  switch (*format++) 
c0027386:	8d 43 01             	lea    0x1(%ebx),%eax
c0027389:	89 44 24 18          	mov    %eax,0x18(%esp)
c002738d:	0f b6 03             	movzbl (%ebx),%eax
c0027390:	8d 50 98             	lea    -0x68(%eax),%edx
c0027393:	80 fa 12             	cmp    $0x12,%dl
c0027396:	0f 87 44 02 00 00    	ja     c00275e0 <.L93>
c002739c:	0f b6 d2             	movzbl %dl,%edx
c002739f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00273a3:	89 ce                	mov    %ecx,%esi
c00273a5:	03 b4 91 88 4a ff ff 	add    -0xb578(%ecx,%edx,4),%esi
c00273ac:	ff e6                	jmp    *%esi
c00273ae:	89 74 24 40          	mov    %esi,0x40(%esp)
  if (c->flags & MINUS)
c00273b2:	f7 c6 01 00 00 00    	test   $0x1,%esi
c00273b8:	0f 84 52 ff ff ff    	je     c0027310 <.L73+0x13>
    c->flags &= ~ZERO;
c00273be:	83 e6 ef             	and    $0xffffffef,%esi
c00273c1:	89 74 24 40          	mov    %esi,0x40(%esp)
c00273c5:	e9 46 ff ff ff       	jmp    c0027310 <.L73+0x13>
      c->width = va_arg (*args, int);
c00273ca:	8b 44 24 74          	mov    0x74(%esp),%eax
c00273ce:	8b 00                	mov    (%eax),%eax
c00273d0:	89 44 24 44          	mov    %eax,0x44(%esp)
c00273d4:	8b 44 24 74          	mov    0x74(%esp),%eax
c00273d8:	8d 40 04             	lea    0x4(%eax),%eax
c00273db:	89 44 24 74          	mov    %eax,0x74(%esp)
      switch (*format++) 
c00273df:	89 cb                	mov    %ecx,%ebx
c00273e1:	e9 73 ff ff ff       	jmp    c0027359 <.L73+0x5c>
      c->width = -c->width;
c00273e6:	f7 d8                	neg    %eax
c00273e8:	89 44 24 44          	mov    %eax,0x44(%esp)
      c->flags |= MINUS;
c00273ec:	83 4c 24 40 01       	orl    $0x1,0x40(%esp)
c00273f1:	e9 6f ff ff ff       	jmp    c0027365 <.L73+0x68>
      if (*format == '*') 
c00273f6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00273fa:	3c 2a                	cmp    $0x2a,%al
c00273fc:	74 4a                	je     c0027448 <.L73+0x14b>
      format++;
c00273fe:	83 c3 01             	add    $0x1,%ebx
          c->precision = 0;
c0027401:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
c0027408:	00 
          for (; isdigit (*format); format++)
c0027409:	0f be c0             	movsbl %al,%eax
c002740c:	8d 50 d0             	lea    -0x30(%eax),%edx
c002740f:	83 fa 09             	cmp    $0x9,%edx
c0027412:	77 5b                	ja     c002746f <.L73+0x172>
c0027414:	ba 00 00 00 00       	mov    $0x0,%edx
            c->precision = c->precision * 10 + *format - '0';
c0027419:	8d 14 92             	lea    (%edx,%edx,4),%edx
c002741c:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
          for (; isdigit (*format); format++)
c0027420:	83 c3 01             	add    $0x1,%ebx
c0027423:	0f be 03             	movsbl (%ebx),%eax
c0027426:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027429:	83 f9 09             	cmp    $0x9,%ecx
c002742c:	76 eb                	jbe    c0027419 <.L73+0x11c>
c002742e:	89 54 24 48          	mov    %edx,0x48(%esp)
      if (c->precision < 0) 
c0027432:	8b 44 24 48          	mov    0x48(%esp),%eax
c0027436:	89 44 24 10          	mov    %eax,0x10(%esp)
c002743a:	85 c0                	test   %eax,%eax
c002743c:	78 24                	js     c0027462 <.L73+0x165>
    c->flags &= ~ZERO;
c002743e:	83 64 24 40 ef       	andl   $0xffffffef,0x40(%esp)
c0027443:	e9 36 ff ff ff       	jmp    c002737e <.L73+0x81>
          format++;
c0027448:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c002744b:	8b 44 24 74          	mov    0x74(%esp),%eax
c002744f:	8b 00                	mov    (%eax),%eax
c0027451:	89 44 24 48          	mov    %eax,0x48(%esp)
c0027455:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027459:	8d 40 04             	lea    0x4(%eax),%eax
c002745c:	89 44 24 74          	mov    %eax,0x74(%esp)
c0027460:	eb d0                	jmp    c0027432 <.L73+0x135>
        c->precision = -1;
c0027462:	c7 44 24 48 ff ff ff 	movl   $0xffffffff,0x48(%esp)
c0027469:	ff 
c002746a:	e9 07 ff ff ff       	jmp    c0027376 <.L73+0x79>
  if (c->precision >= 0)
c002746f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0027476:	00 
c0027477:	eb c5                	jmp    c002743e <.L73+0x141>

c0027479 <.L94>:
      if (*format == 'h') 
c0027479:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002747d:	3c 68                	cmp    $0x68,%al
c002747f:	74 2d                	je     c00274ae <.L94+0x35>
        c->type = SHORT;
c0027481:	c7 44 24 4c 02 00 00 	movl   $0x2,0x4c(%esp)
c0027488:	00 
      switch (*format) 
c0027489:	0f be d0             	movsbl %al,%edx
c002748c:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0027490:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027493:	80 f9 33             	cmp    $0x33,%cl
c0027496:	0f 87 dd 05 00 00    	ja     c0027a79 <.L101>
c002749c:	0f b6 c9             	movzbl %cl,%ecx
c002749f:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00274a3:	89 d6                	mov    %edx,%esi
c00274a5:	03 b4 8a d4 4a ff ff 	add    -0xb52c(%edx,%ecx,4),%esi
c00274ac:	ff e6                	jmp    *%esi
          format++;
c00274ae:	8d 43 02             	lea    0x2(%ebx),%eax
c00274b1:	89 44 24 18          	mov    %eax,0x18(%esp)
          c->type = CHAR;
c00274b5:	c7 44 24 4c 01 00 00 	movl   $0x1,0x4c(%esp)
c00274bc:	00 
      switch (*format) 
c00274bd:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c00274c1:	0f be d0             	movsbl %al,%edx
c00274c4:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c00274c8:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00274cb:	80 f9 33             	cmp    $0x33,%cl
c00274ce:	0f 87 a5 05 00 00    	ja     c0027a79 <.L101>
c00274d4:	0f b6 c9             	movzbl %cl,%ecx
c00274d7:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00274db:	89 d6                	mov    %edx,%esi
c00274dd:	03 b4 8a a4 4b ff ff 	add    -0xb45c(%edx,%ecx,4),%esi
c00274e4:	ff e6                	jmp    *%esi

c00274e6 <.L96>:
      c->type = INTMAX;
c00274e6:	c7 44 24 4c 04 00 00 	movl   $0x4,0x4c(%esp)
c00274ed:	00 
      switch (*format) 
c00274ee:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00274f2:	0f be c8             	movsbl %al,%ecx
c00274f5:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c00274f9:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00274fc:	80 f9 33             	cmp    $0x33,%cl
c00274ff:	0f 87 74 05 00 00    	ja     c0027a79 <.L101>
c0027505:	0f b6 c9             	movzbl %cl,%ecx
c0027508:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002750c:	03 9c 8b 74 4c ff ff 	add    -0xb38c(%ebx,%ecx,4),%ebx
c0027513:	ff e3                	jmp    *%ebx

c0027515 <.L97>:
      if (*format == 'l')
c0027515:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027519:	3c 6c                	cmp    $0x6c,%al
c002751b:	74 2d                	je     c002754a <.L97+0x35>
        c->type = LONG;
c002751d:	c7 44 24 4c 05 00 00 	movl   $0x5,0x4c(%esp)
c0027524:	00 
      switch (*format) 
c0027525:	0f be d0             	movsbl %al,%edx
c0027528:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c002752c:	8d 48 bb             	lea    -0x45(%eax),%ecx
c002752f:	80 f9 33             	cmp    $0x33,%cl
c0027532:	0f 87 41 05 00 00    	ja     c0027a79 <.L101>
c0027538:	0f b6 c9             	movzbl %cl,%ecx
c002753b:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002753f:	89 d6                	mov    %edx,%esi
c0027541:	03 b4 8a 44 4d ff ff 	add    -0xb2bc(%edx,%ecx,4),%esi
c0027548:	ff e6                	jmp    *%esi
          format++;
c002754a:	8d 43 02             	lea    0x2(%ebx),%eax
c002754d:	89 44 24 18          	mov    %eax,0x18(%esp)
          c->type = LONGLONG;
c0027551:	c7 44 24 4c 06 00 00 	movl   $0x6,0x4c(%esp)
c0027558:	00 
      switch (*format) 
c0027559:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c002755d:	0f be c8             	movsbl %al,%ecx
c0027560:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027564:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027567:	80 f9 33             	cmp    $0x33,%cl
c002756a:	0f 87 09 05 00 00    	ja     c0027a79 <.L101>
c0027570:	0f b6 c9             	movzbl %cl,%ecx
c0027573:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027577:	89 d6                	mov    %edx,%esi
c0027579:	03 b4 8a 14 4e ff ff 	add    -0xb1ec(%edx,%ecx,4),%esi
c0027580:	ff e6                	jmp    *%esi

c0027582 <.L98>:
      c->type = PTRDIFFT;
c0027582:	c7 44 24 4c 07 00 00 	movl   $0x7,0x4c(%esp)
c0027589:	00 
      switch (*format) 
c002758a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002758e:	0f be c8             	movsbl %al,%ecx
c0027591:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027595:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027598:	80 f9 33             	cmp    $0x33,%cl
c002759b:	0f 87 d8 04 00 00    	ja     c0027a79 <.L101>
c00275a1:	0f b6 c9             	movzbl %cl,%ecx
c00275a4:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00275a8:	03 9c 8b e4 4e ff ff 	add    -0xb11c(%ebx,%ecx,4),%ebx
c00275af:	ff e3                	jmp    *%ebx

c00275b1 <.L99>:
      c->type = SIZET;
c00275b1:	c7 44 24 4c 08 00 00 	movl   $0x8,0x4c(%esp)
c00275b8:	00 
      switch (*format) 
c00275b9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00275bd:	0f be c8             	movsbl %al,%ecx
c00275c0:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c00275c4:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00275c7:	80 f9 33             	cmp    $0x33,%cl
c00275ca:	0f 87 a9 04 00 00    	ja     c0027a79 <.L101>
c00275d0:	0f b6 c9             	movzbl %cl,%ecx
c00275d3:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00275d7:	03 9c 8b b4 4f ff ff 	add    -0xb04c(%ebx,%ecx,4),%ebx
c00275de:	ff e3                	jmp    *%ebx

c00275e0 <.L93>:
c00275e0:	0f be c8             	movsbl %al,%ecx
c00275e3:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c00275e7:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00275ea:	80 f9 33             	cmp    $0x33,%cl
c00275ed:	0f 87 82 04 00 00    	ja     c0027a75 <.L150>
c00275f3:	0f b6 c9             	movzbl %cl,%ecx
c00275f6:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00275fa:	03 94 8a 84 50 ff ff 	add    -0xaf7c(%edx,%ecx,4),%edx
c0027601:	ff e2                	jmp    *%edx

c0027603 <.L153>:
c0027603:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027607 <.L106>:
            switch (c.type) 
c0027607:	83 7c 24 4c 08       	cmpl   $0x8,0x4c(%esp)
c002760c:	0f 87 8b 01 00 00    	ja     c002779d <.L124>
c0027612:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0027616:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c002761a:	03 8c 81 54 51 ff ff 	add    -0xaeac(%ecx,%eax,4),%ecx
c0027621:	ff e1                	jmp    *%ecx

c0027623 <.L125>:
                value = (signed char) va_arg (args, int);
c0027623:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027627:	0f be 08             	movsbl (%eax),%ecx
c002762a:	89 c8                	mov    %ecx,%eax
c002762c:	99                   	cltd   
c002762d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027631:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027635:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027639:	8d 40 04             	lea    0x4(%eax),%eax
c002763c:	89 44 24 74          	mov    %eax,0x74(%esp)
            format_integer (value < 0 ? -value : value,
c0027640:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027644:	8b 74 24 14          	mov    0x14(%esp),%esi
c0027648:	89 f2                	mov    %esi,%edx
c002764a:	c1 fa 1f             	sar    $0x1f,%edx
c002764d:	89 d1                	mov    %edx,%ecx
c002764f:	31 d9                	xor    %ebx,%ecx
c0027651:	89 4c 24 28          	mov    %ecx,0x28(%esp)
c0027655:	89 d1                	mov    %edx,%ecx
c0027657:	33 4c 24 14          	xor    0x14(%esp),%ecx
c002765b:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
c002765f:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0027663:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c0027667:	29 d1                	sub    %edx,%ecx
c0027669:	19 d3                	sbb    %edx,%ebx
c002766b:	89 c8                	mov    %ecx,%eax
c002766d:	89 da                	mov    %ebx,%edx
c002766f:	83 ec 0c             	sub    $0xc,%esp
c0027672:	55                   	push   %ebp
c0027673:	57                   	push   %edi
c0027674:	8d 4c 24 54          	lea    0x54(%esp),%ecx
c0027678:	51                   	push   %ecx
c0027679:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002767d:	8d 89 a4 05 00 00    	lea    0x5a4(%ecx),%ecx
c0027683:	51                   	push   %ecx
c0027684:	8b 4c 24 30          	mov    0x30(%esp),%ecx
c0027688:	c1 e9 1f             	shr    $0x1f,%ecx
c002768b:	51                   	push   %ecx
c002768c:	b9 01 00 00 00       	mov    $0x1,%ecx
c0027691:	e8 93 f7 ff ff       	call   c0026e29 <format_integer>
          break;
c0027696:	83 c4 20             	add    $0x20,%esp
c0027699:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002769d:	e9 dc fb ff ff       	jmp    c002727e <__vprintf+0x44>

c00276a2 <.L127>:
                value = (short) va_arg (args, int);
c00276a2:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276a6:	0f bf 08             	movswl (%eax),%ecx
c00276a9:	89 c8                	mov    %ecx,%eax
c00276ab:	99                   	cltd   
c00276ac:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00276b0:	89 54 24 14          	mov    %edx,0x14(%esp)
c00276b4:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276b8:	8d 40 04             	lea    0x4(%eax),%eax
c00276bb:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c00276bf:	e9 7c ff ff ff       	jmp    c0027640 <.L125+0x1d>

c00276c4 <.L128>:
                value = va_arg (args, int);
c00276c4:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276c8:	8b 08                	mov    (%eax),%ecx
c00276ca:	89 c8                	mov    %ecx,%eax
c00276cc:	99                   	cltd   
c00276cd:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00276d1:	89 54 24 14          	mov    %edx,0x14(%esp)
c00276d5:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276d9:	8d 40 04             	lea    0x4(%eax),%eax
c00276dc:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c00276e0:	e9 5b ff ff ff       	jmp    c0027640 <.L125+0x1d>

c00276e5 <.L129>:
                value = va_arg (args, intmax_t);
c00276e5:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276e9:	8b 50 04             	mov    0x4(%eax),%edx
c00276ec:	8b 00                	mov    (%eax),%eax
c00276ee:	89 44 24 10          	mov    %eax,0x10(%esp)
c00276f2:	89 54 24 14          	mov    %edx,0x14(%esp)
c00276f6:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276fa:	8d 40 08             	lea    0x8(%eax),%eax
c00276fd:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027701:	e9 3a ff ff ff       	jmp    c0027640 <.L125+0x1d>

c0027706 <.L130>:
                value = va_arg (args, long);
c0027706:	8b 44 24 74          	mov    0x74(%esp),%eax
c002770a:	8b 08                	mov    (%eax),%ecx
c002770c:	89 c8                	mov    %ecx,%eax
c002770e:	99                   	cltd   
c002770f:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027713:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027717:	8b 44 24 74          	mov    0x74(%esp),%eax
c002771b:	8d 40 04             	lea    0x4(%eax),%eax
c002771e:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027722:	e9 19 ff ff ff       	jmp    c0027640 <.L125+0x1d>

c0027727 <.L131>:
                value = va_arg (args, long long);
c0027727:	8b 44 24 74          	mov    0x74(%esp),%eax
c002772b:	8b 50 04             	mov    0x4(%eax),%edx
c002772e:	8b 00                	mov    (%eax),%eax
c0027730:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027734:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027738:	8b 44 24 74          	mov    0x74(%esp),%eax
c002773c:	8d 40 08             	lea    0x8(%eax),%eax
c002773f:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027743:	e9 f8 fe ff ff       	jmp    c0027640 <.L125+0x1d>

c0027748 <.L132>:
                value = va_arg (args, ptrdiff_t);
c0027748:	8b 44 24 74          	mov    0x74(%esp),%eax
c002774c:	8b 08                	mov    (%eax),%ecx
c002774e:	89 c8                	mov    %ecx,%eax
c0027750:	99                   	cltd   
c0027751:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027755:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027759:	8b 44 24 74          	mov    0x74(%esp),%eax
c002775d:	8d 40 04             	lea    0x4(%eax),%eax
c0027760:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027764:	e9 d7 fe ff ff       	jmp    c0027640 <.L125+0x1d>

c0027769 <.L133>:
                value = va_arg (args, size_t);
c0027769:	8b 44 24 74          	mov    0x74(%esp),%eax
c002776d:	83 c0 04             	add    $0x4,%eax
c0027770:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027774:	8b 0a                	mov    (%edx),%ecx
c0027776:	bb 00 00 00 00       	mov    $0x0,%ebx
c002777b:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c002777f:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c0027783:	89 44 24 74          	mov    %eax,0x74(%esp)
                if (value > SIZE_MAX / 2)
c0027787:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
c002778d:	0f 86 ad fe ff ff    	jbe    c0027640 <.L125+0x1d>
                  value = value - SIZE_MAX - 1;
c0027793:	83 6c 24 14 01       	subl   $0x1,0x14(%esp)
c0027798:	e9 a3 fe ff ff       	jmp    c0027640 <.L125+0x1d>

c002779d <.L124>:
                NOT_REACHED ();
c002779d:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00277a1:	8d 83 78 5a ff ff    	lea    -0xa588(%ebx),%eax
c00277a7:	50                   	push   %eax
c00277a8:	8d 83 78 51 ff ff    	lea    -0xae88(%ebx),%eax
c00277ae:	50                   	push   %eax
c00277af:	68 dc 00 00 00       	push   $0xdc
c00277b4:	8d 83 bd 6c ff ff    	lea    -0x9343(%ebx),%eax
c00277ba:	50                   	push   %eax
c00277bb:	e8 cf 17 00 00       	call   c0028f8f <debug_panic>

c00277c0 <.L123>:
                value = va_arg (args, unsigned);
c00277c0:	8b 54 24 74          	mov    0x74(%esp),%edx
c00277c4:	8b 12                	mov    (%edx),%edx
c00277c6:	b9 00 00 00 00       	mov    $0x0,%ecx
c00277cb:	89 54 24 20          	mov    %edx,0x20(%esp)
c00277cf:	89 4c 24 24          	mov    %ecx,0x24(%esp)
c00277d3:	8b 54 24 74          	mov    0x74(%esp),%edx
c00277d7:	8d 52 04             	lea    0x4(%edx),%edx
c00277da:	89 54 24 74          	mov    %edx,0x74(%esp)
            switch (*format) 
c00277de:	3c 6f                	cmp    $0x6f,%al
c00277e0:	0f 84 81 01 00 00    	je     c0027967 <.L121+0x87>
c00277e6:	3c 6f                	cmp    $0x6f,%al
c00277e8:	0f 8e 15 01 00 00    	jle    c0027903 <.L121+0x23>
c00277ee:	3c 75                	cmp    $0x75,%al
c00277f0:	0f 84 1d 01 00 00    	je     c0027913 <.L121+0x33>
c00277f6:	3c 78                	cmp    $0x78,%al
c00277f8:	0f 85 46 01 00 00    	jne    c0027944 <.L121+0x64>
              case 'x': b = &base_x; break;
c00277fe:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027802:	8d 80 84 05 00 00    	lea    0x584(%eax),%eax
c0027808:	e9 10 01 00 00       	jmp    c002791d <.L121+0x3d>

c002780d <.L104>:
                value = (unsigned char) va_arg (args, unsigned);
c002780d:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027811:	0f b6 12             	movzbl (%edx),%edx
c0027814:	89 54 24 20          	mov    %edx,0x20(%esp)
c0027818:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c002781f:	00 
                break;
c0027820:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = (unsigned char) va_arg (args, unsigned);
c0027824:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027828:	8d 52 04             	lea    0x4(%edx),%edx
c002782b:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c002782f:	eb ad                	jmp    c00277de <.L123+0x1e>

c0027831 <.L110>:
                value = (unsigned short) va_arg (args, unsigned);
c0027831:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027835:	0f b7 12             	movzwl (%edx),%edx
c0027838:	89 54 24 20          	mov    %edx,0x20(%esp)
c002783c:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027843:	00 
                break;
c0027844:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = (unsigned short) va_arg (args, unsigned);
c0027848:	8b 54 24 74          	mov    0x74(%esp),%edx
c002784c:	8d 52 04             	lea    0x4(%edx),%edx
c002784f:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027853:	eb 89                	jmp    c00277de <.L123+0x1e>

c0027855 <.L112>:
                value = va_arg (args, uintmax_t);
c0027855:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027859:	8b 0a                	mov    (%edx),%ecx
c002785b:	8b 5a 04             	mov    0x4(%edx),%ebx
c002785e:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027862:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c0027866:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, uintmax_t);
c002786a:	8d 52 08             	lea    0x8(%edx),%edx
c002786d:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027871:	e9 68 ff ff ff       	jmp    c00277de <.L123+0x1e>

c0027876 <.L117>:
                value = va_arg (args, unsigned long);
c0027876:	8b 54 24 74          	mov    0x74(%esp),%edx
c002787a:	8b 0a                	mov    (%edx),%ecx
c002787c:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027881:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027885:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c0027889:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, unsigned long);
c002788d:	8d 52 04             	lea    0x4(%edx),%edx
c0027890:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027894:	e9 45 ff ff ff       	jmp    c00277de <.L123+0x1e>

c0027899 <.L115>:
                value = va_arg (args, unsigned long long);
c0027899:	8b 4c 24 74          	mov    0x74(%esp),%ecx
c002789d:	8b 59 04             	mov    0x4(%ecx),%ebx
c00278a0:	8b 09                	mov    (%ecx),%ecx
c00278a2:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c00278a6:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c00278aa:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, unsigned long long);
c00278ae:	8b 54 24 74          	mov    0x74(%esp),%edx
c00278b2:	8d 4a 08             	lea    0x8(%edx),%ecx
c00278b5:	89 4c 24 74          	mov    %ecx,0x74(%esp)
                break;
c00278b9:	e9 20 ff ff ff       	jmp    c00277de <.L123+0x1e>

c00278be <.L119>:
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c00278be:	8b 54 24 74          	mov    0x74(%esp),%edx
c00278c2:	8b 0a                	mov    (%edx),%ecx
c00278c4:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c00278c8:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00278cf:	00 
                break;
c00278d0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, ptrdiff_t);
c00278d4:	8d 4a 04             	lea    0x4(%edx),%ecx
c00278d7:	89 4c 24 74          	mov    %ecx,0x74(%esp)
                break;
c00278db:	e9 fe fe ff ff       	jmp    c00277de <.L123+0x1e>

c00278e0 <.L121>:
                value = va_arg (args, size_t);
c00278e0:	8b 54 24 74          	mov    0x74(%esp),%edx
c00278e4:	8b 0a                	mov    (%edx),%ecx
c00278e6:	bb 00 00 00 00       	mov    $0x0,%ebx
c00278eb:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c00278ef:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c00278f3:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, size_t);
c00278f7:	8d 52 04             	lea    0x4(%edx),%edx
c00278fa:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c00278fe:	e9 db fe ff ff       	jmp    c00277de <.L123+0x1e>
            switch (*format) 
c0027903:	3c 58                	cmp    $0x58,%al
c0027905:	75 3d                	jne    c0027944 <.L121+0x64>
              case 'X': b = &base_X; break;
c0027907:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002790b:	8d 80 74 05 00 00    	lea    0x574(%eax),%eax
c0027911:	eb 0a                	jmp    c002791d <.L121+0x3d>
              case 'u': b = &base_d; break;
c0027913:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027917:	8d 80 a4 05 00 00    	lea    0x5a4(%eax),%eax
            format_integer (value, false, false, b, &c, output, aux);
c002791d:	83 ec 0c             	sub    $0xc,%esp
c0027920:	55                   	push   %ebp
c0027921:	57                   	push   %edi
c0027922:	8d 54 24 54          	lea    0x54(%esp),%edx
c0027926:	52                   	push   %edx
c0027927:	50                   	push   %eax
c0027928:	6a 00                	push   $0x0
c002792a:	b9 00 00 00 00       	mov    $0x0,%ecx
c002792f:	8b 44 24 40          	mov    0x40(%esp),%eax
c0027933:	8b 54 24 44          	mov    0x44(%esp),%edx
c0027937:	e8 ed f4 ff ff       	call   c0026e29 <format_integer>
          break;
c002793c:	83 c4 20             	add    $0x20,%esp
c002793f:	e9 3a f9 ff ff       	jmp    c002727e <__vprintf+0x44>
              default: NOT_REACHED ();
c0027944:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027948:	8d 83 78 5a ff ff    	lea    -0xa588(%ebx),%eax
c002794e:	50                   	push   %eax
c002794f:	8d 83 78 51 ff ff    	lea    -0xae88(%ebx),%eax
c0027955:	50                   	push   %eax
c0027956:	68 14 01 00 00       	push   $0x114
c002795b:	8d 83 bd 6c ff ff    	lea    -0x9343(%ebx),%eax
c0027961:	50                   	push   %eax
c0027962:	e8 28 16 00 00       	call   c0028f8f <debug_panic>
              case 'o': b = &base_o; break;
c0027967:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002796b:	8d 80 94 05 00 00    	lea    0x594(%eax),%eax
c0027971:	eb aa                	jmp    c002791d <.L121+0x3d>

c0027973 <.L152>:
      switch (*format) 
c0027973:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027977 <.L105>:
            char ch = va_arg (args, int);
c0027977:	8b 44 24 74          	mov    0x74(%esp),%eax
c002797b:	8d 70 04             	lea    0x4(%eax),%esi
c002797e:	8b 00                	mov    (%eax),%eax
c0027980:	88 44 24 3f          	mov    %al,0x3f(%esp)
            format_string (&ch, 1, &c, output, aux);
c0027984:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c0027988:	8d 44 24 3f          	lea    0x3f(%esp),%eax
c002798c:	83 ec 08             	sub    $0x8,%esp
c002798f:	55                   	push   %ebp
c0027990:	57                   	push   %edi
c0027991:	ba 01 00 00 00       	mov    $0x1,%edx
c0027996:	e8 cb f7 ff ff       	call   c0027166 <format_string>
          break;
c002799b:	83 c4 10             	add    $0x10,%esp
c002799e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
            char ch = va_arg (args, int);
c00279a2:	89 74 24 74          	mov    %esi,0x74(%esp)
          break;
c00279a6:	e9 d3 f8 ff ff       	jmp    c002727e <__vprintf+0x44>

c00279ab <.L155>:
      switch (*format) 
c00279ab:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c00279af <.L108>:
            const char *s = va_arg (args, char *);
c00279af:	8b 44 24 74          	mov    0x74(%esp),%eax
c00279b3:	83 c0 04             	add    $0x4,%eax
c00279b6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00279ba:	8b 54 24 74          	mov    0x74(%esp),%edx
c00279be:	8b 12                	mov    (%edx),%edx
              s = "(null)";
c00279c0:	85 d2                	test   %edx,%edx
c00279c2:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00279c6:	8d 83 b6 6c ff ff    	lea    -0x934a(%ebx),%eax
c00279cc:	0f 45 c2             	cmovne %edx,%eax
c00279cf:	89 c6                	mov    %eax,%esi
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c00279d1:	83 ec 08             	sub    $0x8,%esp
c00279d4:	ff 74 24 18          	pushl  0x18(%esp)
c00279d8:	50                   	push   %eax
c00279d9:	e8 d9 0b 00 00       	call   c00285b7 <strnlen>
c00279de:	8d 4c 24 50          	lea    0x50(%esp),%ecx
c00279e2:	83 c4 08             	add    $0x8,%esp
c00279e5:	55                   	push   %ebp
c00279e6:	57                   	push   %edi
c00279e7:	89 c2                	mov    %eax,%edx
c00279e9:	89 f0                	mov    %esi,%eax
c00279eb:	e8 76 f7 ff ff       	call   c0027166 <format_string>
          break;
c00279f0:	83 c4 10             	add    $0x10,%esp
c00279f3:	8b 5c 24 18          	mov    0x18(%esp),%ebx
            const char *s = va_arg (args, char *);
c00279f7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00279fb:	89 44 24 74          	mov    %eax,0x74(%esp)
          break;
c00279ff:	e9 7a f8 ff ff       	jmp    c002727e <__vprintf+0x44>

c0027a04 <.L154>:
      switch (*format) 
c0027a04:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027a08 <.L107>:
            void *p = va_arg (args, void *);
c0027a08:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a0c:	8d 70 04             	lea    0x4(%eax),%esi
c0027a0f:	8b 00                	mov    (%eax),%eax
            c.flags = POUND;
c0027a11:	c7 44 24 40 08 00 00 	movl   $0x8,0x40(%esp)
c0027a18:	00 
            format_integer ((uintptr_t) p, false, false,
c0027a19:	ba 00 00 00 00       	mov    $0x0,%edx
c0027a1e:	83 ec 0c             	sub    $0xc,%esp
c0027a21:	55                   	push   %ebp
c0027a22:	57                   	push   %edi
c0027a23:	8d 4c 24 54          	lea    0x54(%esp),%ecx
c0027a27:	51                   	push   %ecx
c0027a28:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0027a2c:	8d 89 84 05 00 00    	lea    0x584(%ecx),%ecx
c0027a32:	51                   	push   %ecx
c0027a33:	6a 00                	push   $0x0
c0027a35:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027a3a:	e8 ea f3 ff ff       	call   c0026e29 <format_integer>
          break;
c0027a3f:	83 c4 20             	add    $0x20,%esp
c0027a42:	8b 5c 24 18          	mov    0x18(%esp),%ebx
            void *p = va_arg (args, void *);
c0027a46:	89 74 24 74          	mov    %esi,0x74(%esp)
          break;
c0027a4a:	e9 2f f8 ff ff       	jmp    c002727e <__vprintf+0x44>

c0027a4f <.L151>:
      switch (*format) 
c0027a4f:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027a53 <.L102>:
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027a53:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027a57:	55                   	push   %ebp
c0027a58:	57                   	push   %edi
c0027a59:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027a5d:	8d 80 cf 6c ff ff    	lea    -0x9331(%eax),%eax
c0027a63:	50                   	push   %eax
c0027a64:	e8 b4 f7 ff ff       	call   c002721d <__printf>
          break;
c0027a69:	83 c4 10             	add    $0x10,%esp
c0027a6c:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0027a70:	e9 09 f8 ff ff       	jmp    c002727e <__vprintf+0x44>

c0027a75 <.L150>:
      switch (*format) 
c0027a75:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027a79 <.L101>:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027a79:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027a7d:	55                   	push   %ebp
c0027a7e:	57                   	push   %edi
c0027a7f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027a83:	8d 80 e5 6c ff ff    	lea    -0x931b(%eax),%eax
c0027a89:	50                   	push   %eax
c0027a8a:	e8 8e f7 ff ff       	call   c002721d <__printf>
          break;
c0027a8f:	83 c4 10             	add    $0x10,%esp
c0027a92:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0027a96:	e9 e3 f7 ff ff       	jmp    c002727e <__vprintf+0x44>

c0027a9b <vsnprintf>:
{
c0027a9b:	56                   	push   %esi
c0027a9c:	53                   	push   %ebx
c0027a9d:	83 ec 14             	sub    $0x14,%esp
c0027aa0:	e8 96 5e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0027aa5:	81 c3 27 1a 01 00    	add    $0x11a27,%ebx
c0027aab:	8b 44 24 24          	mov    0x24(%esp),%eax
c0027aaf:	8b 54 24 28          	mov    0x28(%esp),%edx
c0027ab3:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c0027ab7:	8b 74 24 20          	mov    0x20(%esp),%esi
c0027abb:	89 74 24 04          	mov    %esi,0x4(%esp)
  aux.length = 0;
c0027abf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027ac6:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027ac7:	85 c0                	test   %eax,%eax
c0027ac9:	74 2e                	je     c0027af9 <vsnprintf+0x5e>
c0027acb:	83 e8 01             	sub    $0x1,%eax
c0027ace:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027ad2:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027ad6:	50                   	push   %eax
c0027ad7:	8d 83 0a d9 fe ff    	lea    -0x126f6(%ebx),%eax
c0027add:	50                   	push   %eax
c0027ade:	51                   	push   %ecx
c0027adf:	52                   	push   %edx
c0027ae0:	e8 55 f7 ff ff       	call   c002723a <__vprintf>
    *aux.p = '\0';
c0027ae5:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027ae9:	c6 00 00             	movb   $0x0,(%eax)
c0027aec:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0027aef:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0027af3:	83 c4 14             	add    $0x14,%esp
c0027af6:	5b                   	pop    %ebx
c0027af7:	5e                   	pop    %esi
c0027af8:	c3                   	ret    
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027af9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027b00:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027b01:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027b05:	50                   	push   %eax
c0027b06:	8d 83 0a d9 fe ff    	lea    -0x126f6(%ebx),%eax
c0027b0c:	50                   	push   %eax
c0027b0d:	51                   	push   %ecx
c0027b0e:	52                   	push   %edx
c0027b0f:	e8 26 f7 ff ff       	call   c002723a <__vprintf>
c0027b14:	83 c4 10             	add    $0x10,%esp
c0027b17:	eb d6                	jmp    c0027aef <vsnprintf+0x54>

c0027b19 <snprintf>:
{
c0027b19:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0027b1c:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0027b20:	50                   	push   %eax
c0027b21:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027b25:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027b29:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027b2d:	e8 69 ff ff ff       	call   c0027a9b <vsnprintf>
}
c0027b32:	83 c4 1c             	add    $0x1c,%esp
c0027b35:	c3                   	ret    

c0027b36 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027b36:	55                   	push   %ebp
c0027b37:	57                   	push   %edi
c0027b38:	56                   	push   %esi
c0027b39:	53                   	push   %ebx
c0027b3a:	83 ec 1c             	sub    $0x1c,%esp
c0027b3d:	e8 01 5e 00 00       	call   c002d943 <__x86.get_pc_thunk.di>
c0027b42:	81 c7 8a 19 01 00    	add    $0x1198a,%edi
c0027b48:	0f b6 44 24 3c       	movzbl 0x3c(%esp),%eax
c0027b4d:	88 44 24 0b          	mov    %al,0xb(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027b51:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027b56:	0f 84 c6 01 00 00    	je     c0027d22 <hex_dump+0x1ec>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027b5c:	8d 87 fc 6c ff ff    	lea    -0x9304(%edi),%eax
c0027b62:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027b66:	e9 9b 00 00 00       	jmp    c0027c06 <hex_dump+0xd0>
      for (i = 0; i < start; i++)
c0027b6b:	89 eb                	mov    %ebp,%ebx
c0027b6d:	e9 02 01 00 00       	jmp    c0027c74 <hex_dump+0x13e>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027b72:	89 ee                	mov    %ebp,%esi
            printf (" ");
          for (; i < end; i++)
c0027b74:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0027b79:	0f 84 9a 01 00 00    	je     c0027d19 <hex_dump+0x1e3>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027b7f:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027b83:	29 e8                	sub    %ebp,%eax
c0027b85:	89 c5                	mov    %eax,%ebp
c0027b87:	0f b6 44 35 00       	movzbl 0x0(%ebp,%esi,1),%eax
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027b8c:	0f b6 d0             	movzbl %al,%edx
c0027b8f:	83 ea 20             	sub    $0x20,%edx
c0027b92:	83 fa 5f             	cmp    $0x5f,%edx
c0027b95:	b9 2e 00 00 00       	mov    $0x2e,%ecx
c0027b9a:	0f 43 c1             	cmovae %ecx,%eax
            printf ("%c",
c0027b9d:	83 ec 0c             	sub    $0xc,%esp
c0027ba0:	0f b6 c0             	movzbl %al,%eax
c0027ba3:	50                   	push   %eax
c0027ba4:	89 fb                	mov    %edi,%ebx
c0027ba6:	e8 7a 33 00 00       	call   c002af25 <putchar>
          for (; i < end; i++)
c0027bab:	83 c6 01             	add    $0x1,%esi
c0027bae:	83 c4 10             	add    $0x10,%esp
c0027bb1:	39 34 24             	cmp    %esi,(%esp)
c0027bb4:	77 d1                	ja     c0027b87 <hex_dump+0x51>
          for (; i < per_line; i++)
c0027bb6:	83 fe 0f             	cmp    $0xf,%esi
c0027bb9:	77 17                	ja     c0027bd2 <hex_dump+0x9c>
            printf (" ");
c0027bbb:	83 ec 0c             	sub    $0xc,%esp
c0027bbe:	6a 20                	push   $0x20
c0027bc0:	89 fb                	mov    %edi,%ebx
c0027bc2:	e8 5e 33 00 00       	call   c002af25 <putchar>
          for (; i < per_line; i++)
c0027bc7:	83 c6 01             	add    $0x1,%esi
c0027bca:	83 c4 10             	add    $0x10,%esp
c0027bcd:	83 fe 0f             	cmp    $0xf,%esi
c0027bd0:	76 e9                	jbe    c0027bbb <hex_dump+0x85>
          printf ("|");
c0027bd2:	83 ec 0c             	sub    $0xc,%esp
c0027bd5:	6a 7c                	push   $0x7c
c0027bd7:	89 fb                	mov    %edi,%ebx
c0027bd9:	e8 47 33 00 00       	call   c002af25 <putchar>
c0027bde:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027be1:	83 ec 0c             	sub    $0xc,%esp
c0027be4:	6a 0a                	push   $0xa
c0027be6:	89 fb                	mov    %edi,%ebx
c0027be8:	e8 38 33 00 00       	call   c002af25 <putchar>

      ofs += n;
c0027bed:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027bf1:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
c0027bf5:	01 44 24 44          	add    %eax,0x44(%esp)
  while (size > 0)
c0027bf9:	83 c4 10             	add    $0x10,%esp
c0027bfc:	29 44 24 38          	sub    %eax,0x38(%esp)
c0027c00:	0f 84 1c 01 00 00    	je     c0027d22 <hex_dump+0x1ec>
      start = ofs % per_line;
c0027c06:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027c0a:	83 e5 0f             	and    $0xf,%ebp
      if (end - start > size)
c0027c0d:	ba 10 00 00 00       	mov    $0x10,%edx
c0027c12:	29 ea                	sub    %ebp,%edx
        end = start + size;
c0027c14:	89 e8                	mov    %ebp,%eax
c0027c16:	03 44 24 38          	add    0x38(%esp),%eax
c0027c1a:	3b 54 24 38          	cmp    0x38(%esp),%edx
c0027c1e:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027c23:	0f 46 c1             	cmovbe %ecx,%eax
c0027c26:	89 04 24             	mov    %eax,(%esp)
      n = end - start;
c0027c29:	29 e8                	sub    %ebp,%eax
c0027c2b:	89 44 24 04          	mov    %eax,0x4(%esp)
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027c2f:	83 ec 04             	sub    $0x4,%esp
c0027c32:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027c36:	83 e0 f0             	and    $0xfffffff0,%eax
c0027c39:	ba 00 00 00 00       	mov    $0x0,%edx
c0027c3e:	52                   	push   %edx
c0027c3f:	50                   	push   %eax
c0027c40:	ff 74 24 18          	pushl  0x18(%esp)
c0027c44:	e8 af f5 ff ff       	call   c00271f8 <printf>
      for (i = 0; i < start; i++)
c0027c49:	83 c4 10             	add    $0x10,%esp
c0027c4c:	85 ed                	test   %ebp,%ebp
c0027c4e:	0f 84 17 ff ff ff    	je     c0027b6b <hex_dump+0x35>
c0027c54:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c0027c59:	8d b7 04 6d ff ff    	lea    -0x92fc(%edi),%esi
c0027c5f:	83 ec 0c             	sub    $0xc,%esp
c0027c62:	56                   	push   %esi
c0027c63:	e8 90 f5 ff ff       	call   c00271f8 <printf>
      for (i = 0; i < start; i++)
c0027c68:	83 c3 01             	add    $0x1,%ebx
c0027c6b:	83 c4 10             	add    $0x10,%esp
c0027c6e:	39 dd                	cmp    %ebx,%ebp
c0027c70:	75 ed                	jne    c0027c5f <hex_dump+0x129>
c0027c72:	89 eb                	mov    %ebp,%ebx
      for (; i < end; i++) 
c0027c74:	39 1c 24             	cmp    %ebx,(%esp)
c0027c77:	76 36                	jbe    c0027caf <hex_dump+0x179>
        printf ("%02hhx%c",
c0027c79:	be 20 00 00 00       	mov    $0x20,%esi
c0027c7e:	83 fb 07             	cmp    $0x7,%ebx
c0027c81:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027c86:	0f 45 c6             	cmovne %esi,%eax
c0027c89:	83 ec 04             	sub    $0x4,%esp
c0027c8c:	50                   	push   %eax
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027c8d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0027c91:	29 e8                	sub    %ebp,%eax
        printf ("%02hhx%c",
c0027c93:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
c0027c97:	50                   	push   %eax
c0027c98:	8d 87 08 6d ff ff    	lea    -0x92f8(%edi),%eax
c0027c9e:	50                   	push   %eax
c0027c9f:	e8 54 f5 ff ff       	call   c00271f8 <printf>
      for (; i < end; i++) 
c0027ca4:	83 c3 01             	add    $0x1,%ebx
c0027ca7:	83 c4 10             	add    $0x10,%esp
c0027caa:	39 1c 24             	cmp    %ebx,(%esp)
c0027cad:	75 cf                	jne    c0027c7e <hex_dump+0x148>
      if (ascii) 
c0027caf:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
c0027cb4:	0f 84 27 ff ff ff    	je     c0027be1 <hex_dump+0xab>
          for (; i < per_line; i++)
c0027cba:	83 fb 0f             	cmp    $0xf,%ebx
c0027cbd:	77 1a                	ja     c0027cd9 <hex_dump+0x1a3>
            printf ("   ");
c0027cbf:	8d b7 04 6d ff ff    	lea    -0x92fc(%edi),%esi
c0027cc5:	83 ec 0c             	sub    $0xc,%esp
c0027cc8:	56                   	push   %esi
c0027cc9:	e8 2a f5 ff ff       	call   c00271f8 <printf>
          for (; i < per_line; i++)
c0027cce:	83 c3 01             	add    $0x1,%ebx
c0027cd1:	83 c4 10             	add    $0x10,%esp
c0027cd4:	83 fb 10             	cmp    $0x10,%ebx
c0027cd7:	75 ec                	jne    c0027cc5 <hex_dump+0x18f>
          printf ("|");
c0027cd9:	83 ec 0c             	sub    $0xc,%esp
c0027cdc:	6a 7c                	push   $0x7c
c0027cde:	89 fb                	mov    %edi,%ebx
c0027ce0:	e8 40 32 00 00       	call   c002af25 <putchar>
          for (i = 0; i < start; i++)
c0027ce5:	83 c4 10             	add    $0x10,%esp
c0027ce8:	85 ed                	test   %ebp,%ebp
c0027cea:	0f 84 82 fe ff ff    	je     c0027b72 <hex_dump+0x3c>
c0027cf0:	be 00 00 00 00       	mov    $0x0,%esi
            printf (" ");
c0027cf5:	83 ec 0c             	sub    $0xc,%esp
c0027cf8:	6a 20                	push   $0x20
c0027cfa:	89 fb                	mov    %edi,%ebx
c0027cfc:	e8 24 32 00 00       	call   c002af25 <putchar>
          for (i = 0; i < start; i++)
c0027d01:	83 c6 01             	add    $0x1,%esi
c0027d04:	83 c4 10             	add    $0x10,%esp
c0027d07:	39 f5                	cmp    %esi,%ebp
c0027d09:	75 ea                	jne    c0027cf5 <hex_dump+0x1bf>
          for (; i < end; i++)
c0027d0b:	39 34 24             	cmp    %esi,(%esp)
c0027d0e:	0f 87 6b fe ff ff    	ja     c0027b7f <hex_dump+0x49>
c0027d14:	e9 9d fe ff ff       	jmp    c0027bb6 <hex_dump+0x80>
          for (i = 0; i < start; i++)
c0027d19:	8b 74 24 04          	mov    0x4(%esp),%esi
c0027d1d:	e9 99 fe ff ff       	jmp    c0027bbb <hex_dump+0x85>
      size -= n;
    }
}
c0027d22:	83 c4 1c             	add    $0x1c,%esp
c0027d25:	5b                   	pop    %ebx
c0027d26:	5e                   	pop    %esi
c0027d27:	5f                   	pop    %edi
c0027d28:	5d                   	pop    %ebp
c0027d29:	c3                   	ret    

c0027d2a <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027d2a:	57                   	push   %edi
c0027d2b:	56                   	push   %esi
c0027d2c:	53                   	push   %ebx
c0027d2d:	e8 1d 5c 00 00       	call   c002d94f <__x86.get_pc_thunk.dx>
c0027d32:	81 c2 9a 17 01 00    	add    $0x1179a,%edx
c0027d38:	8b 74 24 10          	mov    0x10(%esp),%esi
c0027d3c:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c0027d40:	89 f0                	mov    %esi,%eax
c0027d42:	83 f0 01             	xor    $0x1,%eax
c0027d45:	89 f9                	mov    %edi,%ecx
c0027d47:	09 c1                	or     %eax,%ecx
c0027d49:	74 24                	je     c0027d6f <print_human_readable_size+0x45>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027d4b:	83 ff 00             	cmp    $0x0,%edi
c0027d4e:	77 0e                	ja     c0027d5e <print_human_readable_size+0x34>
c0027d50:	8d 82 d4 05 00 00    	lea    0x5d4(%edx),%eax
c0027d56:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0027d5c:	76 42                	jbe    c0027da0 <print_human_readable_size+0x76>
c0027d5e:	8d 82 d4 05 00 00    	lea    0x5d4(%edx),%eax
c0027d64:	83 ba d8 05 00 00 00 	cmpl   $0x0,0x5d8(%edx)
c0027d6b:	75 1c                	jne    c0027d89 <print_human_readable_size+0x5f>
c0027d6d:	eb 31                	jmp    c0027da0 <print_human_readable_size+0x76>
    printf ("1 byte");
c0027d6f:	83 ec 0c             	sub    $0xc,%esp
c0027d72:	8d 82 11 6d ff ff    	lea    -0x92ef(%edx),%eax
c0027d78:	50                   	push   %eax
c0027d79:	e8 7a f4 ff ff       	call   c00271f8 <printf>
c0027d7e:	83 c4 10             	add    $0x10,%esp
c0027d81:	eb 30                	jmp    c0027db3 <print_human_readable_size+0x89>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027d83:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0027d87:	74 17                	je     c0027da0 <print_human_readable_size+0x76>
        size /= 1024;
c0027d89:	0f ac fe 0a          	shrd   $0xa,%edi,%esi
c0027d8d:	c1 ef 0a             	shr    $0xa,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027d90:	83 c0 04             	add    $0x4,%eax
c0027d93:	83 ff 00             	cmp    $0x0,%edi
c0027d96:	77 eb                	ja     c0027d83 <print_human_readable_size+0x59>
c0027d98:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0027d9e:	77 e3                	ja     c0027d83 <print_human_readable_size+0x59>
      printf ("%"PRIu64" %s", size, *fp);
c0027da0:	ff 30                	pushl  (%eax)
c0027da2:	57                   	push   %edi
c0027da3:	56                   	push   %esi
c0027da4:	8d 82 18 6d ff ff    	lea    -0x92e8(%edx),%eax
c0027daa:	50                   	push   %eax
c0027dab:	e8 48 f4 ff ff       	call   c00271f8 <printf>
c0027db0:	83 c4 10             	add    $0x10,%esp
    }
}
c0027db3:	5b                   	pop    %ebx
c0027db4:	5e                   	pop    %esi
c0027db5:	5f                   	pop    %edi
c0027db6:	c3                   	ret    

c0027db7 <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0027db7:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c0027dba:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027dbe:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027dc2:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027dc6:	ff 10                	call   *(%eax)
}
c0027dc8:	83 c4 1c             	add    $0x1c,%esp
c0027dcb:	c3                   	ret    

c0027dcc <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0027dcc:	55                   	push   %ebp
c0027dcd:	57                   	push   %edi
c0027dce:	56                   	push   %esi
c0027dcf:	53                   	push   %ebx
c0027dd0:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c0027dd4:	8d 5a ff             	lea    -0x1(%edx),%ebx
c0027dd7:	0f af df             	imul   %edi,%ebx
  unsigned char *b = array + (b_idx - 1) * size;
c0027dda:	83 e9 01             	sub    $0x1,%ecx
c0027ddd:	0f af cf             	imul   %edi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c0027de0:	85 ff                	test   %edi,%edi
c0027de2:	74 23                	je     c0027e07 <do_swap+0x3b>
c0027de4:	89 dd                	mov    %ebx,%ebp
c0027de6:	8d 14 18             	lea    (%eax,%ebx,1),%edx
c0027de9:	01 f8                	add    %edi,%eax
c0027deb:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
    {
      unsigned char t = a[i];
c0027dee:	0f b6 32             	movzbl (%edx),%esi
c0027df1:	89 d0                	mov    %edx,%eax
c0027df3:	29 e8                	sub    %ebp,%eax
      a[i] = b[i];
c0027df5:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
c0027df9:	88 1a                	mov    %bl,(%edx)
      b[i] = t;
c0027dfb:	89 f3                	mov    %esi,%ebx
c0027dfd:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
c0027e00:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < size; i++)
c0027e03:	39 fa                	cmp    %edi,%edx
c0027e05:	75 e7                	jne    c0027dee <do_swap+0x22>
    }
}
c0027e07:	5b                   	pop    %ebx
c0027e08:	5e                   	pop    %esi
c0027e09:	5f                   	pop    %edi
c0027e0a:	5d                   	pop    %ebp
c0027e0b:	c3                   	ret    

c0027e0c <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0027e0c:	55                   	push   %ebp
c0027e0d:	57                   	push   %edi
c0027e0e:	56                   	push   %esi
c0027e0f:	53                   	push   %ebx
c0027e10:	83 ec 1c             	sub    $0x1c,%esp
c0027e13:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027e17:	89 d7                	mov    %edx,%edi
c0027e19:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0027e1d:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027e21:	eb 4a                	jmp    c0027e6d <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027e23:	83 ec 04             	sub    $0x4,%esp
c0027e26:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027e2a:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027e2d:	0f af c5             	imul   %ebp,%eax
c0027e30:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0027e34:	01 c8                	add    %ecx,%eax
c0027e36:	50                   	push   %eax
c0027e37:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027e3a:	0f af c5             	imul   %ebp,%eax
c0027e3d:	01 c8                	add    %ecx,%eax
c0027e3f:	50                   	push   %eax
c0027e40:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027e44:	83 c4 10             	add    $0x10,%esp
c0027e47:	85 c0                	test   %eax,%eax
c0027e49:	7e 2e                	jle    c0027e79 <heapify+0x6d>
        max = left;
      if (right <= cnt
c0027e4b:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027e4f:	76 5b                	jbe    c0027eac <heapify+0xa0>
        max = left;
c0027e51:	89 de                	mov    %ebx,%esi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0027e53:	39 f7                	cmp    %esi,%edi
c0027e55:	74 4d                	je     c0027ea4 <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0027e57:	83 ec 0c             	sub    $0xc,%esp
c0027e5a:	55                   	push   %ebp
c0027e5b:	89 f1                	mov    %esi,%ecx
c0027e5d:	89 fa                	mov    %edi,%edx
c0027e5f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0027e63:	e8 64 ff ff ff       	call   c0027dcc <do_swap>
c0027e68:	89 f7                	mov    %esi,%edi
    {
c0027e6a:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c0027e6d:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
      size_t right = 2 * i + 1;
c0027e70:	8d 73 01             	lea    0x1(%ebx),%esi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0027e73:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0027e77:	76 aa                	jbe    c0027e23 <heapify+0x17>
      if (right <= cnt
c0027e79:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0027e7d:	77 25                	ja     c0027ea4 <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027e7f:	83 ec 04             	sub    $0x4,%esp
c0027e82:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027e86:	8d 47 ff             	lea    -0x1(%edi),%eax
c0027e89:	0f af c5             	imul   %ebp,%eax
c0027e8c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027e90:	01 d0                	add    %edx,%eax
c0027e92:	50                   	push   %eax
c0027e93:	0f af dd             	imul   %ebp,%ebx
c0027e96:	01 d3                	add    %edx,%ebx
c0027e98:	53                   	push   %ebx
c0027e99:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0027e9d:	83 c4 10             	add    $0x10,%esp
c0027ea0:	85 c0                	test   %eax,%eax
c0027ea2:	7f af                	jg     c0027e53 <heapify+0x47>
      i = max;
    }
}
c0027ea4:	83 c4 1c             	add    $0x1c,%esp
c0027ea7:	5b                   	pop    %ebx
c0027ea8:	5e                   	pop    %esi
c0027ea9:	5f                   	pop    %edi
c0027eaa:	5d                   	pop    %ebp
c0027eab:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0027eac:	83 ec 04             	sub    $0x4,%esp
c0027eaf:	ff 74 24 3c          	pushl  0x3c(%esp)
c0027eb3:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0027eb6:	0f af c5             	imul   %ebp,%eax
c0027eb9:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0027ebd:	01 c8                	add    %ecx,%eax
c0027ebf:	50                   	push   %eax
c0027ec0:	89 d8                	mov    %ebx,%eax
c0027ec2:	0f af c5             	imul   %ebp,%eax
c0027ec5:	01 c8                	add    %ecx,%eax
c0027ec7:	50                   	push   %eax
c0027ec8:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0027ecc:	83 c4 10             	add    $0x10,%esp
c0027ecf:	85 c0                	test   %eax,%eax
        max = left;
c0027ed1:	0f 4e f3             	cmovle %ebx,%esi
c0027ed4:	e9 7a ff ff ff       	jmp    c0027e53 <heapify+0x47>

c0027ed9 <atoi>:
{
c0027ed9:	56                   	push   %esi
c0027eda:	53                   	push   %ebx
c0027edb:	83 ec 04             	sub    $0x4,%esp
c0027ede:	e8 58 5a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0027ee3:	81 c3 e9 15 01 00    	add    $0x115e9,%ebx
c0027ee9:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c0027eed:	85 d2                	test   %edx,%edx
c0027eef:	75 29                	jne    c0027f1a <atoi+0x41>
c0027ef1:	83 ec 0c             	sub    $0xc,%esp
c0027ef4:	8d 83 b7 6d ff ff    	lea    -0x9249(%ebx),%eax
c0027efa:	50                   	push   %eax
c0027efb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0027f01:	50                   	push   %eax
c0027f02:	8d 83 8c 51 ff ff    	lea    -0xae74(%ebx),%eax
c0027f08:	50                   	push   %eax
c0027f09:	6a 0f                	push   $0xf
c0027f0b:	8d 83 68 6d ff ff    	lea    -0x9298(%ebx),%eax
c0027f11:	50                   	push   %eax
c0027f12:	e8 78 10 00 00       	call   c0028f8f <debug_panic>
    s++;
c0027f17:	83 c2 01             	add    $0x1,%edx
  while (isspace ((unsigned char) *s))
c0027f1a:	0f b6 02             	movzbl (%edx),%eax
          || c == '\r' || c == '\t' || c == '\v');
c0027f1d:	3c 20                	cmp    $0x20,%al
c0027f1f:	74 f6                	je     c0027f17 <atoi+0x3e>
c0027f21:	8d 48 f7             	lea    -0x9(%eax),%ecx
c0027f24:	80 f9 04             	cmp    $0x4,%cl
c0027f27:	76 ee                	jbe    c0027f17 <atoi+0x3e>
  if (*s == '+')
c0027f29:	3c 2b                	cmp    $0x2b,%al
c0027f2b:	74 40                	je     c0027f6d <atoi+0x94>
  negative = false;
c0027f2d:	bb 00 00 00 00       	mov    $0x0,%ebx
  else if (*s == '-')
c0027f32:	3c 2d                	cmp    $0x2d,%al
c0027f34:	74 41                	je     c0027f77 <atoi+0x9e>
  for (value = 0; isdigit (*s); s++)
c0027f36:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027f39:	8d 41 d0             	lea    -0x30(%ecx),%eax
c0027f3c:	83 f8 09             	cmp    $0x9,%eax
c0027f3f:	77 40                	ja     c0027f81 <atoi+0xa8>
c0027f41:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c0027f46:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0027f49:	01 c0                	add    %eax,%eax
c0027f4b:	83 e9 30             	sub    $0x30,%ecx
c0027f4e:	29 c8                	sub    %ecx,%eax
  for (value = 0; isdigit (*s); s++)
c0027f50:	83 c2 01             	add    $0x1,%edx
c0027f53:	0f be 0a             	movsbl (%edx),%ecx
c0027f56:	8d 71 d0             	lea    -0x30(%ecx),%esi
c0027f59:	83 fe 09             	cmp    $0x9,%esi
c0027f5c:	76 e8                	jbe    c0027f46 <atoi+0x6d>
    value = -value;
c0027f5e:	89 c2                	mov    %eax,%edx
c0027f60:	f7 da                	neg    %edx
c0027f62:	84 db                	test   %bl,%bl
c0027f64:	0f 44 c2             	cmove  %edx,%eax
}
c0027f67:	83 c4 04             	add    $0x4,%esp
c0027f6a:	5b                   	pop    %ebx
c0027f6b:	5e                   	pop    %esi
c0027f6c:	c3                   	ret    
    s++;
c0027f6d:	83 c2 01             	add    $0x1,%edx
  negative = false;
c0027f70:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027f75:	eb bf                	jmp    c0027f36 <atoi+0x5d>
      s++;
c0027f77:	83 c2 01             	add    $0x1,%edx
      negative = true;
c0027f7a:	bb 01 00 00 00       	mov    $0x1,%ebx
c0027f7f:	eb b5                	jmp    c0027f36 <atoi+0x5d>
  for (value = 0; isdigit (*s); s++)
c0027f81:	b8 00 00 00 00       	mov    $0x0,%eax
c0027f86:	eb d6                	jmp    c0027f5e <atoi+0x85>

c0027f88 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0027f88:	55                   	push   %ebp
c0027f89:	57                   	push   %edi
c0027f8a:	56                   	push   %esi
c0027f8b:	53                   	push   %ebx
c0027f8c:	83 ec 0c             	sub    $0xc,%esp
c0027f8f:	e8 a7 59 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0027f94:	81 c3 38 15 01 00    	add    $0x11538,%ebx
c0027f9a:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0027f9e:	8b 74 24 24          	mov    0x24(%esp),%esi
c0027fa2:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0027fa6:	85 ff                	test   %edi,%edi
c0027fa8:	75 08                	jne    c0027fb2 <sort+0x2a>
c0027faa:	85 f6                	test   %esi,%esi
c0027fac:	0f 85 93 00 00 00    	jne    c0028045 <sort+0xbd>
  ASSERT (compare != NULL);
c0027fb2:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0027fb7:	0f 84 b1 00 00 00    	je     c002806e <sort+0xe6>
  ASSERT (size > 0);
c0027fbd:	85 ed                	test   %ebp,%ebp
c0027fbf:	0f 84 d2 00 00 00    	je     c0028097 <sort+0x10f>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0027fc5:	89 f3                	mov    %esi,%ebx
c0027fc7:	d1 eb                	shr    %ebx
c0027fc9:	74 33                	je     c0027ffe <sort+0x76>
c0027fcb:	89 74 24 24          	mov    %esi,0x24(%esp)
c0027fcf:	89 fe                	mov    %edi,%esi
c0027fd1:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify (array, i, cnt, size, compare, aux);
c0027fd5:	83 ec 04             	sub    $0x4,%esp
c0027fd8:	ff 74 24 34          	pushl  0x34(%esp)
c0027fdc:	ff 74 24 34          	pushl  0x34(%esp)
c0027fe0:	55                   	push   %ebp
c0027fe1:	89 f9                	mov    %edi,%ecx
c0027fe3:	89 da                	mov    %ebx,%edx
c0027fe5:	89 f0                	mov    %esi,%eax
c0027fe7:	e8 20 fe ff ff       	call   c0027e0c <heapify>
  for (i = cnt / 2; i > 0; i--)
c0027fec:	83 c4 10             	add    $0x10,%esp
c0027fef:	83 eb 01             	sub    $0x1,%ebx
c0027ff2:	75 e1                	jne    c0027fd5 <sort+0x4d>
c0027ff4:	89 7c 24 24          	mov    %edi,0x24(%esp)
c0027ff8:	89 f7                	mov    %esi,%edi
c0027ffa:	8b 74 24 24          	mov    0x24(%esp),%esi

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0027ffe:	83 fe 01             	cmp    $0x1,%esi
c0028001:	76 3a                	jbe    c002803d <sort+0xb5>
c0028003:	89 fb                	mov    %edi,%ebx
c0028005:	8b 7c 24 30          	mov    0x30(%esp),%edi
    {
      do_swap (array, 1, i, size);
c0028009:	83 ec 0c             	sub    $0xc,%esp
c002800c:	55                   	push   %ebp
c002800d:	89 f1                	mov    %esi,%ecx
c002800f:	ba 01 00 00 00       	mov    $0x1,%edx
c0028014:	89 d8                	mov    %ebx,%eax
c0028016:	e8 b1 fd ff ff       	call   c0027dcc <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c002801b:	83 ee 01             	sub    $0x1,%esi
c002801e:	83 c4 0c             	add    $0xc,%esp
c0028021:	57                   	push   %edi
c0028022:	ff 74 24 34          	pushl  0x34(%esp)
c0028026:	55                   	push   %ebp
c0028027:	89 f1                	mov    %esi,%ecx
c0028029:	ba 01 00 00 00       	mov    $0x1,%edx
c002802e:	89 d8                	mov    %ebx,%eax
c0028030:	e8 d7 fd ff ff       	call   c0027e0c <heapify>
  for (i = cnt; i > 1; i--) 
c0028035:	83 c4 10             	add    $0x10,%esp
c0028038:	83 fe 01             	cmp    $0x1,%esi
c002803b:	75 cc                	jne    c0028009 <sort+0x81>
    }
}
c002803d:	83 c4 0c             	add    $0xc,%esp
c0028040:	5b                   	pop    %ebx
c0028041:	5e                   	pop    %esi
c0028042:	5f                   	pop    %edi
c0028043:	5d                   	pop    %ebp
c0028044:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c0028045:	83 ec 0c             	sub    $0xc,%esp
c0028048:	8d 83 7b 6d ff ff    	lea    -0x9285(%ebx),%eax
c002804e:	50                   	push   %eax
c002804f:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0028055:	50                   	push   %eax
c0028056:	8d 83 84 51 ff ff    	lea    -0xae7c(%ebx),%eax
c002805c:	50                   	push   %eax
c002805d:	68 8a 00 00 00       	push   $0x8a
c0028062:	8d 83 68 6d ff ff    	lea    -0x9298(%ebx),%eax
c0028068:	50                   	push   %eax
c0028069:	e8 21 0f 00 00       	call   c0028f8f <debug_panic>
  ASSERT (compare != NULL);
c002806e:	83 ec 0c             	sub    $0xc,%esp
c0028071:	8d 83 95 6d ff ff    	lea    -0x926b(%ebx),%eax
c0028077:	50                   	push   %eax
c0028078:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002807e:	50                   	push   %eax
c002807f:	8d 83 84 51 ff ff    	lea    -0xae7c(%ebx),%eax
c0028085:	50                   	push   %eax
c0028086:	68 8b 00 00 00       	push   $0x8b
c002808b:	8d 83 68 6d ff ff    	lea    -0x9298(%ebx),%eax
c0028091:	50                   	push   %eax
c0028092:	e8 f8 0e 00 00       	call   c0028f8f <debug_panic>
  ASSERT (size > 0);
c0028097:	83 ec 0c             	sub    $0xc,%esp
c002809a:	8d 83 a5 6d ff ff    	lea    -0x925b(%ebx),%eax
c00280a0:	50                   	push   %eax
c00280a1:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00280a7:	50                   	push   %eax
c00280a8:	8d 83 84 51 ff ff    	lea    -0xae7c(%ebx),%eax
c00280ae:	50                   	push   %eax
c00280af:	68 8c 00 00 00       	push   $0x8c
c00280b4:	8d 83 68 6d ff ff    	lea    -0x9298(%ebx),%eax
c00280ba:	50                   	push   %eax
c00280bb:	e8 cf 0e 00 00       	call   c0028f8f <debug_panic>

c00280c0 <qsort>:
{
c00280c0:	83 ec 18             	sub    $0x18,%esp
c00280c3:	e8 77 58 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c00280c8:	05 04 14 01 00       	add    $0x11404,%eax
  sort (array, cnt, size, compare_thunk, &compare);
c00280cd:	8d 54 24 28          	lea    0x28(%esp),%edx
c00280d1:	52                   	push   %edx
c00280d2:	8d 80 eb e8 fe ff    	lea    -0x11715(%eax),%eax
c00280d8:	50                   	push   %eax
c00280d9:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280dd:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280e1:	ff 74 24 2c          	pushl  0x2c(%esp)
c00280e5:	e8 9e fe ff ff       	call   c0027f88 <sort>
}
c00280ea:	83 c4 2c             	add    $0x2c,%esp
c00280ed:	c3                   	ret    

c00280ee <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c00280ee:	55                   	push   %ebp
c00280ef:	57                   	push   %edi
c00280f0:	56                   	push   %esi
c00280f1:	53                   	push   %ebx
c00280f2:	83 ec 0c             	sub    $0xc,%esp
c00280f5:	8b 74 24 24          	mov    0x24(%esp),%esi
c00280f9:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c00280fd:	89 fd                	mov    %edi,%ebp
c00280ff:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c0028104:	01 f5                	add    %esi,%ebp

  while (first < last) 
c0028106:	39 ee                	cmp    %ebp,%esi
c0028108:	72 0d                	jb     c0028117 <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c002810a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002810f:	eb 3e                	jmp    c002814f <binary_search+0x61>
      const unsigned char *middle = first + (range / 2) * size;
c0028111:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c0028113:	39 ee                	cmp    %ebp,%esi
c0028115:	73 33                	jae    c002814a <binary_search+0x5c>
      size_t range = (last - first) / size;
c0028117:	89 e8                	mov    %ebp,%eax
c0028119:	29 f0                	sub    %esi,%eax
c002811b:	ba 00 00 00 00       	mov    $0x0,%edx
c0028120:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c0028122:	d1 e8                	shr    %eax
c0028124:	0f af c7             	imul   %edi,%eax
c0028127:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c002812a:	83 ec 04             	sub    $0x4,%esp
c002812d:	ff 74 24 38          	pushl  0x38(%esp)
c0028131:	53                   	push   %ebx
c0028132:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028136:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c002813a:	83 c4 10             	add    $0x10,%esp
c002813d:	85 c0                	test   %eax,%eax
c002813f:	78 d0                	js     c0028111 <binary_search+0x23>
      else if (cmp > 0) 
c0028141:	85 c0                	test   %eax,%eax
c0028143:	7e 0a                	jle    c002814f <binary_search+0x61>
        first = middle + size;
c0028145:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c0028148:	eb c9                	jmp    c0028113 <binary_search+0x25>
  return NULL;
c002814a:	bb 00 00 00 00       	mov    $0x0,%ebx
}
c002814f:	89 d8                	mov    %ebx,%eax
c0028151:	83 c4 0c             	add    $0xc,%esp
c0028154:	5b                   	pop    %ebx
c0028155:	5e                   	pop    %esi
c0028156:	5f                   	pop    %edi
c0028157:	5d                   	pop    %ebp
c0028158:	c3                   	ret    

c0028159 <bsearch>:
{
c0028159:	83 ec 14             	sub    $0x14,%esp
c002815c:	e8 de 57 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0028161:	05 6b 13 01 00       	add    $0x1136b,%eax
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c0028166:	8d 54 24 28          	lea    0x28(%esp),%edx
c002816a:	52                   	push   %edx
c002816b:	8d 80 eb e8 fe ff    	lea    -0x11715(%eax),%eax
c0028171:	50                   	push   %eax
c0028172:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028176:	ff 74 24 2c          	pushl  0x2c(%esp)
c002817a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002817e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028182:	e8 67 ff ff ff       	call   c00280ee <binary_search>
}
c0028187:	83 c4 2c             	add    $0x2c,%esp
c002818a:	c3                   	ret    

c002818b <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c002818b:	56                   	push   %esi
c002818c:	53                   	push   %ebx
c002818d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028191:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028195:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c0028199:	85 db                	test   %ebx,%ebx
c002819b:	74 13                	je     c00281b0 <memcpy+0x25>
c002819d:	ba 00 00 00 00       	mov    $0x0,%edx
    *dst++ = *src++;
c00281a2:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c00281a6:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c00281a9:	83 c2 01             	add    $0x1,%edx
  while (size-- > 0)
c00281ac:	39 da                	cmp    %ebx,%edx
c00281ae:	75 f2                	jne    c00281a2 <memcpy+0x17>

  return dst_;
}
c00281b0:	5b                   	pop    %ebx
c00281b1:	5e                   	pop    %esi
c00281b2:	c3                   	ret    

c00281b3 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00281b3:	57                   	push   %edi
c00281b4:	56                   	push   %esi
c00281b5:	53                   	push   %ebx
c00281b6:	8b 44 24 10          	mov    0x10(%esp),%eax
c00281ba:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00281be:	8b 7c 24 18          	mov    0x18(%esp),%edi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c00281c2:	39 c8                	cmp    %ecx,%eax
c00281c4:	73 1d                	jae    c00281e3 <memmove+0x30>
    {
      while (size-- > 0)
c00281c6:	85 ff                	test   %edi,%edi
c00281c8:	74 15                	je     c00281df <memmove+0x2c>
c00281ca:	ba 00 00 00 00       	mov    $0x0,%edx
        *dst++ = *src++;
c00281cf:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c00281d3:	88 1c 10             	mov    %bl,(%eax,%edx,1)
c00281d6:	83 c2 01             	add    $0x1,%edx
      while (size-- > 0)
c00281d9:	39 fa                	cmp    %edi,%edx
c00281db:	75 f2                	jne    c00281cf <memmove+0x1c>
c00281dd:	01 d0                	add    %edx,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c00281df:	5b                   	pop    %ebx
c00281e0:	5e                   	pop    %esi
c00281e1:	5f                   	pop    %edi
c00281e2:	c3                   	ret    
      dst += size;
c00281e3:	8d 34 38             	lea    (%eax,%edi,1),%esi
      while (size-- > 0)
c00281e6:	8d 57 ff             	lea    -0x1(%edi),%edx
c00281e9:	85 ff                	test   %edi,%edi
c00281eb:	74 11                	je     c00281fe <memmove+0x4b>
        *--dst = *--src;
c00281ed:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c00281f1:	88 1c 10             	mov    %bl,(%eax,%edx,1)
      while (size-- > 0)
c00281f4:	83 ea 01             	sub    $0x1,%edx
c00281f7:	83 fa ff             	cmp    $0xffffffff,%edx
c00281fa:	75 f1                	jne    c00281ed <memmove+0x3a>
c00281fc:	eb e1                	jmp    c00281df <memmove+0x2c>
      dst += size;
c00281fe:	89 f0                	mov    %esi,%eax
c0028200:	eb dd                	jmp    c00281df <memmove+0x2c>

c0028202 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028202:	57                   	push   %edi
c0028203:	56                   	push   %esi
c0028204:	53                   	push   %ebx
c0028205:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028209:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002820d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0028211:	85 db                	test   %ebx,%ebx
c0028213:	74 38                	je     c002824d <memcmp+0x4b>
    if (*a != *b)
c0028215:	0f b6 16             	movzbl (%esi),%edx
c0028218:	0f b6 0f             	movzbl (%edi),%ecx
c002821b:	38 ca                	cmp    %cl,%dl
c002821d:	75 19                	jne    c0028238 <memcmp+0x36>
c002821f:	b8 01 00 00 00       	mov    $0x1,%eax
  for (; size-- > 0; a++, b++)
c0028224:	39 d8                	cmp    %ebx,%eax
c0028226:	74 1e                	je     c0028246 <memcmp+0x44>
    if (*a != *b)
c0028228:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
c002822c:	83 c0 01             	add    $0x1,%eax
c002822f:	0f b6 4c 07 ff       	movzbl -0x1(%edi,%eax,1),%ecx
c0028234:	38 ca                	cmp    %cl,%dl
c0028236:	74 ec                	je     c0028224 <memcmp+0x22>
      return *a > *b ? +1 : -1;
c0028238:	38 d1                	cmp    %dl,%cl
c002823a:	19 c0                	sbb    %eax,%eax
c002823c:	83 e0 02             	and    $0x2,%eax
c002823f:	83 e8 01             	sub    $0x1,%eax
  return 0;
}
c0028242:	5b                   	pop    %ebx
c0028243:	5e                   	pop    %esi
c0028244:	5f                   	pop    %edi
c0028245:	c3                   	ret    
  return 0;
c0028246:	b8 00 00 00 00       	mov    $0x0,%eax
c002824b:	eb f5                	jmp    c0028242 <memcmp+0x40>
c002824d:	b8 00 00 00 00       	mov    $0x0,%eax
c0028252:	eb ee                	jmp    c0028242 <memcmp+0x40>

c0028254 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028254:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028258:	8b 54 24 08          	mov    0x8(%esp),%edx
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c002825c:	0f b6 01             	movzbl (%ecx),%eax
c002825f:	84 c0                	test   %al,%al
c0028261:	74 15                	je     c0028278 <strcmp+0x24>
c0028263:	3a 02                	cmp    (%edx),%al
c0028265:	75 11                	jne    c0028278 <strcmp+0x24>
    {
      a++;
c0028267:	83 c1 01             	add    $0x1,%ecx
      b++;
c002826a:	83 c2 01             	add    $0x1,%edx
  while (*a != '\0' && *a == *b) 
c002826d:	0f b6 01             	movzbl (%ecx),%eax
c0028270:	84 c0                	test   %al,%al
c0028272:	74 04                	je     c0028278 <strcmp+0x24>
c0028274:	3a 02                	cmp    (%edx),%al
c0028276:	74 ef                	je     c0028267 <strcmp+0x13>
    }

  return *a < *b ? -1 : *a > *b;
c0028278:	0f b6 12             	movzbl (%edx),%edx
c002827b:	38 c2                	cmp    %al,%dl
c002827d:	77 07                	ja     c0028286 <strcmp+0x32>
c002827f:	0f 92 c0             	setb   %al
c0028282:	0f b6 c0             	movzbl %al,%eax
c0028285:	c3                   	ret    
c0028286:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002828b:	c3                   	ret    

c002828c <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c002828c:	53                   	push   %ebx
c002828d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028291:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028295:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0028299:	85 d2                	test   %edx,%edx
c002829b:	74 1c                	je     c00282b9 <memchr+0x2d>
c002829d:	89 d9                	mov    %ebx,%ecx
    if (*block == ch)
c002829f:	3a 18                	cmp    (%eax),%bl
c00282a1:	74 14                	je     c00282b7 <memchr+0x2b>
c00282a3:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c00282a5:	83 c0 01             	add    $0x1,%eax
c00282a8:	39 c2                	cmp    %eax,%edx
c00282aa:	74 06                	je     c00282b2 <memchr+0x26>
    if (*block == ch)
c00282ac:	38 08                	cmp    %cl,(%eax)
c00282ae:	75 f5                	jne    c00282a5 <memchr+0x19>
c00282b0:	eb 05                	jmp    c00282b7 <memchr+0x2b>
      return (void *) block;

  return NULL;
c00282b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00282b7:	5b                   	pop    %ebx
c00282b8:	c3                   	ret    
  return NULL;
c00282b9:	b8 00 00 00 00       	mov    $0x0,%eax
c00282be:	eb f7                	jmp    c00282b7 <memchr+0x2b>

c00282c0 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c00282c0:	53                   	push   %ebx
c00282c1:	8b 44 24 08          	mov    0x8(%esp),%eax
c00282c5:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c00282c9:	0f b6 18             	movzbl (%eax),%ebx
c00282cc:	38 da                	cmp    %bl,%dl
c00282ce:	74 19                	je     c00282e9 <strchr+0x29>
c00282d0:	89 d1                	mov    %edx,%ecx
      return (char *) string;
    else if (*string == '\0')
c00282d2:	84 db                	test   %bl,%bl
c00282d4:	74 15                	je     c00282eb <strchr+0x2b>
      return NULL;
    else
      string++;
c00282d6:	83 c0 01             	add    $0x1,%eax
    if (*string == c)
c00282d9:	0f b6 10             	movzbl (%eax),%edx
c00282dc:	38 ca                	cmp    %cl,%dl
c00282de:	74 09                	je     c00282e9 <strchr+0x29>
    else if (*string == '\0')
c00282e0:	84 d2                	test   %dl,%dl
c00282e2:	75 f2                	jne    c00282d6 <strchr+0x16>
      return NULL;
c00282e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00282e9:	5b                   	pop    %ebx
c00282ea:	c3                   	ret    
      return NULL;
c00282eb:	b8 00 00 00 00       	mov    $0x0,%eax
c00282f0:	eb f7                	jmp    c00282e9 <strchr+0x29>

c00282f2 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00282f2:	57                   	push   %edi
c00282f3:	56                   	push   %esi
c00282f4:	53                   	push   %ebx
c00282f5:	8b 74 24 10          	mov    0x10(%esp),%esi
c00282f9:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00282fd:	0f b6 06             	movzbl (%esi),%eax
c0028300:	84 c0                	test   %al,%al
c0028302:	74 27                	je     c002832b <strcspn+0x39>
c0028304:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0028309:	0f be c0             	movsbl %al,%eax
c002830c:	50                   	push   %eax
c002830d:	57                   	push   %edi
c002830e:	e8 ad ff ff ff       	call   c00282c0 <strchr>
c0028313:	83 c4 08             	add    $0x8,%esp
c0028316:	85 c0                	test   %eax,%eax
c0028318:	75 0b                	jne    c0028325 <strcspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c002831a:	83 c3 01             	add    $0x1,%ebx
c002831d:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028321:	84 c0                	test   %al,%al
c0028323:	75 e4                	jne    c0028309 <strcspn+0x17>
      break;
  return length;
}
c0028325:	89 d8                	mov    %ebx,%eax
c0028327:	5b                   	pop    %ebx
c0028328:	5e                   	pop    %esi
c0028329:	5f                   	pop    %edi
c002832a:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c002832b:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028330:	eb f3                	jmp    c0028325 <strcspn+0x33>

c0028332 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0028332:	56                   	push   %esi
c0028333:	53                   	push   %ebx
c0028334:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028338:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c002833c:	0f b6 13             	movzbl (%ebx),%edx
c002833f:	84 d2                	test   %dl,%dl
c0028341:	74 1d                	je     c0028360 <strpbrk+0x2e>
    if (strchr (stop, *string) != NULL)
c0028343:	0f be d2             	movsbl %dl,%edx
c0028346:	52                   	push   %edx
c0028347:	56                   	push   %esi
c0028348:	e8 73 ff ff ff       	call   c00282c0 <strchr>
c002834d:	83 c4 08             	add    $0x8,%esp
c0028350:	85 c0                	test   %eax,%eax
c0028352:	75 13                	jne    c0028367 <strpbrk+0x35>
  for (; *string != '\0'; string++)
c0028354:	83 c3 01             	add    $0x1,%ebx
c0028357:	0f b6 13             	movzbl (%ebx),%edx
c002835a:	84 d2                	test   %dl,%dl
c002835c:	75 e5                	jne    c0028343 <strpbrk+0x11>
c002835e:	eb 09                	jmp    c0028369 <strpbrk+0x37>
      return (char *) string;
  return NULL;
c0028360:	b8 00 00 00 00       	mov    $0x0,%eax
c0028365:	eb 02                	jmp    c0028369 <strpbrk+0x37>
c0028367:	89 d8                	mov    %ebx,%eax
}
c0028369:	5b                   	pop    %ebx
c002836a:	5e                   	pop    %esi
c002836b:	c3                   	ret    

c002836c <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c002836c:	53                   	push   %ebx
c002836d:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c0028371:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0028376:	0f b6 0a             	movzbl (%edx),%ecx
c0028379:	84 c9                	test   %cl,%cl
c002837b:	74 16                	je     c0028393 <strrchr+0x27>
  const char *p = NULL;
c002837d:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c0028382:	38 cb                	cmp    %cl,%bl
c0028384:	0f 44 c2             	cmove  %edx,%eax
  for (; *string != '\0'; string++)
c0028387:	83 c2 01             	add    $0x1,%edx
c002838a:	0f b6 0a             	movzbl (%edx),%ecx
c002838d:	84 c9                	test   %cl,%cl
c002838f:	75 f1                	jne    c0028382 <strrchr+0x16>
      p = string;
  return (char *) p;
}
c0028391:	5b                   	pop    %ebx
c0028392:	c3                   	ret    
  const char *p = NULL;
c0028393:	b8 00 00 00 00       	mov    $0x0,%eax
  return (char *) p;
c0028398:	eb f7                	jmp    c0028391 <strrchr+0x25>

c002839a <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c002839a:	57                   	push   %edi
c002839b:	56                   	push   %esi
c002839c:	53                   	push   %ebx
c002839d:	8b 74 24 10          	mov    0x10(%esp),%esi
c00283a1:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c00283a5:	0f b6 06             	movzbl (%esi),%eax
c00283a8:	84 c0                	test   %al,%al
c00283aa:	74 27                	je     c00283d3 <strspn+0x39>
c00283ac:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c00283b1:	0f be c0             	movsbl %al,%eax
c00283b4:	50                   	push   %eax
c00283b5:	57                   	push   %edi
c00283b6:	e8 05 ff ff ff       	call   c00282c0 <strchr>
c00283bb:	83 c4 08             	add    $0x8,%esp
c00283be:	85 c0                	test   %eax,%eax
c00283c0:	74 0b                	je     c00283cd <strspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c00283c2:	83 c3 01             	add    $0x1,%ebx
c00283c5:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c00283c9:	84 c0                	test   %al,%al
c00283cb:	75 e4                	jne    c00283b1 <strspn+0x17>
      break;
  return length;
}
c00283cd:	89 d8                	mov    %ebx,%eax
c00283cf:	5b                   	pop    %ebx
c00283d0:	5e                   	pop    %esi
c00283d1:	5f                   	pop    %edi
c00283d2:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c00283d3:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c00283d8:	eb f3                	jmp    c00283cd <strspn+0x33>

c00283da <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c00283da:	55                   	push   %ebp
c00283db:	57                   	push   %edi
c00283dc:	56                   	push   %esi
c00283dd:	53                   	push   %ebx
c00283de:	83 ec 1c             	sub    $0x1c,%esp
c00283e1:	e8 55 55 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00283e6:	81 c3 e6 10 01 00    	add    $0x110e6,%ebx
c00283ec:	8b 74 24 30          	mov    0x30(%esp),%esi
c00283f0:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c00283f4:	85 ff                	test   %edi,%edi
c00283f6:	74 33                	je     c002842b <strtok_r+0x51>
  ASSERT (save_ptr != NULL);
c00283f8:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00283fd:	74 55                	je     c0028454 <strtok_r+0x7a>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c00283ff:	85 f6                	test   %esi,%esi
c0028401:	74 7a                	je     c002847d <strtok_r+0xa3>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0028403:	0f b6 1e             	movzbl (%esi),%ebx
c0028406:	83 ec 08             	sub    $0x8,%esp
c0028409:	0f be c3             	movsbl %bl,%eax
c002840c:	50                   	push   %eax
c002840d:	57                   	push   %edi
c002840e:	e8 ad fe ff ff       	call   c00282c0 <strchr>
c0028413:	83 c4 10             	add    $0x10,%esp
c0028416:	85 c0                	test   %eax,%eax
c0028418:	0f 84 a9 00 00 00    	je     c00284c7 <strtok_r+0xed>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c002841e:	84 db                	test   %bl,%bl
c0028420:	0f 84 8e 00 00 00    	je     c00284b4 <strtok_r+0xda>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c0028426:	83 c6 01             	add    $0x1,%esi
c0028429:	eb d8                	jmp    c0028403 <strtok_r+0x29>
  ASSERT (delimiters != NULL);
c002842b:	83 ec 0c             	sub    $0xc,%esp
c002842e:	8d 83 ae 6d ff ff    	lea    -0x9252(%ebx),%eax
c0028434:	50                   	push   %eax
c0028435:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002843b:	50                   	push   %eax
c002843c:	8d 83 a4 51 ff ff    	lea    -0xae5c(%ebx),%eax
c0028442:	50                   	push   %eax
c0028443:	68 ef 00 00 00       	push   $0xef
c0028448:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c002844e:	50                   	push   %eax
c002844f:	e8 3b 0b 00 00       	call   c0028f8f <debug_panic>
  ASSERT (save_ptr != NULL);
c0028454:	83 ec 0c             	sub    $0xc,%esp
c0028457:	8d 83 d4 6d ff ff    	lea    -0x922c(%ebx),%eax
c002845d:	50                   	push   %eax
c002845e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0028464:	50                   	push   %eax
c0028465:	8d 83 a4 51 ff ff    	lea    -0xae5c(%ebx),%eax
c002846b:	50                   	push   %eax
c002846c:	68 f0 00 00 00       	push   $0xf0
c0028471:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c0028477:	50                   	push   %eax
c0028478:	e8 12 0b 00 00       	call   c0028f8f <debug_panic>
    s = *save_ptr;
c002847d:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028481:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c0028483:	85 f6                	test   %esi,%esi
c0028485:	0f 85 78 ff ff ff    	jne    c0028403 <strtok_r+0x29>
c002848b:	83 ec 0c             	sub    $0xc,%esp
c002848e:	8d 83 b7 6d ff ff    	lea    -0x9249(%ebx),%eax
c0028494:	50                   	push   %eax
c0028495:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002849b:	50                   	push   %eax
c002849c:	8d 83 a4 51 ff ff    	lea    -0xae5c(%ebx),%eax
c00284a2:	50                   	push   %eax
c00284a3:	68 f6 00 00 00       	push   $0xf6
c00284a8:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c00284ae:	50                   	push   %eax
c00284af:	e8 db 0a 00 00       	call   c0028f8f <debug_panic>
          *save_ptr = s;
c00284b4:	8b 44 24 38          	mov    0x38(%esp),%eax
c00284b8:	89 30                	mov    %esi,(%eax)
          return NULL;
c00284ba:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c00284bf:	83 c4 1c             	add    $0x1c,%esp
c00284c2:	5b                   	pop    %ebx
c00284c3:	5e                   	pop    %esi
c00284c4:	5f                   	pop    %edi
c00284c5:	5d                   	pop    %ebp
c00284c6:	c3                   	ret    
c00284c7:	89 f3                	mov    %esi,%ebx
c00284c9:	eb 02                	jmp    c00284cd <strtok_r+0xf3>
    s++;
c00284cb:	89 eb                	mov    %ebp,%ebx
c00284cd:	8d 6b 01             	lea    0x1(%ebx),%ebp
  while (strchr (delimiters, *s) == NULL)
c00284d0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00284d4:	88 44 24 0f          	mov    %al,0xf(%esp)
c00284d8:	83 ec 08             	sub    $0x8,%esp
c00284db:	0f be c0             	movsbl %al,%eax
c00284de:	50                   	push   %eax
c00284df:	57                   	push   %edi
c00284e0:	e8 db fd ff ff       	call   c00282c0 <strchr>
c00284e5:	83 c4 10             	add    $0x10,%esp
c00284e8:	85 c0                	test   %eax,%eax
c00284ea:	74 df                	je     c00284cb <strtok_r+0xf1>
  if (*s != '\0') 
c00284ec:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00284f1:	75 0a                	jne    c00284fd <strtok_r+0x123>
    *save_ptr = s;
c00284f3:	8b 44 24 38          	mov    0x38(%esp),%eax
c00284f7:	89 28                	mov    %ebp,(%eax)
c00284f9:	89 f0                	mov    %esi,%eax
c00284fb:	eb c2                	jmp    c00284bf <strtok_r+0xe5>
      *s = '\0';
c00284fd:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
      *save_ptr = s + 1;
c0028501:	83 c3 02             	add    $0x2,%ebx
c0028504:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028508:	89 18                	mov    %ebx,(%eax)
c002850a:	89 f0                	mov    %esi,%eax
c002850c:	eb b1                	jmp    c00284bf <strtok_r+0xe5>

c002850e <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c002850e:	53                   	push   %ebx
c002850f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028513:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028517:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c002851b:	85 c9                	test   %ecx,%ecx
c002851d:	74 0e                	je     c002852d <memset+0x1f>
c002851f:	01 c1                	add    %eax,%ecx
  unsigned char *dst = dst_;
c0028521:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c0028523:	83 c2 01             	add    $0x1,%edx
c0028526:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0028529:	39 d1                	cmp    %edx,%ecx
c002852b:	75 f6                	jne    c0028523 <memset+0x15>

  return dst_;
}
c002852d:	5b                   	pop    %ebx
c002852e:	c3                   	ret    

c002852f <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c002852f:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c0028533:	89 d0                	mov    %edx,%eax
c0028535:	80 3a 00             	cmpb   $0x0,(%edx)
c0028538:	75 03                	jne    c002853d <strlen+0xe>
    continue;
  return p - string;
c002853a:	29 d0                	sub    %edx,%eax
}
c002853c:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c002853d:	83 c0 01             	add    $0x1,%eax
c0028540:	80 38 00             	cmpb   $0x0,(%eax)
c0028543:	74 f5                	je     c002853a <strlen+0xb>
c0028545:	eb f6                	jmp    c002853d <strlen+0xe>

c0028547 <strstr>:
{
c0028547:	55                   	push   %ebp
c0028548:	57                   	push   %edi
c0028549:	56                   	push   %esi
c002854a:	53                   	push   %ebx
c002854b:	83 ec 04             	sub    $0x4,%esp
c002854e:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c0028552:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0028557:	b8 00 00 00 00       	mov    $0x0,%eax
c002855c:	89 d9                	mov    %ebx,%ecx
c002855e:	8b 7c 24 18          	mov    0x18(%esp),%edi
c0028562:	f2 ae                	repnz scas %es:(%edi),%al
c0028564:	f7 d1                	not    %ecx
c0028566:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c0028569:	89 d9                	mov    %ebx,%ecx
c002856b:	89 ef                	mov    %ebp,%edi
c002856d:	f2 ae                	repnz scas %es:(%edi),%al
c002856f:	89 c8                	mov    %ecx,%eax
c0028571:	f7 d0                	not    %eax
c0028573:	8d 70 ff             	lea    -0x1(%eax),%esi
  if (haystack_len >= needle_len) 
c0028576:	39 f2                	cmp    %esi,%edx
c0028578:	72 36                	jb     c00285b0 <strstr+0x69>
      for (i = 0; i <= haystack_len - needle_len; i++)
c002857a:	29 f2                	sub    %esi,%edx
c002857c:	89 14 24             	mov    %edx,(%esp)
c002857f:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028584:	89 df                	mov    %ebx,%edi
c0028586:	03 7c 24 18          	add    0x18(%esp),%edi
        if (!memcmp (haystack + i, needle, needle_len))
c002858a:	56                   	push   %esi
c002858b:	55                   	push   %ebp
c002858c:	57                   	push   %edi
c002858d:	e8 70 fc ff ff       	call   c0028202 <memcmp>
c0028592:	83 c4 0c             	add    $0xc,%esp
c0028595:	85 c0                	test   %eax,%eax
c0028597:	74 0d                	je     c00285a6 <strstr+0x5f>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0028599:	83 c3 01             	add    $0x1,%ebx
c002859c:	3b 1c 24             	cmp    (%esp),%ebx
c002859f:	76 e3                	jbe    c0028584 <strstr+0x3d>
  return NULL;
c00285a1:	bf 00 00 00 00       	mov    $0x0,%edi
}
c00285a6:	89 f8                	mov    %edi,%eax
c00285a8:	83 c4 04             	add    $0x4,%esp
c00285ab:	5b                   	pop    %ebx
c00285ac:	5e                   	pop    %esi
c00285ad:	5f                   	pop    %edi
c00285ae:	5d                   	pop    %ebp
c00285af:	c3                   	ret    
  return NULL;
c00285b0:	bf 00 00 00 00       	mov    $0x0,%edi
c00285b5:	eb ef                	jmp    c00285a6 <strstr+0x5f>

c00285b7 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00285b7:	8b 54 24 04          	mov    0x4(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00285bb:	80 3a 00             	cmpb   $0x0,(%edx)
c00285be:	74 07                	je     c00285c7 <strnlen+0x10>
c00285c0:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c00285c5:	75 07                	jne    c00285ce <strnlen+0x17>
c00285c7:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c00285cc:	f3 c3                	repz ret 
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00285ce:	b8 00 00 00 00       	mov    $0x0,%eax
c00285d3:	83 c0 01             	add    $0x1,%eax
c00285d6:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c00285da:	74 f0                	je     c00285cc <strnlen+0x15>
c00285dc:	39 44 24 08          	cmp    %eax,0x8(%esp)
c00285e0:	76 ea                	jbe    c00285cc <strnlen+0x15>
c00285e2:	eb ef                	jmp    c00285d3 <strnlen+0x1c>

c00285e4 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c00285e4:	55                   	push   %ebp
c00285e5:	57                   	push   %edi
c00285e6:	56                   	push   %esi
c00285e7:	53                   	push   %ebx
c00285e8:	83 ec 0c             	sub    $0xc,%esp
c00285eb:	e8 4b 53 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00285f0:	81 c3 dc 0e 01 00    	add    $0x10edc,%ebx
c00285f6:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c00285fa:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c00285fe:	85 ed                	test   %ebp,%ebp
c0028600:	74 49                	je     c002864b <strlcpy+0x67>
  ASSERT (src != NULL);
c0028602:	85 d2                	test   %edx,%edx
c0028604:	74 6e                	je     c0028674 <strlcpy+0x90>

  src_len = strlen (src);
c0028606:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002860b:	b8 00 00 00 00       	mov    $0x0,%eax
c0028610:	89 d7                	mov    %edx,%edi
c0028612:	f2 ae                	repnz scas %es:(%edi),%al
c0028614:	89 ce                	mov    %ecx,%esi
c0028616:	f7 d6                	not    %esi
c0028618:	8d 76 ff             	lea    -0x1(%esi),%esi
  if (size > 0) 
c002861b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0028620:	74 1f                	je     c0028641 <strlcpy+0x5d>
    {
      size_t dst_len = size - 1;
c0028622:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028626:	8d 78 ff             	lea    -0x1(%eax),%edi
c0028629:	39 fe                	cmp    %edi,%esi
c002862b:	0f 46 fe             	cmovbe %esi,%edi
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c002862e:	83 ec 04             	sub    $0x4,%esp
c0028631:	57                   	push   %edi
c0028632:	52                   	push   %edx
c0028633:	55                   	push   %ebp
c0028634:	e8 52 fb ff ff       	call   c002818b <memcpy>
      dst[dst_len] = '\0';
c0028639:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
c002863e:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
c0028641:	89 f0                	mov    %esi,%eax
c0028643:	83 c4 0c             	add    $0xc,%esp
c0028646:	5b                   	pop    %ebx
c0028647:	5e                   	pop    %esi
c0028648:	5f                   	pop    %edi
c0028649:	5d                   	pop    %ebp
c002864a:	c3                   	ret    
  ASSERT (dst != NULL);
c002864b:	83 ec 0c             	sub    $0xc,%esp
c002864e:	8d 83 e5 6d ff ff    	lea    -0x921b(%ebx),%eax
c0028654:	50                   	push   %eax
c0028655:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002865b:	50                   	push   %eax
c002865c:	8d 83 9c 51 ff ff    	lea    -0xae64(%ebx),%eax
c0028662:	50                   	push   %eax
c0028663:	68 4a 01 00 00       	push   $0x14a
c0028668:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c002866e:	50                   	push   %eax
c002866f:	e8 1b 09 00 00       	call   c0028f8f <debug_panic>
  ASSERT (src != NULL);
c0028674:	83 ec 0c             	sub    $0xc,%esp
c0028677:	8d 83 f1 6d ff ff    	lea    -0x920f(%ebx),%eax
c002867d:	50                   	push   %eax
c002867e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0028684:	50                   	push   %eax
c0028685:	8d 83 9c 51 ff ff    	lea    -0xae64(%ebx),%eax
c002868b:	50                   	push   %eax
c002868c:	68 4b 01 00 00       	push   $0x14b
c0028691:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c0028697:	50                   	push   %eax
c0028698:	e8 f2 08 00 00       	call   c0028f8f <debug_panic>

c002869d <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c002869d:	55                   	push   %ebp
c002869e:	57                   	push   %edi
c002869f:	56                   	push   %esi
c00286a0:	53                   	push   %ebx
c00286a1:	83 ec 1c             	sub    $0x1c,%esp
c00286a4:	e8 92 52 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00286a9:	81 c3 23 0e 01 00    	add    $0x10e23,%ebx
c00286af:	8b 54 24 34          	mov    0x34(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c00286b3:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00286b8:	74 75                	je     c002872f <strlcat+0x92>
  ASSERT (src != NULL);
c00286ba:	85 d2                	test   %edx,%edx
c00286bc:	0f 84 96 00 00 00    	je     c0028758 <strlcat+0xbb>

  src_len = strlen (src);
c00286c2:	be ff ff ff ff       	mov    $0xffffffff,%esi
c00286c7:	b8 00 00 00 00       	mov    $0x0,%eax
c00286cc:	89 f1                	mov    %esi,%ecx
c00286ce:	89 d7                	mov    %edx,%edi
c00286d0:	f2 ae                	repnz scas %es:(%edi),%al
c00286d2:	f7 d1                	not    %ecx
c00286d4:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
c00286d7:	89 f1                	mov    %esi,%ecx
c00286d9:	8b 7c 24 30          	mov    0x30(%esp),%edi
c00286dd:	f2 ae                	repnz scas %es:(%edi),%al
c00286df:	89 ce                	mov    %ecx,%esi
c00286e1:	f7 d6                	not    %esi
c00286e3:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
c00286e6:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00286eb:	74 36                	je     c0028723 <strlcat+0x86>
c00286ed:	3b 74 24 38          	cmp    0x38(%esp),%esi
c00286f1:	73 30                	jae    c0028723 <strlcat+0x86>
    {
      size_t copy_cnt = size - dst_len - 1;
c00286f3:	8b 44 24 38          	mov    0x38(%esp),%eax
c00286f7:	83 e8 01             	sub    $0x1,%eax
c00286fa:	29 f0                	sub    %esi,%eax
c00286fc:	39 c5                	cmp    %eax,%ebp
c00286fe:	0f 46 c5             	cmovbe %ebp,%eax
c0028701:	89 c7                	mov    %eax,%edi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c0028703:	89 f0                	mov    %esi,%eax
c0028705:	03 44 24 30          	add    0x30(%esp),%eax
c0028709:	83 ec 04             	sub    $0x4,%esp
c002870c:	57                   	push   %edi
c002870d:	52                   	push   %edx
c002870e:	89 44 24 18          	mov    %eax,0x18(%esp)
c0028712:	50                   	push   %eax
c0028713:	e8 73 fa ff ff       	call   c002818b <memcpy>
      dst[dst_len + copy_cnt] = '\0';
c0028718:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002871c:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
c0028720:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
c0028723:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
}
c0028727:	83 c4 1c             	add    $0x1c,%esp
c002872a:	5b                   	pop    %ebx
c002872b:	5e                   	pop    %esi
c002872c:	5f                   	pop    %edi
c002872d:	5d                   	pop    %ebp
c002872e:	c3                   	ret    
  ASSERT (dst != NULL);
c002872f:	83 ec 0c             	sub    $0xc,%esp
c0028732:	8d 83 e5 6d ff ff    	lea    -0x921b(%ebx),%eax
c0028738:	50                   	push   %eax
c0028739:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002873f:	50                   	push   %eax
c0028740:	8d 83 94 51 ff ff    	lea    -0xae6c(%ebx),%eax
c0028746:	50                   	push   %eax
c0028747:	68 68 01 00 00       	push   $0x168
c002874c:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c0028752:	50                   	push   %eax
c0028753:	e8 37 08 00 00       	call   c0028f8f <debug_panic>
  ASSERT (src != NULL);
c0028758:	83 ec 0c             	sub    $0xc,%esp
c002875b:	8d 83 f1 6d ff ff    	lea    -0x920f(%ebx),%eax
c0028761:	50                   	push   %eax
c0028762:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0028768:	50                   	push   %eax
c0028769:	8d 83 94 51 ff ff    	lea    -0xae6c(%ebx),%eax
c002876f:	50                   	push   %eax
c0028770:	68 69 01 00 00       	push   $0x169
c0028775:	8d 83 c1 6d ff ff    	lea    -0x923f(%ebx),%eax
c002877b:	50                   	push   %eax
c002877c:	e8 0e 08 00 00       	call   c0028f8f <debug_panic>

c0028781 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028781:	55                   	push   %ebp
c0028782:	57                   	push   %edi
c0028783:	56                   	push   %esi
c0028784:	53                   	push   %ebx
c0028785:	83 ec 1c             	sub    $0x1c,%esp
c0028788:	89 44 24 08          	mov    %eax,0x8(%esp)
c002878c:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0028790:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c0028794:	8b 74 24 34          	mov    0x34(%esp),%esi
c0028798:	89 1c 24             	mov    %ebx,(%esp)
c002879b:	89 74 24 04          	mov    %esi,0x4(%esp)
  if ((d >> 32) == 0) 
c002879f:	85 f6                	test   %esi,%esi
c00287a1:	0f 84 fc 00 00 00    	je     c00288a3 <udiv64+0x122>
c00287a7:	89 f0                	mov    %esi,%eax
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c00287a9:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c00287ad:	8b 74 24 0c          	mov    0xc(%esp),%esi
c00287b1:	8b 14 24             	mov    (%esp),%edx
c00287b4:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00287b8:	39 f1                	cmp    %esi,%ecx
c00287ba:	0f 87 27 01 00 00    	ja     c00288e7 <udiv64+0x166>
c00287c0:	72 08                	jb     c00287ca <udiv64+0x49>
c00287c2:	39 da                	cmp    %ebx,%edx
c00287c4:	0f 87 1d 01 00 00    	ja     c00288e7 <udiv64+0x166>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
c00287ca:	89 c2                	mov    %eax,%edx
  int n = 0;
c00287cc:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x0000FFFF)
c00287d1:	3d ff ff 00 00       	cmp    $0xffff,%eax
c00287d6:	77 0a                	ja     c00287e2 <udiv64+0x61>
      x <<= 16; 
c00287d8:	c1 e0 10             	shl    $0x10,%eax
c00287db:	89 c2                	mov    %eax,%edx
      n += 16;
c00287dd:	b9 10 00 00 00       	mov    $0x10,%ecx
  if (x <= 0x00FFFFFF)
c00287e2:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
c00287e8:	77 06                	ja     c00287f0 <udiv64+0x6f>
      n += 8;
c00287ea:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c00287ed:	c1 e2 08             	shl    $0x8,%edx
  if (x <= 0x0FFFFFFF)
c00287f0:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c00287f6:	77 06                	ja     c00287fe <udiv64+0x7d>
      n += 4;
c00287f8:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c00287fb:	c1 e2 04             	shl    $0x4,%edx
  if (x <= 0x3FFFFFFF)
c00287fe:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
c0028804:	77 06                	ja     c002880c <udiv64+0x8b>
      n += 2;
c0028806:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0028809:	c1 e2 02             	shl    $0x2,%edx
    n++;
c002880c:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
c0028812:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c0028815:	8b 74 24 08          	mov    0x8(%esp),%esi
c0028819:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002881d:	89 fb                	mov    %edi,%ebx
c002881f:	d1 eb                	shr    %ebx
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028821:	89 f0                	mov    %esi,%eax
c0028823:	0f ac f8 01          	shrd   $0x1,%edi,%eax
c0028827:	8b 3c 24             	mov    (%esp),%edi
c002882a:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c002882e:	0f a5 fd             	shld   %cl,%edi,%ebp
c0028831:	d3 e7                	shl    %cl,%edi
c0028833:	f6 c1 20             	test   $0x20,%cl
c0028836:	74 02                	je     c002883a <udiv64+0xb9>
c0028838:	89 fd                	mov    %edi,%ebp
  asm ("divl %4"
c002883a:	89 da                	mov    %ebx,%edx
c002883c:	f7 f5                	div    %ebp
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c002883e:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0028843:	29 ca                	sub    %ecx,%edx
c0028845:	89 d1                	mov    %edx,%ecx
c0028847:	d3 e8                	shr    %cl,%eax
c0028849:	89 c1                	mov    %eax,%ecx
c002884b:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028850:	89 44 24 10          	mov    %eax,0x10(%esp)
c0028854:	89 5c 24 14          	mov    %ebx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028858:	83 c1 ff             	add    $0xffffffff,%ecx
c002885b:	83 d3 ff             	adc    $0xffffffff,%ebx
c002885e:	89 dd                	mov    %ebx,%ebp
c0028860:	8b 34 24             	mov    (%esp),%esi
c0028863:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0028867:	0f af ee             	imul   %esi,%ebp
c002886a:	89 f8                	mov    %edi,%eax
c002886c:	0f af c1             	imul   %ecx,%eax
c002886f:	01 c5                	add    %eax,%ebp
c0028871:	89 c8                	mov    %ecx,%eax
c0028873:	f7 24 24             	mull   (%esp)
c0028876:	01 ea                	add    %ebp,%edx
c0028878:	8b 74 24 08          	mov    0x8(%esp),%esi
c002887c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0028880:	29 c6                	sub    %eax,%esi
c0028882:	19 d7                	sbb    %edx,%edi
c0028884:	89 f0                	mov    %esi,%eax
c0028886:	89 fa                	mov    %edi,%edx
c0028888:	8b 34 24             	mov    (%esp),%esi
c002888b:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002888f:	39 fa                	cmp    %edi,%edx
c0028891:	72 48                	jb     c00288db <udiv64+0x15a>
c0028893:	77 04                	ja     c0028899 <udiv64+0x118>
c0028895:	39 f0                	cmp    %esi,%eax
c0028897:	72 42                	jb     c00288db <udiv64+0x15a>
c0028899:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002889d:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00288a1:	eb 38                	jmp    c00288db <udiv64+0x15a>
      uint32_t n1 = n >> 32;
c00288a3:	89 d0                	mov    %edx,%eax
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c00288a5:	ba 00 00 00 00       	mov    $0x0,%edx
c00288aa:	f7 f3                	div    %ebx
c00288ac:	89 c7                	mov    %eax,%edi
c00288ae:	89 d3                	mov    %edx,%ebx
c00288b0:	89 da                	mov    %ebx,%edx
c00288b2:	b8 00 00 00 00       	mov    $0x0,%eax
c00288b7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c00288bb:	bb 00 00 00 00       	mov    $0x0,%ebx
c00288c0:	01 c8                	add    %ecx,%eax
c00288c2:	11 da                	adc    %ebx,%edx
  asm ("divl %4"
c00288c4:	f7 34 24             	divl   (%esp)
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c00288c7:	89 fd                	mov    %edi,%ebp
c00288c9:	bf 00 00 00 00       	mov    $0x0,%edi
c00288ce:	89 f9                	mov    %edi,%ecx
c00288d0:	89 eb                	mov    %ebp,%ebx
c00288d2:	ba 00 00 00 00       	mov    $0x0,%edx
c00288d7:	01 c1                	add    %eax,%ecx
c00288d9:	11 d3                	adc    %edx,%ebx
        }
    }
}
c00288db:	89 c8                	mov    %ecx,%eax
c00288dd:	89 da                	mov    %ebx,%edx
c00288df:	83 c4 1c             	add    $0x1c,%esp
c00288e2:	5b                   	pop    %ebx
c00288e3:	5e                   	pop    %esi
c00288e4:	5f                   	pop    %edi
c00288e5:	5d                   	pop    %ebp
c00288e6:	c3                   	ret    
        return 0;
c00288e7:	b9 00 00 00 00       	mov    $0x0,%ecx
c00288ec:	bb 00 00 00 00       	mov    $0x0,%ebx
c00288f1:	eb e8                	jmp    c00288db <udiv64+0x15a>

c00288f3 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c00288f3:	57                   	push   %edi
c00288f4:	56                   	push   %esi
c00288f5:	53                   	push   %ebx
c00288f6:	83 ec 08             	sub    $0x8,%esp
c00288f9:	89 04 24             	mov    %eax,(%esp)
c00288fc:	89 54 24 04          	mov    %edx,0x4(%esp)
c0028900:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028904:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028908:	85 d2                	test   %edx,%edx
c002890a:	78 2b                	js     c0028937 <sdiv64+0x44>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c002890c:	89 f1                	mov    %esi,%ecx
c002890e:	89 fb                	mov    %edi,%ebx
c0028910:	85 ff                	test   %edi,%edi
c0028912:	78 2c                	js     c0028940 <sdiv64+0x4d>
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028914:	53                   	push   %ebx
c0028915:	51                   	push   %ecx
c0028916:	e8 66 fe ff ff       	call   c0028781 <udiv64>
c002891b:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c002891e:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028922:	f7 d1                	not    %ecx
c0028924:	c1 e9 1f             	shr    $0x1f,%ecx
c0028927:	89 fb                	mov    %edi,%ebx
c0028929:	c1 eb 1f             	shr    $0x1f,%ebx
c002892c:	38 d9                	cmp    %bl,%cl
c002892e:	74 19                	je     c0028949 <sdiv64+0x56>
}
c0028930:	83 c4 08             	add    $0x8,%esp
c0028933:	5b                   	pop    %ebx
c0028934:	5e                   	pop    %esi
c0028935:	5f                   	pop    %edi
c0028936:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028937:	f7 d8                	neg    %eax
c0028939:	83 d2 00             	adc    $0x0,%edx
c002893c:	f7 da                	neg    %edx
c002893e:	eb cc                	jmp    c002890c <sdiv64+0x19>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028940:	f7 d9                	neg    %ecx
c0028942:	83 d3 00             	adc    $0x0,%ebx
c0028945:	f7 db                	neg    %ebx
c0028947:	eb cb                	jmp    c0028914 <sdiv64+0x21>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028949:	f7 d8                	neg    %eax
c002894b:	83 d2 00             	adc    $0x0,%edx
c002894e:	f7 da                	neg    %edx
c0028950:	eb de                	jmp    c0028930 <sdiv64+0x3d>

c0028952 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028952:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0028955:	ff 74 24 14          	pushl  0x14(%esp)
c0028959:	ff 74 24 14          	pushl  0x14(%esp)
c002895d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028961:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028965:	e8 89 ff ff ff       	call   c00288f3 <sdiv64>
}
c002896a:	83 c4 0c             	add    $0xc,%esp
c002896d:	c3                   	ret    

c002896e <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c002896e:	57                   	push   %edi
c002896f:	56                   	push   %esi
c0028970:	53                   	push   %ebx
c0028971:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028975:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028979:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c002897d:	57                   	push   %edi
c002897e:	56                   	push   %esi
c002897f:	89 d8                	mov    %ebx,%eax
c0028981:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028985:	e8 69 ff ff ff       	call   c00288f3 <sdiv64>
c002898a:	83 c4 08             	add    $0x8,%esp
c002898d:	0f af c6             	imul   %esi,%eax
c0028990:	29 c3                	sub    %eax,%ebx
  return smod64 (n, d);
c0028992:	89 d8                	mov    %ebx,%eax
c0028994:	99                   	cltd   
}
c0028995:	5b                   	pop    %ebx
c0028996:	5e                   	pop    %esi
c0028997:	5f                   	pop    %edi
c0028998:	c3                   	ret    

c0028999 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028999:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c002899c:	ff 74 24 14          	pushl  0x14(%esp)
c00289a0:	ff 74 24 14          	pushl  0x14(%esp)
c00289a4:	8b 44 24 10          	mov    0x10(%esp),%eax
c00289a8:	8b 54 24 14          	mov    0x14(%esp),%edx
c00289ac:	e8 d0 fd ff ff       	call   c0028781 <udiv64>
}
c00289b1:	83 c4 0c             	add    $0xc,%esp
c00289b4:	c3                   	ret    

c00289b5 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c00289b5:	57                   	push   %edi
c00289b6:	56                   	push   %esi
c00289b7:	53                   	push   %ebx
c00289b8:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00289bc:	8b 74 24 18          	mov    0x18(%esp),%esi
c00289c0:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c00289c4:	57                   	push   %edi
c00289c5:	56                   	push   %esi
c00289c6:	89 d8                	mov    %ebx,%eax
c00289c8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c00289cc:	e8 b0 fd ff ff       	call   c0028781 <udiv64>
c00289d1:	83 c4 08             	add    $0x8,%esp
c00289d4:	0f af c6             	imul   %esi,%eax
c00289d7:	29 c3                	sub    %eax,%ebx
  return umod64 (n, d);
c00289d9:	89 d8                	mov    %ebx,%eax
c00289db:	ba 00 00 00 00       	mov    $0x0,%edx
}
c00289e0:	5b                   	pop    %ebx
c00289e1:	5e                   	pop    %esi
c00289e2:	5f                   	pop    %edi
c00289e3:	c3                   	ret    

c00289e4 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c00289e4:	55                   	push   %ebp
c00289e5:	57                   	push   %edi
c00289e6:	56                   	push   %esi
c00289e7:	53                   	push   %ebx
c00289e8:	83 ec 04             	sub    $0x4,%esp
c00289eb:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c00289ee:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c00289f4:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ofs = 0; ofs < size; ofs++)
c00289f9:	85 d2                	test   %edx,%edx
c00289fb:	74 4d                	je     c0028a4a <parse_octal_field+0x66>
      char c = s[ofs];
c00289fd:	8b 04 24             	mov    (%esp),%eax
c0028a00:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
c0028a03:	8d 6b d0             	lea    -0x30(%ebx),%ebp
  for (ofs = 0; ofs < size; ofs++)
c0028a06:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
c0028a0b:	bf 00 00 00 00       	mov    $0x0,%edi
      if (c >= '0' && c <= '7')
c0028a10:	89 e8                	mov    %ebp,%eax
c0028a12:	3c 07                	cmp    $0x7,%al
c0028a14:	77 3c                	ja     c0028a52 <parse_octal_field+0x6e>
          *value = c - '0' + *value * 8;
c0028a16:	0f be db             	movsbl %bl,%ebx
c0028a19:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0028a1d:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0028a1f:	83 c6 01             	add    $0x1,%esi
c0028a22:	39 f2                	cmp    %esi,%edx
c0028a24:	74 1f                	je     c0028a45 <parse_octal_field+0x61>
      char c = s[ofs];
c0028a26:	8b 04 24             	mov    (%esp),%eax
c0028a29:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
c0028a2d:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c0028a30:	89 e8                	mov    %ebp,%eax
c0028a32:	3c 07                	cmp    $0x7,%al
c0028a34:	77 1c                	ja     c0028a52 <parse_octal_field+0x6e>
          if (*value > ULONG_MAX / 8)
c0028a36:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0028a3c:	76 d8                	jbe    c0028a16 <parse_octal_field+0x32>
              return false;
c0028a3e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028a43:	eb 05                	jmp    c0028a4a <parse_octal_field+0x66>
  return false;
c0028a45:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028a4a:	83 c4 04             	add    $0x4,%esp
c0028a4d:	5b                   	pop    %ebx
c0028a4e:	5e                   	pop    %esi
c0028a4f:	5f                   	pop    %edi
c0028a50:	5d                   	pop    %ebp
c0028a51:	c3                   	ret    
          return false;
c0028a52:	b8 00 00 00 00       	mov    $0x0,%eax
      else if (c == ' ' || c == '\0')
c0028a57:	f6 c3 df             	test   $0xdf,%bl
c0028a5a:	75 ee                	jne    c0028a4a <parse_octal_field+0x66>
          return ofs > 0;
c0028a5c:	85 f6                	test   %esi,%esi
c0028a5e:	0f 95 c0             	setne  %al
c0028a61:	eb e7                	jmp    c0028a4a <parse_octal_field+0x66>

c0028a63 <strip_antisocial_prefixes>:
{
c0028a63:	55                   	push   %ebp
c0028a64:	57                   	push   %edi
c0028a65:	56                   	push   %esi
c0028a66:	53                   	push   %ebx
c0028a67:	83 ec 1c             	sub    $0x1c,%esp
c0028a6a:	e8 cc 4e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0028a6f:	81 c3 5d 0a 01 00    	add    $0x10a5d,%ebx
c0028a75:	89 c5                	mov    %eax,%ebp
         || !memcmp (file_name, "./", 2)
c0028a77:	8d bb 29 62 ff ff    	lea    -0x9dd7(%ebx),%edi
         || !memcmp (file_name, "../", 3))
c0028a7d:	8d 83 fd 6d ff ff    	lea    -0x9203(%ebx),%eax
c0028a83:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (*file_name == '/'
c0028a87:	eb 11                	jmp    c0028a9a <strip_antisocial_prefixes+0x37>
    file_name = strchr (file_name, '/') + 1;
c0028a89:	83 ec 08             	sub    $0x8,%esp
c0028a8c:	6a 2f                	push   $0x2f
c0028a8e:	55                   	push   %ebp
c0028a8f:	e8 2c f8 ff ff       	call   c00282c0 <strchr>
c0028a94:	83 c4 10             	add    $0x10,%esp
c0028a97:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c0028a9a:	0f b6 75 00          	movzbl 0x0(%ebp),%esi
c0028a9e:	89 f0                	mov    %esi,%eax
c0028aa0:	3c 2f                	cmp    $0x2f,%al
c0028aa2:	74 e5                	je     c0028a89 <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "./", 2)
c0028aa4:	83 ec 04             	sub    $0x4,%esp
c0028aa7:	6a 02                	push   $0x2
c0028aa9:	57                   	push   %edi
c0028aaa:	55                   	push   %ebp
c0028aab:	e8 52 f7 ff ff       	call   c0028202 <memcmp>
c0028ab0:	83 c4 10             	add    $0x10,%esp
c0028ab3:	85 c0                	test   %eax,%eax
c0028ab5:	74 d2                	je     c0028a89 <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "../", 3))
c0028ab7:	83 ec 04             	sub    $0x4,%esp
c0028aba:	6a 03                	push   $0x3
c0028abc:	ff 74 24 14          	pushl  0x14(%esp)
c0028ac0:	55                   	push   %ebp
c0028ac1:	e8 3c f7 ff ff       	call   c0028202 <memcmp>
c0028ac6:	83 c4 10             	add    $0x10,%esp
c0028ac9:	85 c0                	test   %eax,%eax
c0028acb:	74 bc                	je     c0028a89 <strip_antisocial_prefixes+0x26>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0028acd:	8d 83 af 67 ff ff    	lea    -0x9851(%ebx),%eax
c0028ad3:	89 f2                	mov    %esi,%edx
c0028ad5:	84 d2                	test   %dl,%dl
c0028ad7:	74 22                	je     c0028afb <strip_antisocial_prefixes+0x98>
c0028ad9:	b9 03 00 00 00       	mov    $0x3,%ecx
c0028ade:	8d bb ae 67 ff ff    	lea    -0x9852(%ebx),%edi
c0028ae4:	89 ee                	mov    %ebp,%esi
c0028ae6:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0028ae8:	0f 97 c0             	seta   %al
c0028aeb:	1c 00                	sbb    $0x0,%al
c0028aed:	0f be c0             	movsbl %al,%eax
c0028af0:	85 c0                	test   %eax,%eax
c0028af2:	8d 83 af 67 ff ff    	lea    -0x9851(%ebx),%eax
c0028af8:	0f 45 c5             	cmovne %ebp,%eax
}
c0028afb:	83 c4 1c             	add    $0x1c,%esp
c0028afe:	5b                   	pop    %ebx
c0028aff:	5e                   	pop    %esi
c0028b00:	5f                   	pop    %edi
c0028b01:	5d                   	pop    %ebp
c0028b02:	c3                   	ret    

c0028b03 <ustar_make_header>:
{
c0028b03:	55                   	push   %ebp
c0028b04:	57                   	push   %edi
c0028b05:	56                   	push   %esi
c0028b06:	53                   	push   %ebx
c0028b07:	83 ec 1c             	sub    $0x1c,%esp
c0028b0a:	e8 2c 4e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0028b0f:	81 c3 bd 09 01 00    	add    $0x109bd,%ebx
c0028b15:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028b19:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028b1d:	83 fd 30             	cmp    $0x30,%ebp
c0028b20:	0f 94 c2             	sete   %dl
c0028b23:	83 fd 35             	cmp    $0x35,%ebp
c0028b26:	0f 94 c0             	sete   %al
c0028b29:	08 c2                	or     %al,%dl
c0028b2b:	88 54 24 0f          	mov    %dl,0xf(%esp)
c0028b2f:	0f 84 77 01 00 00    	je     c0028cac <ustar_make_header+0x1a9>
  file_name = strip_antisocial_prefixes (file_name);
c0028b35:	8b 44 24 30          	mov    0x30(%esp),%eax
c0028b39:	e8 25 ff ff ff       	call   c0028a63 <strip_antisocial_prefixes>
c0028b3e:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028b40:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028b45:	b8 00 00 00 00       	mov    $0x0,%eax
c0028b4a:	89 d7                	mov    %edx,%edi
c0028b4c:	f2 ae                	repnz scas %es:(%edi),%al
c0028b4e:	f7 d1                	not    %ecx
c0028b50:	83 e9 01             	sub    $0x1,%ecx
c0028b53:	83 f9 63             	cmp    $0x63,%ecx
c0028b56:	0f 87 76 01 00 00    	ja     c0028cd2 <ustar_make_header+0x1cf>
  memset (h, 0, sizeof *h);
c0028b5c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0028b62:	c7 86 fc 01 00 00 00 	movl   $0x0,0x1fc(%esi)
c0028b69:	00 00 00 
c0028b6c:	8d 7e 04             	lea    0x4(%esi),%edi
c0028b6f:	83 e7 fc             	and    $0xfffffffc,%edi
c0028b72:	89 f1                	mov    %esi,%ecx
c0028b74:	29 f9                	sub    %edi,%ecx
c0028b76:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0028b7c:	c1 e9 02             	shr    $0x2,%ecx
c0028b7f:	b8 00 00 00 00       	mov    $0x0,%eax
c0028b84:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028b86:	83 ec 04             	sub    $0x4,%esp
c0028b89:	6a 64                	push   $0x64
c0028b8b:	52                   	push   %edx
c0028b8c:	56                   	push   %esi
c0028b8d:	e8 52 fa ff ff       	call   c00285e4 <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028b92:	83 c4 10             	add    $0x10,%esp
c0028b95:	83 fd 30             	cmp    $0x30,%ebp
c0028b98:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0028b9d:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0028ba2:	0f 45 c2             	cmovne %edx,%eax
c0028ba5:	50                   	push   %eax
c0028ba6:	8d 83 2b 6e ff ff    	lea    -0x91d5(%ebx),%eax
c0028bac:	50                   	push   %eax
c0028bad:	6a 08                	push   $0x8
c0028baf:	8d 46 64             	lea    0x64(%esi),%eax
c0028bb2:	50                   	push   %eax
c0028bb3:	e8 61 ef ff ff       	call   c0027b19 <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0028bb8:	83 c4 0c             	add    $0xc,%esp
c0028bbb:	6a 08                	push   $0x8
c0028bbd:	8d bb 30 6e ff ff    	lea    -0x91d0(%ebx),%edi
c0028bc3:	57                   	push   %edi
c0028bc4:	8d 46 6c             	lea    0x6c(%esi),%eax
c0028bc7:	50                   	push   %eax
c0028bc8:	e8 17 fa ff ff       	call   c00285e4 <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0028bcd:	83 c4 0c             	add    $0xc,%esp
c0028bd0:	6a 08                	push   $0x8
c0028bd2:	57                   	push   %edi
c0028bd3:	8d 46 74             	lea    0x74(%esi),%eax
c0028bd6:	50                   	push   %eax
c0028bd7:	e8 08 fa ff ff       	call   c00285e4 <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0028bdc:	ff 74 24 48          	pushl  0x48(%esp)
c0028be0:	8d bb 38 6e ff ff    	lea    -0x91c8(%ebx),%edi
c0028be6:	57                   	push   %edi
c0028be7:	6a 0c                	push   $0xc
c0028be9:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028bec:	50                   	push   %eax
c0028bed:	e8 27 ef ff ff       	call   c0027b19 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0028bf2:	83 c4 20             	add    $0x20,%esp
c0028bf5:	68 00 8c b7 43       	push   $0x43b78c00
c0028bfa:	57                   	push   %edi
c0028bfb:	6a 0c                	push   $0xc
c0028bfd:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0028c03:	50                   	push   %eax
c0028c04:	e8 10 ef ff ff       	call   c0027b19 <snprintf>
  h->typeflag = type;
c0028c09:	89 e8                	mov    %ebp,%eax
c0028c0b:	88 86 9c 00 00 00    	mov    %al,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0028c11:	83 c4 0c             	add    $0xc,%esp
c0028c14:	6a 06                	push   $0x6
c0028c16:	8d 83 3e 6e ff ff    	lea    -0x91c2(%ebx),%eax
c0028c1c:	50                   	push   %eax
c0028c1d:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028c23:	50                   	push   %eax
c0028c24:	e8 bb f9 ff ff       	call   c00285e4 <strlcpy>
  h->version[0] = h->version[1] = '0';
c0028c29:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0028c30:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c0028c37:	83 c4 0c             	add    $0xc,%esp
c0028c3a:	6a 20                	push   $0x20
c0028c3c:	8d bb e0 63 ff ff    	lea    -0x9c20(%ebx),%edi
c0028c42:	57                   	push   %edi
c0028c43:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c0028c49:	50                   	push   %eax
c0028c4a:	e8 95 f9 ff ff       	call   c00285e4 <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0028c4f:	83 c4 0c             	add    $0xc,%esp
c0028c52:	6a 20                	push   $0x20
c0028c54:	57                   	push   %edi
c0028c55:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0028c5b:	50                   	push   %eax
c0028c5c:	e8 83 f9 ff ff       	call   c00285e4 <strlcpy>
c0028c61:	83 c4 10             	add    $0x10,%esp
c0028c64:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028c69:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c0028c6e:	bf 20 00 00 00       	mov    $0x20,%edi
c0028c73:	83 f8 07             	cmp    $0x7,%eax
c0028c76:	77 74                	ja     c0028cec <ustar_make_header+0x1e9>
c0028c78:	89 f9                	mov    %edi,%ecx
c0028c7a:	01 ca                	add    %ecx,%edx
c0028c7c:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028c7f:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028c84:	75 ed                	jne    c0028c73 <ustar_make_header+0x170>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0028c86:	52                   	push   %edx
c0028c87:	8d 83 2b 6e ff ff    	lea    -0x91d5(%ebx),%eax
c0028c8d:	50                   	push   %eax
c0028c8e:	6a 08                	push   $0x8
c0028c90:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028c96:	56                   	push   %esi
c0028c97:	e8 7d ee ff ff       	call   c0027b19 <snprintf>
  return true;
c0028c9c:	83 c4 10             	add    $0x10,%esp
}
c0028c9f:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0028ca4:	83 c4 1c             	add    $0x1c,%esp
c0028ca7:	5b                   	pop    %ebx
c0028ca8:	5e                   	pop    %esi
c0028ca9:	5f                   	pop    %edi
c0028caa:	5d                   	pop    %ebp
c0028cab:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028cac:	83 ec 0c             	sub    $0xc,%esp
c0028caf:	8d 83 e8 6e ff ff    	lea    -0x9118(%ebx),%eax
c0028cb5:	50                   	push   %eax
c0028cb6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0028cbc:	50                   	push   %eax
c0028cbd:	8d 83 b0 51 ff ff    	lea    -0xae50(%ebx),%eax
c0028cc3:	50                   	push   %eax
c0028cc4:	6a 59                	push   $0x59
c0028cc6:	8d 83 01 6e ff ff    	lea    -0x91ff(%ebx),%eax
c0028ccc:	50                   	push   %eax
c0028ccd:	e8 bd 02 00 00       	call   c0028f8f <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028cd2:	83 ec 08             	sub    $0x8,%esp
c0028cd5:	52                   	push   %edx
c0028cd6:	8d 83 13 6e ff ff    	lea    -0x91ed(%ebx),%eax
c0028cdc:	50                   	push   %eax
c0028cdd:	e8 16 e5 ff ff       	call   c00271f8 <printf>
      return false;
c0028ce2:	83 c4 10             	add    $0x10,%esp
c0028ce5:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
c0028cea:	eb b3                	jmp    c0028c9f <ustar_make_header+0x19c>
      chksum += in_chksum_field ? ' ' : header[i];
c0028cec:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0028cf3:	00 
c0028cf4:	eb 84                	jmp    c0028c7a <ustar_make_header+0x177>

c0028cf6 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0028cf6:	57                   	push   %edi
c0028cf7:	56                   	push   %esi
c0028cf8:	53                   	push   %ebx
c0028cf9:	83 ec 10             	sub    $0x10,%esp
c0028cfc:	e8 3a 4c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0028d01:	81 c3 cb 07 01 00    	add    $0x107cb,%ebx
c0028d07:	8b 74 24 20          	mov    0x20(%esp),%esi
c0028d0b:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
c0028d11:	89 f0                	mov    %esi,%eax
    if (*block++ != 0)
c0028d13:	83 c0 01             	add    $0x1,%eax
c0028d16:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0028d1a:	75 70                	jne    c0028d8c <ustar_parse_header+0x96>
  while (cnt-- > 0)
c0028d1c:	39 c2                	cmp    %eax,%edx
c0028d1e:	75 f3                	jne    c0028d13 <ustar_parse_header+0x1d>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0028d20:	8b 44 24 24          	mov    0x24(%esp),%eax
c0028d24:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0028d2a:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028d2e:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0028d34:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0028d38:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0028d3e:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c0028d43:	89 c8                	mov    %ecx,%eax
c0028d45:	83 c4 10             	add    $0x10,%esp
c0028d48:	5b                   	pop    %ebx
c0028d49:	5e                   	pop    %esi
c0028d4a:	5f                   	pop    %edi
c0028d4b:	c3                   	ret    
      chksum += in_chksum_field ? ' ' : header[i];
c0028d4c:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0028d53:	00 
c0028d54:	e9 b0 00 00 00       	jmp    c0028e09 <ustar_parse_header+0x113>
    size_ul = 0;
c0028d59:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0028d60:	00 
  *file_name = strip_antisocial_prefixes (h->name);
c0028d61:	89 f0                	mov    %esi,%eax
c0028d63:	e8 fb fc ff ff       	call   c0028a63 <strip_antisocial_prefixes>
c0028d68:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028d6c:	89 07                	mov    %eax,(%edi)
  *type = h->typeflag;
c0028d6e:	0f be 86 9c 00 00 00 	movsbl 0x9c(%esi),%eax
c0028d75:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0028d79:	89 07                	mov    %eax,(%edi)
  *size = size_ul;
c0028d7b:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028d7f:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0028d83:	89 07                	mov    %eax,(%edi)
  return NULL;
c0028d85:	b9 00 00 00 00       	mov    $0x0,%ecx
c0028d8a:	eb b7                	jmp    c0028d43 <ustar_parse_header+0x4d>
  if (memcmp (h->magic, "ustar", 6))
c0028d8c:	83 ec 04             	sub    $0x4,%esp
c0028d8f:	6a 06                	push   $0x6
c0028d91:	8d 83 3e 6e ff ff    	lea    -0x91c2(%ebx),%eax
c0028d97:	50                   	push   %eax
c0028d98:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028d9e:	50                   	push   %eax
c0028d9f:	e8 5e f4 ff ff       	call   c0028202 <memcmp>
c0028da4:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c0028da7:	8d 8b 44 6e ff ff    	lea    -0x91bc(%ebx),%ecx
  if (memcmp (h->magic, "ustar", 6))
c0028dad:	85 c0                	test   %eax,%eax
c0028daf:	75 92                	jne    c0028d43 <ustar_parse_header+0x4d>
    return "invalid ustar version";
c0028db1:	8d 8b 58 6e ff ff    	lea    -0x91a8(%ebx),%ecx
  else if (h->version[0] != '0' || h->version[1] != '0')
c0028db7:	80 be 07 01 00 00 30 	cmpb   $0x30,0x107(%esi)
c0028dbe:	75 83                	jne    c0028d43 <ustar_parse_header+0x4d>
c0028dc0:	80 be 08 01 00 00 30 	cmpb   $0x30,0x108(%esi)
c0028dc7:	0f 85 76 ff ff ff    	jne    c0028d43 <ustar_parse_header+0x4d>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028dcd:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0028dd1:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c0028dd7:	ba 08 00 00 00       	mov    $0x8,%edx
c0028ddc:	e8 03 fc ff ff       	call   c00289e4 <parse_octal_field>
    return "corrupt chksum field";
c0028de1:	8d 8b 6e 6e ff ff    	lea    -0x9192(%ebx),%ecx
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0028de7:	84 c0                	test   %al,%al
c0028de9:	0f 84 54 ff ff ff    	je     c0028d43 <ustar_parse_header+0x4d>
c0028def:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028df4:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c0028df9:	bf 20 00 00 00       	mov    $0x20,%edi
c0028dfe:	83 f8 07             	cmp    $0x7,%eax
c0028e01:	0f 87 45 ff ff ff    	ja     c0028d4c <ustar_parse_header+0x56>
c0028e07:	89 f9                	mov    %edi,%ecx
c0028e09:	01 ca                	add    %ecx,%edx
c0028e0b:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028e0e:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028e13:	75 e9                	jne    c0028dfe <ustar_parse_header+0x108>
    return "checksum mismatch";
c0028e15:	8d 8b 83 6e ff ff    	lea    -0x917d(%ebx),%ecx
  else if (chksum != calculate_chksum (h))
c0028e1b:	39 54 24 0c          	cmp    %edx,0xc(%esp)
c0028e1f:	0f 85 1e ff ff ff    	jne    c0028d43 <ustar_parse_header+0x4d>
    return "file name too long";
c0028e25:	8d 8b 95 6e ff ff    	lea    -0x916b(%ebx),%ecx
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0028e2b:	80 7e 63 00          	cmpb   $0x0,0x63(%esi)
c0028e2f:	0f 85 0e ff ff ff    	jne    c0028d43 <ustar_parse_header+0x4d>
c0028e35:	80 be 59 01 00 00 00 	cmpb   $0x0,0x159(%esi)
c0028e3c:	0f 85 01 ff ff ff    	jne    c0028d43 <ustar_parse_header+0x4d>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028e42:	0f b6 86 9c 00 00 00 	movzbl 0x9c(%esi),%eax
c0028e49:	3c 30                	cmp    $0x30,%al
c0028e4b:	74 0e                	je     c0028e5b <ustar_parse_header+0x165>
    return "unimplemented file type";
c0028e4d:	8d 8b a8 6e ff ff    	lea    -0x9158(%ebx),%ecx
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0028e53:	3c 35                	cmp    $0x35,%al
c0028e55:	0f 85 e8 fe ff ff    	jne    c0028d43 <ustar_parse_header+0x4d>
  if (h->typeflag == USTAR_REGULAR)
c0028e5b:	3c 30                	cmp    $0x30,%al
c0028e5d:	0f 85 f6 fe ff ff    	jne    c0028d59 <ustar_parse_header+0x63>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028e63:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0028e67:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028e6a:	ba 0c 00 00 00       	mov    $0xc,%edx
c0028e6f:	e8 70 fb ff ff       	call   c00289e4 <parse_octal_field>
        return "corrupt file size field";
c0028e74:	8d 8b c0 6e ff ff    	lea    -0x9140(%ebx),%ecx
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0028e7a:	84 c0                	test   %al,%al
c0028e7c:	0f 84 c1 fe ff ff    	je     c0028d43 <ustar_parse_header+0x4d>
        return "file too large";
c0028e82:	8d 8b d8 6e ff ff    	lea    -0x9128(%ebx),%ecx
      else if (size_ul > INT_MAX)
c0028e88:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028e8d:	0f 88 b0 fe ff ff    	js     c0028d43 <ustar_parse_header+0x4d>
c0028e93:	e9 c9 fe ff ff       	jmp    c0028d61 <ustar_parse_header+0x6b>

c0028e98 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0028e98:	55                   	push   %ebp
c0028e99:	89 e5                	mov    %esp,%ebp
c0028e9b:	57                   	push   %edi
c0028e9c:	56                   	push   %esi
c0028e9d:	53                   	push   %ebx
c0028e9e:	83 ec 0c             	sub    $0xc,%esp
c0028ea1:	e8 95 4a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0028ea6:	81 c3 26 06 01 00    	add    $0x10626,%ebx
c0028eac:	8b 75 08             	mov    0x8(%ebp),%esi
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0028eaf:	8b 56 04             	mov    0x4(%esi),%edx
    case THREAD_RUNNING:  
      status = "RUNNING";
      break;

    case THREAD_READY:  
      status = "READY";
c0028eb2:	8d 83 19 6f ff ff    	lea    -0x90e7(%ebx),%eax
  switch (t->status) {
c0028eb8:	83 fa 01             	cmp    $0x1,%edx
c0028ebb:	74 1d                	je     c0028eda <print_stacktrace+0x42>
      status = "RUNNING";
c0028ebd:	8d 83 bd 59 ff ff    	lea    -0xa643(%ebx),%eax
  switch (t->status) {
c0028ec3:	83 fa 01             	cmp    $0x1,%edx
c0028ec6:	72 12                	jb     c0028eda <print_stacktrace+0x42>
  const char *status = "UNKNOWN";
c0028ec8:	83 fa 02             	cmp    $0x2,%edx
c0028ecb:	8d 83 77 59 ff ff    	lea    -0xa689(%ebx),%eax
c0028ed1:	8d 93 1f 6f ff ff    	lea    -0x90e1(%ebx),%edx
c0028ed7:	0f 45 c2             	cmovne %edx,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0028eda:	83 ec 04             	sub    $0x4,%esp
c0028edd:	50                   	push   %eax
c0028ede:	8d 46 08             	lea    0x8(%esi),%eax
c0028ee1:	50                   	push   %eax
c0028ee2:	8d 83 44 6f ff ff    	lea    -0x90bc(%ebx),%eax
c0028ee8:	50                   	push   %eax
c0028ee9:	e8 0a e3 ff ff       	call   c00271f8 <printf>

  if (t == thread_current()) 
c0028eee:	e8 90 7c ff ff       	call   c0020b83 <thread_current>
c0028ef3:	83 c4 10             	add    $0x10,%esp
c0028ef6:	39 f0                	cmp    %esi,%eax
c0028ef8:	74 79                	je     c0028f73 <print_stacktrace+0xdb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0028efa:	8b 56 18             	mov    0x18(%esi),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0028efd:	81 c6 00 10 00 00    	add    $0x1000,%esi
c0028f03:	39 f2                	cmp    %esi,%edx
c0028f05:	74 74                	je     c0028f7b <print_stacktrace+0xe3>
c0028f07:	8b 42 10             	mov    0x10(%edx),%eax
c0028f0a:	81 f8 84 19 02 c0    	cmp    $0xc0021984,%eax
c0028f10:	74 69                	je     c0028f7b <print_stacktrace+0xe3>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c0028f12:	8b 72 08             	mov    0x8(%edx),%esi
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c0028f15:	83 ec 08             	sub    $0x8,%esp
c0028f18:	50                   	push   %eax
c0028f19:	8d 83 18 6c ff ff    	lea    -0x93e8(%ebx),%eax
c0028f1f:	50                   	push   %eax
c0028f20:	e8 d3 e2 ff ff       	call   c00271f8 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028f25:	83 c4 10             	add    $0x10,%esp
c0028f28:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0028f2e:	76 29                	jbe    c0028f59 <print_stacktrace+0xc1>
c0028f30:	83 3e 00             	cmpl   $0x0,(%esi)
c0028f33:	74 24                	je     c0028f59 <print_stacktrace+0xc1>
    printf (" %p", frame[1]);
c0028f35:	8d bb 18 6c ff ff    	lea    -0x93e8(%ebx),%edi
c0028f3b:	83 ec 08             	sub    $0x8,%esp
c0028f3e:	ff 76 04             	pushl  0x4(%esi)
c0028f41:	57                   	push   %edi
c0028f42:	e8 b1 e2 ff ff       	call   c00271f8 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0028f47:	8b 36                	mov    (%esi),%esi
c0028f49:	83 c4 10             	add    $0x10,%esp
c0028f4c:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0028f52:	76 05                	jbe    c0028f59 <print_stacktrace+0xc1>
c0028f54:	83 3e 00             	cmpl   $0x0,(%esi)
c0028f57:	75 e2                	jne    c0028f3b <print_stacktrace+0xa3>
  printf (".\n");
c0028f59:	83 ec 0c             	sub    $0xc,%esp
c0028f5c:	8d 83 af 67 ff ff    	lea    -0x9851(%ebx),%eax
c0028f62:	50                   	push   %eax
c0028f63:	e8 4b 1f 00 00       	call   c002aeb3 <puts>
c0028f68:	83 c4 10             	add    $0x10,%esp
}
c0028f6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028f6e:	5b                   	pop    %ebx
c0028f6f:	5e                   	pop    %esi
c0028f70:	5f                   	pop    %edi
c0028f71:	5d                   	pop    %ebp
c0028f72:	c3                   	ret    
      frame = __builtin_frame_address (1);
c0028f73:	8b 75 00             	mov    0x0(%ebp),%esi
      retaddr = __builtin_return_address (0);
c0028f76:	8b 45 04             	mov    0x4(%ebp),%eax
c0028f79:	eb 9a                	jmp    c0028f15 <print_stacktrace+0x7d>
          printf (" thread was never scheduled.\n");
c0028f7b:	83 ec 0c             	sub    $0xc,%esp
c0028f7e:	8d 83 27 6f ff ff    	lea    -0x90d9(%ebx),%eax
c0028f84:	50                   	push   %eax
c0028f85:	e8 29 1f 00 00       	call   c002aeb3 <puts>
          return;
c0028f8a:	83 c4 10             	add    $0x10,%esp
c0028f8d:	eb dc                	jmp    c0028f6b <print_stacktrace+0xd3>

c0028f8f <debug_panic>:
{
c0028f8f:	55                   	push   %ebp
c0028f90:	57                   	push   %edi
c0028f91:	56                   	push   %esi
c0028f92:	53                   	push   %ebx
c0028f93:	83 ec 0c             	sub    $0xc,%esp
c0028f96:	e8 a0 49 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0028f9b:	81 c3 31 05 01 00    	add    $0x10531,%ebx
c0028fa1:	8b 74 24 20          	mov    0x20(%esp),%esi
c0028fa5:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028fa9:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  intr_disable ();
c0028fad:	e8 94 8b ff ff       	call   c0021b46 <intr_disable>
  console_panic ();
c0028fb2:	e8 7b 1e 00 00       	call   c002ae32 <console_panic>
  level++;
c0028fb7:	8b 83 14 23 00 00    	mov    0x2314(%ebx),%eax
c0028fbd:	83 c0 01             	add    $0x1,%eax
c0028fc0:	89 83 14 23 00 00    	mov    %eax,0x2314(%ebx)
  if (level == 1) 
c0028fc6:	83 f8 01             	cmp    $0x1,%eax
c0028fc9:	74 11                	je     c0028fdc <debug_panic+0x4d>
  else if (level == 2)
c0028fcb:	83 f8 02             	cmp    $0x2,%eax
c0028fce:	74 42                	je     c0029012 <debug_panic+0x83>
  serial_flush ();
c0028fd0:	e8 b7 bd ff ff       	call   c0024d8c <serial_flush>
  shutdown ();
c0028fd5:	e8 1b db ff ff       	call   c0026af5 <shutdown>
c0028fda:	eb fe                	jmp    c0028fda <debug_panic+0x4b>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0028fdc:	55                   	push   %ebp
c0028fdd:	57                   	push   %edi
c0028fde:	56                   	push   %esi
c0028fdf:	8d 83 6c 6f ff ff    	lea    -0x9094(%ebx),%eax
c0028fe5:	50                   	push   %eax
c0028fe6:	e8 0d e2 ff ff       	call   c00271f8 <printf>
      va_start (args, message);
c0028feb:	8d 44 24 40          	lea    0x40(%esp),%eax
      vprintf (message, args);
c0028fef:	83 c4 08             	add    $0x8,%esp
c0028ff2:	50                   	push   %eax
c0028ff3:	ff 74 24 38          	pushl  0x38(%esp)
c0028ff7:	e8 74 1e 00 00       	call   c002ae70 <vprintf>
      printf ("\n");
c0028ffc:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0029003:	e8 1d 1f 00 00       	call   c002af25 <putchar>
      debug_backtrace ();
c0029008:	e8 cf db ff ff       	call   c0026bdc <debug_backtrace>
c002900d:	83 c4 10             	add    $0x10,%esp
c0029010:	eb be                	jmp    c0028fd0 <debug_panic+0x41>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0029012:	55                   	push   %ebp
c0029013:	57                   	push   %edi
c0029014:	56                   	push   %esi
c0029015:	8d 83 8c 6f ff ff    	lea    -0x9074(%ebx),%eax
c002901b:	50                   	push   %eax
c002901c:	e8 d7 e1 ff ff       	call   c00271f8 <printf>
c0029021:	83 c4 10             	add    $0x10,%esp
c0029024:	eb aa                	jmp    c0028fd0 <debug_panic+0x41>

c0029026 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0029026:	56                   	push   %esi
c0029027:	53                   	push   %ebx
c0029028:	83 ec 04             	sub    $0x4,%esp
c002902b:	e8 0b 49 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029030:	81 c3 9c 04 01 00    	add    $0x1049c,%ebx
  enum intr_level oldlevel = intr_disable ();
c0029036:	e8 0b 8b ff ff       	call   c0021b46 <intr_disable>
c002903b:	89 c6                	mov    %eax,%esi

  thread_foreach (print_stacktrace, 0);
c002903d:	83 ec 08             	sub    $0x8,%esp
c0029040:	6a 00                	push   $0x0
c0029042:	8d 83 cc f9 fe ff    	lea    -0x10634(%ebx),%eax
c0029048:	50                   	push   %eax
c0029049:	e8 2a 7c ff ff       	call   c0020c78 <thread_foreach>
  intr_set_level (oldlevel);
c002904e:	89 34 24             	mov    %esi,(%esp)
c0029051:	e8 f7 8a ff ff       	call   c0021b4d <intr_set_level>
}
c0029056:	83 c4 14             	add    $0x14,%esp
c0029059:	5b                   	pop    %ebx
c002905a:	5e                   	pop    %esi
c002905b:	c3                   	ret    

c002905c <list_init>:
}

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c002905c:	53                   	push   %ebx
c002905d:	83 ec 08             	sub    $0x8,%esp
c0029060:	e8 d6 48 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029065:	81 c3 67 04 01 00    	add    $0x10467,%ebx
c002906b:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002906f:	85 c0                	test   %eax,%eax
c0029071:	74 1b                	je     c002908e <list_init+0x32>
  list->head.prev = NULL;
c0029073:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0029079:	8d 50 08             	lea    0x8(%eax),%edx
c002907c:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c002907f:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c0029082:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029089:	83 c4 08             	add    $0x8,%esp
c002908c:	5b                   	pop    %ebx
c002908d:	c3                   	ret    
  ASSERT (list != NULL);
c002908e:	83 ec 0c             	sub    $0xc,%esp
c0029091:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c0029097:	50                   	push   %eax
c0029098:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002909e:	50                   	push   %eax
c002909f:	8d 83 ac 52 ff ff    	lea    -0xad54(%ebx),%eax
c00290a5:	50                   	push   %eax
c00290a6:	6a 3f                	push   $0x3f
c00290a8:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00290ae:	50                   	push   %eax
c00290af:	e8 db fe ff ff       	call   c0028f8f <debug_panic>

c00290b4 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c00290b4:	53                   	push   %ebx
c00290b5:	83 ec 08             	sub    $0x8,%esp
c00290b8:	e8 7e 48 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00290bd:	81 c3 0f 04 01 00    	add    $0x1040f,%ebx
c00290c3:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00290c7:	85 c0                	test   %eax,%eax
c00290c9:	74 08                	je     c00290d3 <list_begin+0x1f>
  return list->head.next;
c00290cb:	8b 40 04             	mov    0x4(%eax),%eax
}
c00290ce:	83 c4 08             	add    $0x8,%esp
c00290d1:	5b                   	pop    %ebx
c00290d2:	c3                   	ret    
  ASSERT (list != NULL);
c00290d3:	83 ec 0c             	sub    $0xc,%esp
c00290d6:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c00290dc:	50                   	push   %eax
c00290dd:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00290e3:	50                   	push   %eax
c00290e4:	8d 83 a0 52 ff ff    	lea    -0xad60(%ebx),%eax
c00290ea:	50                   	push   %eax
c00290eb:	6a 4a                	push   $0x4a
c00290ed:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00290f3:	50                   	push   %eax
c00290f4:	e8 96 fe ff ff       	call   c0028f8f <debug_panic>

c00290f9 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c00290f9:	53                   	push   %ebx
c00290fa:	83 ec 08             	sub    $0x8,%esp
c00290fd:	e8 39 48 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029102:	81 c3 ca 03 01 00    	add    $0x103ca,%ebx
c0029108:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002910c:	85 c0                	test   %eax,%eax
c002910e:	74 20                	je     c0029130 <list_next+0x37>
c0029110:	83 38 00             	cmpl   $0x0,(%eax)
c0029113:	74 13                	je     c0029128 <list_next+0x2f>
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029115:	83 38 00             	cmpl   $0x0,(%eax)
c0029118:	74 16                	je     c0029130 <list_next+0x37>
c002911a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002911e:	74 10                	je     c0029130 <list_next+0x37>
  ASSERT (is_head (elem) || is_interior (elem));
  return elem->next;
c0029120:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029123:	83 c4 08             	add    $0x8,%esp
c0029126:	5b                   	pop    %ebx
c0029127:	c3                   	ret    
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029128:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002912c:	75 f2                	jne    c0029120 <list_next+0x27>
c002912e:	eb e5                	jmp    c0029115 <list_next+0x1c>
  ASSERT (is_head (elem) || is_interior (elem));
c0029130:	83 ec 0c             	sub    $0xc,%esp
c0029133:	8d 83 78 70 ff ff    	lea    -0x8f88(%ebx),%eax
c0029139:	50                   	push   %eax
c002913a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029140:	50                   	push   %eax
c0029141:	8d 83 94 52 ff ff    	lea    -0xad6c(%ebx),%eax
c0029147:	50                   	push   %eax
c0029148:	6a 54                	push   $0x54
c002914a:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029150:	50                   	push   %eax
c0029151:	e8 39 fe ff ff       	call   c0028f8f <debug_panic>

c0029156 <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029156:	53                   	push   %ebx
c0029157:	83 ec 08             	sub    $0x8,%esp
c002915a:	e8 dc 47 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002915f:	81 c3 6d 03 01 00    	add    $0x1036d,%ebx
c0029165:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0029169:	85 c0                	test   %eax,%eax
c002916b:	74 08                	je     c0029175 <list_end+0x1f>
  return &list->tail;
c002916d:	83 c0 08             	add    $0x8,%eax
}
c0029170:	83 c4 08             	add    $0x8,%esp
c0029173:	5b                   	pop    %ebx
c0029174:	c3                   	ret    
  ASSERT (list != NULL);
c0029175:	83 ec 0c             	sub    $0xc,%esp
c0029178:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c002917e:	50                   	push   %eax
c002917f:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029185:	50                   	push   %eax
c0029186:	8d 83 88 52 ff ff    	lea    -0xad78(%ebx),%eax
c002918c:	50                   	push   %eax
c002918d:	6a 60                	push   $0x60
c002918f:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029195:	50                   	push   %eax
c0029196:	e8 f4 fd ff ff       	call   c0028f8f <debug_panic>

c002919b <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c002919b:	53                   	push   %ebx
c002919c:	83 ec 08             	sub    $0x8,%esp
c002919f:	e8 97 47 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00291a4:	81 c3 28 03 01 00    	add    $0x10328,%ebx
c00291aa:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00291ae:	85 c0                	test   %eax,%eax
c00291b0:	74 08                	je     c00291ba <list_rbegin+0x1f>
  return list->tail.prev;
c00291b2:	8b 40 08             	mov    0x8(%eax),%eax
}
c00291b5:	83 c4 08             	add    $0x8,%esp
c00291b8:	5b                   	pop    %ebx
c00291b9:	c3                   	ret    
  ASSERT (list != NULL);
c00291ba:	83 ec 0c             	sub    $0xc,%esp
c00291bd:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c00291c3:	50                   	push   %eax
c00291c4:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00291ca:	50                   	push   %eax
c00291cb:	8d 83 7c 52 ff ff    	lea    -0xad84(%ebx),%eax
c00291d1:	50                   	push   %eax
c00291d2:	6a 69                	push   $0x69
c00291d4:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00291da:	50                   	push   %eax
c00291db:	e8 af fd ff ff       	call   c0028f8f <debug_panic>

c00291e0 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00291e0:	53                   	push   %ebx
c00291e1:	83 ec 08             	sub    $0x8,%esp
c00291e4:	e8 52 47 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00291e9:	81 c3 e3 02 01 00    	add    $0x102e3,%ebx
c00291ef:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00291f3:	85 c0                	test   %eax,%eax
c00291f5:	74 1d                	je     c0029214 <list_prev+0x34>
c00291f7:	83 38 00             	cmpl   $0x0,(%eax)
c00291fa:	74 0d                	je     c0029209 <list_prev+0x29>
c00291fc:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029200:	74 07                	je     c0029209 <list_prev+0x29>
  ASSERT (is_interior (elem) || is_tail (elem));
  return elem->prev;
c0029202:	8b 00                	mov    (%eax),%eax
}
c0029204:	83 c4 08             	add    $0x8,%esp
c0029207:	5b                   	pop    %ebx
c0029208:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029209:	83 38 00             	cmpl   $0x0,(%eax)
c002920c:	74 06                	je     c0029214 <list_prev+0x34>
c002920e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029212:	74 ee                	je     c0029202 <list_prev+0x22>
  ASSERT (is_interior (elem) || is_tail (elem));
c0029214:	83 ec 0c             	sub    $0xc,%esp
c0029217:	8d 83 a0 70 ff ff    	lea    -0x8f60(%ebx),%eax
c002921d:	50                   	push   %eax
c002921e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029224:	50                   	push   %eax
c0029225:	8d 83 70 52 ff ff    	lea    -0xad90(%ebx),%eax
c002922b:	50                   	push   %eax
c002922c:	6a 73                	push   $0x73
c002922e:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029234:	50                   	push   %eax
c0029235:	e8 55 fd ff ff       	call   c0028f8f <debug_panic>

c002923a <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002923a:	55                   	push   %ebp
c002923b:	57                   	push   %edi
c002923c:	56                   	push   %esi
c002923d:	53                   	push   %ebx
c002923e:	83 ec 1c             	sub    $0x1c,%esp
c0029241:	e8 fd 46 00 00       	call   c002d943 <__x86.get_pc_thunk.di>
c0029246:	81 c7 86 02 01 00    	add    $0x10286,%edi
c002924c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0029250:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (a != NULL);
c0029254:	85 c0                	test   %eax,%eax
c0029256:	74 50                	je     c00292a8 <find_end_of_run+0x6e>
c0029258:	89 c3                	mov    %eax,%ebx
c002925a:	89 d6                	mov    %edx,%esi
c002925c:	89 cf                	mov    %ecx,%edi
  ASSERT (b != NULL);
c002925e:	85 d2                	test   %edx,%edx
c0029260:	74 73                	je     c00292d5 <find_end_of_run+0x9b>
  ASSERT (less != NULL);
c0029262:	85 c9                	test   %ecx,%ecx
c0029264:	0f 84 98 00 00 00    	je     c0029302 <find_end_of_run+0xc8>
  ASSERT (a != b);
c002926a:	39 d0                	cmp    %edx,%eax
c002926c:	0f 84 bd 00 00 00    	je     c002932f <find_end_of_run+0xf5>
  
  do 
    {
      a = list_next (a);
c0029272:	83 ec 0c             	sub    $0xc,%esp
c0029275:	53                   	push   %ebx
c0029276:	e8 7e fe ff ff       	call   c00290f9 <list_next>
c002927b:	83 c4 10             	add    $0x10,%esp
c002927e:	89 c3                	mov    %eax,%ebx
    }
  while (a != b && !less (a, list_prev (a), aux));
c0029280:	39 c6                	cmp    %eax,%esi
c0029282:	74 1a                	je     c002929e <find_end_of_run+0x64>
c0029284:	83 ec 0c             	sub    $0xc,%esp
c0029287:	50                   	push   %eax
c0029288:	e8 53 ff ff ff       	call   c00291e0 <list_prev>
c002928d:	83 c4 0c             	add    $0xc,%esp
c0029290:	55                   	push   %ebp
c0029291:	50                   	push   %eax
c0029292:	53                   	push   %ebx
c0029293:	ff d7                	call   *%edi
c0029295:	83 c4 10             	add    $0x10,%esp
c0029298:	84 c0                	test   %al,%al
c002929a:	74 d6                	je     c0029272 <find_end_of_run+0x38>
      a = list_next (a);
c002929c:	89 de                	mov    %ebx,%esi
  return a;
}
c002929e:	89 f0                	mov    %esi,%eax
c00292a0:	83 c4 1c             	add    $0x1c,%esp
c00292a3:	5b                   	pop    %ebx
c00292a4:	5e                   	pop    %esi
c00292a5:	5f                   	pop    %edi
c00292a6:	5d                   	pop    %ebp
c00292a7:	c3                   	ret    
  ASSERT (a != NULL);
c00292a8:	83 ec 0c             	sub    $0xc,%esp
c00292ab:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00292af:	8d 83 45 5e ff ff    	lea    -0xa1bb(%ebx),%eax
c00292b5:	50                   	push   %eax
c00292b6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00292bc:	50                   	push   %eax
c00292bd:	8d 83 f4 51 ff ff    	lea    -0xae0c(%ebx),%eax
c00292c3:	50                   	push   %eax
c00292c4:	68 69 01 00 00       	push   $0x169
c00292c9:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00292cf:	50                   	push   %eax
c00292d0:	e8 ba fc ff ff       	call   c0028f8f <debug_panic>
  ASSERT (b != NULL);
c00292d5:	83 ec 0c             	sub    $0xc,%esp
c00292d8:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00292dc:	8d 83 db 6f ff ff    	lea    -0x9025(%ebx),%eax
c00292e2:	50                   	push   %eax
c00292e3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00292e9:	50                   	push   %eax
c00292ea:	8d 83 f4 51 ff ff    	lea    -0xae0c(%ebx),%eax
c00292f0:	50                   	push   %eax
c00292f1:	68 6a 01 00 00       	push   $0x16a
c00292f6:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00292fc:	50                   	push   %eax
c00292fd:	e8 8d fc ff ff       	call   c0028f8f <debug_panic>
  ASSERT (less != NULL);
c0029302:	83 ec 0c             	sub    $0xc,%esp
c0029305:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029309:	8d 83 e5 6f ff ff    	lea    -0x901b(%ebx),%eax
c002930f:	50                   	push   %eax
c0029310:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029316:	50                   	push   %eax
c0029317:	8d 83 f4 51 ff ff    	lea    -0xae0c(%ebx),%eax
c002931d:	50                   	push   %eax
c002931e:	68 6b 01 00 00       	push   $0x16b
c0029323:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029329:	50                   	push   %eax
c002932a:	e8 60 fc ff ff       	call   c0028f8f <debug_panic>
  ASSERT (a != b);
c002932f:	83 ec 0c             	sub    $0xc,%esp
c0029332:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029336:	8d 83 f2 6f ff ff    	lea    -0x900e(%ebx),%eax
c002933c:	50                   	push   %eax
c002933d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029343:	50                   	push   %eax
c0029344:	8d 83 f4 51 ff ff    	lea    -0xae0c(%ebx),%eax
c002934a:	50                   	push   %eax
c002934b:	68 6c 01 00 00       	push   $0x16c
c0029350:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029356:	50                   	push   %eax
c0029357:	e8 33 fc ff ff       	call   c0028f8f <debug_panic>

c002935c <is_sorted>:
{
c002935c:	55                   	push   %ebp
c002935d:	57                   	push   %edi
c002935e:	56                   	push   %esi
c002935f:	53                   	push   %ebx
c0029360:	83 ec 0c             	sub    $0xc,%esp
c0029363:	89 c3                	mov    %eax,%ebx
c0029365:	89 d6                	mov    %edx,%esi
c0029367:	89 cd                	mov    %ecx,%ebp
c0029369:	8b 7c 24 20          	mov    0x20(%esp),%edi
  if (a != b)
c002936d:	39 d0                	cmp    %edx,%eax
c002936f:	74 31                	je     c00293a2 <is_sorted+0x46>
    while ((a = list_next (a)) != b) 
c0029371:	83 ec 0c             	sub    $0xc,%esp
c0029374:	53                   	push   %ebx
c0029375:	e8 7f fd ff ff       	call   c00290f9 <list_next>
c002937a:	83 c4 10             	add    $0x10,%esp
c002937d:	89 c3                	mov    %eax,%ebx
c002937f:	39 c6                	cmp    %eax,%esi
c0029381:	74 26                	je     c00293a9 <is_sorted+0x4d>
      if (less (a, list_prev (a), aux))
c0029383:	83 ec 0c             	sub    $0xc,%esp
c0029386:	53                   	push   %ebx
c0029387:	e8 54 fe ff ff       	call   c00291e0 <list_prev>
c002938c:	83 c4 0c             	add    $0xc,%esp
c002938f:	57                   	push   %edi
c0029390:	50                   	push   %eax
c0029391:	53                   	push   %ebx
c0029392:	ff d5                	call   *%ebp
c0029394:	83 c4 10             	add    $0x10,%esp
c0029397:	84 c0                	test   %al,%al
c0029399:	74 d6                	je     c0029371 <is_sorted+0x15>
        return false;
c002939b:	b8 00 00 00 00       	mov    $0x0,%eax
c00293a0:	eb 0c                	jmp    c00293ae <is_sorted+0x52>
  return true;
c00293a2:	b8 01 00 00 00       	mov    $0x1,%eax
c00293a7:	eb 05                	jmp    c00293ae <is_sorted+0x52>
c00293a9:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00293ae:	83 c4 0c             	add    $0xc,%esp
c00293b1:	5b                   	pop    %ebx
c00293b2:	5e                   	pop    %esi
c00293b3:	5f                   	pop    %edi
c00293b4:	5d                   	pop    %ebp
c00293b5:	c3                   	ret    

c00293b6 <list_rend>:
{
c00293b6:	53                   	push   %ebx
c00293b7:	83 ec 08             	sub    $0x8,%esp
c00293ba:	e8 7c 45 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00293bf:	81 c3 0d 01 01 00    	add    $0x1010d,%ebx
c00293c5:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00293c9:	85 c0                	test   %eax,%eax
c00293cb:	74 05                	je     c00293d2 <list_rend+0x1c>
}
c00293cd:	83 c4 08             	add    $0x8,%esp
c00293d0:	5b                   	pop    %ebx
c00293d1:	c3                   	ret    
  ASSERT (list != NULL);
c00293d2:	83 ec 0c             	sub    $0xc,%esp
c00293d5:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c00293db:	50                   	push   %eax
c00293dc:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00293e2:	50                   	push   %eax
c00293e3:	8d 83 64 52 ff ff    	lea    -0xad9c(%ebx),%eax
c00293e9:	50                   	push   %eax
c00293ea:	68 87 00 00 00       	push   $0x87
c00293ef:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00293f5:	50                   	push   %eax
c00293f6:	e8 94 fb ff ff       	call   c0028f8f <debug_panic>

c00293fb <list_head>:
{
c00293fb:	53                   	push   %ebx
c00293fc:	83 ec 08             	sub    $0x8,%esp
c00293ff:	e8 37 45 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029404:	81 c3 c8 00 01 00    	add    $0x100c8,%ebx
c002940a:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002940e:	85 c0                	test   %eax,%eax
c0029410:	74 05                	je     c0029417 <list_head+0x1c>
}
c0029412:	83 c4 08             	add    $0x8,%esp
c0029415:	5b                   	pop    %ebx
c0029416:	c3                   	ret    
  ASSERT (list != NULL);
c0029417:	83 ec 0c             	sub    $0xc,%esp
c002941a:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c0029420:	50                   	push   %eax
c0029421:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029427:	50                   	push   %eax
c0029428:	8d 83 58 52 ff ff    	lea    -0xada8(%ebx),%eax
c002942e:	50                   	push   %eax
c002942f:	68 99 00 00 00       	push   $0x99
c0029434:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c002943a:	50                   	push   %eax
c002943b:	e8 4f fb ff ff       	call   c0028f8f <debug_panic>

c0029440 <list_tail>:
{
c0029440:	53                   	push   %ebx
c0029441:	83 ec 08             	sub    $0x8,%esp
c0029444:	e8 f2 44 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029449:	81 c3 83 00 01 00    	add    $0x10083,%ebx
c002944f:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0029453:	85 c0                	test   %eax,%eax
c0029455:	74 08                	je     c002945f <list_tail+0x1f>
  return &list->tail;
c0029457:	83 c0 08             	add    $0x8,%eax
}
c002945a:	83 c4 08             	add    $0x8,%esp
c002945d:	5b                   	pop    %ebx
c002945e:	c3                   	ret    
  ASSERT (list != NULL);
c002945f:	83 ec 0c             	sub    $0xc,%esp
c0029462:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c0029468:	50                   	push   %eax
c0029469:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002946f:	50                   	push   %eax
c0029470:	8d 83 4c 52 ff ff    	lea    -0xadb4(%ebx),%eax
c0029476:	50                   	push   %eax
c0029477:	68 a1 00 00 00       	push   $0xa1
c002947c:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029482:	50                   	push   %eax
c0029483:	e8 07 fb ff ff       	call   c0028f8f <debug_panic>

c0029488 <list_insert>:
{
c0029488:	53                   	push   %ebx
c0029489:	83 ec 08             	sub    $0x8,%esp
c002948c:	e8 aa 44 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029491:	81 c3 3b 00 01 00    	add    $0x1003b,%ebx
c0029497:	8b 44 24 10          	mov    0x10(%esp),%eax
c002949b:	8b 54 24 14          	mov    0x14(%esp),%edx
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002949f:	85 c0                	test   %eax,%eax
c00294a1:	74 2d                	je     c00294d0 <list_insert+0x48>
c00294a3:	83 38 00             	cmpl   $0x0,(%eax)
c00294a6:	74 1d                	je     c00294c5 <list_insert+0x3d>
c00294a8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00294ac:	74 17                	je     c00294c5 <list_insert+0x3d>
  ASSERT (elem != NULL);
c00294ae:	85 d2                	test   %edx,%edx
c00294b0:	74 47                	je     c00294f9 <list_insert+0x71>
  elem->prev = before->prev;
c00294b2:	8b 08                	mov    (%eax),%ecx
c00294b4:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c00294b6:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c00294b9:	8b 08                	mov    (%eax),%ecx
c00294bb:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c00294be:	89 10                	mov    %edx,(%eax)
}
c00294c0:	83 c4 08             	add    $0x8,%esp
c00294c3:	5b                   	pop    %ebx
c00294c4:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00294c5:	83 38 00             	cmpl   $0x0,(%eax)
c00294c8:	74 06                	je     c00294d0 <list_insert+0x48>
c00294ca:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00294ce:	74 de                	je     c00294ae <list_insert+0x26>
  ASSERT (is_interior (before) || is_tail (before));
c00294d0:	83 ec 0c             	sub    $0xc,%esp
c00294d3:	8d 83 c8 70 ff ff    	lea    -0x8f38(%ebx),%eax
c00294d9:	50                   	push   %eax
c00294da:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00294e0:	50                   	push   %eax
c00294e1:	8d 83 40 52 ff ff    	lea    -0xadc0(%ebx),%eax
c00294e7:	50                   	push   %eax
c00294e8:	68 ab 00 00 00       	push   $0xab
c00294ed:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00294f3:	50                   	push   %eax
c00294f4:	e8 96 fa ff ff       	call   c0028f8f <debug_panic>
  ASSERT (elem != NULL);
c00294f9:	83 ec 0c             	sub    $0xc,%esp
c00294fc:	8d 83 f9 6f ff ff    	lea    -0x9007(%ebx),%eax
c0029502:	50                   	push   %eax
c0029503:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029509:	50                   	push   %eax
c002950a:	8d 83 40 52 ff ff    	lea    -0xadc0(%ebx),%eax
c0029510:	50                   	push   %eax
c0029511:	68 ac 00 00 00       	push   $0xac
c0029516:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c002951c:	50                   	push   %eax
c002951d:	e8 6d fa ff ff       	call   c0028f8f <debug_panic>

c0029522 <list_splice>:
{
c0029522:	57                   	push   %edi
c0029523:	56                   	push   %esi
c0029524:	53                   	push   %ebx
c0029525:	e8 11 44 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002952a:	81 c3 a2 ff 00 00    	add    $0xffa2,%ebx
c0029530:	8b 74 24 10          	mov    0x10(%esp),%esi
c0029534:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0029538:	8b 44 24 18          	mov    0x18(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002953c:	85 f6                	test   %esi,%esi
c002953e:	74 6a                	je     c00295aa <list_splice+0x88>
c0029540:	83 3e 00             	cmpl   $0x0,(%esi)
c0029543:	74 5a                	je     c002959f <list_splice+0x7d>
c0029545:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029549:	74 54                	je     c002959f <list_splice+0x7d>
  if (first == last)
c002954b:	39 c7                	cmp    %eax,%edi
c002954d:	74 4c                	je     c002959b <list_splice+0x79>
  last = list_prev (last);
c002954f:	83 ec 0c             	sub    $0xc,%esp
c0029552:	50                   	push   %eax
c0029553:	e8 88 fc ff ff       	call   c00291e0 <list_prev>
c0029558:	83 c4 10             	add    $0x10,%esp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002955b:	85 ff                	test   %edi,%edi
c002955d:	74 74                	je     c00295d3 <list_splice+0xb1>
c002955f:	8b 17                	mov    (%edi),%edx
c0029561:	85 d2                	test   %edx,%edx
c0029563:	74 6e                	je     c00295d3 <list_splice+0xb1>
c0029565:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c0029569:	74 68                	je     c00295d3 <list_splice+0xb1>
c002956b:	85 c0                	test   %eax,%eax
c002956d:	0f 84 89 00 00 00    	je     c00295fc <list_splice+0xda>
c0029573:	83 38 00             	cmpl   $0x0,(%eax)
c0029576:	0f 84 80 00 00 00    	je     c00295fc <list_splice+0xda>
c002957c:	8b 48 04             	mov    0x4(%eax),%ecx
c002957f:	85 c9                	test   %ecx,%ecx
c0029581:	74 79                	je     c00295fc <list_splice+0xda>
  first->prev->next = last->next;
c0029583:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c0029586:	8b 50 04             	mov    0x4(%eax),%edx
c0029589:	8b 0f                	mov    (%edi),%ecx
c002958b:	89 0a                	mov    %ecx,(%edx)
  first->prev = before->prev;
c002958d:	8b 16                	mov    (%esi),%edx
c002958f:	89 17                	mov    %edx,(%edi)
  last->next = before;
c0029591:	89 70 04             	mov    %esi,0x4(%eax)
  before->prev->next = first;
c0029594:	8b 16                	mov    (%esi),%edx
c0029596:	89 7a 04             	mov    %edi,0x4(%edx)
  before->prev = last;
c0029599:	89 06                	mov    %eax,(%esi)
}
c002959b:	5b                   	pop    %ebx
c002959c:	5e                   	pop    %esi
c002959d:	5f                   	pop    %edi
c002959e:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002959f:	83 3e 00             	cmpl   $0x0,(%esi)
c00295a2:	74 06                	je     c00295aa <list_splice+0x88>
c00295a4:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00295a8:	74 a1                	je     c002954b <list_splice+0x29>
  ASSERT (is_interior (before) || is_tail (before));
c00295aa:	83 ec 0c             	sub    $0xc,%esp
c00295ad:	8d 83 c8 70 ff ff    	lea    -0x8f38(%ebx),%eax
c00295b3:	50                   	push   %eax
c00295b4:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00295ba:	50                   	push   %eax
c00295bb:	8d 83 34 52 ff ff    	lea    -0xadcc(%ebx),%eax
c00295c1:	50                   	push   %eax
c00295c2:	68 bb 00 00 00       	push   $0xbb
c00295c7:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00295cd:	50                   	push   %eax
c00295ce:	e8 bc f9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (is_interior (first));
c00295d3:	83 ec 0c             	sub    $0xc,%esp
c00295d6:	8d 83 06 70 ff ff    	lea    -0x8ffa(%ebx),%eax
c00295dc:	50                   	push   %eax
c00295dd:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00295e3:	50                   	push   %eax
c00295e4:	8d 83 34 52 ff ff    	lea    -0xadcc(%ebx),%eax
c00295ea:	50                   	push   %eax
c00295eb:	68 c0 00 00 00       	push   $0xc0
c00295f0:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00295f6:	50                   	push   %eax
c00295f7:	e8 93 f9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (is_interior (last));
c00295fc:	83 ec 0c             	sub    $0xc,%esp
c00295ff:	8d 83 1a 70 ff ff    	lea    -0x8fe6(%ebx),%eax
c0029605:	50                   	push   %eax
c0029606:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002960c:	50                   	push   %eax
c002960d:	8d 83 34 52 ff ff    	lea    -0xadcc(%ebx),%eax
c0029613:	50                   	push   %eax
c0029614:	68 c1 00 00 00       	push   $0xc1
c0029619:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c002961f:	50                   	push   %eax
c0029620:	e8 6a f9 ff ff       	call   c0028f8f <debug_panic>

c0029625 <list_push_front>:
{
c0029625:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_begin (list), elem);
c0029628:	ff 74 24 1c          	pushl  0x1c(%esp)
c002962c:	e8 83 fa ff ff       	call   c00290b4 <list_begin>
c0029631:	83 c4 08             	add    $0x8,%esp
c0029634:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029638:	50                   	push   %eax
c0029639:	e8 4a fe ff ff       	call   c0029488 <list_insert>
}
c002963e:	83 c4 1c             	add    $0x1c,%esp
c0029641:	c3                   	ret    

c0029642 <list_push_back>:
{
c0029642:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_end (list), elem);
c0029645:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029649:	e8 08 fb ff ff       	call   c0029156 <list_end>
c002964e:	83 c4 08             	add    $0x8,%esp
c0029651:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029655:	50                   	push   %eax
c0029656:	e8 2d fe ff ff       	call   c0029488 <list_insert>
}
c002965b:	83 c4 1c             	add    $0x1c,%esp
c002965e:	c3                   	ret    

c002965f <list_remove>:
{
c002965f:	53                   	push   %ebx
c0029660:	83 ec 08             	sub    $0x8,%esp
c0029663:	e8 d3 42 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029668:	81 c3 64 fe 00 00    	add    $0xfe64,%ebx
c002966e:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029672:	85 c0                	test   %eax,%eax
c0029674:	74 1f                	je     c0029695 <list_remove+0x36>
c0029676:	8b 10                	mov    (%eax),%edx
c0029678:	85 d2                	test   %edx,%edx
c002967a:	74 19                	je     c0029695 <list_remove+0x36>
c002967c:	8b 48 04             	mov    0x4(%eax),%ecx
c002967f:	85 c9                	test   %ecx,%ecx
c0029681:	74 12                	je     c0029695 <list_remove+0x36>
  elem->prev->next = elem->next;
c0029683:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c0029686:	8b 50 04             	mov    0x4(%eax),%edx
c0029689:	8b 08                	mov    (%eax),%ecx
c002968b:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c002968d:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029690:	83 c4 08             	add    $0x8,%esp
c0029693:	5b                   	pop    %ebx
c0029694:	c3                   	ret    
  ASSERT (is_interior (elem));
c0029695:	83 ec 0c             	sub    $0xc,%esp
c0029698:	8d 83 2d 70 ff ff    	lea    -0x8fd3(%ebx),%eax
c002969e:	50                   	push   %eax
c002969f:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00296a5:	50                   	push   %eax
c00296a6:	8d 83 28 52 ff ff    	lea    -0xadd8(%ebx),%eax
c00296ac:	50                   	push   %eax
c00296ad:	68 fb 00 00 00       	push   $0xfb
c00296b2:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00296b8:	50                   	push   %eax
c00296b9:	e8 d1 f8 ff ff       	call   c0028f8f <debug_panic>

c00296be <list_size>:
{
c00296be:	57                   	push   %edi
c00296bf:	56                   	push   %esi
c00296c0:	53                   	push   %ebx
c00296c1:	8b 7c 24 10          	mov    0x10(%esp),%edi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00296c5:	83 ec 0c             	sub    $0xc,%esp
c00296c8:	57                   	push   %edi
c00296c9:	e8 e6 f9 ff ff       	call   c00290b4 <list_begin>
c00296ce:	83 c4 10             	add    $0x10,%esp
c00296d1:	89 c3                	mov    %eax,%ebx
  size_t cnt = 0;
c00296d3:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00296d8:	eb 11                	jmp    c00296eb <list_size+0x2d>
    cnt++;
c00296da:	83 c6 01             	add    $0x1,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00296dd:	83 ec 0c             	sub    $0xc,%esp
c00296e0:	53                   	push   %ebx
c00296e1:	e8 13 fa ff ff       	call   c00290f9 <list_next>
c00296e6:	83 c4 10             	add    $0x10,%esp
c00296e9:	89 c3                	mov    %eax,%ebx
c00296eb:	83 ec 0c             	sub    $0xc,%esp
c00296ee:	57                   	push   %edi
c00296ef:	e8 62 fa ff ff       	call   c0029156 <list_end>
c00296f4:	83 c4 10             	add    $0x10,%esp
c00296f7:	39 d8                	cmp    %ebx,%eax
c00296f9:	75 df                	jne    c00296da <list_size+0x1c>
}
c00296fb:	89 f0                	mov    %esi,%eax
c00296fd:	5b                   	pop    %ebx
c00296fe:	5e                   	pop    %esi
c00296ff:	5f                   	pop    %edi
c0029700:	c3                   	ret    

c0029701 <list_empty>:
{
c0029701:	56                   	push   %esi
c0029702:	53                   	push   %ebx
c0029703:	83 ec 10             	sub    $0x10,%esp
c0029706:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin (list) == list_end (list);
c002970a:	53                   	push   %ebx
c002970b:	e8 a4 f9 ff ff       	call   c00290b4 <list_begin>
c0029710:	89 c6                	mov    %eax,%esi
c0029712:	89 1c 24             	mov    %ebx,(%esp)
c0029715:	e8 3c fa ff ff       	call   c0029156 <list_end>
c002971a:	39 c6                	cmp    %eax,%esi
c002971c:	0f 94 c0             	sete   %al
}
c002971f:	83 c4 14             	add    $0x14,%esp
c0029722:	5b                   	pop    %ebx
c0029723:	5e                   	pop    %esi
c0029724:	c3                   	ret    

c0029725 <list_front>:
{
c0029725:	56                   	push   %esi
c0029726:	53                   	push   %ebx
c0029727:	83 ec 10             	sub    $0x10,%esp
c002972a:	e8 0c 42 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002972f:	81 c3 9d fd 00 00    	add    $0xfd9d,%ebx
c0029735:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (!list_empty (list));
c0029739:	56                   	push   %esi
c002973a:	e8 c2 ff ff ff       	call   c0029701 <list_empty>
c002973f:	83 c4 10             	add    $0x10,%esp
c0029742:	84 c0                	test   %al,%al
c0029744:	75 09                	jne    c002974f <list_front+0x2a>
  return list->head.next;
c0029746:	8b 46 04             	mov    0x4(%esi),%eax
}
c0029749:	83 c4 04             	add    $0x4,%esp
c002974c:	5b                   	pop    %ebx
c002974d:	5e                   	pop    %esi
c002974e:	c3                   	ret    
  ASSERT (!list_empty (list));
c002974f:	83 ec 0c             	sub    $0xc,%esp
c0029752:	8d 83 40 70 ff ff    	lea    -0x8fc0(%ebx),%eax
c0029758:	50                   	push   %eax
c0029759:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002975f:	50                   	push   %eax
c0029760:	8d 83 1c 52 ff ff    	lea    -0xade4(%ebx),%eax
c0029766:	50                   	push   %eax
c0029767:	68 1a 01 00 00       	push   $0x11a
c002976c:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029772:	50                   	push   %eax
c0029773:	e8 17 f8 ff ff       	call   c0028f8f <debug_panic>

c0029778 <list_pop_front>:
{
c0029778:	53                   	push   %ebx
c0029779:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front (list);
c002977c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029780:	e8 a0 ff ff ff       	call   c0029725 <list_front>
c0029785:	89 c3                	mov    %eax,%ebx
  list_remove (front);
c0029787:	89 04 24             	mov    %eax,(%esp)
c002978a:	e8 d0 fe ff ff       	call   c002965f <list_remove>
}
c002978f:	89 d8                	mov    %ebx,%eax
c0029791:	83 c4 18             	add    $0x18,%esp
c0029794:	5b                   	pop    %ebx
c0029795:	c3                   	ret    

c0029796 <list_back>:
{
c0029796:	56                   	push   %esi
c0029797:	53                   	push   %ebx
c0029798:	83 ec 10             	sub    $0x10,%esp
c002979b:	e8 9b 41 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c00297a0:	81 c3 2c fd 00 00    	add    $0xfd2c,%ebx
c00297a6:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (!list_empty (list));
c00297aa:	56                   	push   %esi
c00297ab:	e8 51 ff ff ff       	call   c0029701 <list_empty>
c00297b0:	83 c4 10             	add    $0x10,%esp
c00297b3:	84 c0                	test   %al,%al
c00297b5:	75 09                	jne    c00297c0 <list_back+0x2a>
  return list->tail.prev;
c00297b7:	8b 46 08             	mov    0x8(%esi),%eax
}
c00297ba:	83 c4 04             	add    $0x4,%esp
c00297bd:	5b                   	pop    %ebx
c00297be:	5e                   	pop    %esi
c00297bf:	c3                   	ret    
  ASSERT (!list_empty (list));
c00297c0:	83 ec 0c             	sub    $0xc,%esp
c00297c3:	8d 83 40 70 ff ff    	lea    -0x8fc0(%ebx),%eax
c00297c9:	50                   	push   %eax
c00297ca:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00297d0:	50                   	push   %eax
c00297d1:	8d 83 10 52 ff ff    	lea    -0xadf0(%ebx),%eax
c00297d7:	50                   	push   %eax
c00297d8:	68 23 01 00 00       	push   $0x123
c00297dd:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00297e3:	50                   	push   %eax
c00297e4:	e8 a6 f7 ff ff       	call   c0028f8f <debug_panic>

c00297e9 <list_pop_back>:
{
c00297e9:	53                   	push   %ebx
c00297ea:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back (list);
c00297ed:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297f1:	e8 a0 ff ff ff       	call   c0029796 <list_back>
c00297f6:	89 c3                	mov    %eax,%ebx
  list_remove (back);
c00297f8:	89 04 24             	mov    %eax,(%esp)
c00297fb:	e8 5f fe ff ff       	call   c002965f <list_remove>
}
c0029800:	89 d8                	mov    %ebx,%eax
c0029802:	83 c4 18             	add    $0x18,%esp
c0029805:	5b                   	pop    %ebx
c0029806:	c3                   	ret    

c0029807 <list_reverse>:
{
c0029807:	56                   	push   %esi
c0029808:	53                   	push   %ebx
c0029809:	83 ec 10             	sub    $0x10,%esp
c002980c:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty (list)) 
c0029810:	56                   	push   %esi
c0029811:	e8 eb fe ff ff       	call   c0029701 <list_empty>
c0029816:	83 c4 10             	add    $0x10,%esp
c0029819:	84 c0                	test   %al,%al
c002981b:	74 06                	je     c0029823 <list_reverse+0x1c>
}
c002981d:	83 c4 04             	add    $0x4,%esp
c0029820:	5b                   	pop    %ebx
c0029821:	5e                   	pop    %esi
c0029822:	c3                   	ret    
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029823:	83 ec 0c             	sub    $0xc,%esp
c0029826:	56                   	push   %esi
c0029827:	e8 88 f8 ff ff       	call   c00290b4 <list_begin>
c002982c:	83 c4 10             	add    $0x10,%esp
c002982f:	89 c3                	mov    %eax,%ebx
c0029831:	eb 0c                	jmp    c002983f <list_reverse+0x38>
  struct list_elem *t = *a;
c0029833:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c0029835:	8b 43 04             	mov    0x4(%ebx),%eax
c0029838:	89 03                	mov    %eax,(%ebx)
  *b = t;
c002983a:	89 53 04             	mov    %edx,0x4(%ebx)
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002983d:	89 c3                	mov    %eax,%ebx
c002983f:	83 ec 0c             	sub    $0xc,%esp
c0029842:	56                   	push   %esi
c0029843:	e8 0e f9 ff ff       	call   c0029156 <list_end>
c0029848:	83 c4 10             	add    $0x10,%esp
c002984b:	39 d8                	cmp    %ebx,%eax
c002984d:	75 e4                	jne    c0029833 <list_reverse+0x2c>
  struct list_elem *t = *a;
c002984f:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c0029852:	8b 56 08             	mov    0x8(%esi),%edx
c0029855:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c0029858:	89 46 08             	mov    %eax,0x8(%esi)
  struct list_elem *t = *a;
c002985b:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c002985d:	8b 58 04             	mov    0x4(%eax),%ebx
c0029860:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c0029862:	89 48 04             	mov    %ecx,0x4(%eax)
}
c0029865:	eb b6                	jmp    c002981d <list_reverse+0x16>

c0029867 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c0029867:	55                   	push   %ebp
c0029868:	57                   	push   %edi
c0029869:	56                   	push   %esi
c002986a:	53                   	push   %ebx
c002986b:	83 ec 1c             	sub    $0x1c,%esp
c002986e:	e8 cc 40 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c0029873:	05 59 fc 00 00       	add    $0xfc59,%eax
c0029878:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002987c:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0029880:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c0029884:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0029889:	74 35                	je     c00298c0 <list_sort+0x59>
  ASSERT (less != NULL);
c002988b:	85 ed                	test   %ebp,%ebp
c002988d:	0f 85 41 02 00 00    	jne    c0029ad4 <list_sort+0x26d>
c0029893:	83 ec 0c             	sub    $0xc,%esp
c0029896:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002989a:	8d 83 e5 6f ff ff    	lea    -0x901b(%ebx),%eax
c00298a0:	50                   	push   %eax
c00298a1:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00298a7:	50                   	push   %eax
c00298a8:	8d 83 04 52 ff ff    	lea    -0xadfc(%ebx),%eax
c00298ae:	50                   	push   %eax
c00298af:	68 9a 01 00 00       	push   $0x19a
c00298b4:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00298ba:	50                   	push   %eax
c00298bb:	e8 cf f6 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (list != NULL);
c00298c0:	83 ec 0c             	sub    $0xc,%esp
c00298c3:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00298c7:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c00298cd:	50                   	push   %eax
c00298ce:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c00298d4:	50                   	push   %eax
c00298d5:	8d 83 04 52 ff ff    	lea    -0xadfc(%ebx),%eax
c00298db:	50                   	push   %eax
c00298dc:	68 99 01 00 00       	push   $0x199
c00298e1:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c00298e7:	50                   	push   %eax
c00298e8:	e8 a2 f6 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (a0 != NULL);
c00298ed:	83 ec 0c             	sub    $0xc,%esp
c00298f0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00298f4:	8d 83 53 70 ff ff    	lea    -0x8fad(%ebx),%eax
c00298fa:	50                   	push   %eax
c00298fb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029901:	50                   	push   %eax
c0029902:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c0029908:	50                   	push   %eax
c0029909:	68 80 01 00 00       	push   $0x180
c002990e:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029914:	50                   	push   %eax
c0029915:	e8 75 f6 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (a1b0 != NULL);
c002991a:	83 ec 0c             	sub    $0xc,%esp
c002991d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029921:	8d 83 5e 70 ff ff    	lea    -0x8fa2(%ebx),%eax
c0029927:	50                   	push   %eax
c0029928:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002992e:	50                   	push   %eax
c002992f:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c0029935:	50                   	push   %eax
c0029936:	68 81 01 00 00       	push   $0x181
c002993b:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029941:	50                   	push   %eax
c0029942:	e8 48 f6 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (b1 != NULL);
c0029947:	83 ec 0c             	sub    $0xc,%esp
c002994a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002994e:	8d 83 6b 70 ff ff    	lea    -0x8f95(%ebx),%eax
c0029954:	50                   	push   %eax
c0029955:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002995b:	50                   	push   %eax
c002995c:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c0029962:	50                   	push   %eax
c0029963:	68 82 01 00 00       	push   $0x182
c0029968:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c002996e:	50                   	push   %eax
c002996f:	e8 1b f6 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0029974:	83 ec 0c             	sub    $0xc,%esp
c0029977:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002997b:	8d 83 f4 70 ff ff    	lea    -0x8f0c(%ebx),%eax
c0029981:	50                   	push   %eax
c0029982:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029988:	50                   	push   %eax
c0029989:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c002998f:	50                   	push   %eax
c0029990:	68 84 01 00 00       	push   $0x184
c0029995:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c002999b:	50                   	push   %eax
c002999c:	e8 ee f5 ff ff       	call   c0028f8f <debug_panic>
        a1b0 = list_next (a1b0);
c00299a1:	83 ec 0c             	sub    $0xc,%esp
c00299a4:	53                   	push   %ebx
c00299a5:	e8 4f f7 ff ff       	call   c00290f9 <list_next>
c00299aa:	89 c3                	mov    %eax,%ebx
        list_splice (a0, list_prev (a1b0), a1b0);
c00299ac:	89 04 24             	mov    %eax,(%esp)
c00299af:	e8 2c f8 ff ff       	call   c00291e0 <list_prev>
c00299b4:	83 c4 0c             	add    $0xc,%esp
c00299b7:	53                   	push   %ebx
c00299b8:	50                   	push   %eax
c00299b9:	56                   	push   %esi
c00299ba:	e8 63 fb ff ff       	call   c0029522 <list_splice>
c00299bf:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c00299c2:	39 f3                	cmp    %esi,%ebx
c00299c4:	0f 95 c2             	setne  %dl
c00299c7:	39 5c 24 04          	cmp    %ebx,0x4(%esp)
c00299cb:	0f 95 c0             	setne  %al
c00299ce:	84 c2                	test   %al,%dl
c00299d0:	74 1f                	je     c00299f1 <list_sort+0x18a>
    if (!less (a1b0, a0, aux)) 
c00299d2:	83 ec 04             	sub    $0x4,%esp
c00299d5:	57                   	push   %edi
c00299d6:	56                   	push   %esi
c00299d7:	53                   	push   %ebx
c00299d8:	ff d5                	call   *%ebp
c00299da:	83 c4 10             	add    $0x10,%esp
c00299dd:	84 c0                	test   %al,%al
c00299df:	75 c0                	jne    c00299a1 <list_sort+0x13a>
      a0 = list_next (a0);
c00299e1:	83 ec 0c             	sub    $0xc,%esp
c00299e4:	56                   	push   %esi
c00299e5:	e8 0f f7 ff ff       	call   c00290f9 <list_next>
c00299ea:	83 c4 10             	add    $0x10,%esp
c00299ed:	89 c6                	mov    %eax,%esi
c00299ef:	eb d1                	jmp    c00299c2 <list_sort+0x15b>
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c00299f1:	8b 74 24 04          	mov    0x4(%esp),%esi
c00299f5:	83 ec 0c             	sub    $0xc,%esp
c00299f8:	ff 74 24 3c          	pushl  0x3c(%esp)
c00299fc:	e8 55 f7 ff ff       	call   c0029156 <list_end>
c0029a01:	83 c4 10             	add    $0x10,%esp
c0029a04:	39 f0                	cmp    %esi,%eax
c0029a06:	0f 84 c1 00 00 00    	je     c0029acd <list_sort+0x266>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c0029a0c:	83 44 24 08 01       	addl   $0x1,0x8(%esp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c0029a11:	83 ec 0c             	sub    $0xc,%esp
c0029a14:	57                   	push   %edi
c0029a15:	89 e9                	mov    %ebp,%ecx
c0029a17:	89 c2                	mov    %eax,%edx
c0029a19:	89 f0                	mov    %esi,%eax
c0029a1b:	e8 1a f8 ff ff       	call   c002923a <find_end_of_run>
c0029a20:	89 c3                	mov    %eax,%ebx
          if (a1b0 == list_end (list))
c0029a22:	83 c4 04             	add    $0x4,%esp
c0029a25:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029a29:	e8 28 f7 ff ff       	call   c0029156 <list_end>
c0029a2e:	83 c4 10             	add    $0x10,%esp
c0029a31:	39 d8                	cmp    %ebx,%eax
c0029a33:	0f 84 94 00 00 00    	je     c0029acd <list_sort+0x266>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c0029a39:	83 ec 0c             	sub    $0xc,%esp
c0029a3c:	57                   	push   %edi
c0029a3d:	89 e9                	mov    %ebp,%ecx
c0029a3f:	89 c2                	mov    %eax,%edx
c0029a41:	89 d8                	mov    %ebx,%eax
c0029a43:	e8 f2 f7 ff ff       	call   c002923a <find_end_of_run>
c0029a48:	89 44 24 14          	mov    %eax,0x14(%esp)
  ASSERT (a0 != NULL);
c0029a4c:	83 c4 10             	add    $0x10,%esp
c0029a4f:	85 f6                	test   %esi,%esi
c0029a51:	0f 84 96 fe ff ff    	je     c00298ed <list_sort+0x86>
  ASSERT (a1b0 != NULL);
c0029a57:	85 db                	test   %ebx,%ebx
c0029a59:	0f 84 bb fe ff ff    	je     c002991a <list_sort+0xb3>
  ASSERT (b1 != NULL);
c0029a5f:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0029a64:	0f 84 dd fe ff ff    	je     c0029947 <list_sort+0xe0>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0029a6a:	83 ec 0c             	sub    $0xc,%esp
c0029a6d:	57                   	push   %edi
c0029a6e:	89 e9                	mov    %ebp,%ecx
c0029a70:	89 da                	mov    %ebx,%edx
c0029a72:	89 f0                	mov    %esi,%eax
c0029a74:	e8 e3 f8 ff ff       	call   c002935c <is_sorted>
c0029a79:	83 c4 10             	add    $0x10,%esp
c0029a7c:	84 c0                	test   %al,%al
c0029a7e:	0f 84 f0 fe ff ff    	je     c0029974 <list_sort+0x10d>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0029a84:	83 ec 0c             	sub    $0xc,%esp
c0029a87:	57                   	push   %edi
c0029a88:	89 e9                	mov    %ebp,%ecx
c0029a8a:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029a8e:	89 d8                	mov    %ebx,%eax
c0029a90:	e8 c7 f8 ff ff       	call   c002935c <is_sorted>
c0029a95:	83 c4 10             	add    $0x10,%esp
c0029a98:	84 c0                	test   %al,%al
c0029a9a:	0f 85 22 ff ff ff    	jne    c00299c2 <list_sort+0x15b>
c0029aa0:	83 ec 0c             	sub    $0xc,%esp
c0029aa3:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029aa7:	8d 83 14 71 ff ff    	lea    -0x8eec(%ebx),%eax
c0029aad:	50                   	push   %eax
c0029aae:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029ab4:	50                   	push   %eax
c0029ab5:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c0029abb:	50                   	push   %eax
c0029abc:	68 85 01 00 00       	push   $0x185
c0029ac1:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029ac7:	50                   	push   %eax
c0029ac8:	e8 c2 f4 ff ff       	call   c0028f8f <debug_panic>

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c0029acd:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
c0029ad2:	76 1e                	jbe    c0029af2 <list_sort+0x28b>
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0029ad4:	83 ec 0c             	sub    $0xc,%esp
c0029ad7:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029adb:	e8 d4 f5 ff ff       	call   c00290b4 <list_begin>
c0029ae0:	83 c4 10             	add    $0x10,%esp
c0029ae3:	89 c6                	mov    %eax,%esi
      output_run_cnt = 0;
c0029ae5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029aec:	00 
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0029aed:	e9 03 ff ff ff       	jmp    c00299f5 <list_sort+0x18e>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0029af2:	83 ec 0c             	sub    $0xc,%esp
c0029af5:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029af9:	e8 58 f6 ff ff       	call   c0029156 <list_end>
c0029afe:	83 c4 04             	add    $0x4,%esp
c0029b01:	89 c3                	mov    %eax,%ebx
c0029b03:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029b07:	e8 a8 f5 ff ff       	call   c00290b4 <list_begin>
c0029b0c:	89 3c 24             	mov    %edi,(%esp)
c0029b0f:	89 e9                	mov    %ebp,%ecx
c0029b11:	89 da                	mov    %ebx,%edx
c0029b13:	e8 44 f8 ff ff       	call   c002935c <is_sorted>
c0029b18:	83 c4 10             	add    $0x10,%esp
c0029b1b:	84 c0                	test   %al,%al
c0029b1d:	74 08                	je     c0029b27 <list_sort+0x2c0>
}
c0029b1f:	83 c4 1c             	add    $0x1c,%esp
c0029b22:	5b                   	pop    %ebx
c0029b23:	5e                   	pop    %esi
c0029b24:	5f                   	pop    %edi
c0029b25:	5d                   	pop    %ebp
c0029b26:	c3                   	ret    
  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0029b27:	83 ec 0c             	sub    $0xc,%esp
c0029b2a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029b2e:	8d 83 34 71 ff ff    	lea    -0x8ecc(%ebx),%eax
c0029b34:	50                   	push   %eax
c0029b35:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029b3b:	50                   	push   %eax
c0029b3c:	8d 83 04 52 ff ff    	lea    -0xadfc(%ebx),%eax
c0029b42:	50                   	push   %eax
c0029b43:	68 b7 01 00 00       	push   $0x1b7
c0029b48:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029b4e:	50                   	push   %eax
c0029b4f:	e8 3b f4 ff ff       	call   c0028f8f <debug_panic>

c0029b54 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c0029b54:	55                   	push   %ebp
c0029b55:	57                   	push   %edi
c0029b56:	56                   	push   %esi
c0029b57:	53                   	push   %ebx
c0029b58:	83 ec 0c             	sub    $0xc,%esp
c0029b5b:	e8 db 3d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029b60:	81 c3 6c f9 00 00    	add    $0xf96c,%ebx
c0029b66:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029b6a:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029b6e:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT (list != NULL);
c0029b72:	85 f6                	test   %esi,%esi
c0029b74:	74 54                	je     c0029bca <list_insert_ordered+0x76>
  ASSERT (elem != NULL);
c0029b76:	85 ff                	test   %edi,%edi
c0029b78:	74 79                	je     c0029bf3 <list_insert_ordered+0x9f>
  ASSERT (less != NULL);
c0029b7a:	85 ed                	test   %ebp,%ebp
c0029b7c:	0f 84 9a 00 00 00    	je     c0029c1c <list_insert_ordered+0xc8>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029b82:	83 ec 0c             	sub    $0xc,%esp
c0029b85:	56                   	push   %esi
c0029b86:	e8 29 f5 ff ff       	call   c00290b4 <list_begin>
c0029b8b:	83 c4 10             	add    $0x10,%esp
c0029b8e:	89 c3                	mov    %eax,%ebx
c0029b90:	83 ec 0c             	sub    $0xc,%esp
c0029b93:	56                   	push   %esi
c0029b94:	e8 bd f5 ff ff       	call   c0029156 <list_end>
c0029b99:	83 c4 10             	add    $0x10,%esp
c0029b9c:	39 d8                	cmp    %ebx,%eax
c0029b9e:	0f 84 a3 00 00 00    	je     c0029c47 <list_insert_ordered+0xf3>
    if (less (elem, e, aux))
c0029ba4:	83 ec 04             	sub    $0x4,%esp
c0029ba7:	ff 74 24 30          	pushl  0x30(%esp)
c0029bab:	53                   	push   %ebx
c0029bac:	57                   	push   %edi
c0029bad:	ff d5                	call   *%ebp
c0029baf:	83 c4 10             	add    $0x10,%esp
c0029bb2:	84 c0                	test   %al,%al
c0029bb4:	0f 85 8b 00 00 00    	jne    c0029c45 <list_insert_ordered+0xf1>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029bba:	83 ec 0c             	sub    $0xc,%esp
c0029bbd:	53                   	push   %ebx
c0029bbe:	e8 36 f5 ff ff       	call   c00290f9 <list_next>
c0029bc3:	83 c4 10             	add    $0x10,%esp
c0029bc6:	89 c3                	mov    %eax,%ebx
c0029bc8:	eb c6                	jmp    c0029b90 <list_insert_ordered+0x3c>
  ASSERT (list != NULL);
c0029bca:	83 ec 0c             	sub    $0xc,%esp
c0029bcd:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c0029bd3:	50                   	push   %eax
c0029bd4:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029bda:	50                   	push   %eax
c0029bdb:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c0029be1:	50                   	push   %eax
c0029be2:	68 c3 01 00 00       	push   $0x1c3
c0029be7:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029bed:	50                   	push   %eax
c0029bee:	e8 9c f3 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (elem != NULL);
c0029bf3:	83 ec 0c             	sub    $0xc,%esp
c0029bf6:	8d 83 f9 6f ff ff    	lea    -0x9007(%ebx),%eax
c0029bfc:	50                   	push   %eax
c0029bfd:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029c03:	50                   	push   %eax
c0029c04:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c0029c0a:	50                   	push   %eax
c0029c0b:	68 c4 01 00 00       	push   $0x1c4
c0029c10:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029c16:	50                   	push   %eax
c0029c17:	e8 73 f3 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (less != NULL);
c0029c1c:	83 ec 0c             	sub    $0xc,%esp
c0029c1f:	8d 83 e5 6f ff ff    	lea    -0x901b(%ebx),%eax
c0029c25:	50                   	push   %eax
c0029c26:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029c2c:	50                   	push   %eax
c0029c2d:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c0029c33:	50                   	push   %eax
c0029c34:	68 c5 01 00 00       	push   $0x1c5
c0029c39:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029c3f:	50                   	push   %eax
c0029c40:	e8 4a f3 ff ff       	call   c0028f8f <debug_panic>
c0029c45:	89 d8                	mov    %ebx,%eax
      break;
  return list_insert (e, elem);
c0029c47:	83 ec 08             	sub    $0x8,%esp
c0029c4a:	57                   	push   %edi
c0029c4b:	50                   	push   %eax
c0029c4c:	e8 37 f8 ff ff       	call   c0029488 <list_insert>
}
c0029c51:	83 c4 1c             	add    $0x1c,%esp
c0029c54:	5b                   	pop    %ebx
c0029c55:	5e                   	pop    %esi
c0029c56:	5f                   	pop    %edi
c0029c57:	5d                   	pop    %ebp
c0029c58:	c3                   	ret    

c0029c59 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c0029c59:	55                   	push   %ebp
c0029c5a:	57                   	push   %edi
c0029c5b:	56                   	push   %esi
c0029c5c:	53                   	push   %ebx
c0029c5d:	83 ec 0c             	sub    $0xc,%esp
c0029c60:	e8 d6 3c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029c65:	81 c3 67 f8 00 00    	add    $0xf867,%ebx
c0029c6b:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0029c6f:	8b 7c 24 28          	mov    0x28(%esp),%edi
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c0029c73:	85 ed                	test   %ebp,%ebp
c0029c75:	74 1c                	je     c0029c93 <list_unique+0x3a>
  ASSERT (less != NULL);
c0029c77:	85 ff                	test   %edi,%edi
c0029c79:	74 41                	je     c0029cbc <list_unique+0x63>
  if (list_empty (list))
c0029c7b:	83 ec 0c             	sub    $0xc,%esp
c0029c7e:	55                   	push   %ebp
c0029c7f:	e8 7d fa ff ff       	call   c0029701 <list_empty>
c0029c84:	83 c4 10             	add    $0x10,%esp
c0029c87:	84 c0                	test   %al,%al
c0029c89:	74 5a                	je     c0029ce5 <list_unique+0x8c>
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c0029c8b:	83 c4 0c             	add    $0xc,%esp
c0029c8e:	5b                   	pop    %ebx
c0029c8f:	5e                   	pop    %esi
c0029c90:	5f                   	pop    %edi
c0029c91:	5d                   	pop    %ebp
c0029c92:	c3                   	ret    
  ASSERT (list != NULL);
c0029c93:	83 ec 0c             	sub    $0xc,%esp
c0029c96:	8d 83 b6 6f ff ff    	lea    -0x904a(%ebx),%eax
c0029c9c:	50                   	push   %eax
c0029c9d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029ca3:	50                   	push   %eax
c0029ca4:	8d 83 c4 51 ff ff    	lea    -0xae3c(%ebx),%eax
c0029caa:	50                   	push   %eax
c0029cab:	68 d7 01 00 00       	push   $0x1d7
c0029cb0:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029cb6:	50                   	push   %eax
c0029cb7:	e8 d3 f2 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (less != NULL);
c0029cbc:	83 ec 0c             	sub    $0xc,%esp
c0029cbf:	8d 83 e5 6f ff ff    	lea    -0x901b(%ebx),%eax
c0029cc5:	50                   	push   %eax
c0029cc6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029ccc:	50                   	push   %eax
c0029ccd:	8d 83 c4 51 ff ff    	lea    -0xae3c(%ebx),%eax
c0029cd3:	50                   	push   %eax
c0029cd4:	68 d8 01 00 00       	push   $0x1d8
c0029cd9:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c0029cdf:	50                   	push   %eax
c0029ce0:	e8 aa f2 ff ff       	call   c0028f8f <debug_panic>
  elem = list_begin (list);
c0029ce5:	83 ec 0c             	sub    $0xc,%esp
c0029ce8:	55                   	push   %ebp
c0029ce9:	e8 c6 f3 ff ff       	call   c00290b4 <list_begin>
c0029cee:	83 c4 10             	add    $0x10,%esp
c0029cf1:	89 c6                	mov    %eax,%esi
  while ((next = list_next (elem)) != list_end (list))
c0029cf3:	eb 04                	jmp    c0029cf9 <list_unique+0xa0>
c0029cf5:	89 f3                	mov    %esi,%ebx
c0029cf7:	89 de                	mov    %ebx,%esi
c0029cf9:	83 ec 0c             	sub    $0xc,%esp
c0029cfc:	56                   	push   %esi
c0029cfd:	e8 f7 f3 ff ff       	call   c00290f9 <list_next>
c0029d02:	89 c3                	mov    %eax,%ebx
c0029d04:	89 2c 24             	mov    %ebp,(%esp)
c0029d07:	e8 4a f4 ff ff       	call   c0029156 <list_end>
c0029d0c:	83 c4 10             	add    $0x10,%esp
c0029d0f:	39 d8                	cmp    %ebx,%eax
c0029d11:	0f 84 74 ff ff ff    	je     c0029c8b <list_unique+0x32>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c0029d17:	83 ec 04             	sub    $0x4,%esp
c0029d1a:	ff 74 24 30          	pushl  0x30(%esp)
c0029d1e:	53                   	push   %ebx
c0029d1f:	56                   	push   %esi
c0029d20:	ff d7                	call   *%edi
c0029d22:	83 c4 10             	add    $0x10,%esp
c0029d25:	84 c0                	test   %al,%al
c0029d27:	75 ce                	jne    c0029cf7 <list_unique+0x9e>
c0029d29:	83 ec 04             	sub    $0x4,%esp
c0029d2c:	ff 74 24 30          	pushl  0x30(%esp)
c0029d30:	56                   	push   %esi
c0029d31:	53                   	push   %ebx
c0029d32:	ff d7                	call   *%edi
c0029d34:	83 c4 10             	add    $0x10,%esp
c0029d37:	84 c0                	test   %al,%al
c0029d39:	75 bc                	jne    c0029cf7 <list_unique+0x9e>
        list_remove (next);
c0029d3b:	83 ec 0c             	sub    $0xc,%esp
c0029d3e:	53                   	push   %ebx
c0029d3f:	e8 1b f9 ff ff       	call   c002965f <list_remove>
        if (duplicates != NULL)
c0029d44:	83 c4 10             	add    $0x10,%esp
c0029d47:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0029d4c:	74 a7                	je     c0029cf5 <list_unique+0x9c>
          list_push_back (duplicates, next);
c0029d4e:	83 ec 08             	sub    $0x8,%esp
c0029d51:	53                   	push   %ebx
c0029d52:	ff 74 24 30          	pushl  0x30(%esp)
c0029d56:	e8 e7 f8 ff ff       	call   c0029642 <list_push_back>
c0029d5b:	83 c4 10             	add    $0x10,%esp
c0029d5e:	89 f3                	mov    %esi,%ebx
c0029d60:	eb 95                	jmp    c0029cf7 <list_unique+0x9e>

c0029d62 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c0029d62:	55                   	push   %ebp
c0029d63:	57                   	push   %edi
c0029d64:	56                   	push   %esi
c0029d65:	53                   	push   %ebx
c0029d66:	83 ec 18             	sub    $0x18,%esp
c0029d69:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029d6d:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin (list);
c0029d71:	57                   	push   %edi
c0029d72:	e8 3d f3 ff ff       	call   c00290b4 <list_begin>
c0029d77:	89 c6                	mov    %eax,%esi
  if (max != list_end (list)) 
c0029d79:	89 3c 24             	mov    %edi,(%esp)
c0029d7c:	e8 d5 f3 ff ff       	call   c0029156 <list_end>
c0029d81:	83 c4 10             	add    $0x10,%esp
c0029d84:	39 f0                	cmp    %esi,%eax
c0029d86:	74 3c                	je     c0029dc4 <list_max+0x62>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c0029d88:	83 ec 0c             	sub    $0xc,%esp
c0029d8b:	56                   	push   %esi
c0029d8c:	e8 68 f3 ff ff       	call   c00290f9 <list_next>
c0029d91:	83 c4 10             	add    $0x10,%esp
c0029d94:	89 c3                	mov    %eax,%ebx
c0029d96:	eb 1c                	jmp    c0029db4 <list_max+0x52>
        if (less (max, e, aux))
c0029d98:	83 ec 04             	sub    $0x4,%esp
c0029d9b:	55                   	push   %ebp
c0029d9c:	53                   	push   %ebx
c0029d9d:	56                   	push   %esi
c0029d9e:	ff 54 24 34          	call   *0x34(%esp)
c0029da2:	84 c0                	test   %al,%al
          max = e; 
c0029da4:	0f 45 f3             	cmovne %ebx,%esi
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c0029da7:	89 1c 24             	mov    %ebx,(%esp)
c0029daa:	e8 4a f3 ff ff       	call   c00290f9 <list_next>
c0029daf:	83 c4 10             	add    $0x10,%esp
c0029db2:	89 c3                	mov    %eax,%ebx
c0029db4:	83 ec 0c             	sub    $0xc,%esp
c0029db7:	57                   	push   %edi
c0029db8:	e8 99 f3 ff ff       	call   c0029156 <list_end>
c0029dbd:	83 c4 10             	add    $0x10,%esp
c0029dc0:	39 d8                	cmp    %ebx,%eax
c0029dc2:	75 d4                	jne    c0029d98 <list_max+0x36>
    }
  return max;
}
c0029dc4:	89 f0                	mov    %esi,%eax
c0029dc6:	83 c4 0c             	add    $0xc,%esp
c0029dc9:	5b                   	pop    %ebx
c0029dca:	5e                   	pop    %esi
c0029dcb:	5f                   	pop    %edi
c0029dcc:	5d                   	pop    %ebp
c0029dcd:	c3                   	ret    

c0029dce <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c0029dce:	55                   	push   %ebp
c0029dcf:	57                   	push   %edi
c0029dd0:	56                   	push   %esi
c0029dd1:	53                   	push   %ebx
c0029dd2:	83 ec 18             	sub    $0x18,%esp
c0029dd5:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029dd9:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin (list);
c0029ddd:	57                   	push   %edi
c0029dde:	e8 d1 f2 ff ff       	call   c00290b4 <list_begin>
c0029de3:	89 c6                	mov    %eax,%esi
  if (min != list_end (list)) 
c0029de5:	89 3c 24             	mov    %edi,(%esp)
c0029de8:	e8 69 f3 ff ff       	call   c0029156 <list_end>
c0029ded:	83 c4 10             	add    $0x10,%esp
c0029df0:	39 f0                	cmp    %esi,%eax
c0029df2:	74 3c                	je     c0029e30 <list_min+0x62>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c0029df4:	83 ec 0c             	sub    $0xc,%esp
c0029df7:	56                   	push   %esi
c0029df8:	e8 fc f2 ff ff       	call   c00290f9 <list_next>
c0029dfd:	83 c4 10             	add    $0x10,%esp
c0029e00:	89 c3                	mov    %eax,%ebx
c0029e02:	eb 1c                	jmp    c0029e20 <list_min+0x52>
        if (less (e, min, aux))
c0029e04:	83 ec 04             	sub    $0x4,%esp
c0029e07:	55                   	push   %ebp
c0029e08:	56                   	push   %esi
c0029e09:	53                   	push   %ebx
c0029e0a:	ff 54 24 34          	call   *0x34(%esp)
c0029e0e:	84 c0                	test   %al,%al
          min = e; 
c0029e10:	0f 45 f3             	cmovne %ebx,%esi
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c0029e13:	89 1c 24             	mov    %ebx,(%esp)
c0029e16:	e8 de f2 ff ff       	call   c00290f9 <list_next>
c0029e1b:	83 c4 10             	add    $0x10,%esp
c0029e1e:	89 c3                	mov    %eax,%ebx
c0029e20:	83 ec 0c             	sub    $0xc,%esp
c0029e23:	57                   	push   %edi
c0029e24:	e8 2d f3 ff ff       	call   c0029156 <list_end>
c0029e29:	83 c4 10             	add    $0x10,%esp
c0029e2c:	39 d8                	cmp    %ebx,%eax
c0029e2e:	75 d4                	jne    c0029e04 <list_min+0x36>
    }
  return min;
}
c0029e30:	89 f0                	mov    %esi,%eax
c0029e32:	83 c4 0c             	add    $0xc,%esp
c0029e35:	5b                   	pop    %ebx
c0029e36:	5e                   	pop    %esi
c0029e37:	5f                   	pop    %edi
c0029e38:	5d                   	pop    %ebp
c0029e39:	c3                   	ret    

c0029e3a <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c0029e3a:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029e3e:	83 c0 1f             	add    $0x1f,%eax
c0029e41:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c0029e44:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0029e4b:	c3                   	ret    

c0029e4c <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0029e4c:	56                   	push   %esi
c0029e4d:	53                   	push   %ebx
c0029e4e:	83 ec 04             	sub    $0x4,%esp
c0029e51:	e8 e5 3a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029e56:	81 c3 76 f6 00 00    	add    $0xf676,%ebx
c0029e5c:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (b != NULL) 
c0029e60:	85 f6                	test   %esi,%esi
c0029e62:	74 16                	je     c0029e7a <bitmap_destroy+0x2e>
    {
      free (b->bits);
c0029e64:	83 ec 0c             	sub    $0xc,%esp
c0029e67:	ff 76 04             	pushl  0x4(%esi)
c0029e6a:	e8 85 9f ff ff       	call   c0023df4 <free>
      free (b);
c0029e6f:	89 34 24             	mov    %esi,(%esp)
c0029e72:	e8 7d 9f ff ff       	call   c0023df4 <free>
c0029e77:	83 c4 10             	add    $0x10,%esp
    }
}
c0029e7a:	83 c4 04             	add    $0x4,%esp
c0029e7d:	5b                   	pop    %ebx
c0029e7e:	5e                   	pop    %esi
c0029e7f:	c3                   	ret    

c0029e80 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c0029e80:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029e84:	8b 00                	mov    (%eax),%eax
}
c0029e86:	c3                   	ret    

c0029e87 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c0029e87:	53                   	push   %ebx
c0029e88:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029e8c:	89 cb                	mov    %ecx,%ebx
c0029e8e:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029e91:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029e95:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029e98:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e9d:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029e9f:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c0029ea2:	5b                   	pop    %ebx
c0029ea3:	c3                   	ret    

c0029ea4 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c0029ea4:	53                   	push   %ebx
c0029ea5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029ea9:	89 cb                	mov    %ecx,%ebx
c0029eab:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0029eae:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029eb2:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029eb5:	b8 01 00 00 00       	mov    $0x1,%eax
c0029eba:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0029ebc:	f7 d0                	not    %eax
c0029ebe:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c0029ec1:	5b                   	pop    %ebx
c0029ec2:	c3                   	ret    

c0029ec3 <bitmap_set>:
{
c0029ec3:	53                   	push   %ebx
c0029ec4:	83 ec 08             	sub    $0x8,%esp
c0029ec7:	e8 6f 3a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029ecc:	81 c3 00 f6 00 00    	add    $0xf600,%ebx
c0029ed2:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029ed6:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029eda:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c0029ede:	85 c0                	test   %eax,%eax
c0029ee0:	74 1a                	je     c0029efc <bitmap_set+0x39>
  ASSERT (idx < b->bit_cnt);
c0029ee2:	39 10                	cmp    %edx,(%eax)
c0029ee4:	76 3f                	jbe    c0029f25 <bitmap_set+0x62>
  if (value)
c0029ee6:	84 c9                	test   %cl,%cl
c0029ee8:	75 64                	jne    c0029f4e <bitmap_set+0x8b>
    bitmap_reset (b, idx);
c0029eea:	83 ec 08             	sub    $0x8,%esp
c0029eed:	52                   	push   %edx
c0029eee:	50                   	push   %eax
c0029eef:	e8 b0 ff ff ff       	call   c0029ea4 <bitmap_reset>
c0029ef4:	83 c4 10             	add    $0x10,%esp
}
c0029ef7:	83 c4 08             	add    $0x8,%esp
c0029efa:	5b                   	pop    %ebx
c0029efb:	c3                   	ret    
  ASSERT (b != NULL);
c0029efc:	83 ec 0c             	sub    $0xc,%esp
c0029eff:	8d 83 db 6f ff ff    	lea    -0x9025(%ebx),%eax
c0029f05:	50                   	push   %eax
c0029f06:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029f0c:	50                   	push   %eax
c0029f0d:	8d 83 14 53 ff ff    	lea    -0xacec(%ebx),%eax
c0029f13:	50                   	push   %eax
c0029f14:	68 93 00 00 00       	push   $0x93
c0029f19:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c0029f1f:	50                   	push   %eax
c0029f20:	e8 6a f0 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (idx < b->bit_cnt);
c0029f25:	83 ec 0c             	sub    $0xc,%esp
c0029f28:	8d 83 88 71 ff ff    	lea    -0x8e78(%ebx),%eax
c0029f2e:	50                   	push   %eax
c0029f2f:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029f35:	50                   	push   %eax
c0029f36:	8d 83 14 53 ff ff    	lea    -0xacec(%ebx),%eax
c0029f3c:	50                   	push   %eax
c0029f3d:	68 94 00 00 00       	push   $0x94
c0029f42:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c0029f48:	50                   	push   %eax
c0029f49:	e8 41 f0 ff ff       	call   c0028f8f <debug_panic>
    bitmap_mark (b, idx);
c0029f4e:	83 ec 08             	sub    $0x8,%esp
c0029f51:	52                   	push   %edx
c0029f52:	50                   	push   %eax
c0029f53:	e8 2f ff ff ff       	call   c0029e87 <bitmap_mark>
c0029f58:	83 c4 10             	add    $0x10,%esp
c0029f5b:	eb 9a                	jmp    c0029ef7 <bitmap_set+0x34>

c0029f5d <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c0029f5d:	53                   	push   %ebx
c0029f5e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c0029f62:	89 cb                	mov    %ecx,%ebx
c0029f64:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029f67:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029f6b:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029f6e:	b8 01 00 00 00       	mov    $0x1,%eax
c0029f73:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0029f75:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c0029f78:	5b                   	pop    %ebx
c0029f79:	c3                   	ret    

c0029f7a <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c0029f7a:	53                   	push   %ebx
c0029f7b:	83 ec 08             	sub    $0x8,%esp
c0029f7e:	e8 b8 39 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c0029f83:	81 c3 49 f5 00 00    	add    $0xf549,%ebx
c0029f89:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029f8d:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c0029f91:	85 c0                	test   %eax,%eax
c0029f93:	74 1e                	je     c0029fb3 <bitmap_test+0x39>
  ASSERT (idx < b->bit_cnt);
c0029f95:	39 08                	cmp    %ecx,(%eax)
c0029f97:	76 43                	jbe    c0029fdc <bitmap_test+0x62>
  return bit_idx / ELEM_BITS;
c0029f99:	89 cb                	mov    %ecx,%ebx
c0029f9b:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029f9e:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c0029fa1:	b8 01 00 00 00       	mov    $0x1,%eax
c0029fa6:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0029fa8:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c0029fab:	0f 95 c0             	setne  %al
}
c0029fae:	83 c4 08             	add    $0x8,%esp
c0029fb1:	5b                   	pop    %ebx
c0029fb2:	c3                   	ret    
  ASSERT (b != NULL);
c0029fb3:	83 ec 0c             	sub    $0xc,%esp
c0029fb6:	8d 83 db 6f ff ff    	lea    -0x9025(%ebx),%eax
c0029fbc:	50                   	push   %eax
c0029fbd:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029fc3:	50                   	push   %eax
c0029fc4:	8d 83 08 53 ff ff    	lea    -0xacf8(%ebx),%eax
c0029fca:	50                   	push   %eax
c0029fcb:	68 c8 00 00 00       	push   $0xc8
c0029fd0:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c0029fd6:	50                   	push   %eax
c0029fd7:	e8 b3 ef ff ff       	call   c0028f8f <debug_panic>
  ASSERT (idx < b->bit_cnt);
c0029fdc:	83 ec 0c             	sub    $0xc,%esp
c0029fdf:	8d 83 88 71 ff ff    	lea    -0x8e78(%ebx),%eax
c0029fe5:	50                   	push   %eax
c0029fe6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c0029fec:	50                   	push   %eax
c0029fed:	8d 83 08 53 ff ff    	lea    -0xacf8(%ebx),%eax
c0029ff3:	50                   	push   %eax
c0029ff4:	68 c9 00 00 00       	push   $0xc9
c0029ff9:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c0029fff:	50                   	push   %eax
c002a000:	e8 8a ef ff ff       	call   c0028f8f <debug_panic>

c002a005 <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a005:	55                   	push   %ebp
c002a006:	57                   	push   %edi
c002a007:	56                   	push   %esi
c002a008:	53                   	push   %ebx
c002a009:	83 ec 0c             	sub    $0xc,%esp
c002a00c:	e8 3a 39 00 00       	call   c002d94b <__x86.get_pc_thunk.cx>
c002a011:	81 c1 bb f4 00 00    	add    $0xf4bb,%ecx
c002a017:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a01b:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a01f:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a023:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a028:	85 ff                	test   %edi,%edi
c002a02a:	74 31                	je     c002a05d <bitmap_set_multiple+0x58>
  ASSERT (start <= b->bit_cnt);
c002a02c:	8b 17                	mov    (%edi),%edx
c002a02e:	39 f2                	cmp    %esi,%edx
c002a030:	72 56                	jb     c002a088 <bitmap_set_multiple+0x83>
  ASSERT (start + cnt <= b->bit_cnt);
c002a032:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a035:	39 ea                	cmp    %ebp,%edx
c002a037:	72 7a                	jb     c002a0b3 <bitmap_set_multiple+0xae>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c002a039:	0f b6 db             	movzbl %bl,%ebx
  for (i = 0; i < cnt; i++)
c002a03c:	85 c0                	test   %eax,%eax
c002a03e:	74 15                	je     c002a055 <bitmap_set_multiple+0x50>
    bitmap_set (b, start + i, value);
c002a040:	83 ec 04             	sub    $0x4,%esp
c002a043:	53                   	push   %ebx
c002a044:	56                   	push   %esi
c002a045:	57                   	push   %edi
c002a046:	e8 78 fe ff ff       	call   c0029ec3 <bitmap_set>
c002a04b:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a04e:	83 c4 10             	add    $0x10,%esp
c002a051:	39 f5                	cmp    %esi,%ebp
c002a053:	75 eb                	jne    c002a040 <bitmap_set_multiple+0x3b>
}
c002a055:	83 c4 0c             	add    $0xc,%esp
c002a058:	5b                   	pop    %ebx
c002a059:	5e                   	pop    %esi
c002a05a:	5f                   	pop    %edi
c002a05b:	5d                   	pop    %ebp
c002a05c:	c3                   	ret    
  ASSERT (b != NULL);
c002a05d:	83 ec 0c             	sub    $0xc,%esp
c002a060:	8d 81 db 6f ff ff    	lea    -0x9025(%ecx),%eax
c002a066:	50                   	push   %eax
c002a067:	8d 81 eb 55 ff ff    	lea    -0xaa15(%ecx),%eax
c002a06d:	50                   	push   %eax
c002a06e:	8d 81 e4 52 ff ff    	lea    -0xad1c(%ecx),%eax
c002a074:	50                   	push   %eax
c002a075:	68 de 00 00 00       	push   $0xde
c002a07a:	8d 81 6e 71 ff ff    	lea    -0x8e92(%ecx),%eax
c002a080:	50                   	push   %eax
c002a081:	89 cb                	mov    %ecx,%ebx
c002a083:	e8 07 ef ff ff       	call   c0028f8f <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a088:	83 ec 0c             	sub    $0xc,%esp
c002a08b:	8d 81 99 71 ff ff    	lea    -0x8e67(%ecx),%eax
c002a091:	50                   	push   %eax
c002a092:	8d 81 eb 55 ff ff    	lea    -0xaa15(%ecx),%eax
c002a098:	50                   	push   %eax
c002a099:	8d 81 e4 52 ff ff    	lea    -0xad1c(%ecx),%eax
c002a09f:	50                   	push   %eax
c002a0a0:	68 df 00 00 00       	push   $0xdf
c002a0a5:	8d 81 6e 71 ff ff    	lea    -0x8e92(%ecx),%eax
c002a0ab:	50                   	push   %eax
c002a0ac:	89 cb                	mov    %ecx,%ebx
c002a0ae:	e8 dc ee ff ff       	call   c0028f8f <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a0b3:	83 ec 0c             	sub    $0xc,%esp
c002a0b6:	8d 81 ad 71 ff ff    	lea    -0x8e53(%ecx),%eax
c002a0bc:	50                   	push   %eax
c002a0bd:	8d 81 eb 55 ff ff    	lea    -0xaa15(%ecx),%eax
c002a0c3:	50                   	push   %eax
c002a0c4:	8d 81 e4 52 ff ff    	lea    -0xad1c(%ecx),%eax
c002a0ca:	50                   	push   %eax
c002a0cb:	68 e0 00 00 00       	push   $0xe0
c002a0d0:	8d 81 6e 71 ff ff    	lea    -0x8e92(%ecx),%eax
c002a0d6:	50                   	push   %eax
c002a0d7:	89 cb                	mov    %ecx,%ebx
c002a0d9:	e8 b1 ee ff ff       	call   c0028f8f <debug_panic>

c002a0de <bitmap_set_all>:
{
c002a0de:	53                   	push   %ebx
c002a0df:	83 ec 08             	sub    $0x8,%esp
c002a0e2:	e8 54 38 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a0e7:	81 c3 e5 f3 00 00    	add    $0xf3e5,%ebx
c002a0ed:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a0f1:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c002a0f5:	85 c0                	test   %eax,%eax
c002a0f7:	74 13                	je     c002a10c <bitmap_set_all+0x2e>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a0f9:	0f b6 d2             	movzbl %dl,%edx
c002a0fc:	52                   	push   %edx
c002a0fd:	ff 30                	pushl  (%eax)
c002a0ff:	6a 00                	push   $0x0
c002a101:	50                   	push   %eax
c002a102:	e8 fe fe ff ff       	call   c002a005 <bitmap_set_multiple>
}
c002a107:	83 c4 18             	add    $0x18,%esp
c002a10a:	5b                   	pop    %ebx
c002a10b:	c3                   	ret    
  ASSERT (b != NULL);
c002a10c:	83 ec 0c             	sub    $0xc,%esp
c002a10f:	8d 83 db 6f ff ff    	lea    -0x9025(%ebx),%eax
c002a115:	50                   	push   %eax
c002a116:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002a11c:	50                   	push   %eax
c002a11d:	8d 83 f8 52 ff ff    	lea    -0xad08(%ebx),%eax
c002a123:	50                   	push   %eax
c002a124:	68 d3 00 00 00       	push   $0xd3
c002a129:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c002a12f:	50                   	push   %eax
c002a130:	e8 5a ee ff ff       	call   c0028f8f <debug_panic>

c002a135 <bitmap_create>:
{
c002a135:	57                   	push   %edi
c002a136:	56                   	push   %esi
c002a137:	53                   	push   %ebx
c002a138:	e8 fe 37 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a13d:	81 c3 8f f3 00 00    	add    $0xf38f,%ebx
c002a143:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct bitmap *b = malloc (sizeof *b);
c002a147:	83 ec 0c             	sub    $0xc,%esp
c002a14a:	6a 08                	push   $0x8
c002a14c:	e8 ed 9a ff ff       	call   c0023c3e <malloc>
c002a151:	89 c6                	mov    %eax,%esi
  if (b != NULL)
c002a153:	83 c4 10             	add    $0x10,%esp
c002a156:	85 c0                	test   %eax,%eax
c002a158:	74 30                	je     c002a18a <bitmap_create+0x55>
      b->bit_cnt = bit_cnt;
c002a15a:	89 38                	mov    %edi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a15c:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a15f:	8d 47 1f             	lea    0x1f(%edi),%eax
c002a162:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a165:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c002a168:	50                   	push   %eax
c002a169:	e8 d0 9a ff ff       	call   c0023c3e <malloc>
c002a16e:	89 46 04             	mov    %eax,0x4(%esi)
      if (b->bits != NULL || bit_cnt == 0)
c002a171:	83 c4 10             	add    $0x10,%esp
c002a174:	85 ff                	test   %edi,%edi
c002a176:	74 04                	je     c002a17c <bitmap_create+0x47>
c002a178:	85 c0                	test   %eax,%eax
c002a17a:	74 14                	je     c002a190 <bitmap_create+0x5b>
          bitmap_set_all (b, false);
c002a17c:	83 ec 08             	sub    $0x8,%esp
c002a17f:	6a 00                	push   $0x0
c002a181:	56                   	push   %esi
c002a182:	e8 57 ff ff ff       	call   c002a0de <bitmap_set_all>
          return b;
c002a187:	83 c4 10             	add    $0x10,%esp
}
c002a18a:	89 f0                	mov    %esi,%eax
c002a18c:	5b                   	pop    %ebx
c002a18d:	5e                   	pop    %esi
c002a18e:	5f                   	pop    %edi
c002a18f:	c3                   	ret    
      free (b);
c002a190:	83 ec 0c             	sub    $0xc,%esp
c002a193:	56                   	push   %esi
c002a194:	e8 5b 9c ff ff       	call   c0023df4 <free>
c002a199:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002a19c:	be 00 00 00 00       	mov    $0x0,%esi
c002a1a1:	eb e7                	jmp    c002a18a <bitmap_create+0x55>

c002a1a3 <bitmap_create_in_buf>:
{
c002a1a3:	57                   	push   %edi
c002a1a4:	56                   	push   %esi
c002a1a5:	53                   	push   %ebx
c002a1a6:	e8 90 37 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a1ab:	81 c3 21 f3 00 00    	add    $0xf321,%ebx
c002a1b1:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002a1b5:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a1b9:	57                   	push   %edi
c002a1ba:	e8 7b fc ff ff       	call   c0029e3a <bitmap_buf_size>
c002a1bf:	83 c4 04             	add    $0x4,%esp
c002a1c2:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002a1c6:	77 1c                	ja     c002a1e4 <bitmap_create_in_buf+0x41>
  b->bit_cnt = bit_cnt;
c002a1c8:	89 3e                	mov    %edi,(%esi)
  b->bits = (elem_type *) (b + 1);
c002a1ca:	8d 46 08             	lea    0x8(%esi),%eax
c002a1cd:	89 46 04             	mov    %eax,0x4(%esi)
  bitmap_set_all (b, false);
c002a1d0:	83 ec 08             	sub    $0x8,%esp
c002a1d3:	6a 00                	push   $0x0
c002a1d5:	56                   	push   %esi
c002a1d6:	e8 03 ff ff ff       	call   c002a0de <bitmap_set_all>
  return b;
c002a1db:	83 c4 10             	add    $0x10,%esp
}
c002a1de:	89 f0                	mov    %esi,%eax
c002a1e0:	5b                   	pop    %ebx
c002a1e1:	5e                   	pop    %esi
c002a1e2:	5f                   	pop    %edi
c002a1e3:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a1e4:	83 ec 0c             	sub    $0xc,%esp
c002a1e7:	8d 83 c8 71 ff ff    	lea    -0x8e38(%ebx),%eax
c002a1ed:	50                   	push   %eax
c002a1ee:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002a1f4:	50                   	push   %eax
c002a1f5:	8d 83 20 53 ff ff    	lea    -0xace0(%ebx),%eax
c002a1fb:	50                   	push   %eax
c002a1fc:	6a 68                	push   $0x68
c002a1fe:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c002a204:	50                   	push   %eax
c002a205:	e8 85 ed ff ff       	call   c0028f8f <debug_panic>

c002a20a <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a20a:	55                   	push   %ebp
c002a20b:	57                   	push   %edi
c002a20c:	56                   	push   %esi
c002a20d:	53                   	push   %ebx
c002a20e:	83 ec 1c             	sub    $0x1c,%esp
c002a211:	e8 25 37 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a216:	81 c3 b6 f2 00 00    	add    $0xf2b6,%ebx
c002a21c:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a220:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a224:	8b 44 24 38          	mov    0x38(%esp),%eax
c002a228:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c002a22d:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a231:	85 ff                	test   %edi,%edi
c002a233:	74 44                	je     c002a279 <bitmap_count+0x6f>
  ASSERT (start <= b->bit_cnt);
c002a235:	8b 17                	mov    (%edi),%edx
c002a237:	39 f2                	cmp    %esi,%edx
c002a239:	72 67                	jb     c002a2a2 <bitmap_count+0x98>
  ASSERT (start + cnt <= b->bit_cnt);
c002a23b:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a23e:	39 ea                	cmp    %ebp,%edx
c002a240:	0f 82 89 00 00 00    	jb     c002a2cf <bitmap_count+0xc5>

  value_cnt = 0;
c002a246:	bb 00 00 00 00       	mov    $0x0,%ebx
  for (i = 0; i < cnt; i++)
c002a24b:	85 c0                	test   %eax,%eax
c002a24d:	74 7c                	je     c002a2cb <bitmap_count+0xc1>
    if (bitmap_test (b, start + i) == value)
c002a24f:	83 ec 08             	sub    $0x8,%esp
c002a252:	56                   	push   %esi
c002a253:	57                   	push   %edi
c002a254:	e8 21 fd ff ff       	call   c0029f7a <bitmap_test>
c002a259:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c002a25c:	3a 44 24 0f          	cmp    0xf(%esp),%al
c002a260:	0f 94 c0             	sete   %al
c002a263:	0f b6 c0             	movzbl %al,%eax
c002a266:	01 c3                	add    %eax,%ebx
c002a268:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a26b:	39 f5                	cmp    %esi,%ebp
c002a26d:	75 e0                	jne    c002a24f <bitmap_count+0x45>
  return value_cnt;
}
c002a26f:	89 d8                	mov    %ebx,%eax
c002a271:	83 c4 1c             	add    $0x1c,%esp
c002a274:	5b                   	pop    %ebx
c002a275:	5e                   	pop    %esi
c002a276:	5f                   	pop    %edi
c002a277:	5d                   	pop    %ebp
c002a278:	c3                   	ret    
  ASSERT (b != NULL);
c002a279:	83 ec 0c             	sub    $0xc,%esp
c002a27c:	8d 83 db 6f ff ff    	lea    -0x9025(%ebx),%eax
c002a282:	50                   	push   %eax
c002a283:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002a289:	50                   	push   %eax
c002a28a:	8d 83 d4 52 ff ff    	lea    -0xad2c(%ebx),%eax
c002a290:	50                   	push   %eax
c002a291:	68 ed 00 00 00       	push   $0xed
c002a296:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c002a29c:	50                   	push   %eax
c002a29d:	e8 ed ec ff ff       	call   c0028f8f <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a2a2:	83 ec 0c             	sub    $0xc,%esp
c002a2a5:	8d 83 99 71 ff ff    	lea    -0x8e67(%ebx),%eax
c002a2ab:	50                   	push   %eax
c002a2ac:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002a2b2:	50                   	push   %eax
c002a2b3:	8d 83 d4 52 ff ff    	lea    -0xad2c(%ebx),%eax
c002a2b9:	50                   	push   %eax
c002a2ba:	68 ee 00 00 00       	push   $0xee
c002a2bf:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c002a2c5:	50                   	push   %eax
c002a2c6:	e8 c4 ec ff ff       	call   c0028f8f <debug_panic>
  value_cnt = 0;
c002a2cb:	89 c3                	mov    %eax,%ebx
c002a2cd:	eb a0                	jmp    c002a26f <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c002a2cf:	83 ec 0c             	sub    $0xc,%esp
c002a2d2:	8d 83 ad 71 ff ff    	lea    -0x8e53(%ebx),%eax
c002a2d8:	50                   	push   %eax
c002a2d9:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002a2df:	50                   	push   %eax
c002a2e0:	8d 83 d4 52 ff ff    	lea    -0xad2c(%ebx),%eax
c002a2e6:	50                   	push   %eax
c002a2e7:	68 ef 00 00 00       	push   $0xef
c002a2ec:	8d 83 6e 71 ff ff    	lea    -0x8e92(%ebx),%eax
c002a2f2:	50                   	push   %eax
c002a2f3:	e8 97 ec ff ff       	call   c0028f8f <debug_panic>

c002a2f8 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a2f8:	55                   	push   %ebp
c002a2f9:	57                   	push   %edi
c002a2fa:	56                   	push   %esi
c002a2fb:	53                   	push   %ebx
c002a2fc:	83 ec 0c             	sub    $0xc,%esp
c002a2ff:	e8 47 36 00 00       	call   c002d94b <__x86.get_pc_thunk.cx>
c002a304:	81 c1 c8 f1 00 00    	add    $0xf1c8,%ecx
c002a30a:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a30e:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a312:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a316:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a31b:	85 ff                	test   %edi,%edi
c002a31d:	74 3f                	je     c002a35e <bitmap_contains+0x66>
  ASSERT (start <= b->bit_cnt);
c002a31f:	8b 17                	mov    (%edi),%edx
c002a321:	39 f2                	cmp    %esi,%edx
c002a323:	72 64                	jb     c002a389 <bitmap_contains+0x91>
  ASSERT (start + cnt <= b->bit_cnt);
c002a325:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a328:	39 ea                	cmp    %ebp,%edx
c002a32a:	0f 82 84 00 00 00    	jb     c002a3b4 <bitmap_contains+0xbc>

  for (i = 0; i < cnt; i++)
c002a330:	85 c0                	test   %eax,%eax
c002a332:	0f 84 ac 00 00 00    	je     c002a3e4 <bitmap_contains+0xec>
    if (bitmap_test (b, start + i) == value)
c002a338:	83 ec 08             	sub    $0x8,%esp
c002a33b:	56                   	push   %esi
c002a33c:	57                   	push   %edi
c002a33d:	e8 38 fc ff ff       	call   c0029f7a <bitmap_test>
c002a342:	83 c4 10             	add    $0x10,%esp
c002a345:	38 d8                	cmp    %bl,%al
c002a347:	0f 84 92 00 00 00    	je     c002a3df <bitmap_contains+0xe7>
c002a34d:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a350:	39 f5                	cmp    %esi,%ebp
c002a352:	75 e4                	jne    c002a338 <bitmap_contains+0x40>
      return true;
  return false;
c002a354:	b8 00 00 00 00       	mov    $0x0,%eax
c002a359:	e9 86 00 00 00       	jmp    c002a3e4 <bitmap_contains+0xec>
  ASSERT (b != NULL);
c002a35e:	83 ec 0c             	sub    $0xc,%esp
c002a361:	8d 81 db 6f ff ff    	lea    -0x9025(%ecx),%eax
c002a367:	50                   	push   %eax
c002a368:	8d 81 eb 55 ff ff    	lea    -0xaa15(%ecx),%eax
c002a36e:	50                   	push   %eax
c002a36f:	8d 81 c4 52 ff ff    	lea    -0xad3c(%ecx),%eax
c002a375:	50                   	push   %eax
c002a376:	68 ff 00 00 00       	push   $0xff
c002a37b:	8d 81 6e 71 ff ff    	lea    -0x8e92(%ecx),%eax
c002a381:	50                   	push   %eax
c002a382:	89 cb                	mov    %ecx,%ebx
c002a384:	e8 06 ec ff ff       	call   c0028f8f <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a389:	83 ec 0c             	sub    $0xc,%esp
c002a38c:	8d 81 99 71 ff ff    	lea    -0x8e67(%ecx),%eax
c002a392:	50                   	push   %eax
c002a393:	8d 81 eb 55 ff ff    	lea    -0xaa15(%ecx),%eax
c002a399:	50                   	push   %eax
c002a39a:	8d 81 c4 52 ff ff    	lea    -0xad3c(%ecx),%eax
c002a3a0:	50                   	push   %eax
c002a3a1:	68 00 01 00 00       	push   $0x100
c002a3a6:	8d 81 6e 71 ff ff    	lea    -0x8e92(%ecx),%eax
c002a3ac:	50                   	push   %eax
c002a3ad:	89 cb                	mov    %ecx,%ebx
c002a3af:	e8 db eb ff ff       	call   c0028f8f <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a3b4:	83 ec 0c             	sub    $0xc,%esp
c002a3b7:	8d 81 ad 71 ff ff    	lea    -0x8e53(%ecx),%eax
c002a3bd:	50                   	push   %eax
c002a3be:	8d 81 eb 55 ff ff    	lea    -0xaa15(%ecx),%eax
c002a3c4:	50                   	push   %eax
c002a3c5:	8d 81 c4 52 ff ff    	lea    -0xad3c(%ecx),%eax
c002a3cb:	50                   	push   %eax
c002a3cc:	68 01 01 00 00       	push   $0x101
c002a3d1:	8d 81 6e 71 ff ff    	lea    -0x8e92(%ecx),%eax
c002a3d7:	50                   	push   %eax
c002a3d8:	89 cb                	mov    %ecx,%ebx
c002a3da:	e8 b0 eb ff ff       	call   c0028f8f <debug_panic>
      return true;
c002a3df:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a3e4:	83 c4 0c             	add    $0xc,%esp
c002a3e7:	5b                   	pop    %ebx
c002a3e8:	5e                   	pop    %esi
c002a3e9:	5f                   	pop    %edi
c002a3ea:	5d                   	pop    %ebp
c002a3eb:	c3                   	ret    

c002a3ec <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a3ec:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c002a3ef:	6a 01                	push   $0x1
c002a3f1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a3f5:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a3f9:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a3fd:	e8 f6 fe ff ff       	call   c002a2f8 <bitmap_contains>
}
c002a402:	83 c4 1c             	add    $0x1c,%esp
c002a405:	c3                   	ret    

c002a406 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a406:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002a409:	6a 01                	push   $0x1
c002a40b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a40f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a413:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a417:	e8 dc fe ff ff       	call   c002a2f8 <bitmap_contains>
c002a41c:	83 f0 01             	xor    $0x1,%eax
}
c002a41f:	83 c4 1c             	add    $0x1c,%esp
c002a422:	c3                   	ret    

c002a423 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a423:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c002a426:	6a 00                	push   $0x0
c002a428:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a42c:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a430:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a434:	e8 bf fe ff ff       	call   c002a2f8 <bitmap_contains>
c002a439:	83 f0 01             	xor    $0x1,%eax
}
c002a43c:	83 c4 1c             	add    $0x1c,%esp
c002a43f:	c3                   	ret    

c002a440 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a440:	55                   	push   %ebp
c002a441:	57                   	push   %edi
c002a442:	56                   	push   %esi
c002a443:	53                   	push   %ebx
c002a444:	83 ec 1c             	sub    $0x1c,%esp
c002a447:	e8 f3 34 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c002a44c:	05 80 f0 00 00       	add    $0xf080,%eax
c002a451:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a455:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a459:	8b 6c 24 38          	mov    0x38(%esp),%ebp
c002a45d:	0f b6 5c 24 3c       	movzbl 0x3c(%esp),%ebx
  ASSERT (b != NULL);
c002a462:	85 ff                	test   %edi,%edi
c002a464:	74 43                	je     c002a4a9 <bitmap_scan+0x69>
  ASSERT (start <= b->bit_cnt);
c002a466:	8b 17                	mov    (%edi),%edx
c002a468:	39 f2                	cmp    %esi,%edx
c002a46a:	72 68                	jb     c002a4d4 <bitmap_scan+0x94>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002a46c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  if (cnt <= b->bit_cnt) 
c002a471:	39 ea                	cmp    %ebp,%edx
c002a473:	0f 82 8f 00 00 00    	jb     c002a508 <bitmap_scan+0xc8>
      size_t last = b->bit_cnt - cnt;
c002a479:	29 ea                	sub    %ebp,%edx
c002a47b:	89 54 24 0c          	mov    %edx,0xc(%esp)
      for (i = start; i <= last; i++)
c002a47f:	39 d6                	cmp    %edx,%esi
c002a481:	77 7c                	ja     c002a4ff <bitmap_scan+0xbf>
        if (!bitmap_contains (b, i, cnt, !value))
c002a483:	83 f3 01             	xor    $0x1,%ebx
c002a486:	0f b6 db             	movzbl %bl,%ebx
c002a489:	53                   	push   %ebx
c002a48a:	55                   	push   %ebp
c002a48b:	56                   	push   %esi
c002a48c:	57                   	push   %edi
c002a48d:	e8 66 fe ff ff       	call   c002a2f8 <bitmap_contains>
c002a492:	83 c4 10             	add    $0x10,%esp
c002a495:	84 c0                	test   %al,%al
c002a497:	74 6d                	je     c002a506 <bitmap_scan+0xc6>
      for (i = start; i <= last; i++)
c002a499:	83 c6 01             	add    $0x1,%esi
c002a49c:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c002a4a0:	73 e7                	jae    c002a489 <bitmap_scan+0x49>
  return BITMAP_ERROR;
c002a4a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a4a7:	eb 5f                	jmp    c002a508 <bitmap_scan+0xc8>
  ASSERT (b != NULL);
c002a4a9:	83 ec 0c             	sub    $0xc,%esp
c002a4ac:	8d 90 db 6f ff ff    	lea    -0x9025(%eax),%edx
c002a4b2:	52                   	push   %edx
c002a4b3:	8d 90 eb 55 ff ff    	lea    -0xaa15(%eax),%edx
c002a4b9:	52                   	push   %edx
c002a4ba:	8d 90 b8 52 ff ff    	lea    -0xad48(%eax),%edx
c002a4c0:	52                   	push   %edx
c002a4c1:	68 2a 01 00 00       	push   $0x12a
c002a4c6:	8d 90 6e 71 ff ff    	lea    -0x8e92(%eax),%edx
c002a4cc:	52                   	push   %edx
c002a4cd:	89 c3                	mov    %eax,%ebx
c002a4cf:	e8 bb ea ff ff       	call   c0028f8f <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a4d4:	83 ec 0c             	sub    $0xc,%esp
c002a4d7:	8d 90 99 71 ff ff    	lea    -0x8e67(%eax),%edx
c002a4dd:	52                   	push   %edx
c002a4de:	8d 90 eb 55 ff ff    	lea    -0xaa15(%eax),%edx
c002a4e4:	52                   	push   %edx
c002a4e5:	8d 90 b8 52 ff ff    	lea    -0xad48(%eax),%edx
c002a4eb:	52                   	push   %edx
c002a4ec:	68 2b 01 00 00       	push   $0x12b
c002a4f1:	8d 90 6e 71 ff ff    	lea    -0x8e92(%eax),%edx
c002a4f7:	52                   	push   %edx
c002a4f8:	89 c3                	mov    %eax,%ebx
c002a4fa:	e8 90 ea ff ff       	call   c0028f8f <debug_panic>
  return BITMAP_ERROR;
c002a4ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a504:	eb 02                	jmp    c002a508 <bitmap_scan+0xc8>
c002a506:	89 f0                	mov    %esi,%eax
}
c002a508:	83 c4 1c             	add    $0x1c,%esp
c002a50b:	5b                   	pop    %ebx
c002a50c:	5e                   	pop    %esi
c002a50d:	5f                   	pop    %edi
c002a50e:	5d                   	pop    %ebp
c002a50f:	c3                   	ret    

c002a510 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002a510:	55                   	push   %ebp
c002a511:	57                   	push   %edi
c002a512:	56                   	push   %esi
c002a513:	53                   	push   %ebx
c002a514:	83 ec 0c             	sub    $0xc,%esp
c002a517:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a51b:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002a51f:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c002a523:	0f b6 c3             	movzbl %bl,%eax
c002a526:	50                   	push   %eax
c002a527:	55                   	push   %ebp
c002a528:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a52c:	57                   	push   %edi
c002a52d:	e8 0e ff ff ff       	call   c002a440 <bitmap_scan>
c002a532:	83 c4 10             	add    $0x10,%esp
c002a535:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c002a537:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a53a:	74 12                	je     c002a54e <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple (b, idx, cnt, !value);
c002a53c:	83 f3 01             	xor    $0x1,%ebx
c002a53f:	0f b6 db             	movzbl %bl,%ebx
c002a542:	53                   	push   %ebx
c002a543:	55                   	push   %ebp
c002a544:	50                   	push   %eax
c002a545:	57                   	push   %edi
c002a546:	e8 ba fa ff ff       	call   c002a005 <bitmap_set_multiple>
c002a54b:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c002a54e:	89 f0                	mov    %esi,%eax
c002a550:	83 c4 0c             	add    $0xc,%esp
c002a553:	5b                   	pop    %ebx
c002a554:	5e                   	pop    %esi
c002a555:	5f                   	pop    %edi
c002a556:	5d                   	pop    %ebp
c002a557:	c3                   	ret    

c002a558 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002a558:	53                   	push   %ebx
c002a559:	83 ec 08             	sub    $0x8,%esp
c002a55c:	e8 da 33 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a561:	81 c3 6b ef 00 00    	add    $0xef6b,%ebx
c002a567:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a56b:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a56d:	8b 02                	mov    (%edx),%eax
c002a56f:	83 c0 1f             	add    $0x1f,%eax
c002a572:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a575:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a578:	50                   	push   %eax
c002a579:	ff 72 04             	pushl  0x4(%edx)
c002a57c:	6a 00                	push   $0x0
c002a57e:	e8 b3 d5 ff ff       	call   c0027b36 <hex_dump>
}
c002a583:	83 c4 18             	add    $0x18,%esp
c002a586:	5b                   	pop    %ebx
c002a587:	c3                   	ret    

c002a588 <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002a588:	53                   	push   %ebx
c002a589:	83 ec 10             	sub    $0x10,%esp
c002a58c:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002a58e:	ff 70 14             	pushl  0x14(%eax)
c002a591:	52                   	push   %edx
c002a592:	ff 50 0c             	call   *0xc(%eax)
c002a595:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002a598:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002a59b:	21 d0                	and    %edx,%eax
  return &h->buckets[bucket_idx];
c002a59d:	c1 e0 04             	shl    $0x4,%eax
c002a5a0:	03 43 08             	add    0x8(%ebx),%eax
}
c002a5a3:	83 c4 18             	add    $0x18,%esp
c002a5a6:	5b                   	pop    %ebx
c002a5a7:	c3                   	ret    

c002a5a8 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002a5a8:	55                   	push   %ebp
c002a5a9:	57                   	push   %edi
c002a5aa:	56                   	push   %esi
c002a5ab:	53                   	push   %ebx
c002a5ac:	83 ec 28             	sub    $0x28,%esp
c002a5af:	e8 87 33 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a5b4:	81 c3 18 ef 00 00    	add    $0xef18,%ebx
c002a5ba:	89 c7                	mov    %eax,%edi
c002a5bc:	89 54 24 18          	mov    %edx,0x18(%esp)
c002a5c0:	89 cd                	mov    %ecx,%ebp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002a5c2:	52                   	push   %edx
c002a5c3:	e8 ec ea ff ff       	call   c00290b4 <list_begin>
c002a5c8:	89 c6                	mov    %eax,%esi
c002a5ca:	83 c4 10             	add    $0x10,%esp
c002a5cd:	eb 0e                	jmp    c002a5dd <find_elem+0x35>
c002a5cf:	83 ec 0c             	sub    $0xc,%esp
c002a5d2:	56                   	push   %esi
c002a5d3:	e8 21 eb ff ff       	call   c00290f9 <list_next>
c002a5d8:	89 c6                	mov    %eax,%esi
c002a5da:	83 c4 10             	add    $0x10,%esp
c002a5dd:	83 ec 0c             	sub    $0xc,%esp
c002a5e0:	ff 74 24 18          	pushl  0x18(%esp)
c002a5e4:	e8 6d eb ff ff       	call   c0029156 <list_end>
c002a5e9:	83 c4 10             	add    $0x10,%esp
c002a5ec:	39 f0                	cmp    %esi,%eax
c002a5ee:	74 26                	je     c002a616 <find_elem+0x6e>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002a5f0:	83 ec 04             	sub    $0x4,%esp
c002a5f3:	ff 77 14             	pushl  0x14(%edi)
c002a5f6:	55                   	push   %ebp
c002a5f7:	56                   	push   %esi
c002a5f8:	ff 57 10             	call   *0x10(%edi)
c002a5fb:	83 c4 10             	add    $0x10,%esp
c002a5fe:	84 c0                	test   %al,%al
c002a600:	75 cd                	jne    c002a5cf <find_elem+0x27>
c002a602:	83 ec 04             	sub    $0x4,%esp
c002a605:	ff 77 14             	pushl  0x14(%edi)
c002a608:	56                   	push   %esi
c002a609:	55                   	push   %ebp
c002a60a:	ff 57 10             	call   *0x10(%edi)
c002a60d:	83 c4 10             	add    $0x10,%esp
c002a610:	84 c0                	test   %al,%al
c002a612:	75 bb                	jne    c002a5cf <find_elem+0x27>
c002a614:	eb 05                	jmp    c002a61b <find_elem+0x73>
        return hi; 
    }
  return NULL;
c002a616:	be 00 00 00 00       	mov    $0x0,%esi
}
c002a61b:	89 f0                	mov    %esi,%eax
c002a61d:	83 c4 1c             	add    $0x1c,%esp
c002a620:	5b                   	pop    %ebx
c002a621:	5e                   	pop    %esi
c002a622:	5f                   	pop    %edi
c002a623:	5d                   	pop    %ebp
c002a624:	c3                   	ret    

c002a625 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002a625:	55                   	push   %ebp
c002a626:	57                   	push   %edi
c002a627:	56                   	push   %esi
c002a628:	53                   	push   %ebx
c002a629:	83 ec 2c             	sub    $0x2c,%esp
c002a62c:	e8 0a 33 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a631:	81 c3 9b ee 00 00    	add    $0xee9b,%ebx
c002a637:	89 44 24 10          	mov    %eax,0x10(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002a63b:	85 c0                	test   %eax,%eax
c002a63d:	74 22                	je     c002a661 <rehash+0x3c>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c002a63f:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a643:	8b 48 04             	mov    0x4(%eax),%ecx
c002a646:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002a64a:	8b 00                	mov    (%eax),%eax
c002a64c:	89 44 24 14          	mov    %eax,0x14(%esp)
c002a650:	89 c6                	mov    %eax,%esi
c002a652:	d1 ee                	shr    %esi
c002a654:	83 fe 04             	cmp    $0x4,%esi
c002a657:	b8 04 00 00 00       	mov    $0x4,%eax
c002a65c:	0f 42 f0             	cmovb  %eax,%esi
c002a65f:	eb 2e                	jmp    c002a68f <rehash+0x6a>
  ASSERT (h != NULL);
c002a661:	83 ec 0c             	sub    $0xc,%esp
c002a664:	8d 83 f0 71 ff ff    	lea    -0x8e10(%ebx),%eax
c002a66a:	50                   	push   %eax
c002a66b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002a671:	50                   	push   %eax
c002a672:	8d 83 74 53 ff ff    	lea    -0xac8c(%ebx),%eax
c002a678:	50                   	push   %eax
c002a679:	68 66 01 00 00       	push   $0x166
c002a67e:	8d 83 fa 71 ff ff    	lea    -0x8e06(%ebx),%eax
c002a684:	50                   	push   %eax
c002a685:	e8 05 e9 ff ff       	call   c0028f8f <debug_panic>
  return x & (x - 1);
c002a68a:	8d 46 ff             	lea    -0x1(%esi),%eax
c002a68d:	21 c6                	and    %eax,%esi
  return x != 0 && turn_off_least_1bit (x) == 0;
c002a68f:	85 f6                	test   %esi,%esi
c002a691:	74 f7                	je     c002a68a <rehash+0x65>
  return x & (x - 1);
c002a693:	8d 46 ff             	lea    -0x1(%esi),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002a696:	85 f0                	test   %esi,%eax
c002a698:	75 f0                	jne    c002a68a <rehash+0x65>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002a69a:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002a69e:	0f 84 df 00 00 00    	je     c002a783 <rehash+0x15e>
  old_buckets = h->buckets;
c002a6a4:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a6a8:	8b 40 08             	mov    0x8(%eax),%eax
c002a6ab:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002a6af:	89 f5                	mov    %esi,%ebp
c002a6b1:	c1 e5 04             	shl    $0x4,%ebp
c002a6b4:	83 ec 0c             	sub    $0xc,%esp
c002a6b7:	55                   	push   %ebp
c002a6b8:	e8 81 95 ff ff       	call   c0023c3e <malloc>
c002a6bd:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (new_buckets == NULL) 
c002a6c1:	83 c4 10             	add    $0x10,%esp
c002a6c4:	85 c0                	test   %eax,%eax
c002a6c6:	0f 84 b7 00 00 00    	je     c002a783 <rehash+0x15e>
c002a6cc:	89 c7                	mov    %eax,%edi
c002a6ce:	01 c5                	add    %eax,%ebp
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c002a6d0:	83 ec 0c             	sub    $0xc,%esp
c002a6d3:	57                   	push   %edi
c002a6d4:	e8 83 e9 ff ff       	call   c002905c <list_init>
c002a6d9:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < new_bucket_cnt; i++) 
c002a6dc:	83 c4 10             	add    $0x10,%esp
c002a6df:	39 ef                	cmp    %ebp,%edi
c002a6e1:	75 ed                	jne    c002a6d0 <rehash+0xab>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002a6e3:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a6e7:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002a6eb:	89 48 08             	mov    %ecx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002a6ee:	89 70 04             	mov    %esi,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002a6f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002a6f5:	85 c0                	test   %eax,%eax
c002a6f7:	74 7b                	je     c002a774 <rehash+0x14f>
c002a6f9:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002a6fd:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002a701:	c1 e0 04             	shl    $0x4,%eax
c002a704:	01 c8                	add    %ecx,%eax
c002a706:	89 44 24 18          	mov    %eax,0x18(%esp)
c002a70a:	eb 52                	jmp    c002a75e <rehash+0x139>

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c002a70c:	89 f2                	mov    %esi,%edx
c002a70e:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a712:	e8 71 fe ff ff       	call   c002a588 <find_bucket>
c002a717:	89 c5                	mov    %eax,%ebp
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c002a719:	83 ec 0c             	sub    $0xc,%esp
c002a71c:	56                   	push   %esi
c002a71d:	e8 d7 e9 ff ff       	call   c00290f9 <list_next>
c002a722:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          list_remove (elem);
c002a726:	89 34 24             	mov    %esi,(%esp)
c002a729:	e8 31 ef ff ff       	call   c002965f <list_remove>
          list_push_front (new_bucket, elem);
c002a72e:	83 c4 08             	add    $0x8,%esp
c002a731:	56                   	push   %esi
c002a732:	55                   	push   %ebp
c002a733:	e8 ed ee ff ff       	call   c0029625 <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c002a738:	83 c4 10             	add    $0x10,%esp
c002a73b:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a73f:	83 ec 0c             	sub    $0xc,%esp
c002a742:	57                   	push   %edi
c002a743:	e8 0e ea ff ff       	call   c0029156 <list_end>
      for (elem = list_begin (old_bucket);
c002a748:	83 c4 10             	add    $0x10,%esp
c002a74b:	39 f0                	cmp    %esi,%eax
c002a74d:	75 bd                	jne    c002a70c <rehash+0xe7>
c002a74f:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002a754:	8b 44 24 14          	mov    0x14(%esp),%eax
  for (i = 0; i < old_bucket_cnt; i++) 
c002a758:	39 44 24 18          	cmp    %eax,0x18(%esp)
c002a75c:	74 16                	je     c002a774 <rehash+0x14f>
      old_bucket = &old_buckets[i];
c002a75e:	8b 44 24 14          	mov    0x14(%esp),%eax
c002a762:	89 c7                	mov    %eax,%edi
      for (elem = list_begin (old_bucket);
c002a764:	83 ec 0c             	sub    $0xc,%esp
c002a767:	50                   	push   %eax
c002a768:	e8 47 e9 ff ff       	call   c00290b4 <list_begin>
c002a76d:	89 c6                	mov    %eax,%esi
c002a76f:	83 c4 10             	add    $0x10,%esp
c002a772:	eb cb                	jmp    c002a73f <rehash+0x11a>
        }
    }

  free (old_buckets);
c002a774:	83 ec 0c             	sub    $0xc,%esp
c002a777:	ff 74 24 28          	pushl  0x28(%esp)
c002a77b:	e8 74 96 ff ff       	call   c0023df4 <free>
c002a780:	83 c4 10             	add    $0x10,%esp
}
c002a783:	83 c4 2c             	add    $0x2c,%esp
c002a786:	5b                   	pop    %ebx
c002a787:	5e                   	pop    %esi
c002a788:	5f                   	pop    %edi
c002a789:	5d                   	pop    %ebp
c002a78a:	c3                   	ret    

c002a78b <hash_clear>:
{
c002a78b:	55                   	push   %ebp
c002a78c:	57                   	push   %edi
c002a78d:	56                   	push   %esi
c002a78e:	53                   	push   %ebx
c002a78f:	83 ec 1c             	sub    $0x1c,%esp
c002a792:	e8 a4 31 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a797:	81 c3 35 ed 00 00    	add    $0xed35,%ebx
c002a79d:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a7a1:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  for (i = 0; i < h->bucket_cnt; i++) 
c002a7a5:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002a7a9:	74 59                	je     c002a804 <hash_clear+0x79>
c002a7ab:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002a7b2:	00 
c002a7b3:	eb 3f                	jmp    c002a7f4 <hash_clear+0x69>
            struct list_elem *list_elem = list_pop_front (bucket);
c002a7b5:	83 ec 0c             	sub    $0xc,%esp
c002a7b8:	56                   	push   %esi
c002a7b9:	e8 ba ef ff ff       	call   c0029778 <list_pop_front>
            destructor (hash_elem, h->aux);
c002a7be:	83 c4 08             	add    $0x8,%esp
c002a7c1:	ff 77 14             	pushl  0x14(%edi)
c002a7c4:	50                   	push   %eax
c002a7c5:	ff d5                	call   *%ebp
c002a7c7:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002a7ca:	83 ec 0c             	sub    $0xc,%esp
c002a7cd:	56                   	push   %esi
c002a7ce:	e8 2e ef ff ff       	call   c0029701 <list_empty>
c002a7d3:	83 c4 10             	add    $0x10,%esp
c002a7d6:	84 c0                	test   %al,%al
c002a7d8:	74 db                	je     c002a7b5 <hash_clear+0x2a>
      list_init (bucket); 
c002a7da:	83 ec 0c             	sub    $0xc,%esp
c002a7dd:	56                   	push   %esi
c002a7de:	e8 79 e8 ff ff       	call   c002905c <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c002a7e3:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
c002a7e8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a7ec:	83 c4 10             	add    $0x10,%esp
c002a7ef:	39 47 04             	cmp    %eax,0x4(%edi)
c002a7f2:	76 10                	jbe    c002a804 <hash_clear+0x79>
      struct list *bucket = &h->buckets[i];
c002a7f4:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002a7f8:	c1 e6 04             	shl    $0x4,%esi
c002a7fb:	03 77 08             	add    0x8(%edi),%esi
      if (destructor != NULL) 
c002a7fe:	85 ed                	test   %ebp,%ebp
c002a800:	75 c8                	jne    c002a7ca <hash_clear+0x3f>
c002a802:	eb d6                	jmp    c002a7da <hash_clear+0x4f>
  h->elem_cnt = 0;
c002a804:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
c002a80a:	83 c4 1c             	add    $0x1c,%esp
c002a80d:	5b                   	pop    %ebx
c002a80e:	5e                   	pop    %esi
c002a80f:	5f                   	pop    %edi
c002a810:	5d                   	pop    %ebp
c002a811:	c3                   	ret    

c002a812 <hash_init>:
{
c002a812:	56                   	push   %esi
c002a813:	53                   	push   %ebx
c002a814:	83 ec 10             	sub    $0x10,%esp
c002a817:	e8 1f 31 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a81c:	81 c3 b0 ec 00 00    	add    $0xecb0,%ebx
c002a822:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  h->elem_cnt = 0;
c002a826:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  h->bucket_cnt = 4;
c002a82c:	c7 46 04 04 00 00 00 	movl   $0x4,0x4(%esi)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002a833:	6a 40                	push   $0x40
c002a835:	e8 04 94 ff ff       	call   c0023c3e <malloc>
c002a83a:	89 c2                	mov    %eax,%edx
c002a83c:	89 46 08             	mov    %eax,0x8(%esi)
  h->hash = hash;
c002a83f:	8b 44 24 24          	mov    0x24(%esp),%eax
c002a843:	89 46 0c             	mov    %eax,0xc(%esi)
  h->less = less;
c002a846:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a84a:	89 46 10             	mov    %eax,0x10(%esi)
  h->aux = aux;
c002a84d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002a851:	89 46 14             	mov    %eax,0x14(%esi)
  if (h->buckets != NULL) 
c002a854:	83 c4 10             	add    $0x10,%esp
    return false;
c002a857:	b8 00 00 00 00       	mov    $0x0,%eax
  if (h->buckets != NULL) 
c002a85c:	85 d2                	test   %edx,%edx
c002a85e:	74 13                	je     c002a873 <hash_init+0x61>
      hash_clear (h, NULL);
c002a860:	83 ec 08             	sub    $0x8,%esp
c002a863:	6a 00                	push   $0x0
c002a865:	56                   	push   %esi
c002a866:	e8 20 ff ff ff       	call   c002a78b <hash_clear>
      return true;
c002a86b:	83 c4 10             	add    $0x10,%esp
c002a86e:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a873:	83 c4 04             	add    $0x4,%esp
c002a876:	5b                   	pop    %ebx
c002a877:	5e                   	pop    %esi
c002a878:	c3                   	ret    

c002a879 <hash_destroy>:
{
c002a879:	56                   	push   %esi
c002a87a:	53                   	push   %ebx
c002a87b:	83 ec 04             	sub    $0x4,%esp
c002a87e:	e8 b8 30 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a883:	81 c3 49 ec 00 00    	add    $0xec49,%ebx
c002a889:	8b 74 24 10          	mov    0x10(%esp),%esi
c002a88d:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002a891:	85 c0                	test   %eax,%eax
c002a893:	74 0d                	je     c002a8a2 <hash_destroy+0x29>
    hash_clear (h, destructor);
c002a895:	83 ec 08             	sub    $0x8,%esp
c002a898:	50                   	push   %eax
c002a899:	56                   	push   %esi
c002a89a:	e8 ec fe ff ff       	call   c002a78b <hash_clear>
c002a89f:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002a8a2:	83 ec 0c             	sub    $0xc,%esp
c002a8a5:	ff 76 08             	pushl  0x8(%esi)
c002a8a8:	e8 47 95 ff ff       	call   c0023df4 <free>
}
c002a8ad:	83 c4 14             	add    $0x14,%esp
c002a8b0:	5b                   	pop    %ebx
c002a8b1:	5e                   	pop    %esi
c002a8b2:	c3                   	ret    

c002a8b3 <hash_insert>:
{
c002a8b3:	55                   	push   %ebp
c002a8b4:	57                   	push   %edi
c002a8b5:	56                   	push   %esi
c002a8b6:	53                   	push   %ebx
c002a8b7:	83 ec 0c             	sub    $0xc,%esp
c002a8ba:	e8 7c 30 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a8bf:	81 c3 0d ec 00 00    	add    $0xec0d,%ebx
c002a8c5:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002a8c9:	8b 54 24 24          	mov    0x24(%esp),%edx
c002a8cd:	89 f0                	mov    %esi,%eax
c002a8cf:	e8 b4 fc ff ff       	call   c002a588 <find_bucket>
c002a8d4:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002a8d6:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002a8da:	89 c2                	mov    %eax,%edx
c002a8dc:	89 f0                	mov    %esi,%eax
c002a8de:	e8 c5 fc ff ff       	call   c002a5a8 <find_elem>
c002a8e3:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c002a8e5:	85 c0                	test   %eax,%eax
c002a8e7:	74 11                	je     c002a8fa <hash_insert+0x47>
  rehash (h);
c002a8e9:	89 f0                	mov    %esi,%eax
c002a8eb:	e8 35 fd ff ff       	call   c002a625 <rehash>
}
c002a8f0:	89 f8                	mov    %edi,%eax
c002a8f2:	83 c4 0c             	add    $0xc,%esp
c002a8f5:	5b                   	pop    %ebx
c002a8f6:	5e                   	pop    %esi
c002a8f7:	5f                   	pop    %edi
c002a8f8:	5d                   	pop    %ebp
c002a8f9:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002a8fa:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002a8fd:	83 ec 08             	sub    $0x8,%esp
c002a900:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a904:	55                   	push   %ebp
c002a905:	e8 1b ed ff ff       	call   c0029625 <list_push_front>
c002a90a:	83 c4 10             	add    $0x10,%esp
c002a90d:	eb da                	jmp    c002a8e9 <hash_insert+0x36>

c002a90f <hash_replace>:
{
c002a90f:	55                   	push   %ebp
c002a910:	57                   	push   %edi
c002a911:	56                   	push   %esi
c002a912:	53                   	push   %ebx
c002a913:	83 ec 0c             	sub    $0xc,%esp
c002a916:	e8 20 30 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a91b:	81 c3 b1 eb 00 00    	add    $0xebb1,%ebx
c002a921:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002a925:	8b 54 24 24          	mov    0x24(%esp),%edx
c002a929:	89 f0                	mov    %esi,%eax
c002a92b:	e8 58 fc ff ff       	call   c002a588 <find_bucket>
c002a930:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002a932:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002a936:	89 c2                	mov    %eax,%edx
c002a938:	89 f0                	mov    %esi,%eax
c002a93a:	e8 69 fc ff ff       	call   c002a5a8 <find_elem>
c002a93f:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c002a941:	85 c0                	test   %eax,%eax
c002a943:	74 0f                	je     c002a954 <hash_replace+0x45>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c002a945:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002a948:	83 ec 0c             	sub    $0xc,%esp
c002a94b:	50                   	push   %eax
c002a94c:	e8 0e ed ff ff       	call   c002965f <list_remove>
c002a951:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c002a954:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002a957:	83 ec 08             	sub    $0x8,%esp
c002a95a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a95e:	55                   	push   %ebp
c002a95f:	e8 c1 ec ff ff       	call   c0029625 <list_push_front>
  rehash (h);
c002a964:	89 f0                	mov    %esi,%eax
c002a966:	e8 ba fc ff ff       	call   c002a625 <rehash>
}
c002a96b:	89 f8                	mov    %edi,%eax
c002a96d:	83 c4 1c             	add    $0x1c,%esp
c002a970:	5b                   	pop    %ebx
c002a971:	5e                   	pop    %esi
c002a972:	5f                   	pop    %edi
c002a973:	5d                   	pop    %ebp
c002a974:	c3                   	ret    

c002a975 <hash_find>:
{
c002a975:	56                   	push   %esi
c002a976:	53                   	push   %ebx
c002a977:	83 ec 04             	sub    $0x4,%esp
c002a97a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002a97e:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem (h, find_bucket (h, e), e);
c002a982:	89 f2                	mov    %esi,%edx
c002a984:	89 d8                	mov    %ebx,%eax
c002a986:	e8 fd fb ff ff       	call   c002a588 <find_bucket>
c002a98b:	89 f1                	mov    %esi,%ecx
c002a98d:	89 c2                	mov    %eax,%edx
c002a98f:	89 d8                	mov    %ebx,%eax
c002a991:	e8 12 fc ff ff       	call   c002a5a8 <find_elem>
}
c002a996:	83 c4 04             	add    $0x4,%esp
c002a999:	5b                   	pop    %ebx
c002a99a:	5e                   	pop    %esi
c002a99b:	c3                   	ret    

c002a99c <hash_delete>:
{
c002a99c:	57                   	push   %edi
c002a99d:	56                   	push   %esi
c002a99e:	53                   	push   %ebx
c002a99f:	e8 97 2f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a9a4:	81 c3 28 eb 00 00    	add    $0xeb28,%ebx
c002a9aa:	8b 74 24 10          	mov    0x10(%esp),%esi
c002a9ae:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002a9b2:	89 fa                	mov    %edi,%edx
c002a9b4:	89 f0                	mov    %esi,%eax
c002a9b6:	e8 cd fb ff ff       	call   c002a588 <find_bucket>
c002a9bb:	89 f9                	mov    %edi,%ecx
c002a9bd:	89 c2                	mov    %eax,%edx
c002a9bf:	89 f0                	mov    %esi,%eax
c002a9c1:	e8 e2 fb ff ff       	call   c002a5a8 <find_elem>
c002a9c6:	89 c7                	mov    %eax,%edi
  if (found != NULL) 
c002a9c8:	85 c0                	test   %eax,%eax
c002a9ca:	74 16                	je     c002a9e2 <hash_delete+0x46>
  h->elem_cnt--;
c002a9cc:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002a9cf:	83 ec 0c             	sub    $0xc,%esp
c002a9d2:	50                   	push   %eax
c002a9d3:	e8 87 ec ff ff       	call   c002965f <list_remove>
      rehash (h); 
c002a9d8:	89 f0                	mov    %esi,%eax
c002a9da:	e8 46 fc ff ff       	call   c002a625 <rehash>
c002a9df:	83 c4 10             	add    $0x10,%esp
}
c002a9e2:	89 f8                	mov    %edi,%eax
c002a9e4:	5b                   	pop    %ebx
c002a9e5:	5e                   	pop    %esi
c002a9e6:	5f                   	pop    %edi
c002a9e7:	c3                   	ret    

c002a9e8 <hash_apply>:
{
c002a9e8:	55                   	push   %ebp
c002a9e9:	57                   	push   %edi
c002a9ea:	56                   	push   %esi
c002a9eb:	53                   	push   %ebx
c002a9ec:	83 ec 1c             	sub    $0x1c,%esp
c002a9ef:	e8 47 2f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002a9f4:	81 c3 d8 ea 00 00    	add    $0xead8,%ebx
c002a9fa:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c002a9fe:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002aa03:	74 16                	je     c002aa1b <hash_apply+0x33>
  for (i = 0; i < h->bucket_cnt; i++) 
c002aa05:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002aa0c:	00 
c002aa0d:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002aa11:	75 6e                	jne    c002aa81 <hash_apply+0x99>
}
c002aa13:	83 c4 1c             	add    $0x1c,%esp
c002aa16:	5b                   	pop    %ebx
c002aa17:	5e                   	pop    %esi
c002aa18:	5f                   	pop    %edi
c002aa19:	5d                   	pop    %ebp
c002aa1a:	c3                   	ret    
  ASSERT (action != NULL);
c002aa1b:	83 ec 0c             	sub    $0xc,%esp
c002aa1e:	8d 83 12 72 ff ff    	lea    -0x8dee(%ebx),%eax
c002aa24:	50                   	push   %eax
c002aa25:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002aa2b:	50                   	push   %eax
c002aa2c:	8d 83 68 53 ff ff    	lea    -0xac98(%ebx),%eax
c002aa32:	50                   	push   %eax
c002aa33:	68 a7 00 00 00       	push   $0xa7
c002aa38:	8d 83 fa 71 ff ff    	lea    -0x8e06(%ebx),%eax
c002aa3e:	50                   	push   %eax
c002aa3f:	e8 4b e5 ff ff       	call   c0028f8f <debug_panic>
          next = list_next (elem);
c002aa44:	83 ec 0c             	sub    $0xc,%esp
c002aa47:	56                   	push   %esi
c002aa48:	e8 ac e6 ff ff       	call   c00290f9 <list_next>
c002aa4d:	89 44 24 18          	mov    %eax,0x18(%esp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002aa51:	83 c4 08             	add    $0x8,%esp
c002aa54:	ff 75 14             	pushl  0x14(%ebp)
c002aa57:	56                   	push   %esi
c002aa58:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002aa5c:	83 c4 10             	add    $0x10,%esp
c002aa5f:	8b 74 24 08          	mov    0x8(%esp),%esi
c002aa63:	83 ec 0c             	sub    $0xc,%esp
c002aa66:	57                   	push   %edi
c002aa67:	e8 ea e6 ff ff       	call   c0029156 <list_end>
c002aa6c:	83 c4 10             	add    $0x10,%esp
c002aa6f:	39 f0                	cmp    %esi,%eax
c002aa71:	75 d1                	jne    c002aa44 <hash_apply+0x5c>
  for (i = 0; i < h->bucket_cnt; i++) 
c002aa73:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002aa78:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002aa7c:	39 45 04             	cmp    %eax,0x4(%ebp)
c002aa7f:	76 92                	jbe    c002aa13 <hash_apply+0x2b>
      struct list *bucket = &h->buckets[i];
c002aa81:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002aa85:	c1 e7 04             	shl    $0x4,%edi
c002aa88:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002aa8b:	83 ec 0c             	sub    $0xc,%esp
c002aa8e:	57                   	push   %edi
c002aa8f:	e8 20 e6 ff ff       	call   c00290b4 <list_begin>
c002aa94:	89 c6                	mov    %eax,%esi
c002aa96:	83 c4 10             	add    $0x10,%esp
c002aa99:	eb c8                	jmp    c002aa63 <hash_apply+0x7b>

c002aa9b <hash_first>:
{
c002aa9b:	56                   	push   %esi
c002aa9c:	53                   	push   %ebx
c002aa9d:	83 ec 04             	sub    $0x4,%esp
c002aaa0:	e8 96 2e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002aaa5:	81 c3 27 ea 00 00    	add    $0xea27,%ebx
c002aaab:	8b 74 24 10          	mov    0x10(%esp),%esi
c002aaaf:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c002aab3:	85 f6                	test   %esi,%esi
c002aab5:	74 1e                	je     c002aad5 <hash_first+0x3a>
  ASSERT (h != NULL);
c002aab7:	85 c0                	test   %eax,%eax
c002aab9:	74 43                	je     c002aafe <hash_first+0x63>
  i->hash = h;
c002aabb:	89 06                	mov    %eax,(%esi)
  i->bucket = i->hash->buckets;
c002aabd:	8b 40 08             	mov    0x8(%eax),%eax
c002aac0:	89 46 04             	mov    %eax,0x4(%esi)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002aac3:	83 ec 0c             	sub    $0xc,%esp
c002aac6:	50                   	push   %eax
c002aac7:	e8 2f e9 ff ff       	call   c00293fb <list_head>
c002aacc:	89 46 08             	mov    %eax,0x8(%esi)
}
c002aacf:	83 c4 14             	add    $0x14,%esp
c002aad2:	5b                   	pop    %ebx
c002aad3:	5e                   	pop    %esi
c002aad4:	c3                   	ret    
  ASSERT (i != NULL);
c002aad5:	83 ec 0c             	sub    $0xc,%esp
c002aad8:	8d 83 21 72 ff ff    	lea    -0x8ddf(%ebx),%eax
c002aade:	50                   	push   %eax
c002aadf:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002aae5:	50                   	push   %eax
c002aae6:	8d 83 5c 53 ff ff    	lea    -0xaca4(%ebx),%eax
c002aaec:	50                   	push   %eax
c002aaed:	68 ca 00 00 00       	push   $0xca
c002aaf2:	8d 83 fa 71 ff ff    	lea    -0x8e06(%ebx),%eax
c002aaf8:	50                   	push   %eax
c002aaf9:	e8 91 e4 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (h != NULL);
c002aafe:	83 ec 0c             	sub    $0xc,%esp
c002ab01:	8d 83 f0 71 ff ff    	lea    -0x8e10(%ebx),%eax
c002ab07:	50                   	push   %eax
c002ab08:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002ab0e:	50                   	push   %eax
c002ab0f:	8d 83 5c 53 ff ff    	lea    -0xaca4(%ebx),%eax
c002ab15:	50                   	push   %eax
c002ab16:	68 cb 00 00 00       	push   $0xcb
c002ab1b:	8d 83 fa 71 ff ff    	lea    -0x8e06(%ebx),%eax
c002ab21:	50                   	push   %eax
c002ab22:	e8 68 e4 ff ff       	call   c0028f8f <debug_panic>

c002ab27 <hash_next>:
{
c002ab27:	57                   	push   %edi
c002ab28:	56                   	push   %esi
c002ab29:	53                   	push   %ebx
c002ab2a:	e8 0c 2e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ab2f:	81 c3 9d e9 00 00    	add    $0xe99d,%ebx
c002ab35:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (i != NULL);
c002ab39:	85 f6                	test   %esi,%esi
c002ab3b:	74 4f                	je     c002ab8c <hash_next+0x65>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002ab3d:	83 ec 0c             	sub    $0xc,%esp
c002ab40:	ff 76 08             	pushl  0x8(%esi)
c002ab43:	e8 b1 e5 ff ff       	call   c00290f9 <list_next>
c002ab48:	89 46 08             	mov    %eax,0x8(%esi)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002ab4b:	83 c4 10             	add    $0x10,%esp
c002ab4e:	8b 7e 08             	mov    0x8(%esi),%edi
c002ab51:	83 ec 0c             	sub    $0xc,%esp
c002ab54:	ff 76 04             	pushl  0x4(%esi)
c002ab57:	e8 fa e5 ff ff       	call   c0029156 <list_end>
c002ab5c:	83 c4 10             	add    $0x10,%esp
c002ab5f:	39 c7                	cmp    %eax,%edi
c002ab61:	75 59                	jne    c002abbc <hash_next+0x95>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002ab63:	8b 46 04             	mov    0x4(%esi),%eax
c002ab66:	8d 50 10             	lea    0x10(%eax),%edx
c002ab69:	89 56 04             	mov    %edx,0x4(%esi)
c002ab6c:	8b 0e                	mov    (%esi),%ecx
c002ab6e:	8b 41 04             	mov    0x4(%ecx),%eax
c002ab71:	c1 e0 04             	shl    $0x4,%eax
c002ab74:	03 41 08             	add    0x8(%ecx),%eax
c002ab77:	39 c2                	cmp    %eax,%edx
c002ab79:	73 3a                	jae    c002abb5 <hash_next+0x8e>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002ab7b:	83 ec 0c             	sub    $0xc,%esp
c002ab7e:	52                   	push   %edx
c002ab7f:	e8 30 e5 ff ff       	call   c00290b4 <list_begin>
c002ab84:	89 46 08             	mov    %eax,0x8(%esi)
c002ab87:	83 c4 10             	add    $0x10,%esp
c002ab8a:	eb c2                	jmp    c002ab4e <hash_next+0x27>
  ASSERT (i != NULL);
c002ab8c:	83 ec 0c             	sub    $0xc,%esp
c002ab8f:	8d 83 21 72 ff ff    	lea    -0x8ddf(%ebx),%eax
c002ab95:	50                   	push   %eax
c002ab96:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002ab9c:	50                   	push   %eax
c002ab9d:	8d 83 50 53 ff ff    	lea    -0xacb0(%ebx),%eax
c002aba3:	50                   	push   %eax
c002aba4:	68 dd 00 00 00       	push   $0xdd
c002aba9:	8d 83 fa 71 ff ff    	lea    -0x8e06(%ebx),%eax
c002abaf:	50                   	push   %eax
c002abb0:	e8 da e3 ff ff       	call   c0028f8f <debug_panic>
          i->elem = NULL;
c002abb5:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  return i->elem;
c002abbc:	8b 46 08             	mov    0x8(%esi),%eax
}
c002abbf:	5b                   	pop    %ebx
c002abc0:	5e                   	pop    %esi
c002abc1:	5f                   	pop    %edi
c002abc2:	c3                   	ret    

c002abc3 <hash_cur>:
  return i->elem;
c002abc3:	8b 44 24 04          	mov    0x4(%esp),%eax
c002abc7:	8b 40 08             	mov    0x8(%eax),%eax
}
c002abca:	c3                   	ret    

c002abcb <hash_size>:
  return h->elem_cnt;
c002abcb:	8b 44 24 04          	mov    0x4(%esp),%eax
c002abcf:	8b 00                	mov    (%eax),%eax
}
c002abd1:	c3                   	ret    

c002abd2 <hash_empty>:
  return h->elem_cnt == 0;
c002abd2:	8b 44 24 04          	mov    0x4(%esp),%eax
c002abd6:	83 38 00             	cmpl   $0x0,(%eax)
c002abd9:	0f 94 c0             	sete   %al
}
c002abdc:	c3                   	ret    

c002abdd <hash_bytes>:
{
c002abdd:	53                   	push   %ebx
c002abde:	83 ec 08             	sub    $0x8,%esp
c002abe1:	e8 55 2d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002abe6:	81 c3 e6 e8 00 00    	add    $0xe8e6,%ebx
c002abec:	8b 54 24 10          	mov    0x10(%esp),%edx
c002abf0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (buf != NULL);
c002abf4:	85 d2                	test   %edx,%edx
c002abf6:	74 24                	je     c002ac1c <hash_bytes+0x3f>
c002abf8:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx
  hash = FNV_32_BASIS;
c002abfb:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (size-- > 0)
c002ac00:	85 c9                	test   %ecx,%ecx
c002ac02:	74 13                	je     c002ac17 <hash_bytes+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002ac04:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002ac0a:	83 c2 01             	add    $0x1,%edx
c002ac0d:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c002ac11:	31 c8                	xor    %ecx,%eax
  while (size-- > 0)
c002ac13:	39 da                	cmp    %ebx,%edx
c002ac15:	75 ed                	jne    c002ac04 <hash_bytes+0x27>
} 
c002ac17:	83 c4 08             	add    $0x8,%esp
c002ac1a:	5b                   	pop    %ebx
c002ac1b:	c3                   	ret    
  ASSERT (buf != NULL);
c002ac1c:	83 ec 0c             	sub    $0xc,%esp
c002ac1f:	8d 83 2b 72 ff ff    	lea    -0x8dd5(%ebx),%eax
c002ac25:	50                   	push   %eax
c002ac26:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002ac2c:	50                   	push   %eax
c002ac2d:	8d 83 44 53 ff ff    	lea    -0xacbc(%ebx),%eax
c002ac33:	50                   	push   %eax
c002ac34:	68 10 01 00 00       	push   $0x110
c002ac39:	8d 83 fa 71 ff ff    	lea    -0x8e06(%ebx),%eax
c002ac3f:	50                   	push   %eax
c002ac40:	e8 4a e3 ff ff       	call   c0028f8f <debug_panic>

c002ac45 <hash_string>:
{
c002ac45:	56                   	push   %esi
c002ac46:	53                   	push   %ebx
c002ac47:	83 ec 04             	sub    $0x4,%esp
c002ac4a:	e8 ec 2c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ac4f:	81 c3 7d e8 00 00    	add    $0xe87d,%ebx
c002ac55:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (s != NULL);
c002ac59:	85 f6                	test   %esi,%esi
c002ac5b:	74 27                	je     c002ac84 <hash_string+0x3f>
  while (*s != '\0')
c002ac5d:	0f b6 16             	movzbl (%esi),%edx
  hash = FNV_32_BASIS;
c002ac60:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (*s != '\0')
c002ac65:	84 d2                	test   %dl,%dl
c002ac67:	74 15                	je     c002ac7e <hash_string+0x39>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002ac69:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002ac6f:	83 c6 01             	add    $0x1,%esi
c002ac72:	0f b6 c2             	movzbl %dl,%eax
c002ac75:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c002ac77:	0f b6 16             	movzbl (%esi),%edx
c002ac7a:	84 d2                	test   %dl,%dl
c002ac7c:	75 eb                	jne    c002ac69 <hash_string+0x24>
}
c002ac7e:	83 c4 04             	add    $0x4,%esp
c002ac81:	5b                   	pop    %ebx
c002ac82:	5e                   	pop    %esi
c002ac83:	c3                   	ret    
  ASSERT (s != NULL);
c002ac84:	83 ec 0c             	sub    $0xc,%esp
c002ac87:	8d 93 b7 6d ff ff    	lea    -0x9249(%ebx),%edx
c002ac8d:	52                   	push   %edx
c002ac8e:	8d 93 eb 55 ff ff    	lea    -0xaa15(%ebx),%edx
c002ac94:	52                   	push   %edx
c002ac95:	8d 93 38 53 ff ff    	lea    -0xacc8(%ebx),%edx
c002ac9b:	52                   	push   %edx
c002ac9c:	68 20 01 00 00       	push   $0x120
c002aca1:	8d 93 fa 71 ff ff    	lea    -0x8e06(%ebx),%edx
c002aca7:	52                   	push   %edx
c002aca8:	e8 e2 e2 ff ff       	call   c0028f8f <debug_panic>

c002acad <hash_int>:
{
c002acad:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c002acb0:	6a 04                	push   $0x4
c002acb2:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002acb6:	50                   	push   %eax
c002acb7:	e8 21 ff ff ff       	call   c002abdd <hash_bytes>
}
c002acbc:	83 c4 1c             	add    $0x1c,%esp
c002acbf:	c3                   	ret    

c002acc0 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002acc0:	56                   	push   %esi
c002acc1:	53                   	push   %ebx
c002acc2:	83 ec 04             	sub    $0x4,%esp
c002acc5:	e8 71 2c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002acca:	81 c3 02 e8 00 00    	add    $0xe802,%ebx
c002acd0:	89 c6                	mov    %eax,%esi
  return (intr_context ()
c002acd2:	e8 13 71 ff ff       	call   c0021dea <intr_context>
          || lock_held_by_current_thread (&console_lock));
c002acd7:	84 c0                	test   %al,%al
c002acd9:	75 09                	jne    c002ace4 <putchar_have_lock+0x24>
          || !use_console_lock
c002acdb:	80 bb 40 23 00 00 00 	cmpb   $0x0,0x2340(%ebx)
c002ace2:	75 2a                	jne    c002ad0e <putchar_have_lock+0x4e>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c002ace4:	83 83 34 23 00 00 01 	addl   $0x1,0x2334(%ebx)
c002aceb:	83 93 38 23 00 00 00 	adcl   $0x0,0x2338(%ebx)
  serial_putc (c);
c002acf2:	89 f0                	mov    %esi,%eax
c002acf4:	0f b6 f0             	movzbl %al,%esi
c002acf7:	83 ec 0c             	sub    $0xc,%esp
c002acfa:	56                   	push   %esi
c002acfb:	e8 ee 9f ff ff       	call   c0024cee <serial_putc>
  vga_putc (c);
c002ad00:	89 34 24             	mov    %esi,(%esp)
c002ad03:	e8 b4 9b ff ff       	call   c00248bc <vga_putc>
}
c002ad08:	83 c4 14             	add    $0x14,%esp
c002ad0b:	5b                   	pop    %ebx
c002ad0c:	5e                   	pop    %esi
c002ad0d:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c002ad0e:	83 ec 0c             	sub    $0xc,%esp
c002ad11:	8d 83 54 23 00 00    	lea    0x2354(%ebx),%eax
c002ad17:	50                   	push   %eax
c002ad18:	e8 cd 82 ff ff       	call   c0022fea <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c002ad1d:	83 c4 10             	add    $0x10,%esp
c002ad20:	84 c0                	test   %al,%al
c002ad22:	75 c0                	jne    c002ace4 <putchar_have_lock+0x24>
c002ad24:	83 ec 0c             	sub    $0xc,%esp
c002ad27:	8d 83 38 72 ff ff    	lea    -0x8dc8(%ebx),%eax
c002ad2d:	50                   	push   %eax
c002ad2e:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002ad34:	50                   	push   %eax
c002ad35:	8d 83 7c 53 ff ff    	lea    -0xac84(%ebx),%eax
c002ad3b:	50                   	push   %eax
c002ad3c:	68 bb 00 00 00       	push   $0xbb
c002ad41:	8d 83 7d 72 ff ff    	lea    -0x8d83(%ebx),%eax
c002ad47:	50                   	push   %eax
c002ad48:	e8 42 e2 ff ff       	call   c0028f8f <debug_panic>

c002ad4d <vprintf_helper>:
{
c002ad4d:	83 ec 0c             	sub    $0xc,%esp
c002ad50:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002ad54:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock (c);
c002ad57:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002ad5c:	e8 5f ff ff ff       	call   c002acc0 <putchar_have_lock>
}
c002ad61:	83 c4 0c             	add    $0xc,%esp
c002ad64:	c3                   	ret    

c002ad65 <acquire_console>:
{
c002ad65:	53                   	push   %ebx
c002ad66:	83 ec 08             	sub    $0x8,%esp
c002ad69:	e8 cd 2b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ad6e:	81 c3 5e e7 00 00    	add    $0xe75e,%ebx
  if (!intr_context () && use_console_lock) 
c002ad74:	e8 71 70 ff ff       	call   c0021dea <intr_context>
c002ad79:	84 c0                	test   %al,%al
c002ad7b:	75 09                	jne    c002ad86 <acquire_console+0x21>
c002ad7d:	80 bb 40 23 00 00 00 	cmpb   $0x0,0x2340(%ebx)
c002ad84:	75 05                	jne    c002ad8b <acquire_console+0x26>
}
c002ad86:	83 c4 08             	add    $0x8,%esp
c002ad89:	5b                   	pop    %ebx
c002ad8a:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002ad8b:	83 ec 0c             	sub    $0xc,%esp
c002ad8e:	8d 83 54 23 00 00    	lea    0x2354(%ebx),%eax
c002ad94:	50                   	push   %eax
c002ad95:	e8 50 82 ff ff       	call   c0022fea <lock_held_by_current_thread>
c002ad9a:	83 c4 10             	add    $0x10,%esp
c002ad9d:	84 c0                	test   %al,%al
c002ad9f:	74 09                	je     c002adaa <acquire_console+0x45>
        console_lock_depth++; 
c002ada1:	83 83 3c 23 00 00 01 	addl   $0x1,0x233c(%ebx)
c002ada8:	eb dc                	jmp    c002ad86 <acquire_console+0x21>
        lock_acquire (&console_lock); 
c002adaa:	83 ec 0c             	sub    $0xc,%esp
c002adad:	8d 83 54 23 00 00    	lea    0x2354(%ebx),%eax
c002adb3:	50                   	push   %eax
c002adb4:	e8 84 82 ff ff       	call   c002303d <lock_acquire>
c002adb9:	83 c4 10             	add    $0x10,%esp
}
c002adbc:	eb c8                	jmp    c002ad86 <acquire_console+0x21>

c002adbe <release_console>:
{
c002adbe:	53                   	push   %ebx
c002adbf:	83 ec 08             	sub    $0x8,%esp
c002adc2:	e8 74 2b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002adc7:	81 c3 05 e7 00 00    	add    $0xe705,%ebx
  if (!intr_context () && use_console_lock) 
c002adcd:	e8 18 70 ff ff       	call   c0021dea <intr_context>
c002add2:	84 c0                	test   %al,%al
c002add4:	75 1c                	jne    c002adf2 <release_console+0x34>
c002add6:	80 bb 40 23 00 00 00 	cmpb   $0x0,0x2340(%ebx)
c002addd:	74 13                	je     c002adf2 <release_console+0x34>
      if (console_lock_depth > 0)
c002addf:	8b 83 3c 23 00 00    	mov    0x233c(%ebx),%eax
c002ade5:	85 c0                	test   %eax,%eax
c002ade7:	7e 0e                	jle    c002adf7 <release_console+0x39>
        console_lock_depth--;
c002ade9:	83 e8 01             	sub    $0x1,%eax
c002adec:	89 83 3c 23 00 00    	mov    %eax,0x233c(%ebx)
}
c002adf2:	83 c4 08             	add    $0x8,%esp
c002adf5:	5b                   	pop    %ebx
c002adf6:	c3                   	ret    
        lock_release (&console_lock); 
c002adf7:	83 ec 0c             	sub    $0xc,%esp
c002adfa:	8d 83 54 23 00 00    	lea    0x2354(%ebx),%eax
c002ae00:	50                   	push   %eax
c002ae01:	e8 2f 84 ff ff       	call   c0023235 <lock_release>
c002ae06:	83 c4 10             	add    $0x10,%esp
}
c002ae09:	eb e7                	jmp    c002adf2 <release_console+0x34>

c002ae0b <console_init>:
{
c002ae0b:	53                   	push   %ebx
c002ae0c:	83 ec 14             	sub    $0x14,%esp
c002ae0f:	e8 27 2b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ae14:	81 c3 b8 e6 00 00    	add    $0xe6b8,%ebx
  lock_init (&console_lock);
c002ae1a:	8d 83 54 23 00 00    	lea    0x2354(%ebx),%eax
c002ae20:	50                   	push   %eax
c002ae21:	e8 6b 81 ff ff       	call   c0022f91 <lock_init>
  use_console_lock = true;
c002ae26:	c6 83 40 23 00 00 01 	movb   $0x1,0x2340(%ebx)
}
c002ae2d:	83 c4 18             	add    $0x18,%esp
c002ae30:	5b                   	pop    %ebx
c002ae31:	c3                   	ret    

c002ae32 <console_panic>:
{
c002ae32:	e8 08 2b 00 00       	call   c002d93f <__x86.get_pc_thunk.ax>
c002ae37:	05 95 e6 00 00       	add    $0xe695,%eax
  use_console_lock = false;
c002ae3c:	c6 80 40 23 00 00 00 	movb   $0x0,0x2340(%eax)
}
c002ae43:	c3                   	ret    

c002ae44 <console_print_stats>:
{
c002ae44:	53                   	push   %ebx
c002ae45:	83 ec 0c             	sub    $0xc,%esp
c002ae48:	e8 ee 2a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ae4d:	81 c3 7f e6 00 00    	add    $0xe67f,%ebx
  printf ("Console: %lld characters output\n", write_cnt);
c002ae53:	ff b3 38 23 00 00    	pushl  0x2338(%ebx)
c002ae59:	ff b3 34 23 00 00    	pushl  0x2334(%ebx)
c002ae5f:	8d 83 5c 72 ff ff    	lea    -0x8da4(%ebx),%eax
c002ae65:	50                   	push   %eax
c002ae66:	e8 8d c3 ff ff       	call   c00271f8 <printf>
}
c002ae6b:	83 c4 18             	add    $0x18,%esp
c002ae6e:	5b                   	pop    %ebx
c002ae6f:	c3                   	ret    

c002ae70 <vprintf>:
{
c002ae70:	53                   	push   %ebx
c002ae71:	83 ec 18             	sub    $0x18,%esp
c002ae74:	e8 c2 2a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ae79:	81 c3 53 e6 00 00    	add    $0xe653,%ebx
  int char_cnt = 0;
c002ae7f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002ae86:	00 
  acquire_console ();
c002ae87:	e8 d9 fe ff ff       	call   c002ad65 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002ae8c:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002ae90:	50                   	push   %eax
c002ae91:	8d 83 81 18 ff ff    	lea    -0xe77f(%ebx),%eax
c002ae97:	50                   	push   %eax
c002ae98:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ae9c:	ff 74 24 2c          	pushl  0x2c(%esp)
c002aea0:	e8 95 c3 ff ff       	call   c002723a <__vprintf>
  release_console ();
c002aea5:	e8 14 ff ff ff       	call   c002adbe <release_console>
}
c002aeaa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002aeae:	83 c4 28             	add    $0x28,%esp
c002aeb1:	5b                   	pop    %ebx
c002aeb2:	c3                   	ret    

c002aeb3 <puts>:
{
c002aeb3:	53                   	push   %ebx
c002aeb4:	83 ec 08             	sub    $0x8,%esp
c002aeb7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002aebb:	e8 a5 fe ff ff       	call   c002ad65 <acquire_console>
  while (*s != '\0')
c002aec0:	0f b6 03             	movzbl (%ebx),%eax
c002aec3:	84 c0                	test   %al,%al
c002aec5:	74 12                	je     c002aed9 <puts+0x26>
    putchar_have_lock (*s++);
c002aec7:	83 c3 01             	add    $0x1,%ebx
c002aeca:	0f b6 c0             	movzbl %al,%eax
c002aecd:	e8 ee fd ff ff       	call   c002acc0 <putchar_have_lock>
  while (*s != '\0')
c002aed2:	0f b6 03             	movzbl (%ebx),%eax
c002aed5:	84 c0                	test   %al,%al
c002aed7:	75 ee                	jne    c002aec7 <puts+0x14>
  putchar_have_lock ('\n');
c002aed9:	b8 0a 00 00 00       	mov    $0xa,%eax
c002aede:	e8 dd fd ff ff       	call   c002acc0 <putchar_have_lock>
  release_console ();
c002aee3:	e8 d6 fe ff ff       	call   c002adbe <release_console>
}
c002aee8:	b8 00 00 00 00       	mov    $0x0,%eax
c002aeed:	83 c4 08             	add    $0x8,%esp
c002aef0:	5b                   	pop    %ebx
c002aef1:	c3                   	ret    

c002aef2 <putbuf>:
{
c002aef2:	56                   	push   %esi
c002aef3:	53                   	push   %ebx
c002aef4:	83 ec 04             	sub    $0x4,%esp
c002aef7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002aefb:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002aeff:	e8 61 fe ff ff       	call   c002ad65 <acquire_console>
  while (n-- > 0)
c002af04:	85 f6                	test   %esi,%esi
c002af06:	74 12                	je     c002af1a <putbuf+0x28>
c002af08:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002af0a:	83 c3 01             	add    $0x1,%ebx
c002af0d:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002af11:	e8 aa fd ff ff       	call   c002acc0 <putchar_have_lock>
  while (n-- > 0)
c002af16:	39 de                	cmp    %ebx,%esi
c002af18:	75 f0                	jne    c002af0a <putbuf+0x18>
  release_console ();
c002af1a:	e8 9f fe ff ff       	call   c002adbe <release_console>
}
c002af1f:	83 c4 04             	add    $0x4,%esp
c002af22:	5b                   	pop    %ebx
c002af23:	5e                   	pop    %esi
c002af24:	c3                   	ret    

c002af25 <putchar>:
{
c002af25:	53                   	push   %ebx
c002af26:	83 ec 08             	sub    $0x8,%esp
c002af29:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002af2d:	e8 33 fe ff ff       	call   c002ad65 <acquire_console>
  putchar_have_lock (c);
c002af32:	0f b6 c3             	movzbl %bl,%eax
c002af35:	e8 86 fd ff ff       	call   c002acc0 <putchar_have_lock>
  release_console ();
c002af3a:	e8 7f fe ff ff       	call   c002adbe <release_console>
}
c002af3f:	89 d8                	mov    %ebx,%eax
c002af41:	83 c4 08             	add    $0x8,%esp
c002af44:	5b                   	pop    %ebx
c002af45:	c3                   	ret    

c002af46 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002af46:	53                   	push   %ebx
c002af47:	83 ec 10             	sub    $0x10,%esp
c002af4a:	e8 ec 29 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002af4f:	81 c3 7d e5 00 00    	add    $0xe57d,%ebx
  va_list args;
  
  printf ("(%s) ", test_name);
c002af55:	ff b3 78 23 00 00    	pushl  0x2378(%ebx)
c002af5b:	8d 83 98 72 ff ff    	lea    -0x8d68(%ebx),%eax
c002af61:	50                   	push   %eax
c002af62:	e8 91 c2 ff ff       	call   c00271f8 <printf>
  va_start (args, format);
c002af67:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c002af6b:	83 c4 08             	add    $0x8,%esp
c002af6e:	50                   	push   %eax
c002af6f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002af73:	e8 f8 fe ff ff       	call   c002ae70 <vprintf>
  va_end (args);
  putchar ('\n');
c002af78:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c002af7f:	e8 a1 ff ff ff       	call   c002af25 <putchar>
}
c002af84:	83 c4 18             	add    $0x18,%esp
c002af87:	5b                   	pop    %ebx
c002af88:	c3                   	ret    

c002af89 <run_test>:
{
c002af89:	55                   	push   %ebp
c002af8a:	57                   	push   %edi
c002af8b:	56                   	push   %esi
c002af8c:	53                   	push   %ebx
c002af8d:	83 ec 0c             	sub    $0xc,%esp
c002af90:	e8 a6 29 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002af95:	81 c3 37 e5 00 00    	add    $0xe537,%ebx
c002af9b:	8b 7c 24 20          	mov    0x20(%esp),%edi
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002af9f:	8d b3 f4 05 00 00    	lea    0x5f4(%ebx),%esi
c002afa5:	8d ab cc 06 00 00    	lea    0x6cc(%ebx),%ebp
    if (!strcmp (name, t->name))
c002afab:	83 ec 08             	sub    $0x8,%esp
c002afae:	ff 36                	pushl  (%esi)
c002afb0:	57                   	push   %edi
c002afb1:	e8 9e d2 ff ff       	call   c0028254 <strcmp>
c002afb6:	83 c4 10             	add    $0x10,%esp
c002afb9:	85 c0                	test   %eax,%eax
c002afbb:	74 27                	je     c002afe4 <run_test+0x5b>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002afbd:	83 c6 08             	add    $0x8,%esi
c002afc0:	39 ee                	cmp    %ebp,%esi
c002afc2:	75 e7                	jne    c002afab <run_test+0x22>
  PANIC ("no test named \"%s\"", name);
c002afc4:	83 ec 0c             	sub    $0xc,%esp
c002afc7:	57                   	push   %edi
c002afc8:	8d 83 a8 72 ff ff    	lea    -0x8d58(%ebx),%eax
c002afce:	50                   	push   %eax
c002afcf:	8d 83 98 53 ff ff    	lea    -0xac68(%ebx),%eax
c002afd5:	50                   	push   %eax
c002afd6:	6a 3c                	push   $0x3c
c002afd8:	8d 83 bb 72 ff ff    	lea    -0x8d45(%ebx),%eax
c002afde:	50                   	push   %eax
c002afdf:	e8 ab df ff ff       	call   c0028f8f <debug_panic>
        test_name = name;
c002afe4:	89 bb 78 23 00 00    	mov    %edi,0x2378(%ebx)
        msg ("begin");
c002afea:	83 ec 0c             	sub    $0xc,%esp
c002afed:	8d 83 9e 72 ff ff    	lea    -0x8d62(%ebx),%eax
c002aff3:	50                   	push   %eax
c002aff4:	e8 4d ff ff ff       	call   c002af46 <msg>
        t->function ();
c002aff9:	ff 56 04             	call   *0x4(%esi)
        msg ("end");
c002affc:	8d 83 a4 72 ff ff    	lea    -0x8d5c(%ebx),%eax
c002b002:	89 04 24             	mov    %eax,(%esp)
c002b005:	e8 3c ff ff ff       	call   c002af46 <msg>
}
c002b00a:	83 c4 1c             	add    $0x1c,%esp
c002b00d:	5b                   	pop    %ebx
c002b00e:	5e                   	pop    %esi
c002b00f:	5f                   	pop    %edi
c002b010:	5d                   	pop    %ebp
c002b011:	c3                   	ret    

c002b012 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002b012:	53                   	push   %ebx
c002b013:	83 ec 10             	sub    $0x10,%esp
c002b016:	e8 20 29 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b01b:	81 c3 b1 e4 00 00    	add    $0xe4b1,%ebx
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002b021:	ff b3 78 23 00 00    	pushl  0x2378(%ebx)
c002b027:	8d 83 d7 72 ff ff    	lea    -0x8d29(%ebx),%eax
c002b02d:	50                   	push   %eax
c002b02e:	e8 c5 c1 ff ff       	call   c00271f8 <printf>
  va_start (args, format);
c002b033:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c002b037:	83 c4 08             	add    $0x8,%esp
c002b03a:	50                   	push   %eax
c002b03b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002b03f:	e8 2c fe ff ff       	call   c002ae70 <vprintf>
  va_end (args);
  putchar ('\n');
c002b044:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c002b04b:	e8 d5 fe ff ff       	call   c002af25 <putchar>

  PANIC ("test failed");
c002b050:	8d 83 e3 72 ff ff    	lea    -0x8d1d(%ebx),%eax
c002b056:	50                   	push   %eax
c002b057:	8d 83 90 53 ff ff    	lea    -0xac70(%ebx),%eax
c002b05d:	50                   	push   %eax
c002b05e:	6a 5d                	push   $0x5d
c002b060:	8d 83 bb 72 ff ff    	lea    -0x8d45(%ebx),%eax
c002b066:	50                   	push   %eax
c002b067:	e8 23 df ff ff       	call   c0028f8f <debug_panic>

c002b06c <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002b06c:	53                   	push   %ebx
c002b06d:	83 ec 10             	sub    $0x10,%esp
c002b070:	e8 c6 28 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b075:	81 c3 57 e4 00 00    	add    $0xe457,%ebx
  printf ("(%s) PASS\n", test_name);
c002b07b:	ff b3 78 23 00 00    	pushl  0x2378(%ebx)
c002b081:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002b087:	50                   	push   %eax
c002b088:	e8 6b c1 ff ff       	call   c00271f8 <printf>
}
c002b08d:	83 c4 18             	add    $0x18,%esp
c002b090:	5b                   	pop    %ebx
c002b091:	c3                   	ret    

c002b092 <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002b092:	55                   	push   %ebp
c002b093:	57                   	push   %edi
c002b094:	56                   	push   %esi
c002b095:	53                   	push   %ebx
c002b096:	83 ec 1c             	sub    $0x1c,%esp
c002b099:	e8 9d 28 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b09e:	81 c3 2e e4 00 00    	add    $0xe42e,%ebx
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
c002b0a4:	8b 44 24 30          	mov    0x30(%esp),%eax
c002b0a8:	8b 28                	mov    (%eax),%ebp
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002b0aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b0ae:	7e 71                	jle    c002b121 <sleeper+0x8f>
c002b0b0:	be 01 00 00 00       	mov    $0x1,%esi
    {
      int64_t sleep_until = test->start + i * t->duration;
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
c002b0b5:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b0b8:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002b0bc:	89 74 24 08          	mov    %esi,0x8(%esp)
      int64_t sleep_until = test->start + i * t->duration;
c002b0c0:	8b 44 24 08          	mov    0x8(%esp),%eax
c002b0c4:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002b0c8:	0f af 47 08          	imul   0x8(%edi),%eax
c002b0cc:	99                   	cltd   
c002b0cd:	03 45 00             	add    0x0(%ebp),%eax
c002b0d0:	13 55 04             	adc    0x4(%ebp),%edx
c002b0d3:	89 c6                	mov    %eax,%esi
c002b0d5:	89 d7                	mov    %edx,%edi
      timer_sleep (sleep_until - timer_ticks ());
c002b0d7:	e8 85 92 ff ff       	call   c0024361 <timer_ticks>
c002b0dc:	83 ec 08             	sub    $0x8,%esp
c002b0df:	29 c6                	sub    %eax,%esi
c002b0e1:	19 d7                	sbb    %edx,%edi
c002b0e3:	57                   	push   %edi
c002b0e4:	56                   	push   %esi
c002b0e5:	e8 c6 92 ff ff       	call   c00243b0 <timer_sleep>
      lock_acquire (&test->output_lock);
c002b0ea:	8b 74 24 1c          	mov    0x1c(%esp),%esi
c002b0ee:	89 34 24             	mov    %esi,(%esp)
c002b0f1:	e8 47 7f ff ff       	call   c002303d <lock_acquire>
      *test->output_pos++ = t->id;
c002b0f6:	8b 45 30             	mov    0x30(%ebp),%eax
c002b0f9:	8d 50 04             	lea    0x4(%eax),%edx
c002b0fc:	89 55 30             	mov    %edx,0x30(%ebp)
c002b0ff:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c002b103:	8b 51 04             	mov    0x4(%ecx),%edx
c002b106:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002b108:	89 34 24             	mov    %esi,(%esp)
c002b10b:	e8 25 81 ff ff       	call   c0023235 <lock_release>
  for (i = 1; i <= test->iterations; i++) 
c002b110:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
c002b115:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b119:	83 c4 10             	add    $0x10,%esp
c002b11c:	39 45 08             	cmp    %eax,0x8(%ebp)
c002b11f:	7d 9f                	jge    c002b0c0 <sleeper+0x2e>
    }
}
c002b121:	83 c4 1c             	add    $0x1c,%esp
c002b124:	5b                   	pop    %ebx
c002b125:	5e                   	pop    %esi
c002b126:	5f                   	pop    %edi
c002b127:	5d                   	pop    %ebp
c002b128:	c3                   	ret    

c002b129 <test_sleep>:
{
c002b129:	55                   	push   %ebp
c002b12a:	57                   	push   %edi
c002b12b:	56                   	push   %esi
c002b12c:	53                   	push   %ebx
c002b12d:	83 ec 7c             	sub    $0x7c,%esp
c002b130:	e8 06 28 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b135:	81 c3 97 e3 00 00    	add    $0xe397,%ebx
c002b13b:	89 44 24 08          	mov    %eax,0x8(%esp)
c002b13f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  ASSERT (!thread_mlfqs);
c002b143:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002b149:	80 38 00             	cmpb   $0x0,(%eax)
c002b14c:	0f 85 b9 01 00 00    	jne    c002b30b <test_sleep+0x1e2>
  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002b152:	83 ec 04             	sub    $0x4,%esp
c002b155:	8b 74 24 20          	mov    0x20(%esp),%esi
c002b159:	56                   	push   %esi
c002b15a:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002b15e:	57                   	push   %edi
c002b15f:	8d 83 20 75 ff ff    	lea    -0x8ae0(%ebx),%eax
c002b165:	50                   	push   %eax
c002b166:	e8 db fd ff ff       	call   c002af46 <msg>
  msg ("Thread 0 sleeps 10 ticks each time,");
c002b16b:	8d 83 4c 75 ff ff    	lea    -0x8ab4(%ebx),%eax
c002b171:	89 04 24             	mov    %eax,(%esp)
c002b174:	e8 cd fd ff ff       	call   c002af46 <msg>
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002b179:	8d 83 70 75 ff ff    	lea    -0x8a90(%ebx),%eax
c002b17f:	89 04 24             	mov    %eax,(%esp)
c002b182:	e8 bf fd ff ff       	call   c002af46 <msg>
  msg ("If successful, product of iteration count and");
c002b187:	8d 83 a0 75 ff ff    	lea    -0x8a60(%ebx),%eax
c002b18d:	89 04 24             	mov    %eax,(%esp)
c002b190:	e8 b1 fd ff ff       	call   c002af46 <msg>
  msg ("sleep duration will appear in nondescending order.");
c002b195:	8d 83 d0 75 ff ff    	lea    -0x8a30(%ebx),%eax
c002b19b:	89 04 24             	mov    %eax,(%esp)
c002b19e:	e8 a3 fd ff ff       	call   c002af46 <msg>
  threads = malloc (sizeof *threads * thread_cnt);
c002b1a3:	89 f8                	mov    %edi,%eax
c002b1a5:	c1 e0 04             	shl    $0x4,%eax
c002b1a8:	89 04 24             	mov    %eax,(%esp)
c002b1ab:	e8 8e 8a ff ff       	call   c0023c3e <malloc>
c002b1b0:	89 c5                	mov    %eax,%ebp
c002b1b2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002b1b6:	8d 04 f5 00 00 00 00 	lea    0x0(,%esi,8),%eax
c002b1bd:	0f af c7             	imul   %edi,%eax
c002b1c0:	89 04 24             	mov    %eax,(%esp)
c002b1c3:	e8 76 8a ff ff       	call   c0023c3e <malloc>
c002b1c8:	89 44 24 28          	mov    %eax,0x28(%esp)
  if (threads == NULL || output == NULL)
c002b1cc:	83 c4 10             	add    $0x10,%esp
c002b1cf:	85 ed                	test   %ebp,%ebp
c002b1d1:	0f 84 5a 01 00 00    	je     c002b331 <test_sleep+0x208>
c002b1d7:	85 c0                	test   %eax,%eax
c002b1d9:	0f 84 52 01 00 00    	je     c002b331 <test_sleep+0x208>
  test.start = timer_ticks () + 100;
c002b1df:	e8 7d 91 ff ff       	call   c0024361 <timer_ticks>
c002b1e4:	83 c0 64             	add    $0x64,%eax
c002b1e7:	83 d2 00             	adc    $0x0,%edx
c002b1ea:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c002b1ee:	89 54 24 40          	mov    %edx,0x40(%esp)
  test.iterations = iterations;
c002b1f2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b1f6:	89 44 24 44          	mov    %eax,0x44(%esp)
  lock_init (&test.output_lock);
c002b1fa:	83 ec 0c             	sub    $0xc,%esp
c002b1fd:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b201:	50                   	push   %eax
c002b202:	e8 8a 7d ff ff       	call   c0022f91 <lock_init>
  test.output_pos = output;
c002b207:	8b 44 24 28          	mov    0x28(%esp),%eax
c002b20b:	89 44 24 7c          	mov    %eax,0x7c(%esp)
  ASSERT (output != NULL);
c002b20f:	83 c4 10             	add    $0x10,%esp
c002b212:	85 c0                	test   %eax,%eax
c002b214:	0f 84 33 01 00 00    	je     c002b34d <test_sleep+0x224>
  for (i = 0; i < thread_cnt; i++)
c002b21a:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002b21f:	0f 8e 1c 02 00 00    	jle    c002b441 <test_sleep+0x318>
c002b225:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002b229:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
c002b230:	00 
c002b231:	b8 00 00 00 00       	mov    $0x0,%eax
      t->test = &test;
c002b236:	8d 4c 24 3c          	lea    0x3c(%esp),%ecx
c002b23a:	89 4c 24 10          	mov    %ecx,0x10(%esp)
      snprintf (name, sizeof name, "thread %d", i);
c002b23e:	8d 8b d5 74 ff ff    	lea    -0x8b2b(%ebx),%ecx
c002b244:	89 4c 24 14          	mov    %ecx,0x14(%esp)
      t->test = &test;
c002b248:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002b24c:	89 0e                	mov    %ecx,(%esi)
      t->id = i;
c002b24e:	89 46 04             	mov    %eax,0x4(%esi)
      t->duration = (i + 1) * 10;
c002b251:	8d 78 01             	lea    0x1(%eax),%edi
c002b254:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002b258:	89 4e 08             	mov    %ecx,0x8(%esi)
      t->iterations = 0;
c002b25b:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
      snprintf (name, sizeof name, "thread %d", i);
c002b262:	50                   	push   %eax
c002b263:	ff 74 24 18          	pushl  0x18(%esp)
c002b267:	6a 10                	push   $0x10
c002b269:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c002b26d:	55                   	push   %ebp
c002b26e:	e8 a6 c8 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002b273:	56                   	push   %esi
c002b274:	8d 83 c6 1b ff ff    	lea    -0xe43a(%ebx),%eax
c002b27a:	50                   	push   %eax
c002b27b:	6a 1f                	push   $0x1f
c002b27d:	55                   	push   %ebp
c002b27e:	e8 d8 5e ff ff       	call   c002115b <thread_create>
c002b283:	83 c6 10             	add    $0x10,%esi
c002b286:	83 44 24 24 0a       	addl   $0xa,0x24(%esp)
  for (i = 0; i < thread_cnt; i++)
c002b28b:	89 f8                	mov    %edi,%eax
c002b28d:	83 c4 20             	add    $0x20,%esp
c002b290:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002b294:	75 b2                	jne    c002b248 <test_sleep+0x11f>
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002b296:	83 ec 08             	sub    $0x8,%esp
c002b299:	0f af 7c 24 24       	imul   0x24(%esp),%edi
c002b29e:	8d 04 bf             	lea    (%edi,%edi,4),%eax
c002b2a1:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c002b2a8:	99                   	cltd   
c002b2a9:	52                   	push   %edx
c002b2aa:	50                   	push   %eax
c002b2ab:	e8 00 91 ff ff       	call   c00243b0 <timer_sleep>
  lock_acquire (&test.output_lock);
c002b2b0:	83 c4 04             	add    $0x4,%esp
c002b2b3:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b2b7:	50                   	push   %eax
c002b2b8:	e8 80 7d ff ff       	call   c002303d <lock_acquire>
  for (op = output; op < test.output_pos; op++) 
c002b2bd:	83 c4 10             	add    $0x10,%esp
c002b2c0:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b2c4:	3b 44 24 6c          	cmp    0x6c(%esp),%eax
c002b2c8:	0f 83 34 01 00 00    	jae    c002b402 <test_sleep+0x2d9>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002b2ce:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b2d2:	8b 30                	mov    (%eax),%esi
c002b2d4:	39 74 24 08          	cmp    %esi,0x8(%esp)
c002b2d8:	0f 8e 95 00 00 00    	jle    c002b373 <test_sleep+0x24a>
c002b2de:	85 f6                	test   %esi,%esi
c002b2e0:	0f 88 8d 00 00 00    	js     c002b373 <test_sleep+0x24a>
  for (op = output; op < test.output_pos; op++) 
c002b2e6:	8b 7c 24 18          	mov    0x18(%esp),%edi
  product = 0;
c002b2ea:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002b2f1:	00 
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002b2f2:	8d 83 28 76 ff ff    	lea    -0x89d8(%ebx),%eax
c002b2f8:	89 44 24 10          	mov    %eax,0x10(%esp)
        fail ("thread %d woke up out of order (%d > %d)!",
c002b2fc:	8d 83 5c 76 ff ff    	lea    -0x89a4(%ebx),%eax
c002b302:	89 44 24 14          	mov    %eax,0x14(%esp)
c002b306:	e9 b7 00 00 00       	jmp    c002b3c2 <test_sleep+0x299>
  ASSERT (!thread_mlfqs);
c002b30b:	83 ec 0c             	sub    $0xc,%esp
c002b30e:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002b314:	50                   	push   %eax
c002b315:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002b31b:	50                   	push   %eax
c002b31c:	8d 83 a4 53 ff ff    	lea    -0xac5c(%ebx),%eax
c002b322:	50                   	push   %eax
c002b323:	6a 3c                	push   $0x3c
c002b325:	8d 83 fc 74 ff ff    	lea    -0x8b04(%ebx),%eax
c002b32b:	50                   	push   %eax
c002b32c:	e8 5e dc ff ff       	call   c0028f8f <debug_panic>
    PANIC ("couldn't allocate memory for test");
c002b331:	8d 83 04 76 ff ff    	lea    -0x89fc(%ebx),%eax
c002b337:	50                   	push   %eax
c002b338:	8d 83 a4 53 ff ff    	lea    -0xac5c(%ebx),%eax
c002b33e:	50                   	push   %eax
c002b33f:	6a 48                	push   $0x48
c002b341:	8d 83 fc 74 ff ff    	lea    -0x8b04(%ebx),%eax
c002b347:	50                   	push   %eax
c002b348:	e8 42 dc ff ff       	call   c0028f8f <debug_panic>
  ASSERT (output != NULL);
c002b34d:	83 ec 0c             	sub    $0xc,%esp
c002b350:	8d 83 c6 74 ff ff    	lea    -0x8b3a(%ebx),%eax
c002b356:	50                   	push   %eax
c002b357:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002b35d:	50                   	push   %eax
c002b35e:	8d 83 a4 53 ff ff    	lea    -0xac5c(%ebx),%eax
c002b364:	50                   	push   %eax
c002b365:	6a 51                	push   $0x51
c002b367:	8d 83 fc 74 ff ff    	lea    -0x8b04(%ebx),%eax
c002b36d:	50                   	push   %eax
c002b36e:	e8 1c dc ff ff       	call   c0028f8f <debug_panic>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002b373:	83 ec 0c             	sub    $0xc,%esp
c002b376:	8d 83 df 74 ff ff    	lea    -0x8b21(%ebx),%eax
c002b37c:	50                   	push   %eax
c002b37d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002b383:	50                   	push   %eax
c002b384:	8d 83 a4 53 ff ff    	lea    -0xac5c(%ebx),%eax
c002b38a:	50                   	push   %eax
c002b38b:	6a 6e                	push   $0x6e
c002b38d:	8d 83 fc 74 ff ff    	lea    -0x8b04(%ebx),%eax
c002b393:	50                   	push   %eax
c002b394:	e8 f6 db ff ff       	call   c0028f8f <debug_panic>
        fail ("thread %d woke up out of order (%d > %d)!",
c002b399:	55                   	push   %ebp
c002b39a:	ff 74 24 08          	pushl  0x8(%esp)
c002b39e:	ff 76 04             	pushl  0x4(%esi)
c002b3a1:	ff 74 24 20          	pushl  0x20(%esp)
c002b3a5:	e8 68 fc ff ff       	call   c002b012 <fail>
c002b3aa:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002b3ad:	83 c7 04             	add    $0x4,%edi
c002b3b0:	39 7c 24 6c          	cmp    %edi,0x6c(%esp)
c002b3b4:	76 45                	jbe    c002b3fb <test_sleep+0x2d2>
      ASSERT (*op >= 0 && *op < thread_cnt);
c002b3b6:	8b 37                	mov    (%edi),%esi
c002b3b8:	3b 74 24 08          	cmp    0x8(%esp),%esi
c002b3bc:	7d b5                	jge    c002b373 <test_sleep+0x24a>
c002b3be:	85 f6                	test   %esi,%esi
c002b3c0:	78 b1                	js     c002b373 <test_sleep+0x24a>
      t = threads + *op;
c002b3c2:	c1 e6 04             	shl    $0x4,%esi
c002b3c5:	03 74 24 0c          	add    0xc(%esp),%esi
      new_prod = ++t->iterations * t->duration;
c002b3c9:	8b 46 0c             	mov    0xc(%esi),%eax
c002b3cc:	83 c0 01             	add    $0x1,%eax
c002b3cf:	89 46 0c             	mov    %eax,0xc(%esi)
c002b3d2:	8b 56 08             	mov    0x8(%esi),%edx
c002b3d5:	89 c5                	mov    %eax,%ebp
c002b3d7:	0f af ea             	imul   %edx,%ebp
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002b3da:	83 ec 0c             	sub    $0xc,%esp
c002b3dd:	55                   	push   %ebp
c002b3de:	50                   	push   %eax
c002b3df:	52                   	push   %edx
c002b3e0:	ff 76 04             	pushl  0x4(%esi)
c002b3e3:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b3e7:	e8 5a fb ff ff       	call   c002af46 <msg>
      if (new_prod >= product)
c002b3ec:	83 c4 20             	add    $0x20,%esp
c002b3ef:	3b 6c 24 04          	cmp    0x4(%esp),%ebp
c002b3f3:	7c a4                	jl     c002b399 <test_sleep+0x270>
        product = new_prod;
c002b3f5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002b3f9:	eb b2                	jmp    c002b3ad <test_sleep+0x284>
  for (i = 0; i < thread_cnt; i++)
c002b3fb:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002b400:	7e 7b                	jle    c002b47d <test_sleep+0x354>
c002b402:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b406:	8d 78 0c             	lea    0xc(%eax),%edi
        product = new_prod;
c002b409:	be 00 00 00 00       	mov    $0x0,%esi
      fail ("thread %d woke up %d times instead of %d",
c002b40e:	8d ab 88 76 ff ff    	lea    -0x8978(%ebx),%ebp
c002b414:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002b418:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
c002b41c:	eb 0c                	jmp    c002b42a <test_sleep+0x301>
  for (i = 0; i < thread_cnt; i++)
c002b41e:	83 c6 01             	add    $0x1,%esi
c002b421:	83 c7 10             	add    $0x10,%edi
c002b424:	39 74 24 08          	cmp    %esi,0x8(%esp)
c002b428:	7e 53                	jle    c002b47d <test_sleep+0x354>
    if (threads[i].iterations != iterations)
c002b42a:	8b 07                	mov    (%edi),%eax
c002b42c:	39 e8                	cmp    %ebp,%eax
c002b42e:	74 ee                	je     c002b41e <test_sleep+0x2f5>
      fail ("thread %d woke up %d times instead of %d",
c002b430:	55                   	push   %ebp
c002b431:	50                   	push   %eax
c002b432:	56                   	push   %esi
c002b433:	ff 74 24 10          	pushl  0x10(%esp)
c002b437:	e8 d6 fb ff ff       	call   c002b012 <fail>
c002b43c:	83 c4 10             	add    $0x10,%esp
c002b43f:	eb dd                	jmp    c002b41e <test_sleep+0x2f5>
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002b441:	83 ec 08             	sub    $0x8,%esp
c002b444:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b448:	0f af 44 24 24       	imul   0x24(%esp),%eax
c002b44d:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002b450:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c002b457:	99                   	cltd   
c002b458:	52                   	push   %edx
c002b459:	50                   	push   %eax
c002b45a:	e8 51 8f ff ff       	call   c00243b0 <timer_sleep>
  lock_acquire (&test.output_lock);
c002b45f:	83 c4 04             	add    $0x4,%esp
c002b462:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b466:	50                   	push   %eax
c002b467:	e8 d1 7b ff ff       	call   c002303d <lock_acquire>
  for (op = output; op < test.output_pos; op++) 
c002b46c:	83 c4 10             	add    $0x10,%esp
c002b46f:	8b 44 24 18          	mov    0x18(%esp),%eax
c002b473:	3b 44 24 6c          	cmp    0x6c(%esp),%eax
c002b477:	0f 82 51 fe ff ff    	jb     c002b2ce <test_sleep+0x1a5>
  lock_release (&test.output_lock);
c002b47d:	83 ec 0c             	sub    $0xc,%esp
c002b480:	8d 44 24 54          	lea    0x54(%esp),%eax
c002b484:	50                   	push   %eax
c002b485:	e8 ab 7d ff ff       	call   c0023235 <lock_release>
  free (output);
c002b48a:	83 c4 04             	add    $0x4,%esp
c002b48d:	ff 74 24 24          	pushl  0x24(%esp)
c002b491:	e8 5e 89 ff ff       	call   c0023df4 <free>
  free (threads);
c002b496:	83 c4 04             	add    $0x4,%esp
c002b499:	ff 74 24 18          	pushl  0x18(%esp)
c002b49d:	e8 52 89 ff ff       	call   c0023df4 <free>
}
c002b4a2:	81 c4 8c 00 00 00    	add    $0x8c,%esp
c002b4a8:	5b                   	pop    %ebx
c002b4a9:	5e                   	pop    %esi
c002b4aa:	5f                   	pop    %edi
c002b4ab:	5d                   	pop    %ebp
c002b4ac:	c3                   	ret    

c002b4ad <test_alarm_single>:
{
c002b4ad:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 1);
c002b4b0:	ba 01 00 00 00       	mov    $0x1,%edx
c002b4b5:	b8 05 00 00 00       	mov    $0x5,%eax
c002b4ba:	e8 6a fc ff ff       	call   c002b129 <test_sleep>
}
c002b4bf:	83 c4 0c             	add    $0xc,%esp
c002b4c2:	c3                   	ret    

c002b4c3 <test_alarm_multiple>:
{
c002b4c3:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 7);
c002b4c6:	ba 07 00 00 00       	mov    $0x7,%edx
c002b4cb:	b8 05 00 00 00       	mov    $0x5,%eax
c002b4d0:	e8 54 fc ff ff       	call   c002b129 <test_sleep>
}
c002b4d5:	83 c4 0c             	add    $0xc,%esp
c002b4d8:	c3                   	ret    

c002b4d9 <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002b4d9:	55                   	push   %ebp
c002b4da:	57                   	push   %edi
c002b4db:	56                   	push   %esi
c002b4dc:	53                   	push   %ebx
c002b4dd:	83 ec 24             	sub    $0x24,%esp
c002b4e0:	e8 56 24 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b4e5:	81 c3 e7 df 00 00    	add    $0xdfe7,%ebx
c002b4eb:	8b 6c 24 38          	mov    0x38(%esp),%ebp
  struct sleep_test *test = test_;
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002b4ef:	6a 00                	push   $0x0
c002b4f1:	6a 01                	push   $0x1
c002b4f3:	e8 b8 8e ff ff       	call   c00243b0 <timer_sleep>

  for (i = 1; i <= test->iterations; i++) 
c002b4f8:	83 c4 10             	add    $0x10,%esp
c002b4fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b4ff:	7e 62                	jle    c002b563 <sleeper+0x8a>
c002b501:	be 0a 00 00 00       	mov    $0xa,%esi
c002b506:	bf 01 00 00 00       	mov    $0x1,%edi
c002b50b:	89 74 24 0c          	mov    %esi,0xc(%esp)
c002b50f:	89 7c 24 08          	mov    %edi,0x8(%esp)
    {
      int64_t sleep_until = test->start + i * 10;
c002b513:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b517:	99                   	cltd   
c002b518:	03 45 00             	add    0x0(%ebp),%eax
c002b51b:	13 55 04             	adc    0x4(%ebp),%edx
c002b51e:	89 c6                	mov    %eax,%esi
c002b520:	89 d7                	mov    %edx,%edi
      timer_sleep (sleep_until - timer_ticks ());
c002b522:	e8 3a 8e ff ff       	call   c0024361 <timer_ticks>
c002b527:	83 ec 08             	sub    $0x8,%esp
c002b52a:	29 c6                	sub    %eax,%esi
c002b52c:	19 d7                	sbb    %edx,%edi
c002b52e:	57                   	push   %edi
c002b52f:	56                   	push   %esi
c002b530:	e8 7b 8e ff ff       	call   c00243b0 <timer_sleep>
      *test->output_pos++ = timer_ticks () - test->start;
c002b535:	e8 27 8e ff ff       	call   c0024361 <timer_ticks>
c002b53a:	2b 45 00             	sub    0x0(%ebp),%eax
c002b53d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b540:	8d 4a 04             	lea    0x4(%edx),%ecx
c002b543:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c002b546:	89 02                	mov    %eax,(%edx)
      thread_yield ();
c002b548:	e8 80 5b ff ff       	call   c00210cd <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002b54d:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
c002b552:	8b 7c 24 18          	mov    0x18(%esp),%edi
c002b556:	83 44 24 1c 0a       	addl   $0xa,0x1c(%esp)
c002b55b:	83 c4 10             	add    $0x10,%esp
c002b55e:	39 7d 08             	cmp    %edi,0x8(%ebp)
c002b561:	7d b0                	jge    c002b513 <sleeper+0x3a>
    }
}
c002b563:	83 c4 1c             	add    $0x1c,%esp
c002b566:	5b                   	pop    %ebx
c002b567:	5e                   	pop    %esi
c002b568:	5f                   	pop    %edi
c002b569:	5d                   	pop    %ebp
c002b56a:	c3                   	ret    

c002b56b <test_alarm_simultaneous>:
{
c002b56b:	55                   	push   %ebp
c002b56c:	57                   	push   %edi
c002b56d:	56                   	push   %esi
c002b56e:	53                   	push   %ebx
c002b56f:	83 ec 3c             	sub    $0x3c,%esp
c002b572:	e8 c4 23 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b577:	81 c3 55 df 00 00    	add    $0xdf55,%ebx
  ASSERT (!thread_mlfqs);
c002b57d:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002b583:	80 38 00             	cmpb   $0x0,(%eax)
c002b586:	0f 85 33 01 00 00    	jne    c002b6bf <test_alarm_simultaneous+0x154>
  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002b58c:	83 ec 04             	sub    $0x4,%esp
c002b58f:	6a 05                	push   $0x5
c002b591:	6a 03                	push   $0x3
c002b593:	8d 83 20 75 ff ff    	lea    -0x8ae0(%ebx),%eax
c002b599:	50                   	push   %eax
c002b59a:	e8 a7 f9 ff ff       	call   c002af46 <msg>
  msg ("Each thread sleeps 10 ticks each time.");
c002b59f:	8d 83 e0 76 ff ff    	lea    -0x8920(%ebx),%eax
c002b5a5:	89 04 24             	mov    %eax,(%esp)
c002b5a8:	e8 99 f9 ff ff       	call   c002af46 <msg>
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002b5ad:	8d 83 08 77 ff ff    	lea    -0x88f8(%ebx),%eax
c002b5b3:	89 04 24             	mov    %eax,(%esp)
c002b5b6:	e8 8b f9 ff ff       	call   c002af46 <msg>
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002b5bb:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
c002b5c2:	e8 77 86 ff ff       	call   c0023c3e <malloc>
c002b5c7:	89 c5                	mov    %eax,%ebp
  if (output == NULL)
c002b5c9:	83 c4 10             	add    $0x10,%esp
c002b5cc:	85 c0                	test   %eax,%eax
c002b5ce:	0f 84 11 01 00 00    	je     c002b6e5 <test_alarm_simultaneous+0x17a>
  test.start = timer_ticks () + 100;
c002b5d4:	e8 88 8d ff ff       	call   c0024361 <timer_ticks>
c002b5d9:	83 c0 64             	add    $0x64,%eax
c002b5dc:	83 d2 00             	adc    $0x0,%edx
c002b5df:	89 44 24 10          	mov    %eax,0x10(%esp)
c002b5e3:	89 54 24 14          	mov    %edx,0x14(%esp)
  test.iterations = iterations;
c002b5e7:	c7 44 24 18 05 00 00 	movl   $0x5,0x18(%esp)
c002b5ee:	00 
  test.output_pos = output;
c002b5ef:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
  for (i = 0; i < thread_cnt; i++)
c002b5f3:	be 00 00 00 00       	mov    $0x0,%esi
      snprintf (name, sizeof name, "thread %d", i);
c002b5f8:	8d 83 d5 74 ff ff    	lea    -0x8b2b(%ebx),%eax
c002b5fe:	8d 7c 24 20          	lea    0x20(%esp),%edi
c002b602:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c002b606:	89 c5                	mov    %eax,%ebp
c002b608:	56                   	push   %esi
c002b609:	55                   	push   %ebp
c002b60a:	6a 10                	push   $0x10
c002b60c:	57                   	push   %edi
c002b60d:	e8 07 c5 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002b612:	8d 44 24 20          	lea    0x20(%esp),%eax
c002b616:	50                   	push   %eax
c002b617:	8d 83 0d 20 ff ff    	lea    -0xdff3(%ebx),%eax
c002b61d:	50                   	push   %eax
c002b61e:	6a 1f                	push   $0x1f
c002b620:	57                   	push   %edi
c002b621:	e8 35 5b ff ff       	call   c002115b <thread_create>
  for (i = 0; i < thread_cnt; i++)
c002b626:	83 c6 01             	add    $0x1,%esi
c002b629:	83 c4 20             	add    $0x20,%esp
c002b62c:	83 fe 03             	cmp    $0x3,%esi
c002b62f:	75 d7                	jne    c002b608 <test_alarm_simultaneous+0x9d>
c002b631:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  timer_sleep (100 + iterations * 10 + 100);
c002b635:	83 ec 08             	sub    $0x8,%esp
c002b638:	6a 00                	push   $0x0
c002b63a:	68 fa 00 00 00       	push   $0xfa
c002b63f:	e8 6c 8d ff ff       	call   c00243b0 <timer_sleep>
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002b644:	83 c4 08             	add    $0x8,%esp
c002b647:	ff 75 00             	pushl  0x0(%ebp)
c002b64a:	8d 83 4c 77 ff ff    	lea    -0x88b4(%ebx),%eax
c002b650:	50                   	push   %eax
c002b651:	e8 f0 f8 ff ff       	call   c002af46 <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c002b656:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c002b65a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002b65e:	29 e8                	sub    %ebp,%eax
c002b660:	83 c4 10             	add    $0x10,%esp
c002b663:	83 f8 04             	cmp    $0x4,%eax
c002b666:	7e 46                	jle    c002b6ae <test_alarm_simultaneous+0x143>
c002b668:	be 01 00 00 00       	mov    $0x1,%esi
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002b66d:	8d bb 7c 77 ff ff    	lea    -0x8884(%ebx),%edi
c002b673:	8b 44 b5 00          	mov    0x0(%ebp,%esi,4),%eax
c002b677:	2b 44 b5 fc          	sub    -0x4(%ebp,%esi,4),%eax
c002b67b:	50                   	push   %eax
c002b67c:	b8 56 55 55 55       	mov    $0x55555556,%eax
c002b681:	f7 ee                	imul   %esi
c002b683:	89 f0                	mov    %esi,%eax
c002b685:	c1 f8 1f             	sar    $0x1f,%eax
c002b688:	29 c2                	sub    %eax,%edx
c002b68a:	8d 04 52             	lea    (%edx,%edx,2),%eax
c002b68d:	89 f1                	mov    %esi,%ecx
c002b68f:	29 c1                	sub    %eax,%ecx
c002b691:	51                   	push   %ecx
c002b692:	52                   	push   %edx
c002b693:	57                   	push   %edi
c002b694:	e8 ad f8 ff ff       	call   c002af46 <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c002b699:	83 c6 01             	add    $0x1,%esi
c002b69c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002b6a0:	2b 44 24 1c          	sub    0x1c(%esp),%eax
c002b6a4:	c1 f8 02             	sar    $0x2,%eax
c002b6a7:	83 c4 10             	add    $0x10,%esp
c002b6aa:	39 c6                	cmp    %eax,%esi
c002b6ac:	7c c5                	jl     c002b673 <test_alarm_simultaneous+0x108>
  free (output);
c002b6ae:	83 ec 0c             	sub    $0xc,%esp
c002b6b1:	55                   	push   %ebp
c002b6b2:	e8 3d 87 ff ff       	call   c0023df4 <free>
}
c002b6b7:	83 c4 4c             	add    $0x4c,%esp
c002b6ba:	5b                   	pop    %ebx
c002b6bb:	5e                   	pop    %esi
c002b6bc:	5f                   	pop    %edi
c002b6bd:	5d                   	pop    %ebp
c002b6be:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b6bf:	83 ec 0c             	sub    $0xc,%esp
c002b6c2:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002b6c8:	50                   	push   %eax
c002b6c9:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002b6cf:	50                   	push   %eax
c002b6d0:	8d 83 b0 53 ff ff    	lea    -0xac50(%ebx),%eax
c002b6d6:	50                   	push   %eax
c002b6d7:	6a 28                	push   $0x28
c002b6d9:	8d 83 b4 76 ff ff    	lea    -0x894c(%ebx),%eax
c002b6df:	50                   	push   %eax
c002b6e0:	e8 aa d8 ff ff       	call   c0028f8f <debug_panic>
    PANIC ("couldn't allocate memory for test");
c002b6e5:	8d 83 04 76 ff ff    	lea    -0x89fc(%ebx),%eax
c002b6eb:	50                   	push   %eax
c002b6ec:	8d 83 b0 53 ff ff    	lea    -0xac50(%ebx),%eax
c002b6f2:	50                   	push   %eax
c002b6f3:	6a 31                	push   $0x31
c002b6f5:	8d 83 b4 76 ff ff    	lea    -0x894c(%ebx),%eax
c002b6fb:	50                   	push   %eax
c002b6fc:	e8 8e d8 ff ff       	call   c0028f8f <debug_panic>

c002b701 <alarm_priority_thread>:
    sema_down (&wait_sema);
}

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002b701:	57                   	push   %edi
c002b702:	56                   	push   %esi
c002b703:	53                   	push   %ebx
c002b704:	e8 32 22 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b709:	81 c3 c3 dd 00 00    	add    $0xddc3,%ebx
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002b70f:	e8 4d 8c ff ff       	call   c0024361 <timer_ticks>
c002b714:	89 c6                	mov    %eax,%esi
c002b716:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) == 0)
c002b718:	83 ec 08             	sub    $0x8,%esp
c002b71b:	57                   	push   %edi
c002b71c:	56                   	push   %esi
c002b71d:	e8 72 8c ff ff       	call   c0024394 <timer_elapsed>
c002b722:	83 c4 10             	add    $0x10,%esp
c002b725:	09 c2                	or     %eax,%edx
c002b727:	74 ef                	je     c002b718 <alarm_priority_thread+0x17>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002b729:	8b b3 94 23 00 00    	mov    0x2394(%ebx),%esi
c002b72f:	8b bb 98 23 00 00    	mov    0x2398(%ebx),%edi
c002b735:	e8 27 8c ff ff       	call   c0024361 <timer_ticks>
c002b73a:	83 ec 08             	sub    $0x8,%esp
c002b73d:	29 c6                	sub    %eax,%esi
c002b73f:	19 d7                	sbb    %edx,%edi
c002b741:	57                   	push   %edi
c002b742:	56                   	push   %esi
c002b743:	e8 68 8c ff ff       	call   c00243b0 <timer_sleep>

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002b748:	e8 0e 55 ff ff       	call   c0020c5b <thread_name>
c002b74d:	83 c4 08             	add    $0x8,%esp
c002b750:	50                   	push   %eax
c002b751:	8d 83 ac 77 ff ff    	lea    -0x8854(%ebx),%eax
c002b757:	50                   	push   %eax
c002b758:	e8 e9 f7 ff ff       	call   c002af46 <msg>

  sema_up (&wait_sema);
c002b75d:	8d 83 7c 23 00 00    	lea    0x237c(%ebx),%eax
c002b763:	89 04 24             	mov    %eax,(%esp)
c002b766:	e8 cc 76 ff ff       	call   c0022e37 <sema_up>
}
c002b76b:	83 c4 10             	add    $0x10,%esp
c002b76e:	5b                   	pop    %ebx
c002b76f:	5e                   	pop    %esi
c002b770:	5f                   	pop    %edi
c002b771:	c3                   	ret    

c002b772 <test_alarm_priority>:
{
c002b772:	55                   	push   %ebp
c002b773:	57                   	push   %edi
c002b774:	56                   	push   %esi
c002b775:	53                   	push   %ebx
c002b776:	83 ec 1c             	sub    $0x1c,%esp
c002b779:	e8 bd 21 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b77e:	81 c3 4e dd 00 00    	add    $0xdd4e,%ebx
  ASSERT (!thread_mlfqs);
c002b784:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002b78a:	80 38 00             	cmpb   $0x0,(%eax)
c002b78d:	0f 85 b3 00 00 00    	jne    c002b846 <test_alarm_priority+0xd4>
  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002b793:	e8 c9 8b ff ff       	call   c0024361 <timer_ticks>
c002b798:	05 f4 01 00 00       	add    $0x1f4,%eax
c002b79d:	83 d2 00             	adc    $0x0,%edx
c002b7a0:	89 83 94 23 00 00    	mov    %eax,0x2394(%ebx)
c002b7a6:	89 93 98 23 00 00    	mov    %edx,0x2398(%ebx)
  sema_init (&wait_sema, 0);
c002b7ac:	83 ec 08             	sub    $0x8,%esp
c002b7af:	6a 00                	push   $0x0
c002b7b1:	8d 83 7c 23 00 00    	lea    0x237c(%ebx),%eax
c002b7b7:	50                   	push   %eax
c002b7b8:	e8 fe 74 ff ff       	call   c0022cbb <sema_init>
c002b7bd:	83 c4 10             	add    $0x10,%esp
c002b7c0:	be 05 00 00 00       	mov    $0x5,%esi
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002b7c5:	b8 67 66 66 66       	mov    $0x66666667,%eax
c002b7ca:	f7 ee                	imul   %esi
c002b7cc:	c1 fa 02             	sar    $0x2,%edx
c002b7cf:	89 f0                	mov    %esi,%eax
c002b7d1:	c1 f8 1f             	sar    $0x1f,%eax
c002b7d4:	29 c2                	sub    %eax,%edx
c002b7d6:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002b7d9:	01 c0                	add    %eax,%eax
c002b7db:	89 f1                	mov    %esi,%ecx
c002b7dd:	29 c1                	sub    %eax,%ecx
c002b7df:	bd 1e 00 00 00       	mov    $0x1e,%ebp
c002b7e4:	29 cd                	sub    %ecx,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002b7e6:	55                   	push   %ebp
c002b7e7:	8d 83 bf 77 ff ff    	lea    -0x8841(%ebx),%eax
c002b7ed:	50                   	push   %eax
c002b7ee:	6a 10                	push   $0x10
c002b7f0:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002b7f4:	57                   	push   %edi
c002b7f5:	e8 1f c3 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, priority, alarm_priority_thread, NULL);
c002b7fa:	6a 00                	push   $0x0
c002b7fc:	8d 83 35 22 ff ff    	lea    -0xddcb(%ebx),%eax
c002b802:	50                   	push   %eax
c002b803:	55                   	push   %ebp
c002b804:	57                   	push   %edi
c002b805:	e8 51 59 ff ff       	call   c002115b <thread_create>
c002b80a:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < 10; i++) 
c002b80d:	83 c4 20             	add    $0x20,%esp
c002b810:	83 fe 0f             	cmp    $0xf,%esi
c002b813:	75 b0                	jne    c002b7c5 <test_alarm_priority+0x53>
  thread_set_priority (PRI_MIN);
c002b815:	83 ec 0c             	sub    $0xc,%esp
c002b818:	6a 00                	push   $0x0
c002b81a:	e8 f3 5a ff ff       	call   c0021312 <thread_set_priority>
c002b81f:	83 c4 10             	add    $0x10,%esp
c002b822:	be 0a 00 00 00       	mov    $0xa,%esi
    sema_down (&wait_sema);
c002b827:	8d bb 7c 23 00 00    	lea    0x237c(%ebx),%edi
c002b82d:	83 ec 0c             	sub    $0xc,%esp
c002b830:	57                   	push   %edi
c002b831:	e8 d9 74 ff ff       	call   c0022d0f <sema_down>
  for (i = 0; i < 10; i++)
c002b836:	83 c4 10             	add    $0x10,%esp
c002b839:	83 ee 01             	sub    $0x1,%esi
c002b83c:	75 ef                	jne    c002b82d <test_alarm_priority+0xbb>
}
c002b83e:	83 c4 1c             	add    $0x1c,%esp
c002b841:	5b                   	pop    %ebx
c002b842:	5e                   	pop    %esi
c002b843:	5f                   	pop    %edi
c002b844:	5d                   	pop    %ebp
c002b845:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b846:	83 ec 0c             	sub    $0xc,%esp
c002b849:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002b84f:	50                   	push   %eax
c002b850:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002b856:	50                   	push   %eax
c002b857:	8d 83 bc 53 ff ff    	lea    -0xac44(%ebx),%eax
c002b85d:	50                   	push   %eax
c002b85e:	6a 16                	push   $0x16
c002b860:	8d 83 cc 77 ff ff    	lea    -0x8834(%ebx),%eax
c002b866:	50                   	push   %eax
c002b867:	e8 23 d7 ff ff       	call   c0028f8f <debug_panic>

c002b86c <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002b86c:	53                   	push   %ebx
c002b86d:	83 ec 10             	sub    $0x10,%esp
c002b870:	e8 c6 20 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b875:	81 c3 57 dc 00 00    	add    $0xdc57,%ebx
  timer_sleep (0);
c002b87b:	6a 00                	push   $0x0
c002b87d:	6a 00                	push   $0x0
c002b87f:	e8 2c 8b ff ff       	call   c00243b0 <timer_sleep>
  pass ();
c002b884:	e8 e3 f7 ff ff       	call   c002b06c <pass>
}
c002b889:	83 c4 18             	add    $0x18,%esp
c002b88c:	5b                   	pop    %ebx
c002b88d:	c3                   	ret    

c002b88e <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002b88e:	53                   	push   %ebx
c002b88f:	83 ec 10             	sub    $0x10,%esp
c002b892:	e8 a4 20 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b897:	81 c3 35 dc 00 00    	add    $0xdc35,%ebx
  timer_sleep (-100);
c002b89d:	6a ff                	push   $0xffffffff
c002b89f:	6a 9c                	push   $0xffffff9c
c002b8a1:	e8 0a 8b ff ff       	call   c00243b0 <timer_sleep>
  pass ();
c002b8a6:	e8 c1 f7 ff ff       	call   c002b06c <pass>
}
c002b8ab:	83 c4 18             	add    $0x18,%esp
c002b8ae:	5b                   	pop    %ebx
c002b8af:	c3                   	ret    

c002b8b0 <changing_thread>:
  msg ("Thread 2 should have just exited.");
}

static void
changing_thread (void *aux UNUSED) 
{
c002b8b0:	53                   	push   %ebx
c002b8b1:	83 ec 14             	sub    $0x14,%esp
c002b8b4:	e8 82 20 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b8b9:	81 c3 13 dc 00 00    	add    $0xdc13,%ebx
  msg ("Thread 2 now lowering priority.");
c002b8bf:	8d 83 f4 77 ff ff    	lea    -0x880c(%ebx),%eax
c002b8c5:	50                   	push   %eax
c002b8c6:	e8 7b f6 ff ff       	call   c002af46 <msg>
  thread_set_priority (PRI_DEFAULT - 1);
c002b8cb:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
c002b8d2:	e8 3b 5a ff ff       	call   c0021312 <thread_set_priority>
  msg ("Thread 2 exiting.");
c002b8d7:	8d 83 b2 78 ff ff    	lea    -0x874e(%ebx),%eax
c002b8dd:	89 04 24             	mov    %eax,(%esp)
c002b8e0:	e8 61 f6 ff ff       	call   c002af46 <msg>
}
c002b8e5:	83 c4 18             	add    $0x18,%esp
c002b8e8:	5b                   	pop    %ebx
c002b8e9:	c3                   	ret    

c002b8ea <test_priority_change>:
{
c002b8ea:	53                   	push   %ebx
c002b8eb:	83 ec 08             	sub    $0x8,%esp
c002b8ee:	e8 48 20 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b8f3:	81 c3 d9 db 00 00    	add    $0xdbd9,%ebx
  ASSERT (!thread_mlfqs);
c002b8f9:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002b8ff:	80 38 00             	cmpb   $0x0,(%eax)
c002b902:	75 54                	jne    c002b958 <test_priority_change+0x6e>
  msg ("Creating a high-priority thread 2.");
c002b904:	83 ec 0c             	sub    $0xc,%esp
c002b907:	8d 83 3c 78 ff ff    	lea    -0x87c4(%ebx),%eax
c002b90d:	50                   	push   %eax
c002b90e:	e8 33 f6 ff ff       	call   c002af46 <msg>
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002b913:	6a 00                	push   $0x0
c002b915:	8d 83 e4 23 ff ff    	lea    -0xdc1c(%ebx),%eax
c002b91b:	50                   	push   %eax
c002b91c:	6a 20                	push   $0x20
c002b91e:	8d 83 c4 78 ff ff    	lea    -0x873c(%ebx),%eax
c002b924:	50                   	push   %eax
c002b925:	e8 31 58 ff ff       	call   c002115b <thread_create>
  msg ("Thread 2 should have just lowered its priority.");
c002b92a:	83 c4 14             	add    $0x14,%esp
c002b92d:	8d 83 60 78 ff ff    	lea    -0x87a0(%ebx),%eax
c002b933:	50                   	push   %eax
c002b934:	e8 0d f6 ff ff       	call   c002af46 <msg>
  thread_set_priority (PRI_DEFAULT - 2);
c002b939:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
c002b940:	e8 cd 59 ff ff       	call   c0021312 <thread_set_priority>
  msg ("Thread 2 should have just exited.");
c002b945:	8d 83 90 78 ff ff    	lea    -0x8770(%ebx),%eax
c002b94b:	89 04 24             	mov    %eax,(%esp)
c002b94e:	e8 f3 f5 ff ff       	call   c002af46 <msg>
}
c002b953:	83 c4 18             	add    $0x18,%esp
c002b956:	5b                   	pop    %ebx
c002b957:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002b958:	83 ec 0c             	sub    $0xc,%esp
c002b95b:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002b961:	50                   	push   %eax
c002b962:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002b968:	50                   	push   %eax
c002b969:	8d 83 d0 53 ff ff    	lea    -0xac30(%ebx),%eax
c002b96f:	50                   	push   %eax
c002b970:	6a 10                	push   $0x10
c002b972:	8d 83 14 78 ff ff    	lea    -0x87ec(%ebx),%eax
c002b978:	50                   	push   %eax
c002b979:	e8 11 d6 ff ff       	call   c0028f8f <debug_panic>

c002b97e <acquire2_thread_func>:
  msg ("acquire1: done");
}

static void
acquire2_thread_func (void *lock_) 
{
c002b97e:	56                   	push   %esi
c002b97f:	53                   	push   %ebx
c002b980:	83 ec 10             	sub    $0x10,%esp
c002b983:	e8 b3 1f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b988:	81 c3 44 db 00 00    	add    $0xdb44,%ebx
c002b98e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002b992:	56                   	push   %esi
c002b993:	e8 a5 76 ff ff       	call   c002303d <lock_acquire>
  msg ("acquire2: got the lock");
c002b998:	8d 83 cd 78 ff ff    	lea    -0x8733(%ebx),%eax
c002b99e:	89 04 24             	mov    %eax,(%esp)
c002b9a1:	e8 a0 f5 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002b9a6:	89 34 24             	mov    %esi,(%esp)
c002b9a9:	e8 87 78 ff ff       	call   c0023235 <lock_release>
  msg ("acquire2: done");
c002b9ae:	8d 83 e4 78 ff ff    	lea    -0x871c(%ebx),%eax
c002b9b4:	89 04 24             	mov    %eax,(%esp)
c002b9b7:	e8 8a f5 ff ff       	call   c002af46 <msg>
}
c002b9bc:	83 c4 14             	add    $0x14,%esp
c002b9bf:	5b                   	pop    %ebx
c002b9c0:	5e                   	pop    %esi
c002b9c1:	c3                   	ret    

c002b9c2 <acquire1_thread_func>:
{
c002b9c2:	56                   	push   %esi
c002b9c3:	53                   	push   %ebx
c002b9c4:	83 ec 10             	sub    $0x10,%esp
c002b9c7:	e8 6f 1f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002b9cc:	81 c3 00 db 00 00    	add    $0xdb00,%ebx
c002b9d2:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002b9d6:	56                   	push   %esi
c002b9d7:	e8 61 76 ff ff       	call   c002303d <lock_acquire>
  msg ("acquire1: got the lock");
c002b9dc:	8d 83 f3 78 ff ff    	lea    -0x870d(%ebx),%eax
c002b9e2:	89 04 24             	mov    %eax,(%esp)
c002b9e5:	e8 5c f5 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002b9ea:	89 34 24             	mov    %esi,(%esp)
c002b9ed:	e8 43 78 ff ff       	call   c0023235 <lock_release>
  msg ("acquire1: done");
c002b9f2:	8d 83 0a 79 ff ff    	lea    -0x86f6(%ebx),%eax
c002b9f8:	89 04 24             	mov    %eax,(%esp)
c002b9fb:	e8 46 f5 ff ff       	call   c002af46 <msg>
}
c002ba00:	83 c4 14             	add    $0x14,%esp
c002ba03:	5b                   	pop    %ebx
c002ba04:	5e                   	pop    %esi
c002ba05:	c3                   	ret    

c002ba06 <test_priority_donate_one>:
{
c002ba06:	57                   	push   %edi
c002ba07:	56                   	push   %esi
c002ba08:	53                   	push   %ebx
c002ba09:	83 ec 30             	sub    $0x30,%esp
c002ba0c:	e8 2a 1f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ba11:	81 c3 bb da 00 00    	add    $0xdabb,%ebx
  ASSERT (!thread_mlfqs);
c002ba17:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002ba1d:	80 38 00             	cmpb   $0x0,(%eax)
c002ba20:	0f 85 a8 00 00 00    	jne    c002bace <test_priority_donate_one+0xc8>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ba26:	e8 e2 52 ff ff       	call   c0020d0d <thread_get_priority>
c002ba2b:	83 f8 1f             	cmp    $0x1f,%eax
c002ba2e:	0f 85 c0 00 00 00    	jne    c002baf4 <test_priority_donate_one+0xee>
  lock_init (&lock);
c002ba34:	83 ec 0c             	sub    $0xc,%esp
c002ba37:	8d 74 24 18          	lea    0x18(%esp),%esi
c002ba3b:	56                   	push   %esi
c002ba3c:	e8 50 75 ff ff       	call   c0022f91 <lock_init>
  lock_acquire (&lock);
c002ba41:	89 34 24             	mov    %esi,(%esp)
c002ba44:	e8 f4 75 ff ff       	call   c002303d <lock_acquire>
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002ba49:	56                   	push   %esi
c002ba4a:	8d 83 f6 24 ff ff    	lea    -0xdb0a(%ebx),%eax
c002ba50:	50                   	push   %eax
c002ba51:	6a 20                	push   $0x20
c002ba53:	8d 83 19 79 ff ff    	lea    -0x86e7(%ebx),%eax
c002ba59:	50                   	push   %eax
c002ba5a:	e8 fc 56 ff ff       	call   c002115b <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ba5f:	83 c4 20             	add    $0x20,%esp
c002ba62:	e8 a6 52 ff ff       	call   c0020d0d <thread_get_priority>
c002ba67:	83 ec 04             	sub    $0x4,%esp
c002ba6a:	50                   	push   %eax
c002ba6b:	6a 20                	push   $0x20
c002ba6d:	8d bb 80 79 ff ff    	lea    -0x8680(%ebx),%edi
c002ba73:	57                   	push   %edi
c002ba74:	e8 cd f4 ff ff       	call   c002af46 <msg>
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002ba79:	56                   	push   %esi
c002ba7a:	8d 83 b2 24 ff ff    	lea    -0xdb4e(%ebx),%eax
c002ba80:	50                   	push   %eax
c002ba81:	6a 21                	push   $0x21
c002ba83:	8d 83 22 79 ff ff    	lea    -0x86de(%ebx),%eax
c002ba89:	50                   	push   %eax
c002ba8a:	e8 cc 56 ff ff       	call   c002115b <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ba8f:	83 c4 20             	add    $0x20,%esp
c002ba92:	e8 76 52 ff ff       	call   c0020d0d <thread_get_priority>
c002ba97:	83 ec 04             	sub    $0x4,%esp
c002ba9a:	50                   	push   %eax
c002ba9b:	6a 21                	push   $0x21
c002ba9d:	57                   	push   %edi
c002ba9e:	e8 a3 f4 ff ff       	call   c002af46 <msg>
  lock_release (&lock);
c002baa3:	89 34 24             	mov    %esi,(%esp)
c002baa6:	e8 8a 77 ff ff       	call   c0023235 <lock_release>
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002baab:	8d 83 bc 79 ff ff    	lea    -0x8644(%ebx),%eax
c002bab1:	89 04 24             	mov    %eax,(%esp)
c002bab4:	e8 8d f4 ff ff       	call   c002af46 <msg>
  msg ("This should be the last line before finishing this test.");
c002bab9:	8d 83 fc 79 ff ff    	lea    -0x8604(%ebx),%eax
c002babf:	89 04 24             	mov    %eax,(%esp)
c002bac2:	e8 7f f4 ff ff       	call   c002af46 <msg>
}
c002bac7:	83 c4 40             	add    $0x40,%esp
c002baca:	5b                   	pop    %ebx
c002bacb:	5e                   	pop    %esi
c002bacc:	5f                   	pop    %edi
c002bacd:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002bace:	83 ec 0c             	sub    $0xc,%esp
c002bad1:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002bad7:	50                   	push   %eax
c002bad8:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bade:	50                   	push   %eax
c002badf:	8d 83 e8 53 ff ff    	lea    -0xac18(%ebx),%eax
c002bae5:	50                   	push   %eax
c002bae6:	6a 1b                	push   $0x1b
c002bae8:	8d 83 2c 79 ff ff    	lea    -0x86d4(%ebx),%eax
c002baee:	50                   	push   %eax
c002baef:	e8 9b d4 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002baf4:	83 ec 0c             	sub    $0xc,%esp
c002baf7:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002bafd:	50                   	push   %eax
c002bafe:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bb04:	50                   	push   %eax
c002bb05:	8d 83 e8 53 ff ff    	lea    -0xac18(%ebx),%eax
c002bb0b:	50                   	push   %eax
c002bb0c:	6a 1e                	push   $0x1e
c002bb0e:	8d 83 2c 79 ff ff    	lea    -0x86d4(%ebx),%eax
c002bb14:	50                   	push   %eax
c002bb15:	e8 75 d4 ff ff       	call   c0028f8f <debug_panic>

c002bb1a <b_thread_func>:
  msg ("Thread a finished.");
}

static void
b_thread_func (void *lock_) 
{
c002bb1a:	56                   	push   %esi
c002bb1b:	53                   	push   %ebx
c002bb1c:	83 ec 10             	sub    $0x10,%esp
c002bb1f:	e8 17 1e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bb24:	81 c3 a8 d9 00 00    	add    $0xd9a8,%ebx
c002bb2a:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002bb2e:	56                   	push   %esi
c002bb2f:	e8 09 75 ff ff       	call   c002303d <lock_acquire>
  msg ("Thread b acquired lock b.");
c002bb34:	8d 83 35 7a ff ff    	lea    -0x85cb(%ebx),%eax
c002bb3a:	89 04 24             	mov    %eax,(%esp)
c002bb3d:	e8 04 f4 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002bb42:	89 34 24             	mov    %esi,(%esp)
c002bb45:	e8 eb 76 ff ff       	call   c0023235 <lock_release>
  msg ("Thread b finished.");
c002bb4a:	8d 83 4f 7a ff ff    	lea    -0x85b1(%ebx),%eax
c002bb50:	89 04 24             	mov    %eax,(%esp)
c002bb53:	e8 ee f3 ff ff       	call   c002af46 <msg>
}
c002bb58:	83 c4 14             	add    $0x14,%esp
c002bb5b:	5b                   	pop    %ebx
c002bb5c:	5e                   	pop    %esi
c002bb5d:	c3                   	ret    

c002bb5e <a_thread_func>:
{
c002bb5e:	56                   	push   %esi
c002bb5f:	53                   	push   %ebx
c002bb60:	83 ec 10             	sub    $0x10,%esp
c002bb63:	e8 d3 1d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bb68:	81 c3 64 d9 00 00    	add    $0xd964,%ebx
c002bb6e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002bb72:	56                   	push   %esi
c002bb73:	e8 c5 74 ff ff       	call   c002303d <lock_acquire>
  msg ("Thread a acquired lock a.");
c002bb78:	8d 83 62 7a ff ff    	lea    -0x859e(%ebx),%eax
c002bb7e:	89 04 24             	mov    %eax,(%esp)
c002bb81:	e8 c0 f3 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002bb86:	89 34 24             	mov    %esi,(%esp)
c002bb89:	e8 a7 76 ff ff       	call   c0023235 <lock_release>
  msg ("Thread a finished.");
c002bb8e:	8d 83 7c 7a ff ff    	lea    -0x8584(%ebx),%eax
c002bb94:	89 04 24             	mov    %eax,(%esp)
c002bb97:	e8 aa f3 ff ff       	call   c002af46 <msg>
}
c002bb9c:	83 c4 14             	add    $0x14,%esp
c002bb9f:	5b                   	pop    %ebx
c002bba0:	5e                   	pop    %esi
c002bba1:	c3                   	ret    

c002bba2 <test_priority_donate_multiple>:
{
c002bba2:	55                   	push   %ebp
c002bba3:	57                   	push   %edi
c002bba4:	56                   	push   %esi
c002bba5:	53                   	push   %ebx
c002bba6:	83 ec 5c             	sub    $0x5c,%esp
c002bba9:	e8 8d 1d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bbae:	81 c3 1e d9 00 00    	add    $0xd91e,%ebx
  ASSERT (!thread_mlfqs);
c002bbb4:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002bbba:	80 38 00             	cmpb   $0x0,(%eax)
c002bbbd:	0f 85 e8 00 00 00    	jne    c002bcab <test_priority_donate_multiple+0x109>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bbc3:	e8 45 51 ff ff       	call   c0020d0d <thread_get_priority>
c002bbc8:	83 f8 1f             	cmp    $0x1f,%eax
c002bbcb:	0f 85 00 01 00 00    	jne    c002bcd1 <test_priority_donate_multiple+0x12f>
  lock_init (&a);
c002bbd1:	83 ec 0c             	sub    $0xc,%esp
c002bbd4:	8d 7c 24 38          	lea    0x38(%esp),%edi
c002bbd8:	57                   	push   %edi
c002bbd9:	e8 b3 73 ff ff       	call   c0022f91 <lock_init>
  lock_init (&b);
c002bbde:	83 c4 04             	add    $0x4,%esp
c002bbe1:	8d 6c 24 14          	lea    0x14(%esp),%ebp
c002bbe5:	55                   	push   %ebp
c002bbe6:	e8 a6 73 ff ff       	call   c0022f91 <lock_init>
  lock_acquire (&a);
c002bbeb:	89 3c 24             	mov    %edi,(%esp)
c002bbee:	e8 4a 74 ff ff       	call   c002303d <lock_acquire>
  lock_acquire (&b);
c002bbf3:	89 2c 24             	mov    %ebp,(%esp)
c002bbf6:	e8 42 74 ff ff       	call   c002303d <lock_acquire>
  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002bbfb:	57                   	push   %edi
c002bbfc:	8d 83 92 26 ff ff    	lea    -0xd96e(%ebx),%eax
c002bc02:	50                   	push   %eax
c002bc03:	6a 20                	push   $0x20
c002bc05:	8d 83 b7 66 ff ff    	lea    -0x9949(%ebx),%eax
c002bc0b:	50                   	push   %eax
c002bc0c:	e8 4a 55 ff ff       	call   c002115b <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bc11:	83 c4 20             	add    $0x20,%esp
c002bc14:	e8 f4 50 ff ff       	call   c0020d0d <thread_get_priority>
c002bc19:	83 ec 04             	sub    $0x4,%esp
c002bc1c:	50                   	push   %eax
c002bc1d:	6a 20                	push   $0x20
c002bc1f:	8d b3 c0 7a ff ff    	lea    -0x8540(%ebx),%esi
c002bc25:	56                   	push   %esi
c002bc26:	e8 1b f3 ff ff       	call   c002af46 <msg>
  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002bc2b:	55                   	push   %ebp
c002bc2c:	8d 83 4e 26 ff ff    	lea    -0xd9b2(%ebx),%eax
c002bc32:	50                   	push   %eax
c002bc33:	6a 21                	push   $0x21
c002bc35:	8d 83 f7 6f ff ff    	lea    -0x9009(%ebx),%eax
c002bc3b:	50                   	push   %eax
c002bc3c:	e8 1a 55 ff ff       	call   c002115b <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bc41:	83 c4 20             	add    $0x20,%esp
c002bc44:	e8 c4 50 ff ff       	call   c0020d0d <thread_get_priority>
c002bc49:	83 ec 04             	sub    $0x4,%esp
c002bc4c:	50                   	push   %eax
c002bc4d:	6a 21                	push   $0x21
c002bc4f:	56                   	push   %esi
c002bc50:	e8 f1 f2 ff ff       	call   c002af46 <msg>
  lock_release (&b);
c002bc55:	89 2c 24             	mov    %ebp,(%esp)
c002bc58:	e8 d8 75 ff ff       	call   c0023235 <lock_release>
  msg ("Thread b should have just finished.");
c002bc5d:	8d 83 fc 7a ff ff    	lea    -0x8504(%ebx),%eax
c002bc63:	89 04 24             	mov    %eax,(%esp)
c002bc66:	e8 db f2 ff ff       	call   c002af46 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bc6b:	e8 9d 50 ff ff       	call   c0020d0d <thread_get_priority>
c002bc70:	83 c4 0c             	add    $0xc,%esp
c002bc73:	50                   	push   %eax
c002bc74:	6a 20                	push   $0x20
c002bc76:	56                   	push   %esi
c002bc77:	e8 ca f2 ff ff       	call   c002af46 <msg>
  lock_release (&a);
c002bc7c:	89 3c 24             	mov    %edi,(%esp)
c002bc7f:	e8 b1 75 ff ff       	call   c0023235 <lock_release>
  msg ("Thread a should have just finished.");
c002bc84:	8d 83 20 7b ff ff    	lea    -0x84e0(%ebx),%eax
c002bc8a:	89 04 24             	mov    %eax,(%esp)
c002bc8d:	e8 b4 f2 ff ff       	call   c002af46 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002bc92:	e8 76 50 ff ff       	call   c0020d0d <thread_get_priority>
c002bc97:	83 c4 0c             	add    $0xc,%esp
c002bc9a:	50                   	push   %eax
c002bc9b:	6a 1f                	push   $0x1f
c002bc9d:	56                   	push   %esi
c002bc9e:	e8 a3 f2 ff ff       	call   c002af46 <msg>
}
c002bca3:	83 c4 6c             	add    $0x6c,%esp
c002bca6:	5b                   	pop    %ebx
c002bca7:	5e                   	pop    %esi
c002bca8:	5f                   	pop    %edi
c002bca9:	5d                   	pop    %ebp
c002bcaa:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002bcab:	83 ec 0c             	sub    $0xc,%esp
c002bcae:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002bcb4:	50                   	push   %eax
c002bcb5:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bcbb:	50                   	push   %eax
c002bcbc:	8d 83 04 54 ff ff    	lea    -0xabfc(%ebx),%eax
c002bcc2:	50                   	push   %eax
c002bcc3:	6a 1b                	push   $0x1b
c002bcc5:	8d 83 90 7a ff ff    	lea    -0x8570(%ebx),%eax
c002bccb:	50                   	push   %eax
c002bccc:	e8 be d2 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bcd1:	83 ec 0c             	sub    $0xc,%esp
c002bcd4:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002bcda:	50                   	push   %eax
c002bcdb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bce1:	50                   	push   %eax
c002bce2:	8d 83 04 54 ff ff    	lea    -0xabfc(%ebx),%eax
c002bce8:	50                   	push   %eax
c002bce9:	6a 1e                	push   $0x1e
c002bceb:	8d 83 90 7a ff ff    	lea    -0x8570(%ebx),%eax
c002bcf1:	50                   	push   %eax
c002bcf2:	e8 98 d2 ff ff       	call   c0028f8f <debug_panic>

c002bcf7 <c_thread_func>:
  msg ("Thread b finished.");
}

static void
c_thread_func (void *a_ UNUSED) 
{
c002bcf7:	53                   	push   %ebx
c002bcf8:	83 ec 14             	sub    $0x14,%esp
c002bcfb:	e8 3b 1c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bd00:	81 c3 cc d7 00 00    	add    $0xd7cc,%ebx
  msg ("Thread c finished.");
c002bd06:	8d 83 44 7b ff ff    	lea    -0x84bc(%ebx),%eax
c002bd0c:	50                   	push   %eax
c002bd0d:	e8 34 f2 ff ff       	call   c002af46 <msg>
}
c002bd12:	83 c4 18             	add    $0x18,%esp
c002bd15:	5b                   	pop    %ebx
c002bd16:	c3                   	ret    

c002bd17 <b_thread_func>:
{
c002bd17:	56                   	push   %esi
c002bd18:	53                   	push   %ebx
c002bd19:	83 ec 10             	sub    $0x10,%esp
c002bd1c:	e8 1a 1c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bd21:	81 c3 ab d7 00 00    	add    $0xd7ab,%ebx
c002bd27:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002bd2b:	56                   	push   %esi
c002bd2c:	e8 0c 73 ff ff       	call   c002303d <lock_acquire>
  msg ("Thread b acquired lock b.");
c002bd31:	8d 83 35 7a ff ff    	lea    -0x85cb(%ebx),%eax
c002bd37:	89 04 24             	mov    %eax,(%esp)
c002bd3a:	e8 07 f2 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002bd3f:	89 34 24             	mov    %esi,(%esp)
c002bd42:	e8 ee 74 ff ff       	call   c0023235 <lock_release>
  msg ("Thread b finished.");
c002bd47:	8d 83 4f 7a ff ff    	lea    -0x85b1(%ebx),%eax
c002bd4d:	89 04 24             	mov    %eax,(%esp)
c002bd50:	e8 f1 f1 ff ff       	call   c002af46 <msg>
}
c002bd55:	83 c4 14             	add    $0x14,%esp
c002bd58:	5b                   	pop    %ebx
c002bd59:	5e                   	pop    %esi
c002bd5a:	c3                   	ret    

c002bd5b <a_thread_func>:
{
c002bd5b:	56                   	push   %esi
c002bd5c:	53                   	push   %ebx
c002bd5d:	83 ec 10             	sub    $0x10,%esp
c002bd60:	e8 d6 1b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bd65:	81 c3 67 d7 00 00    	add    $0xd767,%ebx
c002bd6b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (lock);
c002bd6f:	56                   	push   %esi
c002bd70:	e8 c8 72 ff ff       	call   c002303d <lock_acquire>
  msg ("Thread a acquired lock a.");
c002bd75:	8d 83 62 7a ff ff    	lea    -0x859e(%ebx),%eax
c002bd7b:	89 04 24             	mov    %eax,(%esp)
c002bd7e:	e8 c3 f1 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002bd83:	89 34 24             	mov    %esi,(%esp)
c002bd86:	e8 aa 74 ff ff       	call   c0023235 <lock_release>
  msg ("Thread a finished.");
c002bd8b:	8d 83 7c 7a ff ff    	lea    -0x8584(%ebx),%eax
c002bd91:	89 04 24             	mov    %eax,(%esp)
c002bd94:	e8 ad f1 ff ff       	call   c002af46 <msg>
}
c002bd99:	83 c4 14             	add    $0x14,%esp
c002bd9c:	5b                   	pop    %ebx
c002bd9d:	5e                   	pop    %esi
c002bd9e:	c3                   	ret    

c002bd9f <test_priority_donate_multiple2>:
{
c002bd9f:	55                   	push   %ebp
c002bda0:	57                   	push   %edi
c002bda1:	56                   	push   %esi
c002bda2:	53                   	push   %ebx
c002bda3:	83 ec 5c             	sub    $0x5c,%esp
c002bda6:	e8 90 1b 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bdab:	81 c3 21 d7 00 00    	add    $0xd721,%ebx
  ASSERT (!thread_mlfqs);
c002bdb1:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002bdb7:	80 38 00             	cmpb   $0x0,(%eax)
c002bdba:	0f 85 f1 00 00 00    	jne    c002beb1 <test_priority_donate_multiple2+0x112>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bdc0:	e8 48 4f ff ff       	call   c0020d0d <thread_get_priority>
c002bdc5:	83 f8 1f             	cmp    $0x1f,%eax
c002bdc8:	0f 85 09 01 00 00    	jne    c002bed7 <test_priority_donate_multiple2+0x138>
  lock_init (&a);
c002bdce:	83 ec 0c             	sub    $0xc,%esp
c002bdd1:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c002bdd5:	55                   	push   %ebp
c002bdd6:	e8 b6 71 ff ff       	call   c0022f91 <lock_init>
  lock_init (&b);
c002bddb:	83 c4 04             	add    $0x4,%esp
c002bdde:	8d 7c 24 14          	lea    0x14(%esp),%edi
c002bde2:	57                   	push   %edi
c002bde3:	e8 a9 71 ff ff       	call   c0022f91 <lock_init>
  lock_acquire (&a);
c002bde8:	89 2c 24             	mov    %ebp,(%esp)
c002bdeb:	e8 4d 72 ff ff       	call   c002303d <lock_acquire>
  lock_acquire (&b);
c002bdf0:	89 3c 24             	mov    %edi,(%esp)
c002bdf3:	e8 45 72 ff ff       	call   c002303d <lock_acquire>
  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002bdf8:	55                   	push   %ebp
c002bdf9:	8d 83 8f 28 ff ff    	lea    -0xd771(%ebx),%eax
c002bdff:	50                   	push   %eax
c002be00:	6a 22                	push   $0x22
c002be02:	8d 83 b7 66 ff ff    	lea    -0x9949(%ebx),%eax
c002be08:	50                   	push   %eax
c002be09:	e8 4d 53 ff ff       	call   c002115b <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002be0e:	83 c4 20             	add    $0x20,%esp
c002be11:	e8 f7 4e ff ff       	call   c0020d0d <thread_get_priority>
c002be16:	83 ec 04             	sub    $0x4,%esp
c002be19:	50                   	push   %eax
c002be1a:	6a 22                	push   $0x22
c002be1c:	8d b3 c0 7a ff ff    	lea    -0x8540(%ebx),%esi
c002be22:	56                   	push   %esi
c002be23:	e8 1e f1 ff ff       	call   c002af46 <msg>
  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002be28:	6a 00                	push   $0x0
c002be2a:	8d 83 2b 28 ff ff    	lea    -0xd7d5(%ebx),%eax
c002be30:	50                   	push   %eax
c002be31:	6a 20                	push   $0x20
c002be33:	8d 83 a2 6a ff ff    	lea    -0x955e(%ebx),%eax
c002be39:	50                   	push   %eax
c002be3a:	e8 1c 53 ff ff       	call   c002115b <thread_create>
  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002be3f:	83 c4 20             	add    $0x20,%esp
c002be42:	57                   	push   %edi
c002be43:	8d 83 4b 28 ff ff    	lea    -0xd7b5(%ebx),%eax
c002be49:	50                   	push   %eax
c002be4a:	6a 24                	push   $0x24
c002be4c:	8d 83 f7 6f ff ff    	lea    -0x9009(%ebx),%eax
c002be52:	50                   	push   %eax
c002be53:	e8 03 53 ff ff       	call   c002115b <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002be58:	e8 b0 4e ff ff       	call   c0020d0d <thread_get_priority>
c002be5d:	83 c4 0c             	add    $0xc,%esp
c002be60:	50                   	push   %eax
c002be61:	6a 24                	push   $0x24
c002be63:	56                   	push   %esi
c002be64:	e8 dd f0 ff ff       	call   c002af46 <msg>
  lock_release (&a);
c002be69:	89 2c 24             	mov    %ebp,(%esp)
c002be6c:	e8 c4 73 ff ff       	call   c0023235 <lock_release>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002be71:	e8 97 4e ff ff       	call   c0020d0d <thread_get_priority>
c002be76:	83 c4 0c             	add    $0xc,%esp
c002be79:	50                   	push   %eax
c002be7a:	6a 24                	push   $0x24
c002be7c:	56                   	push   %esi
c002be7d:	e8 c4 f0 ff ff       	call   c002af46 <msg>
  lock_release (&b);
c002be82:	89 3c 24             	mov    %edi,(%esp)
c002be85:	e8 ab 73 ff ff       	call   c0023235 <lock_release>
  msg ("Threads b, a, c should have just finished, in that order.");
c002be8a:	8d 83 88 7b ff ff    	lea    -0x8478(%ebx),%eax
c002be90:	89 04 24             	mov    %eax,(%esp)
c002be93:	e8 ae f0 ff ff       	call   c002af46 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002be98:	e8 70 4e ff ff       	call   c0020d0d <thread_get_priority>
c002be9d:	83 c4 0c             	add    $0xc,%esp
c002bea0:	50                   	push   %eax
c002bea1:	6a 1f                	push   $0x1f
c002bea3:	56                   	push   %esi
c002bea4:	e8 9d f0 ff ff       	call   c002af46 <msg>
}
c002bea9:	83 c4 6c             	add    $0x6c,%esp
c002beac:	5b                   	pop    %ebx
c002bead:	5e                   	pop    %esi
c002beae:	5f                   	pop    %edi
c002beaf:	5d                   	pop    %ebp
c002beb0:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002beb1:	83 ec 0c             	sub    $0xc,%esp
c002beb4:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002beba:	50                   	push   %eax
c002bebb:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bec1:	50                   	push   %eax
c002bec2:	8d 83 24 54 ff ff    	lea    -0xabdc(%ebx),%eax
c002bec8:	50                   	push   %eax
c002bec9:	6a 21                	push   $0x21
c002becb:	8d 83 58 7b ff ff    	lea    -0x84a8(%ebx),%eax
c002bed1:	50                   	push   %eax
c002bed2:	e8 b8 d0 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bed7:	83 ec 0c             	sub    $0xc,%esp
c002beda:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002bee0:	50                   	push   %eax
c002bee1:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002bee7:	50                   	push   %eax
c002bee8:	8d 83 24 54 ff ff    	lea    -0xabdc(%ebx),%eax
c002beee:	50                   	push   %eax
c002beef:	6a 24                	push   $0x24
c002bef1:	8d 83 58 7b ff ff    	lea    -0x84a8(%ebx),%eax
c002bef7:	50                   	push   %eax
c002bef8:	e8 92 d0 ff ff       	call   c0028f8f <debug_panic>

c002befd <high_thread_func>:
  msg ("Middle thread finished.");
}

static void
high_thread_func (void *lock_) 
{
c002befd:	56                   	push   %esi
c002befe:	53                   	push   %ebx
c002beff:	83 ec 10             	sub    $0x10,%esp
c002bf02:	e8 34 1a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bf07:	81 c3 c5 d5 00 00    	add    $0xd5c5,%ebx
c002bf0d:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002bf11:	56                   	push   %esi
c002bf12:	e8 26 71 ff ff       	call   c002303d <lock_acquire>
  msg ("High thread got the lock.");
c002bf17:	8d 83 c2 7b ff ff    	lea    -0x843e(%ebx),%eax
c002bf1d:	89 04 24             	mov    %eax,(%esp)
c002bf20:	e8 21 f0 ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002bf25:	89 34 24             	mov    %esi,(%esp)
c002bf28:	e8 08 73 ff ff       	call   c0023235 <lock_release>
  msg ("High thread finished.");
c002bf2d:	8d 83 dc 7b ff ff    	lea    -0x8424(%ebx),%eax
c002bf33:	89 04 24             	mov    %eax,(%esp)
c002bf36:	e8 0b f0 ff ff       	call   c002af46 <msg>
}
c002bf3b:	83 c4 14             	add    $0x14,%esp
c002bf3e:	5b                   	pop    %ebx
c002bf3f:	5e                   	pop    %esi
c002bf40:	c3                   	ret    

c002bf41 <medium_thread_func>:
{
c002bf41:	56                   	push   %esi
c002bf42:	53                   	push   %ebx
c002bf43:	83 ec 10             	sub    $0x10,%esp
c002bf46:	e8 f0 19 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bf4b:	81 c3 81 d5 00 00    	add    $0xd581,%ebx
c002bf51:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (locks->b);
c002bf55:	ff 76 04             	pushl  0x4(%esi)
c002bf58:	e8 e0 70 ff ff       	call   c002303d <lock_acquire>
  lock_acquire (locks->a);
c002bf5d:	83 c4 04             	add    $0x4,%esp
c002bf60:	ff 36                	pushl  (%esi)
c002bf62:	e8 d6 70 ff ff       	call   c002303d <lock_acquire>
  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002bf67:	e8 a1 4d ff ff       	call   c0020d0d <thread_get_priority>
c002bf6c:	83 c4 0c             	add    $0xc,%esp
c002bf6f:	50                   	push   %eax
c002bf70:	6a 21                	push   $0x21
c002bf72:	8d 83 34 7c ff ff    	lea    -0x83cc(%ebx),%eax
c002bf78:	50                   	push   %eax
c002bf79:	e8 c8 ef ff ff       	call   c002af46 <msg>
  msg ("Medium thread got the lock.");
c002bf7e:	8d 83 f2 7b ff ff    	lea    -0x840e(%ebx),%eax
c002bf84:	89 04 24             	mov    %eax,(%esp)
c002bf87:	e8 ba ef ff ff       	call   c002af46 <msg>
  lock_release (locks->a);
c002bf8c:	83 c4 04             	add    $0x4,%esp
c002bf8f:	ff 36                	pushl  (%esi)
c002bf91:	e8 9f 72 ff ff       	call   c0023235 <lock_release>
  thread_yield ();
c002bf96:	e8 32 51 ff ff       	call   c00210cd <thread_yield>
  lock_release (locks->b);
c002bf9b:	83 c4 04             	add    $0x4,%esp
c002bf9e:	ff 76 04             	pushl  0x4(%esi)
c002bfa1:	e8 8f 72 ff ff       	call   c0023235 <lock_release>
  thread_yield ();
c002bfa6:	e8 22 51 ff ff       	call   c00210cd <thread_yield>
  msg ("High thread should have just finished.");
c002bfab:	8d 83 74 7c ff ff    	lea    -0x838c(%ebx),%eax
c002bfb1:	89 04 24             	mov    %eax,(%esp)
c002bfb4:	e8 8d ef ff ff       	call   c002af46 <msg>
  msg ("Middle thread finished.");
c002bfb9:	8d 83 0e 7c ff ff    	lea    -0x83f2(%ebx),%eax
c002bfbf:	89 04 24             	mov    %eax,(%esp)
c002bfc2:	e8 7f ef ff ff       	call   c002af46 <msg>
}
c002bfc7:	83 c4 14             	add    $0x14,%esp
c002bfca:	5b                   	pop    %ebx
c002bfcb:	5e                   	pop    %esi
c002bfcc:	c3                   	ret    

c002bfcd <test_priority_donate_nest>:
{
c002bfcd:	55                   	push   %ebp
c002bfce:	57                   	push   %edi
c002bfcf:	56                   	push   %esi
c002bfd0:	53                   	push   %ebx
c002bfd1:	83 ec 5c             	sub    $0x5c,%esp
c002bfd4:	e8 62 19 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002bfd9:	81 c3 f3 d4 00 00    	add    $0xd4f3,%ebx
  ASSERT (!thread_mlfqs);
c002bfdf:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002bfe5:	80 38 00             	cmpb   $0x0,(%eax)
c002bfe8:	0f 85 d4 00 00 00    	jne    c002c0c2 <test_priority_donate_nest+0xf5>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002bfee:	e8 1a 4d ff ff       	call   c0020d0d <thread_get_priority>
c002bff3:	83 f8 1f             	cmp    $0x1f,%eax
c002bff6:	0f 85 ec 00 00 00    	jne    c002c0e8 <test_priority_donate_nest+0x11b>
  lock_init (&a);
c002bffc:	83 ec 0c             	sub    $0xc,%esp
c002bfff:	8d 74 24 38          	lea    0x38(%esp),%esi
c002c003:	56                   	push   %esi
c002c004:	e8 88 6f ff ff       	call   c0022f91 <lock_init>
  lock_init (&b);
c002c009:	83 c4 04             	add    $0x4,%esp
c002c00c:	8d 6c 24 14          	lea    0x14(%esp),%ebp
c002c010:	55                   	push   %ebp
c002c011:	e8 7b 6f ff ff       	call   c0022f91 <lock_init>
  lock_acquire (&a);
c002c016:	89 34 24             	mov    %esi,(%esp)
c002c019:	e8 1f 70 ff ff       	call   c002303d <lock_acquire>
  locks.a = &a;
c002c01e:	89 74 24 10          	mov    %esi,0x10(%esp)
  locks.b = &b;
c002c022:	89 6c 24 14          	mov    %ebp,0x14(%esp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002c026:	8d 44 24 10          	lea    0x10(%esp),%eax
c002c02a:	50                   	push   %eax
c002c02b:	8d 83 75 2a ff ff    	lea    -0xd58b(%ebx),%eax
c002c031:	50                   	push   %eax
c002c032:	6a 20                	push   $0x20
c002c034:	8d 83 26 7c ff ff    	lea    -0x83da(%ebx),%eax
c002c03a:	50                   	push   %eax
c002c03b:	e8 1b 51 ff ff       	call   c002115b <thread_create>
  thread_yield ();
c002c040:	83 c4 20             	add    $0x20,%esp
c002c043:	e8 85 50 ff ff       	call   c00210cd <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c048:	e8 c0 4c ff ff       	call   c0020d0d <thread_get_priority>
c002c04d:	83 ec 04             	sub    $0x4,%esp
c002c050:	50                   	push   %eax
c002c051:	6a 20                	push   $0x20
c002c053:	8d bb c8 7c ff ff    	lea    -0x8338(%ebx),%edi
c002c059:	57                   	push   %edi
c002c05a:	e8 e7 ee ff ff       	call   c002af46 <msg>
  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002c05f:	55                   	push   %ebp
c002c060:	8d 83 31 2a ff ff    	lea    -0xd5cf(%ebx),%eax
c002c066:	50                   	push   %eax
c002c067:	6a 21                	push   $0x21
c002c069:	8d 83 2d 7c ff ff    	lea    -0x83d3(%ebx),%eax
c002c06f:	50                   	push   %eax
c002c070:	e8 e6 50 ff ff       	call   c002115b <thread_create>
  thread_yield ();
c002c075:	83 c4 20             	add    $0x20,%esp
c002c078:	e8 50 50 ff ff       	call   c00210cd <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c07d:	e8 8b 4c ff ff       	call   c0020d0d <thread_get_priority>
c002c082:	83 ec 04             	sub    $0x4,%esp
c002c085:	50                   	push   %eax
c002c086:	6a 21                	push   $0x21
c002c088:	57                   	push   %edi
c002c089:	e8 b8 ee ff ff       	call   c002af46 <msg>
  lock_release (&a);
c002c08e:	89 34 24             	mov    %esi,(%esp)
c002c091:	e8 9f 71 ff ff       	call   c0023235 <lock_release>
  thread_yield ();
c002c096:	e8 32 50 ff ff       	call   c00210cd <thread_yield>
  msg ("Medium thread should just have finished.");
c002c09b:	8d 83 04 7d ff ff    	lea    -0x82fc(%ebx),%eax
c002c0a1:	89 04 24             	mov    %eax,(%esp)
c002c0a4:	e8 9d ee ff ff       	call   c002af46 <msg>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c0a9:	e8 5f 4c ff ff       	call   c0020d0d <thread_get_priority>
c002c0ae:	83 c4 0c             	add    $0xc,%esp
c002c0b1:	50                   	push   %eax
c002c0b2:	6a 1f                	push   $0x1f
c002c0b4:	57                   	push   %edi
c002c0b5:	e8 8c ee ff ff       	call   c002af46 <msg>
}
c002c0ba:	83 c4 6c             	add    $0x6c,%esp
c002c0bd:	5b                   	pop    %ebx
c002c0be:	5e                   	pop    %esi
c002c0bf:	5f                   	pop    %edi
c002c0c0:	5d                   	pop    %ebp
c002c0c1:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c0c2:	83 ec 0c             	sub    $0xc,%esp
c002c0c5:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002c0cb:	50                   	push   %eax
c002c0cc:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c0d2:	50                   	push   %eax
c002c0d3:	8d 83 44 54 ff ff    	lea    -0xabbc(%ebx),%eax
c002c0d9:	50                   	push   %eax
c002c0da:	6a 22                	push   $0x22
c002c0dc:	8d 83 9c 7c ff ff    	lea    -0x8364(%ebx),%eax
c002c0e2:	50                   	push   %eax
c002c0e3:	e8 a7 ce ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c0e8:	83 ec 0c             	sub    $0xc,%esp
c002c0eb:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002c0f1:	50                   	push   %eax
c002c0f2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c0f8:	50                   	push   %eax
c002c0f9:	8d 83 44 54 ff ff    	lea    -0xabbc(%ebx),%eax
c002c0ff:	50                   	push   %eax
c002c100:	6a 25                	push   $0x25
c002c102:	8d 83 9c 7c ff ff    	lea    -0x8364(%ebx),%eax
c002c108:	50                   	push   %eax
c002c109:	e8 81 ce ff ff       	call   c0028f8f <debug_panic>

c002c10e <h_thread_func>:
  msg ("Thread M finished.");
}

static void
h_thread_func (void *ls_) 
{
c002c10e:	56                   	push   %esi
c002c10f:	53                   	push   %ebx
c002c110:	83 ec 10             	sub    $0x10,%esp
c002c113:	e8 23 18 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c118:	81 c3 b4 d3 00 00    	add    $0xd3b4,%ebx
c002c11e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock_and_sema *ls = ls_;

  lock_acquire (&ls->lock);
c002c122:	56                   	push   %esi
c002c123:	e8 15 6f ff ff       	call   c002303d <lock_acquire>
  msg ("Thread H acquired lock.");
c002c128:	8d 83 2d 7d ff ff    	lea    -0x82d3(%ebx),%eax
c002c12e:	89 04 24             	mov    %eax,(%esp)
c002c131:	e8 10 ee ff ff       	call   c002af46 <msg>

  sema_up (&ls->sema);
c002c136:	8d 46 24             	lea    0x24(%esi),%eax
c002c139:	89 04 24             	mov    %eax,(%esp)
c002c13c:	e8 f6 6c ff ff       	call   c0022e37 <sema_up>
  lock_release (&ls->lock);
c002c141:	89 34 24             	mov    %esi,(%esp)
c002c144:	e8 ec 70 ff ff       	call   c0023235 <lock_release>
  msg ("Thread H finished.");
c002c149:	8d 83 45 7d ff ff    	lea    -0x82bb(%ebx),%eax
c002c14f:	89 04 24             	mov    %eax,(%esp)
c002c152:	e8 ef ed ff ff       	call   c002af46 <msg>
}
c002c157:	83 c4 14             	add    $0x14,%esp
c002c15a:	5b                   	pop    %ebx
c002c15b:	5e                   	pop    %esi
c002c15c:	c3                   	ret    

c002c15d <m_thread_func>:
{
c002c15d:	53                   	push   %ebx
c002c15e:	83 ec 14             	sub    $0x14,%esp
c002c161:	e8 d5 17 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c166:	81 c3 66 d3 00 00    	add    $0xd366,%ebx
  sema_down (&ls->sema);
c002c16c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002c170:	83 c0 24             	add    $0x24,%eax
c002c173:	50                   	push   %eax
c002c174:	e8 96 6b ff ff       	call   c0022d0f <sema_down>
  msg ("Thread M finished.");
c002c179:	8d 83 58 7d ff ff    	lea    -0x82a8(%ebx),%eax
c002c17f:	89 04 24             	mov    %eax,(%esp)
c002c182:	e8 bf ed ff ff       	call   c002af46 <msg>
}
c002c187:	83 c4 18             	add    $0x18,%esp
c002c18a:	5b                   	pop    %ebx
c002c18b:	c3                   	ret    

c002c18c <l_thread_func>:
{
c002c18c:	56                   	push   %esi
c002c18d:	53                   	push   %ebx
c002c18e:	83 ec 10             	sub    $0x10,%esp
c002c191:	e8 a5 17 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c196:	81 c3 36 d3 00 00    	add    $0xd336,%ebx
c002c19c:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_acquire (&ls->lock);
c002c1a0:	56                   	push   %esi
c002c1a1:	e8 97 6e ff ff       	call   c002303d <lock_acquire>
  msg ("Thread L acquired lock.");
c002c1a6:	8d 83 6b 7d ff ff    	lea    -0x8295(%ebx),%eax
c002c1ac:	89 04 24             	mov    %eax,(%esp)
c002c1af:	e8 92 ed ff ff       	call   c002af46 <msg>
  sema_down (&ls->sema);
c002c1b4:	8d 46 24             	lea    0x24(%esi),%eax
c002c1b7:	89 04 24             	mov    %eax,(%esp)
c002c1ba:	e8 50 6b ff ff       	call   c0022d0f <sema_down>
  msg ("Thread L downed semaphore.");
c002c1bf:	8d 83 83 7d ff ff    	lea    -0x827d(%ebx),%eax
c002c1c5:	89 04 24             	mov    %eax,(%esp)
c002c1c8:	e8 79 ed ff ff       	call   c002af46 <msg>
  lock_release (&ls->lock);
c002c1cd:	89 34 24             	mov    %esi,(%esp)
c002c1d0:	e8 60 70 ff ff       	call   c0023235 <lock_release>
  msg ("Thread L finished.");
c002c1d5:	8d 83 9e 7d ff ff    	lea    -0x8262(%ebx),%eax
c002c1db:	89 04 24             	mov    %eax,(%esp)
c002c1de:	e8 63 ed ff ff       	call   c002af46 <msg>
}
c002c1e3:	83 c4 14             	add    $0x14,%esp
c002c1e6:	5b                   	pop    %ebx
c002c1e7:	5e                   	pop    %esi
c002c1e8:	c3                   	ret    

c002c1e9 <test_priority_donate_sema>:
{
c002c1e9:	57                   	push   %edi
c002c1ea:	56                   	push   %esi
c002c1eb:	53                   	push   %ebx
c002c1ec:	83 ec 40             	sub    $0x40,%esp
c002c1ef:	e8 47 17 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c1f4:	81 c3 d8 d2 00 00    	add    $0xd2d8,%ebx
  ASSERT (!thread_mlfqs);
c002c1fa:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002c200:	80 38 00             	cmpb   $0x0,(%eax)
c002c203:	0f 85 8d 00 00 00    	jne    c002c296 <test_priority_donate_sema+0xad>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c209:	e8 ff 4a ff ff       	call   c0020d0d <thread_get_priority>
c002c20e:	83 f8 1f             	cmp    $0x1f,%eax
c002c211:	0f 85 a5 00 00 00    	jne    c002c2bc <test_priority_donate_sema+0xd3>
  lock_init (&ls.lock);
c002c217:	83 ec 0c             	sub    $0xc,%esp
c002c21a:	8d 74 24 14          	lea    0x14(%esp),%esi
c002c21e:	56                   	push   %esi
c002c21f:	e8 6d 6d ff ff       	call   c0022f91 <lock_init>
  sema_init (&ls.sema, 0);
c002c224:	83 c4 08             	add    $0x8,%esp
c002c227:	6a 00                	push   $0x0
c002c229:	8d 7c 24 38          	lea    0x38(%esp),%edi
c002c22d:	57                   	push   %edi
c002c22e:	e8 88 6a ff ff       	call   c0022cbb <sema_init>
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002c233:	56                   	push   %esi
c002c234:	8d 83 c0 2c ff ff    	lea    -0xd340(%ebx),%eax
c002c23a:	50                   	push   %eax
c002c23b:	6a 20                	push   $0x20
c002c23d:	8d 83 b1 7d ff ff    	lea    -0x824f(%ebx),%eax
c002c243:	50                   	push   %eax
c002c244:	e8 12 4f ff ff       	call   c002115b <thread_create>
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002c249:	83 c4 20             	add    $0x20,%esp
c002c24c:	56                   	push   %esi
c002c24d:	8d 83 91 2c ff ff    	lea    -0xd36f(%ebx),%eax
c002c253:	50                   	push   %eax
c002c254:	6a 22                	push   $0x22
c002c256:	8d 83 b5 7d ff ff    	lea    -0x824b(%ebx),%eax
c002c25c:	50                   	push   %eax
c002c25d:	e8 f9 4e ff ff       	call   c002115b <thread_create>
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002c262:	56                   	push   %esi
c002c263:	8d 83 42 2c ff ff    	lea    -0xd3be(%ebx),%eax
c002c269:	50                   	push   %eax
c002c26a:	6a 24                	push   $0x24
c002c26c:	8d 83 2d 7c ff ff    	lea    -0x83d3(%ebx),%eax
c002c272:	50                   	push   %eax
c002c273:	e8 e3 4e ff ff       	call   c002115b <thread_create>
  sema_up (&ls.sema);
c002c278:	83 c4 14             	add    $0x14,%esp
c002c27b:	57                   	push   %edi
c002c27c:	e8 b6 6b ff ff       	call   c0022e37 <sema_up>
  msg ("Main thread finished.");
c002c281:	8d 83 b9 7d ff ff    	lea    -0x8247(%ebx),%eax
c002c287:	89 04 24             	mov    %eax,(%esp)
c002c28a:	e8 b7 ec ff ff       	call   c002af46 <msg>
}
c002c28f:	83 c4 50             	add    $0x50,%esp
c002c292:	5b                   	pop    %ebx
c002c293:	5e                   	pop    %esi
c002c294:	5f                   	pop    %edi
c002c295:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c296:	83 ec 0c             	sub    $0xc,%esp
c002c299:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002c29f:	50                   	push   %eax
c002c2a0:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c2a6:	50                   	push   %eax
c002c2a7:	8d 83 60 54 ff ff    	lea    -0xaba0(%ebx),%eax
c002c2ad:	50                   	push   %eax
c002c2ae:	6a 23                	push   $0x23
c002c2b0:	8d 83 d0 7d ff ff    	lea    -0x8230(%ebx),%eax
c002c2b6:	50                   	push   %eax
c002c2b7:	e8 d3 cc ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c2bc:	83 ec 0c             	sub    $0xc,%esp
c002c2bf:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002c2c5:	50                   	push   %eax
c002c2c6:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c2cc:	50                   	push   %eax
c002c2cd:	8d 83 60 54 ff ff    	lea    -0xaba0(%ebx),%eax
c002c2d3:	50                   	push   %eax
c002c2d4:	6a 26                	push   $0x26
c002c2d6:	8d 83 d0 7d ff ff    	lea    -0x8230(%ebx),%eax
c002c2dc:	50                   	push   %eax
c002c2dd:	e8 ad cc ff ff       	call   c0028f8f <debug_panic>

c002c2e2 <acquire_thread_func>:
       PRI_DEFAULT - 10, thread_get_priority ());
}

static void
acquire_thread_func (void *lock_) 
{
c002c2e2:	56                   	push   %esi
c002c2e3:	53                   	push   %ebx
c002c2e4:	83 ec 10             	sub    $0x10,%esp
c002c2e7:	e8 4f 16 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c2ec:	81 c3 e0 d1 00 00    	add    $0xd1e0,%ebx
c002c2f2:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct lock *lock = lock_;

  lock_acquire (lock);
c002c2f6:	56                   	push   %esi
c002c2f7:	e8 41 6d ff ff       	call   c002303d <lock_acquire>
  msg ("acquire: got the lock");
c002c2fc:	8d 83 fb 7d ff ff    	lea    -0x8205(%ebx),%eax
c002c302:	89 04 24             	mov    %eax,(%esp)
c002c305:	e8 3c ec ff ff       	call   c002af46 <msg>
  lock_release (lock);
c002c30a:	89 34 24             	mov    %esi,(%esp)
c002c30d:	e8 23 6f ff ff       	call   c0023235 <lock_release>
  msg ("acquire: done");
c002c312:	8d 83 11 7e ff ff    	lea    -0x81ef(%ebx),%eax
c002c318:	89 04 24             	mov    %eax,(%esp)
c002c31b:	e8 26 ec ff ff       	call   c002af46 <msg>
}
c002c320:	83 c4 14             	add    $0x14,%esp
c002c323:	5b                   	pop    %ebx
c002c324:	5e                   	pop    %esi
c002c325:	c3                   	ret    

c002c326 <test_priority_donate_lower>:
{
c002c326:	57                   	push   %edi
c002c327:	56                   	push   %esi
c002c328:	53                   	push   %ebx
c002c329:	83 ec 30             	sub    $0x30,%esp
c002c32c:	e8 0a 16 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c331:	81 c3 9b d1 00 00    	add    $0xd19b,%ebx
  ASSERT (!thread_mlfqs);
c002c337:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002c33d:	80 38 00             	cmpb   $0x0,(%eax)
c002c340:	0f 85 ac 00 00 00    	jne    c002c3f2 <test_priority_donate_lower+0xcc>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c346:	e8 c2 49 ff ff       	call   c0020d0d <thread_get_priority>
c002c34b:	83 f8 1f             	cmp    $0x1f,%eax
c002c34e:	0f 85 c4 00 00 00    	jne    c002c418 <test_priority_donate_lower+0xf2>
  lock_init (&lock);
c002c354:	83 ec 0c             	sub    $0xc,%esp
c002c357:	8d 74 24 18          	lea    0x18(%esp),%esi
c002c35b:	56                   	push   %esi
c002c35c:	e8 30 6c ff ff       	call   c0022f91 <lock_init>
  lock_acquire (&lock);
c002c361:	89 34 24             	mov    %esi,(%esp)
c002c364:	e8 d4 6c ff ff       	call   c002303d <lock_acquire>
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002c369:	56                   	push   %esi
c002c36a:	8d 83 16 2e ff ff    	lea    -0xd1ea(%ebx),%eax
c002c370:	50                   	push   %eax
c002c371:	6a 29                	push   $0x29
c002c373:	8d 83 1f 7e ff ff    	lea    -0x81e1(%ebx),%eax
c002c379:	50                   	push   %eax
c002c37a:	e8 dc 4d ff ff       	call   c002115b <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c37f:	83 c4 20             	add    $0x20,%esp
c002c382:	e8 86 49 ff ff       	call   c0020d0d <thread_get_priority>
c002c387:	83 ec 04             	sub    $0x4,%esp
c002c38a:	50                   	push   %eax
c002c38b:	6a 29                	push   $0x29
c002c38d:	8d bb c0 7a ff ff    	lea    -0x8540(%ebx),%edi
c002c393:	57                   	push   %edi
c002c394:	e8 ad eb ff ff       	call   c002af46 <msg>
  msg ("Lowering base priority...");
c002c399:	8d 83 27 7e ff ff    	lea    -0x81d9(%ebx),%eax
c002c39f:	89 04 24             	mov    %eax,(%esp)
c002c3a2:	e8 9f eb ff ff       	call   c002af46 <msg>
  thread_set_priority (PRI_DEFAULT - 10);
c002c3a7:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c002c3ae:	e8 5f 4f ff ff       	call   c0021312 <thread_set_priority>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c3b3:	e8 55 49 ff ff       	call   c0020d0d <thread_get_priority>
c002c3b8:	83 c4 0c             	add    $0xc,%esp
c002c3bb:	50                   	push   %eax
c002c3bc:	6a 29                	push   $0x29
c002c3be:	57                   	push   %edi
c002c3bf:	e8 82 eb ff ff       	call   c002af46 <msg>
  lock_release (&lock);
c002c3c4:	89 34 24             	mov    %esi,(%esp)
c002c3c7:	e8 69 6e ff ff       	call   c0023235 <lock_release>
  msg ("acquire must already have finished.");
c002c3cc:	8d 83 70 7e ff ff    	lea    -0x8190(%ebx),%eax
c002c3d2:	89 04 24             	mov    %eax,(%esp)
c002c3d5:	e8 6c eb ff ff       	call   c002af46 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c3da:	e8 2e 49 ff ff       	call   c0020d0d <thread_get_priority>
c002c3df:	83 c4 0c             	add    $0xc,%esp
c002c3e2:	50                   	push   %eax
c002c3e3:	6a 15                	push   $0x15
c002c3e5:	57                   	push   %edi
c002c3e6:	e8 5b eb ff ff       	call   c002af46 <msg>
}
c002c3eb:	83 c4 40             	add    $0x40,%esp
c002c3ee:	5b                   	pop    %ebx
c002c3ef:	5e                   	pop    %esi
c002c3f0:	5f                   	pop    %edi
c002c3f1:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c3f2:	83 ec 0c             	sub    $0xc,%esp
c002c3f5:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002c3fb:	50                   	push   %eax
c002c3fc:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c402:	50                   	push   %eax
c002c403:	8d 83 7c 54 ff ff    	lea    -0xab84(%ebx),%eax
c002c409:	50                   	push   %eax
c002c40a:	6a 15                	push   $0x15
c002c40c:	8d 83 44 7e ff ff    	lea    -0x81bc(%ebx),%eax
c002c412:	50                   	push   %eax
c002c413:	e8 77 cb ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c418:	83 ec 0c             	sub    $0xc,%esp
c002c41b:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002c421:	50                   	push   %eax
c002c422:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c428:	50                   	push   %eax
c002c429:	8d 83 7c 54 ff ff    	lea    -0xab84(%ebx),%eax
c002c42f:	50                   	push   %eax
c002c430:	6a 18                	push   $0x18
c002c432:	8d 83 44 7e ff ff    	lea    -0x81bc(%ebx),%eax
c002c438:	50                   	push   %eax
c002c439:	e8 51 cb ff ff       	call   c0028f8f <debug_panic>

c002c43e <simple_thread_func>:
    }
}

static void 
simple_thread_func (void *data_) 
{
c002c43e:	57                   	push   %edi
c002c43f:	56                   	push   %esi
c002c440:	53                   	push   %ebx
c002c441:	e8 f5 14 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c446:	81 c3 86 d0 00 00    	add    $0xd086,%ebx
c002c44c:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c450:	bf 10 00 00 00       	mov    $0x10,%edi
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
    {
      lock_acquire (data->lock);
c002c455:	83 ec 0c             	sub    $0xc,%esp
c002c458:	ff 76 08             	pushl  0x8(%esi)
c002c45b:	e8 dd 6b ff ff       	call   c002303d <lock_acquire>
      *(*data->op)++ = data->id;
c002c460:	8b 56 0c             	mov    0xc(%esi),%edx
c002c463:	8b 02                	mov    (%edx),%eax
c002c465:	8d 48 04             	lea    0x4(%eax),%ecx
c002c468:	89 0a                	mov    %ecx,(%edx)
c002c46a:	8b 16                	mov    (%esi),%edx
c002c46c:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002c46e:	83 c4 04             	add    $0x4,%esp
c002c471:	ff 76 08             	pushl  0x8(%esi)
c002c474:	e8 bc 6d ff ff       	call   c0023235 <lock_release>
      thread_yield ();
c002c479:	e8 4f 4c ff ff       	call   c00210cd <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002c47e:	83 c4 10             	add    $0x10,%esp
c002c481:	83 ef 01             	sub    $0x1,%edi
c002c484:	75 cf                	jne    c002c455 <simple_thread_func+0x17>
    }
}
c002c486:	5b                   	pop    %ebx
c002c487:	5e                   	pop    %esi
c002c488:	5f                   	pop    %edi
c002c489:	c3                   	ret    

c002c48a <test_priority_fifo>:
{
c002c48a:	55                   	push   %ebp
c002c48b:	57                   	push   %edi
c002c48c:	56                   	push   %esi
c002c48d:	53                   	push   %ebx
c002c48e:	81 ec 5c 01 00 00    	sub    $0x15c,%esp
c002c494:	e8 a2 14 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c499:	81 c3 33 d0 00 00    	add    $0xd033,%ebx
  ASSERT (!thread_mlfqs);
c002c49f:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002c4a5:	80 38 00             	cmpb   $0x0,(%eax)
c002c4a8:	0f 85 15 01 00 00    	jne    c002c5c3 <test_priority_fifo+0x139>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c4ae:	e8 5a 48 ff ff       	call   c0020d0d <thread_get_priority>
c002c4b3:	83 f8 1f             	cmp    $0x1f,%eax
c002c4b6:	0f 85 2d 01 00 00    	jne    c002c5e9 <test_priority_fifo+0x15f>
  msg ("%d threads will iterate %d times in the same order each time.",
c002c4bc:	83 ec 04             	sub    $0x4,%esp
c002c4bf:	6a 10                	push   $0x10
c002c4c1:	6a 10                	push   $0x10
c002c4c3:	8d 83 e8 7e ff ff    	lea    -0x8118(%ebx),%eax
c002c4c9:	50                   	push   %eax
c002c4ca:	e8 77 ea ff ff       	call   c002af46 <msg>
  msg ("If the order varies then there is a bug.");
c002c4cf:	8d 83 28 7f ff ff    	lea    -0x80d8(%ebx),%eax
c002c4d5:	89 04 24             	mov    %eax,(%esp)
c002c4d8:	e8 69 ea ff ff       	call   c002af46 <msg>
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002c4dd:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
c002c4e4:	e8 55 77 ff ff       	call   c0023c3e <malloc>
c002c4e9:	89 c5                	mov    %eax,%ebp
c002c4eb:	89 44 24 38          	mov    %eax,0x38(%esp)
  ASSERT (output != NULL);
c002c4ef:	83 c4 10             	add    $0x10,%esp
c002c4f2:	85 c0                	test   %eax,%eax
c002c4f4:	0f 84 15 01 00 00    	je     c002c60f <test_priority_fifo+0x185>
  lock_init (&lock);
c002c4fa:	83 ec 0c             	sub    $0xc,%esp
c002c4fd:	8d 44 24 38          	lea    0x38(%esp),%eax
c002c501:	50                   	push   %eax
c002c502:	e8 8a 6a ff ff       	call   c0022f91 <lock_init>
  thread_set_priority (PRI_DEFAULT + 2);
c002c507:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c002c50e:	e8 ff 4d ff ff       	call   c0021312 <thread_set_priority>
c002c513:	8d 74 24 60          	lea    0x60(%esp),%esi
c002c517:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002c51a:	bf 00 00 00 00       	mov    $0x0,%edi
      snprintf (name, sizeof name, "%d", i);
c002c51f:	8d 83 dc 74 ff ff    	lea    -0x8b24(%ebx),%eax
c002c525:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002c529:	8d 44 24 18          	lea    0x18(%esp),%eax
c002c52d:	89 44 24 08          	mov    %eax,0x8(%esp)
c002c531:	57                   	push   %edi
c002c532:	ff 74 24 10          	pushl  0x10(%esp)
c002c536:	6a 10                	push   $0x10
c002c538:	ff 74 24 14          	pushl  0x14(%esp)
c002c53c:	e8 d8 b5 ff ff       	call   c0027b19 <snprintf>
      d->id = i;
c002c541:	89 3e                	mov    %edi,(%esi)
      d->iterations = 0;
c002c543:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
      d->lock = &lock;
c002c54a:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c002c54e:	89 46 08             	mov    %eax,0x8(%esi)
      d->op = &op;
c002c551:	8d 44 24 38          	lea    0x38(%esp),%eax
c002c555:	89 46 0c             	mov    %eax,0xc(%esi)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002c558:	56                   	push   %esi
c002c559:	8d 83 72 2f ff ff    	lea    -0xd08e(%ebx),%eax
c002c55f:	50                   	push   %eax
c002c560:	6a 20                	push   $0x20
c002c562:	ff 74 24 24          	pushl  0x24(%esp)
c002c566:	e8 f0 4b ff ff       	call   c002115b <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002c56b:	83 c7 01             	add    $0x1,%edi
c002c56e:	83 c6 10             	add    $0x10,%esi
c002c571:	83 c4 20             	add    $0x20,%esp
c002c574:	83 ff 10             	cmp    $0x10,%edi
c002c577:	75 b8                	jne    c002c531 <test_priority_fifo+0xa7>
  thread_set_priority (PRI_DEFAULT);
c002c579:	83 ec 0c             	sub    $0xc,%esp
c002c57c:	6a 1f                	push   $0x1f
c002c57e:	e8 8f 4d ff ff       	call   c0021312 <thread_set_priority>
  ASSERT (lock.holder == NULL);
c002c583:	83 c4 10             	add    $0x10,%esp
c002c586:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c002c58b:	0f 85 a4 00 00 00    	jne    c002c635 <test_priority_fifo+0x1ab>
  for (; output < op; output++) 
c002c591:	3b 6c 24 28          	cmp    0x28(%esp),%ebp
c002c595:	0f 83 49 01 00 00    	jae    c002c6e4 <test_priority_fifo+0x25a>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002c59b:	8b 75 00             	mov    0x0(%ebp),%esi
c002c59e:	83 fe 0f             	cmp    $0xf,%esi
c002c5a1:	0f 87 b4 00 00 00    	ja     c002c65b <test_priority_fifo+0x1d1>
  cnt = 0;
c002c5a7:	bf 00 00 00 00       	mov    $0x0,%edi
      d = data + *output;
c002c5ac:	8d 44 24 50          	lea    0x50(%esp),%eax
c002c5b0:	89 44 24 08          	mov    %eax,0x8(%esp)
        printf ("(priority-fifo) iteration:");
c002c5b4:	8d 83 a8 7e ff ff    	lea    -0x8158(%ebx),%eax
c002c5ba:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002c5be:	e9 e4 00 00 00       	jmp    c002c6a7 <test_priority_fifo+0x21d>
  ASSERT (!thread_mlfqs);
c002c5c3:	83 ec 0c             	sub    $0xc,%esp
c002c5c6:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002c5cc:	50                   	push   %eax
c002c5cd:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c5d3:	50                   	push   %eax
c002c5d4:	8d 83 98 54 ff ff    	lea    -0xab68(%ebx),%eax
c002c5da:	50                   	push   %eax
c002c5db:	6a 28                	push   $0x28
c002c5dd:	8d 83 c4 7e ff ff    	lea    -0x813c(%ebx),%eax
c002c5e3:	50                   	push   %eax
c002c5e4:	e8 a6 c9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c5e9:	83 ec 0c             	sub    $0xc,%esp
c002c5ec:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002c5f2:	50                   	push   %eax
c002c5f3:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c5f9:	50                   	push   %eax
c002c5fa:	8d 83 98 54 ff ff    	lea    -0xab68(%ebx),%eax
c002c600:	50                   	push   %eax
c002c601:	6a 2b                	push   $0x2b
c002c603:	8d 83 c4 7e ff ff    	lea    -0x813c(%ebx),%eax
c002c609:	50                   	push   %eax
c002c60a:	e8 80 c9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (output != NULL);
c002c60f:	83 ec 0c             	sub    $0xc,%esp
c002c612:	8d 83 c6 74 ff ff    	lea    -0x8b3a(%ebx),%eax
c002c618:	50                   	push   %eax
c002c619:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c61f:	50                   	push   %eax
c002c620:	8d 83 98 54 ff ff    	lea    -0xab68(%ebx),%eax
c002c626:	50                   	push   %eax
c002c627:	6a 32                	push   $0x32
c002c629:	8d 83 c4 7e ff ff    	lea    -0x813c(%ebx),%eax
c002c62f:	50                   	push   %eax
c002c630:	e8 5a c9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (lock.holder == NULL);
c002c635:	83 ec 0c             	sub    $0xc,%esp
c002c638:	8d 83 94 7e ff ff    	lea    -0x816c(%ebx),%eax
c002c63e:	50                   	push   %eax
c002c63f:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c645:	50                   	push   %eax
c002c646:	8d 83 98 54 ff ff    	lea    -0xab68(%ebx),%eax
c002c64c:	50                   	push   %eax
c002c64d:	6a 44                	push   $0x44
c002c64f:	8d 83 c4 7e ff ff    	lea    -0x813c(%ebx),%eax
c002c655:	50                   	push   %eax
c002c656:	e8 34 c9 ff ff       	call   c0028f8f <debug_panic>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002c65b:	83 ec 0c             	sub    $0xc,%esp
c002c65e:	8d 83 54 7f ff ff    	lea    -0x80ac(%ebx),%eax
c002c664:	50                   	push   %eax
c002c665:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c66b:	50                   	push   %eax
c002c66c:	8d 83 98 54 ff ff    	lea    -0xab68(%ebx),%eax
c002c672:	50                   	push   %eax
c002c673:	6a 4b                	push   $0x4b
c002c675:	8d 83 c4 7e ff ff    	lea    -0x813c(%ebx),%eax
c002c67b:	50                   	push   %eax
c002c67c:	e8 0e c9 ff ff       	call   c0028f8f <debug_panic>
        printf ("(priority-fifo) iteration:");
c002c681:	83 ec 0c             	sub    $0xc,%esp
c002c684:	ff 74 24 18          	pushl  0x18(%esp)
c002c688:	e8 6b ab ff ff       	call   c00271f8 <printf>
c002c68d:	83 c4 10             	add    $0x10,%esp
c002c690:	eb 24                	jmp    c002c6b6 <test_priority_fifo+0x22c>
      d->iterations++;
c002c692:	83 46 04 01          	addl   $0x1,0x4(%esi)
  for (; output < op; output++) 
c002c696:	83 c5 04             	add    $0x4,%ebp
c002c699:	39 6c 24 28          	cmp    %ebp,0x28(%esp)
c002c69d:	76 45                	jbe    c002c6e4 <test_priority_fifo+0x25a>
      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002c69f:	8b 75 00             	mov    0x0(%ebp),%esi
c002c6a2:	83 fe 0f             	cmp    $0xf,%esi
c002c6a5:	77 b4                	ja     c002c65b <test_priority_fifo+0x1d1>
      d = data + *output;
c002c6a7:	c1 e6 04             	shl    $0x4,%esi
c002c6aa:	03 74 24 08          	add    0x8(%esp),%esi
      if (cnt % THREAD_CNT == 0)
c002c6ae:	f7 c7 0f 00 00 00    	test   $0xf,%edi
c002c6b4:	74 cb                	je     c002c681 <test_priority_fifo+0x1f7>
      printf (" %d", d->id);
c002c6b6:	83 ec 08             	sub    $0x8,%esp
c002c6b9:	ff 36                	pushl  (%esi)
c002c6bb:	8d 83 db 74 ff ff    	lea    -0x8b25(%ebx),%eax
c002c6c1:	50                   	push   %eax
c002c6c2:	e8 31 ab ff ff       	call   c00271f8 <printf>
      if (++cnt % THREAD_CNT == 0)
c002c6c7:	83 c7 01             	add    $0x1,%edi
c002c6ca:	83 c4 10             	add    $0x10,%esp
c002c6cd:	f7 c7 0f 00 00 00    	test   $0xf,%edi
c002c6d3:	75 bd                	jne    c002c692 <test_priority_fifo+0x208>
        printf ("\n");
c002c6d5:	83 ec 0c             	sub    $0xc,%esp
c002c6d8:	6a 0a                	push   $0xa
c002c6da:	e8 46 e8 ff ff       	call   c002af25 <putchar>
c002c6df:	83 c4 10             	add    $0x10,%esp
c002c6e2:	eb ae                	jmp    c002c692 <test_priority_fifo+0x208>
}
c002c6e4:	81 c4 5c 01 00 00    	add    $0x15c,%esp
c002c6ea:	5b                   	pop    %ebx
c002c6eb:	5e                   	pop    %esi
c002c6ec:	5f                   	pop    %edi
c002c6ed:	5d                   	pop    %ebp
c002c6ee:	c3                   	ret    

c002c6ef <simple_thread_func>:
  msg ("The high-priority thread should have already completed.");
}

static void 
simple_thread_func (void *aux UNUSED) 
{
c002c6ef:	57                   	push   %edi
c002c6f0:	56                   	push   %esi
c002c6f1:	53                   	push   %ebx
c002c6f2:	e8 44 12 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c6f7:	81 c3 d5 cd 00 00    	add    $0xcdd5,%ebx
  int i;
  
  for (i = 0; i < 5; i++) 
c002c6fd:	be 00 00 00 00       	mov    $0x0,%esi
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002c702:	8d bb 79 7f ff ff    	lea    -0x8087(%ebx),%edi
c002c708:	e8 4e 45 ff ff       	call   c0020c5b <thread_name>
c002c70d:	83 ec 04             	sub    $0x4,%esp
c002c710:	56                   	push   %esi
c002c711:	50                   	push   %eax
c002c712:	57                   	push   %edi
c002c713:	e8 2e e8 ff ff       	call   c002af46 <msg>
      thread_yield ();
c002c718:	e8 b0 49 ff ff       	call   c00210cd <thread_yield>
  for (i = 0; i < 5; i++) 
c002c71d:	83 c6 01             	add    $0x1,%esi
c002c720:	83 c4 10             	add    $0x10,%esp
c002c723:	83 fe 05             	cmp    $0x5,%esi
c002c726:	75 e0                	jne    c002c708 <simple_thread_func+0x19>
    }
  msg ("Thread %s done!", thread_name ());
c002c728:	e8 2e 45 ff ff       	call   c0020c5b <thread_name>
c002c72d:	83 ec 08             	sub    $0x8,%esp
c002c730:	50                   	push   %eax
c002c731:	8d 83 90 7f ff ff    	lea    -0x8070(%ebx),%eax
c002c737:	50                   	push   %eax
c002c738:	e8 09 e8 ff ff       	call   c002af46 <msg>
}
c002c73d:	83 c4 10             	add    $0x10,%esp
c002c740:	5b                   	pop    %ebx
c002c741:	5e                   	pop    %esi
c002c742:	5f                   	pop    %edi
c002c743:	c3                   	ret    

c002c744 <test_priority_preempt>:
{
c002c744:	53                   	push   %ebx
c002c745:	83 ec 08             	sub    $0x8,%esp
c002c748:	e8 ee 11 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c74d:	81 c3 7f cd 00 00    	add    $0xcd7f,%ebx
  ASSERT (!thread_mlfqs);
c002c753:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002c759:	80 38 00             	cmpb   $0x0,(%eax)
c002c75c:	75 34                	jne    c002c792 <test_priority_preempt+0x4e>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c75e:	e8 aa 45 ff ff       	call   c0020d0d <thread_get_priority>
c002c763:	83 f8 1f             	cmp    $0x1f,%eax
c002c766:	75 50                	jne    c002c7b8 <test_priority_preempt+0x74>
  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002c768:	6a 00                	push   $0x0
c002c76a:	8d 83 23 32 ff ff    	lea    -0xcddd(%ebx),%eax
c002c770:	50                   	push   %eax
c002c771:	6a 20                	push   $0x20
c002c773:	8d 83 a0 7f ff ff    	lea    -0x8060(%ebx),%eax
c002c779:	50                   	push   %eax
c002c77a:	e8 dc 49 ff ff       	call   c002115b <thread_create>
  msg ("The high-priority thread should have already completed.");
c002c77f:	8d 83 d8 7f ff ff    	lea    -0x8028(%ebx),%eax
c002c785:	89 04 24             	mov    %eax,(%esp)
c002c788:	e8 b9 e7 ff ff       	call   c002af46 <msg>
}
c002c78d:	83 c4 18             	add    $0x18,%esp
c002c790:	5b                   	pop    %ebx
c002c791:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c792:	83 ec 0c             	sub    $0xc,%esp
c002c795:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002c79b:	50                   	push   %eax
c002c79c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c7a2:	50                   	push   %eax
c002c7a3:	8d 83 ac 54 ff ff    	lea    -0xab54(%ebx),%eax
c002c7a9:	50                   	push   %eax
c002c7aa:	6a 15                	push   $0x15
c002c7ac:	8d 83 b0 7f ff ff    	lea    -0x8050(%ebx),%eax
c002c7b2:	50                   	push   %eax
c002c7b3:	e8 d7 c7 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c7b8:	83 ec 0c             	sub    $0xc,%esp
c002c7bb:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
c002c7c1:	50                   	push   %eax
c002c7c2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c7c8:	50                   	push   %eax
c002c7c9:	8d 83 ac 54 ff ff    	lea    -0xab54(%ebx),%eax
c002c7cf:	50                   	push   %eax
c002c7d0:	6a 18                	push   $0x18
c002c7d2:	8d 83 b0 7f ff ff    	lea    -0x8050(%ebx),%eax
c002c7d8:	50                   	push   %eax
c002c7d9:	e8 b1 c7 ff ff       	call   c0028f8f <debug_panic>

c002c7de <priority_sema_thread>:
    }
}

static void
priority_sema_thread (void *aux UNUSED) 
{
c002c7de:	53                   	push   %ebx
c002c7df:	83 ec 14             	sub    $0x14,%esp
c002c7e2:	e8 54 11 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c7e7:	81 c3 e5 cc 00 00    	add    $0xcce5,%ebx
  sema_down (&sema);
c002c7ed:	8d 83 9c 23 00 00    	lea    0x239c(%ebx),%eax
c002c7f3:	50                   	push   %eax
c002c7f4:	e8 16 65 ff ff       	call   c0022d0f <sema_down>
  msg ("Thread %s woke up.", thread_name ());
c002c7f9:	e8 5d 44 ff ff       	call   c0020c5b <thread_name>
c002c7fe:	83 c4 08             	add    $0x8,%esp
c002c801:	50                   	push   %eax
c002c802:	8d 83 ac 77 ff ff    	lea    -0x8854(%ebx),%eax
c002c808:	50                   	push   %eax
c002c809:	e8 38 e7 ff ff       	call   c002af46 <msg>
}
c002c80e:	83 c4 18             	add    $0x18,%esp
c002c811:	5b                   	pop    %ebx
c002c812:	c3                   	ret    

c002c813 <test_priority_sema>:
{
c002c813:	55                   	push   %ebp
c002c814:	57                   	push   %edi
c002c815:	56                   	push   %esi
c002c816:	53                   	push   %ebx
c002c817:	83 ec 1c             	sub    $0x1c,%esp
c002c81a:	e8 1c 11 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c81f:	81 c3 ad cc 00 00    	add    $0xccad,%ebx
  ASSERT (!thread_mlfqs);
c002c825:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002c82b:	80 38 00             	cmpb   $0x0,(%eax)
c002c82e:	0f 85 a7 00 00 00    	jne    c002c8db <test_priority_sema+0xc8>
  sema_init (&sema, 0);
c002c834:	83 ec 08             	sub    $0x8,%esp
c002c837:	6a 00                	push   $0x0
c002c839:	8d 83 9c 23 00 00    	lea    0x239c(%ebx),%eax
c002c83f:	50                   	push   %eax
c002c840:	e8 76 64 ff ff       	call   c0022cbb <sema_init>
  thread_set_priority (PRI_MIN);
c002c845:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002c84c:	e8 c1 4a ff ff       	call   c0021312 <thread_set_priority>
c002c851:	83 c4 10             	add    $0x10,%esp
c002c854:	be 03 00 00 00       	mov    $0x3,%esi
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002c859:	b8 67 66 66 66       	mov    $0x66666667,%eax
c002c85e:	f7 ee                	imul   %esi
c002c860:	c1 fa 02             	sar    $0x2,%edx
c002c863:	89 f0                	mov    %esi,%eax
c002c865:	c1 f8 1f             	sar    $0x1f,%eax
c002c868:	29 c2                	sub    %eax,%edx
c002c86a:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002c86d:	01 c0                	add    %eax,%eax
c002c86f:	89 f1                	mov    %esi,%ecx
c002c871:	29 c1                	sub    %eax,%ecx
c002c873:	bd 1e 00 00 00       	mov    $0x1e,%ebp
c002c878:	29 cd                	sub    %ecx,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002c87a:	55                   	push   %ebp
c002c87b:	8d 83 bf 77 ff ff    	lea    -0x8841(%ebx),%eax
c002c881:	50                   	push   %eax
c002c882:	6a 10                	push   $0x10
c002c884:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002c888:	57                   	push   %edi
c002c889:	e8 8b b2 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, priority, priority_sema_thread, NULL);
c002c88e:	6a 00                	push   $0x0
c002c890:	8d 83 12 33 ff ff    	lea    -0xccee(%ebx),%eax
c002c896:	50                   	push   %eax
c002c897:	55                   	push   %ebp
c002c898:	57                   	push   %edi
c002c899:	e8 bd 48 ff ff       	call   c002115b <thread_create>
c002c89e:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < 10; i++) 
c002c8a1:	83 c4 20             	add    $0x20,%esp
c002c8a4:	83 fe 0d             	cmp    $0xd,%esi
c002c8a7:	75 b0                	jne    c002c859 <test_priority_sema+0x46>
c002c8a9:	be 0a 00 00 00       	mov    $0xa,%esi
      sema_up (&sema);
c002c8ae:	8d ab 9c 23 00 00    	lea    0x239c(%ebx),%ebp
      msg ("Back in main thread."); 
c002c8b4:	8d bb 10 80 ff ff    	lea    -0x7ff0(%ebx),%edi
      sema_up (&sema);
c002c8ba:	83 ec 0c             	sub    $0xc,%esp
c002c8bd:	55                   	push   %ebp
c002c8be:	e8 74 65 ff ff       	call   c0022e37 <sema_up>
      msg ("Back in main thread."); 
c002c8c3:	89 3c 24             	mov    %edi,(%esp)
c002c8c6:	e8 7b e6 ff ff       	call   c002af46 <msg>
  for (i = 0; i < 10; i++) 
c002c8cb:	83 c4 10             	add    $0x10,%esp
c002c8ce:	83 ee 01             	sub    $0x1,%esi
c002c8d1:	75 e7                	jne    c002c8ba <test_priority_sema+0xa7>
}
c002c8d3:	83 c4 1c             	add    $0x1c,%esp
c002c8d6:	5b                   	pop    %ebx
c002c8d7:	5e                   	pop    %esi
c002c8d8:	5f                   	pop    %edi
c002c8d9:	5d                   	pop    %ebp
c002c8da:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002c8db:	83 ec 0c             	sub    $0xc,%esp
c002c8de:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002c8e4:	50                   	push   %eax
c002c8e5:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002c8eb:	50                   	push   %eax
c002c8ec:	8d 83 c4 54 ff ff    	lea    -0xab3c(%ebx),%eax
c002c8f2:	50                   	push   %eax
c002c8f3:	6a 15                	push   $0x15
c002c8f5:	8d 83 28 80 ff ff    	lea    -0x7fd8(%ebx),%eax
c002c8fb:	50                   	push   %eax
c002c8fc:	e8 8e c6 ff ff       	call   c0028f8f <debug_panic>

c002c901 <priority_condvar_thread>:
    }
}

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002c901:	56                   	push   %esi
c002c902:	53                   	push   %ebx
c002c903:	83 ec 04             	sub    $0x4,%esp
c002c906:	e8 30 10 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c90b:	81 c3 c1 cb 00 00    	add    $0xcbc1,%ebx
  msg ("Thread %s starting.", thread_name ());
c002c911:	e8 45 43 ff ff       	call   c0020c5b <thread_name>
c002c916:	83 ec 08             	sub    $0x8,%esp
c002c919:	50                   	push   %eax
c002c91a:	8d 83 4c 80 ff ff    	lea    -0x7fb4(%ebx),%eax
c002c920:	50                   	push   %eax
c002c921:	e8 20 e6 ff ff       	call   c002af46 <msg>
  lock_acquire (&lock);
c002c926:	8d b3 d4 23 00 00    	lea    0x23d4(%ebx),%esi
c002c92c:	89 34 24             	mov    %esi,(%esp)
c002c92f:	e8 09 67 ff ff       	call   c002303d <lock_acquire>
  cond_wait (&condition, &lock);
c002c934:	83 c4 08             	add    $0x8,%esp
c002c937:	56                   	push   %esi
c002c938:	8d 83 b4 23 00 00    	lea    0x23b4(%ebx),%eax
c002c93e:	50                   	push   %eax
c002c93f:	e8 fb 69 ff ff       	call   c002333f <cond_wait>
  msg ("Thread %s woke up.", thread_name ());
c002c944:	e8 12 43 ff ff       	call   c0020c5b <thread_name>
c002c949:	83 c4 08             	add    $0x8,%esp
c002c94c:	50                   	push   %eax
c002c94d:	8d 83 ac 77 ff ff    	lea    -0x8854(%ebx),%eax
c002c953:	50                   	push   %eax
c002c954:	e8 ed e5 ff ff       	call   c002af46 <msg>
  lock_release (&lock);
c002c959:	89 34 24             	mov    %esi,(%esp)
c002c95c:	e8 d4 68 ff ff       	call   c0023235 <lock_release>
}
c002c961:	83 c4 14             	add    $0x14,%esp
c002c964:	5b                   	pop    %ebx
c002c965:	5e                   	pop    %esi
c002c966:	c3                   	ret    

c002c967 <test_priority_condvar>:
{
c002c967:	55                   	push   %ebp
c002c968:	57                   	push   %edi
c002c969:	56                   	push   %esi
c002c96a:	53                   	push   %ebx
c002c96b:	83 ec 1c             	sub    $0x1c,%esp
c002c96e:	e8 c8 0f 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002c973:	81 c3 59 cb 00 00    	add    $0xcb59,%ebx
  ASSERT (!thread_mlfqs);
c002c979:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002c97f:	80 38 00             	cmpb   $0x0,(%eax)
c002c982:	0f 85 cb 00 00 00    	jne    c002ca53 <test_priority_condvar+0xec>
  lock_init (&lock);
c002c988:	83 ec 0c             	sub    $0xc,%esp
c002c98b:	8d 83 d4 23 00 00    	lea    0x23d4(%ebx),%eax
c002c991:	50                   	push   %eax
c002c992:	e8 fa 65 ff ff       	call   c0022f91 <lock_init>
  cond_init (&condition);
c002c997:	8d 83 b4 23 00 00    	lea    0x23b4(%ebx),%eax
c002c99d:	89 04 24             	mov    %eax,(%esp)
c002c9a0:	e8 4c 69 ff ff       	call   c00232f1 <cond_init>
  thread_set_priority (PRI_MIN);
c002c9a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002c9ac:	e8 61 49 ff ff       	call   c0021312 <thread_set_priority>
c002c9b1:	83 c4 10             	add    $0x10,%esp
c002c9b4:	be 07 00 00 00       	mov    $0x7,%esi
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002c9b9:	b8 67 66 66 66       	mov    $0x66666667,%eax
c002c9be:	f7 ee                	imul   %esi
c002c9c0:	c1 fa 02             	sar    $0x2,%edx
c002c9c3:	89 f0                	mov    %esi,%eax
c002c9c5:	c1 f8 1f             	sar    $0x1f,%eax
c002c9c8:	29 c2                	sub    %eax,%edx
c002c9ca:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002c9cd:	01 c0                	add    %eax,%eax
c002c9cf:	89 f1                	mov    %esi,%ecx
c002c9d1:	29 c1                	sub    %eax,%ecx
c002c9d3:	bd 1e 00 00 00       	mov    $0x1e,%ebp
c002c9d8:	29 cd                	sub    %ecx,%ebp
      snprintf (name, sizeof name, "priority %d", priority);
c002c9da:	55                   	push   %ebp
c002c9db:	8d 83 bf 77 ff ff    	lea    -0x8841(%ebx),%eax
c002c9e1:	50                   	push   %eax
c002c9e2:	6a 10                	push   $0x10
c002c9e4:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c002c9e8:	57                   	push   %edi
c002c9e9:	e8 2b b1 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, priority, priority_condvar_thread, NULL);
c002c9ee:	6a 00                	push   $0x0
c002c9f0:	8d 83 35 34 ff ff    	lea    -0xcbcb(%ebx),%eax
c002c9f6:	50                   	push   %eax
c002c9f7:	55                   	push   %ebp
c002c9f8:	57                   	push   %edi
c002c9f9:	e8 5d 47 ff ff       	call   c002115b <thread_create>
c002c9fe:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < 10; i++) 
c002ca01:	83 c4 20             	add    $0x20,%esp
c002ca04:	83 fe 11             	cmp    $0x11,%esi
c002ca07:	75 b0                	jne    c002c9b9 <test_priority_condvar+0x52>
c002ca09:	bf 0a 00 00 00       	mov    $0xa,%edi
      lock_acquire (&lock);
c002ca0e:	8d b3 d4 23 00 00    	lea    0x23d4(%ebx),%esi
      msg ("Signaling...");
c002ca14:	8d ab 60 80 ff ff    	lea    -0x7fa0(%ebx),%ebp
      lock_acquire (&lock);
c002ca1a:	83 ec 0c             	sub    $0xc,%esp
c002ca1d:	56                   	push   %esi
c002ca1e:	e8 1a 66 ff ff       	call   c002303d <lock_acquire>
      msg ("Signaling...");
c002ca23:	89 2c 24             	mov    %ebp,(%esp)
c002ca26:	e8 1b e5 ff ff       	call   c002af46 <msg>
      cond_signal (&condition, &lock);
c002ca2b:	83 c4 08             	add    $0x8,%esp
c002ca2e:	56                   	push   %esi
c002ca2f:	8d 83 b4 23 00 00    	lea    0x23b4(%ebx),%eax
c002ca35:	50                   	push   %eax
c002ca36:	e8 2e 6a ff ff       	call   c0023469 <cond_signal>
      lock_release (&lock);
c002ca3b:	89 34 24             	mov    %esi,(%esp)
c002ca3e:	e8 f2 67 ff ff       	call   c0023235 <lock_release>
  for (i = 0; i < 10; i++) 
c002ca43:	83 c4 10             	add    $0x10,%esp
c002ca46:	83 ef 01             	sub    $0x1,%edi
c002ca49:	75 cf                	jne    c002ca1a <test_priority_condvar+0xb3>
}
c002ca4b:	83 c4 1c             	add    $0x1c,%esp
c002ca4e:	5b                   	pop    %ebx
c002ca4f:	5e                   	pop    %esi
c002ca50:	5f                   	pop    %edi
c002ca51:	5d                   	pop    %ebp
c002ca52:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002ca53:	83 ec 0c             	sub    $0xc,%esp
c002ca56:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002ca5c:	50                   	push   %eax
c002ca5d:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002ca63:	50                   	push   %eax
c002ca64:	8d 83 d8 54 ff ff    	lea    -0xab28(%ebx),%eax
c002ca6a:	50                   	push   %eax
c002ca6b:	6a 16                	push   $0x16
c002ca6d:	8d 83 70 80 ff ff    	lea    -0x7f90(%ebx),%eax
c002ca73:	50                   	push   %eax
c002ca74:	e8 16 c5 ff ff       	call   c0028f8f <debug_panic>

c002ca79 <interloper_thread_func>:
                                         thread_get_priority ());
}

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002ca79:	53                   	push   %ebx
c002ca7a:	83 ec 08             	sub    $0x8,%esp
c002ca7d:	e8 b9 0e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ca82:	81 c3 4a ca 00 00    	add    $0xca4a,%ebx
  msg ("%s finished.", thread_name ());
c002ca88:	e8 ce 41 ff ff       	call   c0020c5b <thread_name>
c002ca8d:	83 ec 08             	sub    $0x8,%esp
c002ca90:	50                   	push   %eax
c002ca91:	8d 83 97 80 ff ff    	lea    -0x7f69(%ebx),%eax
c002ca97:	50                   	push   %eax
c002ca98:	e8 a9 e4 ff ff       	call   c002af46 <msg>
}
c002ca9d:	83 c4 18             	add    $0x18,%esp
c002caa0:	5b                   	pop    %ebx
c002caa1:	c3                   	ret    

c002caa2 <donor_thread_func>:
{
c002caa2:	57                   	push   %edi
c002caa3:	56                   	push   %esi
c002caa4:	53                   	push   %ebx
c002caa5:	e8 91 0e 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002caaa:	81 c3 22 ca 00 00    	add    $0xca22,%ebx
c002cab0:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (locks->first)
c002cab4:	8b 46 04             	mov    0x4(%esi),%eax
c002cab7:	85 c0                	test   %eax,%eax
c002cab9:	74 0c                	je     c002cac7 <donor_thread_func+0x25>
    lock_acquire (locks->first);
c002cabb:	83 ec 0c             	sub    $0xc,%esp
c002cabe:	50                   	push   %eax
c002cabf:	e8 79 65 ff ff       	call   c002303d <lock_acquire>
c002cac4:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->second);
c002cac7:	83 ec 0c             	sub    $0xc,%esp
c002caca:	ff 36                	pushl  (%esi)
c002cacc:	e8 6c 65 ff ff       	call   c002303d <lock_acquire>
  msg ("%s got lock", thread_name ());
c002cad1:	e8 85 41 ff ff       	call   c0020c5b <thread_name>
c002cad6:	83 c4 08             	add    $0x8,%esp
c002cad9:	50                   	push   %eax
c002cada:	8d 83 a4 80 ff ff    	lea    -0x7f5c(%ebx),%eax
c002cae0:	50                   	push   %eax
c002cae1:	e8 60 e4 ff ff       	call   c002af46 <msg>
  lock_release (locks->second);
c002cae6:	83 c4 04             	add    $0x4,%esp
c002cae9:	ff 36                	pushl  (%esi)
c002caeb:	e8 45 67 ff ff       	call   c0023235 <lock_release>
  msg ("%s should have priority %d. Actual priority: %d", 
c002caf0:	e8 18 42 ff ff       	call   c0020d0d <thread_get_priority>
c002caf5:	89 c7                	mov    %eax,%edi
c002caf7:	e8 5f 41 ff ff       	call   c0020c5b <thread_name>
c002cafc:	57                   	push   %edi
c002cafd:	6a 15                	push   $0x15
c002caff:	50                   	push   %eax
c002cb00:	8d 83 cc 80 ff ff    	lea    -0x7f34(%ebx),%eax
c002cb06:	50                   	push   %eax
c002cb07:	e8 3a e4 ff ff       	call   c002af46 <msg>
  if (locks->first)
c002cb0c:	8b 46 04             	mov    0x4(%esi),%eax
c002cb0f:	83 c4 20             	add    $0x20,%esp
c002cb12:	85 c0                	test   %eax,%eax
c002cb14:	74 0c                	je     c002cb22 <donor_thread_func+0x80>
    lock_release (locks->first);
c002cb16:	83 ec 0c             	sub    $0xc,%esp
c002cb19:	50                   	push   %eax
c002cb1a:	e8 16 67 ff ff       	call   c0023235 <lock_release>
c002cb1f:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002cb22:	e8 e6 41 ff ff       	call   c0020d0d <thread_get_priority>
c002cb27:	89 c6                	mov    %eax,%esi
c002cb29:	e8 2d 41 ff ff       	call   c0020c5b <thread_name>
c002cb2e:	83 ec 04             	sub    $0x4,%esp
c002cb31:	56                   	push   %esi
c002cb32:	50                   	push   %eax
c002cb33:	8d 83 fc 80 ff ff    	lea    -0x7f04(%ebx),%eax
c002cb39:	50                   	push   %eax
c002cb3a:	e8 07 e4 ff ff       	call   c002af46 <msg>
}
c002cb3f:	83 c4 10             	add    $0x10,%esp
c002cb42:	5b                   	pop    %ebx
c002cb43:	5e                   	pop    %esi
c002cb44:	5f                   	pop    %edi
c002cb45:	c3                   	ret    

c002cb46 <test_priority_donate_chain>:
{
c002cb46:	55                   	push   %ebp
c002cb47:	57                   	push   %edi
c002cb48:	56                   	push   %esi
c002cb49:	53                   	push   %ebx
c002cb4a:	81 ec 7c 01 00 00    	sub    $0x17c,%esp
c002cb50:	e8 e6 0d 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002cb55:	81 c3 77 c9 00 00    	add    $0xc977,%ebx
  ASSERT (!thread_mlfqs);
c002cb5b:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002cb61:	80 38 00             	cmpb   $0x0,(%eax)
c002cb64:	0f 85 5e 01 00 00    	jne    c002ccc8 <test_priority_donate_chain+0x182>
  thread_set_priority (PRI_MIN);
c002cb6a:	83 ec 0c             	sub    $0xc,%esp
c002cb6d:	6a 00                	push   $0x0
c002cb6f:	e8 9e 47 ff ff       	call   c0021312 <thread_set_priority>
c002cb74:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
c002cb7b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002cb7f:	8d bc 24 80 01 00 00 	lea    0x180(%esp),%edi
c002cb86:	83 c4 10             	add    $0x10,%esp
c002cb89:	89 c6                	mov    %eax,%esi
    lock_init (&locks[i]);
c002cb8b:	83 ec 0c             	sub    $0xc,%esp
c002cb8e:	56                   	push   %esi
c002cb8f:	e8 fd 63 ff ff       	call   c0022f91 <lock_init>
c002cb94:	83 c6 24             	add    $0x24,%esi
  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002cb97:	83 c4 10             	add    $0x10,%esp
c002cb9a:	39 fe                	cmp    %edi,%esi
c002cb9c:	75 ed                	jne    c002cb8b <test_priority_donate_chain+0x45>
  lock_acquire (&locks[0]);
c002cb9e:	83 ec 0c             	sub    $0xc,%esp
c002cba1:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
c002cba8:	50                   	push   %eax
c002cba9:	e8 8f 64 ff ff       	call   c002303d <lock_acquire>
  msg ("%s got lock.", thread_name ());
c002cbae:	e8 a8 40 ff ff       	call   c0020c5b <thread_name>
c002cbb3:	83 c4 08             	add    $0x8,%esp
c002cbb6:	50                   	push   %eax
c002cbb7:	8d 83 b0 80 ff ff    	lea    -0x7f50(%ebx),%eax
c002cbbd:	50                   	push   %eax
c002cbbe:	e8 83 e3 ff ff       	call   c002af46 <msg>
c002cbc3:	8d 7c 24 4c          	lea    0x4c(%esp),%edi
c002cbc7:	83 c4 10             	add    $0x10,%esp
c002cbca:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
c002cbd1:	00 
  for (i = 1; i < NESTING_DEPTH; i++)
c002cbd2:	be 01 00 00 00       	mov    $0x1,%esi
      snprintf (name, sizeof name, "thread %d", i);
c002cbd7:	8d 83 d5 74 ff ff    	lea    -0x8b2b(%ebx),%eax
c002cbdd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002cbe1:	8d 6c 24 24          	lea    0x24(%esp),%ebp
c002cbe5:	56                   	push   %esi
c002cbe6:	ff 74 24 20          	pushl  0x20(%esp)
c002cbea:	6a 10                	push   $0x10
c002cbec:	55                   	push   %ebp
c002cbed:	e8 27 af ff ff       	call   c0027b19 <snprintf>
      thread_priority = PRI_MIN + i * 3;
c002cbf2:	8b 4c 24 20          	mov    0x20(%esp),%ecx
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002cbf6:	83 c4 10             	add    $0x10,%esp
c002cbf9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002cbfd:	83 c0 24             	add    $0x24,%eax
c002cc00:	83 fe 07             	cmp    $0x7,%esi
c002cc03:	ba 00 00 00 00       	mov    $0x0,%edx
c002cc08:	0f 4d c2             	cmovge %edx,%eax
c002cc0b:	89 47 04             	mov    %eax,0x4(%edi)
      lock_pairs[i].second = locks + i - 1;
c002cc0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002cc12:	89 07                	mov    %eax,(%edi)
      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002cc14:	57                   	push   %edi
c002cc15:	8d 83 d6 35 ff ff    	lea    -0xca2a(%ebx),%eax
c002cc1b:	50                   	push   %eax
c002cc1c:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c002cc20:	51                   	push   %ecx
c002cc21:	55                   	push   %ebp
c002cc22:	e8 34 45 ff ff       	call   c002115b <thread_create>
      msg ("%s should have priority %d.  Actual priority: %d.",
c002cc27:	e8 e1 40 ff ff       	call   c0020d0d <thread_get_priority>
c002cc2c:	89 44 24 28          	mov    %eax,0x28(%esp)
c002cc30:	e8 26 40 ff ff       	call   c0020c5b <thread_name>
c002cc35:	ff 74 24 28          	pushl  0x28(%esp)
c002cc39:	ff 74 24 28          	pushl  0x28(%esp)
c002cc3d:	50                   	push   %eax
c002cc3e:	8d 83 48 81 ff ff    	lea    -0x7eb8(%ebx),%eax
c002cc44:	50                   	push   %eax
c002cc45:	e8 fc e2 ff ff       	call   c002af46 <msg>
      snprintf (name, sizeof name, "interloper %d", i);
c002cc4a:	83 c4 20             	add    $0x20,%esp
c002cc4d:	56                   	push   %esi
c002cc4e:	8d 83 bd 80 ff ff    	lea    -0x7f43(%ebx),%eax
c002cc54:	50                   	push   %eax
c002cc55:	6a 10                	push   $0x10
c002cc57:	55                   	push   %ebp
c002cc58:	e8 bc ae ff ff       	call   c0027b19 <snprintf>
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002cc5d:	6a 00                	push   $0x0
c002cc5f:	8d 83 ad 35 ff ff    	lea    -0xca53(%ebx),%eax
c002cc65:	50                   	push   %eax
c002cc66:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c002cc6a:	8d 41 ff             	lea    -0x1(%ecx),%eax
c002cc6d:	50                   	push   %eax
c002cc6e:	55                   	push   %ebp
c002cc6f:	e8 e7 44 ff ff       	call   c002115b <thread_create>
  for (i = 1; i < NESTING_DEPTH; i++)
c002cc74:	83 c6 01             	add    $0x1,%esi
c002cc77:	83 44 24 2c 24       	addl   $0x24,0x2c(%esp)
c002cc7c:	83 c7 08             	add    $0x8,%edi
c002cc7f:	83 44 24 30 03       	addl   $0x3,0x30(%esp)
c002cc84:	83 c4 20             	add    $0x20,%esp
c002cc87:	83 fe 08             	cmp    $0x8,%esi
c002cc8a:	0f 85 55 ff ff ff    	jne    c002cbe5 <test_priority_donate_chain+0x9f>
  lock_release (&locks[0]);
c002cc90:	83 ec 0c             	sub    $0xc,%esp
c002cc93:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
c002cc9a:	50                   	push   %eax
c002cc9b:	e8 95 65 ff ff       	call   c0023235 <lock_release>
  msg ("%s finishing with priority %d.", thread_name (),
c002cca0:	e8 68 40 ff ff       	call   c0020d0d <thread_get_priority>
c002cca5:	89 c6                	mov    %eax,%esi
c002cca7:	e8 af 3f ff ff       	call   c0020c5b <thread_name>
c002ccac:	83 c4 0c             	add    $0xc,%esp
c002ccaf:	56                   	push   %esi
c002ccb0:	50                   	push   %eax
c002ccb1:	8d 83 fc 80 ff ff    	lea    -0x7f04(%ebx),%eax
c002ccb7:	50                   	push   %eax
c002ccb8:	e8 89 e2 ff ff       	call   c002af46 <msg>
}
c002ccbd:	81 c4 8c 01 00 00    	add    $0x18c,%esp
c002ccc3:	5b                   	pop    %ebx
c002ccc4:	5e                   	pop    %esi
c002ccc5:	5f                   	pop    %edi
c002ccc6:	5d                   	pop    %ebp
c002ccc7:	c3                   	ret    
  ASSERT (!thread_mlfqs);
c002ccc8:	83 ec 0c             	sub    $0xc,%esp
c002cccb:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c002ccd1:	50                   	push   %eax
c002ccd2:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002ccd8:	50                   	push   %eax
c002ccd9:	8d 83 f0 54 ff ff    	lea    -0xab10(%ebx),%eax
c002ccdf:	50                   	push   %eax
c002cce0:	6a 34                	push   $0x34
c002cce2:	8d 83 1c 81 ff ff    	lea    -0x7ee4(%ebx),%eax
c002cce8:	50                   	push   %eax
c002cce9:	e8 a1 c2 ff ff       	call   c0028f8f <debug_panic>

c002ccee <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002ccee:	55                   	push   %ebp
c002ccef:	57                   	push   %edi
c002ccf0:	56                   	push   %esi
c002ccf1:	53                   	push   %ebx
c002ccf2:	83 ec 1c             	sub    $0x1c,%esp
c002ccf5:	e8 41 0c 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ccfa:	81 c3 d2 c7 00 00    	add    $0xc7d2,%ebx
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002cd00:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002cd06:	80 38 00             	cmpb   $0x0,(%eax)
c002cd09:	74 27                	je     c002cd32 <test_mlfqs_load_1+0x44>

  msg ("spinning for up to 45 seconds, please wait...");
c002cd0b:	83 ec 0c             	sub    $0xc,%esp
c002cd0e:	8d 83 c8 81 ff ff    	lea    -0x7e38(%ebx),%eax
c002cd14:	50                   	push   %eax
c002cd15:	e8 2c e2 ff ff       	call   c002af46 <msg>

  start_time = timer_ticks ();
c002cd1a:	e8 42 76 ff ff       	call   c0024361 <timer_ticks>
c002cd1f:	89 c6                	mov    %eax,%esi
c002cd21:	89 d7                	mov    %edx,%edi
c002cd23:	83 c4 10             	add    $0x10,%esp
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
        break;
      else if (elapsed > 45)
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002cd26:	8d 83 44 82 ff ff    	lea    -0x7dbc(%ebx),%eax
c002cd2c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002cd30:	eb 74                	jmp    c002cda6 <test_mlfqs_load_1+0xb8>
  ASSERT (thread_mlfqs);
c002cd32:	83 ec 0c             	sub    $0xc,%esp
c002cd35:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c002cd3b:	50                   	push   %eax
c002cd3c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002cd42:	50                   	push   %eax
c002cd43:	8d 83 0c 55 ff ff    	lea    -0xaaf4(%ebx),%eax
c002cd49:	50                   	push   %eax
c002cd4a:	6a 18                	push   $0x18
c002cd4c:	8d 83 a4 81 ff ff    	lea    -0x7e5c(%ebx),%eax
c002cd52:	50                   	push   %eax
c002cd53:	e8 37 c2 ff ff       	call   c0028f8f <debug_panic>
      ASSERT (load_avg >= 0);
c002cd58:	83 ec 0c             	sub    $0xc,%esp
c002cd5b:	8d 83 7a 81 ff ff    	lea    -0x7e86(%ebx),%eax
c002cd61:	50                   	push   %eax
c002cd62:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002cd68:	50                   	push   %eax
c002cd69:	8d 83 0c 55 ff ff    	lea    -0xaaf4(%ebx),%eax
c002cd6f:	50                   	push   %eax
c002cd70:	6a 20                	push   $0x20
c002cd72:	8d 83 a4 81 ff ff    	lea    -0x7e5c(%ebx),%eax
c002cd78:	50                   	push   %eax
c002cd79:	e8 11 c2 ff ff       	call   c0028f8f <debug_panic>
        fail ("load average is %d.%02d "
c002cd7e:	50                   	push   %eax
c002cd7f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002cd84:	f7 ed                	imul   %ebp
c002cd86:	c1 fa 05             	sar    $0x5,%edx
c002cd89:	89 e8                	mov    %ebp,%eax
c002cd8b:	c1 f8 1f             	sar    $0x1f,%eax
c002cd8e:	29 c2                	sub    %eax,%edx
c002cd90:	6b c2 64             	imul   $0x64,%edx,%eax
c002cd93:	29 c5                	sub    %eax,%ebp
c002cd95:	55                   	push   %ebp
c002cd96:	52                   	push   %edx
c002cd97:	8d 83 f8 81 ff ff    	lea    -0x7e08(%ebx),%eax
c002cd9d:	50                   	push   %eax
c002cd9e:	e8 6f e2 ff ff       	call   c002b012 <fail>
c002cda3:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002cda6:	e8 80 3f ff ff       	call   c0020d2b <thread_get_load_avg>
c002cdab:	89 c5                	mov    %eax,%ebp
      ASSERT (load_avg >= 0);
c002cdad:	85 c0                	test   %eax,%eax
c002cdaf:	78 a7                	js     c002cd58 <test_mlfqs_load_1+0x6a>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002cdb1:	83 ec 08             	sub    $0x8,%esp
c002cdb4:	57                   	push   %edi
c002cdb5:	56                   	push   %esi
c002cdb6:	e8 d9 75 ff ff       	call   c0024394 <timer_elapsed>
c002cdbb:	6a 00                	push   $0x0
c002cdbd:	6a 64                	push   $0x64
c002cdbf:	52                   	push   %edx
c002cdc0:	50                   	push   %eax
c002cdc1:	e8 8c bb ff ff       	call   c0028952 <__divdi3>
      if (load_avg > 100)
c002cdc6:	83 c4 20             	add    $0x20,%esp
c002cdc9:	83 fd 64             	cmp    $0x64,%ebp
c002cdcc:	7f b0                	jg     c002cd7e <test_mlfqs_load_1+0x90>
      else if (load_avg > 50)
c002cdce:	83 fd 32             	cmp    $0x32,%ebp
c002cdd1:	7f 16                	jg     c002cde9 <test_mlfqs_load_1+0xfb>
      else if (elapsed > 45)
c002cdd3:	83 f8 2d             	cmp    $0x2d,%eax
c002cdd6:	7e ce                	jle    c002cda6 <test_mlfqs_load_1+0xb8>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002cdd8:	83 ec 0c             	sub    $0xc,%esp
c002cddb:	ff 74 24 18          	pushl  0x18(%esp)
c002cddf:	e8 2e e2 ff ff       	call   c002b012 <fail>
c002cde4:	83 c4 10             	add    $0x10,%esp
c002cde7:	eb bd                	jmp    c002cda6 <test_mlfqs_load_1+0xb8>
c002cde9:	89 c7                	mov    %eax,%edi
    }

  if (elapsed < 38)
c002cdeb:	83 f8 25             	cmp    $0x25,%eax
c002cdee:	7e 76                	jle    c002ce66 <test_mlfqs_load_1+0x178>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002cdf0:	83 ec 08             	sub    $0x8,%esp
c002cdf3:	57                   	push   %edi
c002cdf4:	8d 83 b0 82 ff ff    	lea    -0x7d50(%ebx),%eax
c002cdfa:	50                   	push   %eax
c002cdfb:	e8 46 e1 ff ff       	call   c002af46 <msg>

  msg ("sleeping for another 10 seconds, please wait...");
c002ce00:	8d 83 dc 82 ff ff    	lea    -0x7d24(%ebx),%eax
c002ce06:	89 04 24             	mov    %eax,(%esp)
c002ce09:	e8 38 e1 ff ff       	call   c002af46 <msg>
  timer_sleep (TIMER_FREQ * 10);
c002ce0e:	83 c4 08             	add    $0x8,%esp
c002ce11:	6a 00                	push   $0x0
c002ce13:	68 e8 03 00 00       	push   $0x3e8
c002ce18:	e8 93 75 ff ff       	call   c00243b0 <timer_sleep>

  load_avg = thread_get_load_avg ();
c002ce1d:	e8 09 3f ff ff       	call   c0020d2b <thread_get_load_avg>
c002ce22:	89 c6                	mov    %eax,%esi
  if (load_avg < 0)
c002ce24:	83 c4 10             	add    $0x10,%esp
c002ce27:	85 c0                	test   %eax,%eax
c002ce29:	78 53                	js     c002ce7e <test_mlfqs_load_1+0x190>
    fail ("load average fell below 0");
  if (load_avg > 50)
c002ce2b:	83 fe 32             	cmp    $0x32,%esi
c002ce2e:	7f 62                	jg     c002ce92 <test_mlfqs_load_1+0x1a4>
    fail ("load average stayed above 0.5 for more than 10 seconds");
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002ce30:	83 ec 04             	sub    $0x4,%esp
c002ce33:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002ce38:	89 f0                	mov    %esi,%eax
c002ce3a:	f7 ea                	imul   %edx
c002ce3c:	c1 fa 05             	sar    $0x5,%edx
c002ce3f:	89 f0                	mov    %esi,%eax
c002ce41:	c1 f8 1f             	sar    $0x1f,%eax
c002ce44:	29 c2                	sub    %eax,%edx
c002ce46:	6b c2 64             	imul   $0x64,%edx,%eax
c002ce49:	29 c6                	sub    %eax,%esi
c002ce4b:	56                   	push   %esi
c002ce4c:	52                   	push   %edx
c002ce4d:	8d 83 44 83 ff ff    	lea    -0x7cbc(%ebx),%eax
c002ce53:	50                   	push   %eax
c002ce54:	e8 ed e0 ff ff       	call   c002af46 <msg>
       load_avg / 100, load_avg % 100);

  pass ();
c002ce59:	e8 0e e2 ff ff       	call   c002b06c <pass>
}
c002ce5e:	83 c4 2c             	add    $0x2c,%esp
c002ce61:	5b                   	pop    %ebx
c002ce62:	5e                   	pop    %esi
c002ce63:	5f                   	pop    %edi
c002ce64:	5d                   	pop    %ebp
c002ce65:	c3                   	ret    
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002ce66:	83 ec 08             	sub    $0x8,%esp
c002ce69:	50                   	push   %eax
c002ce6a:	8d 83 7c 82 ff ff    	lea    -0x7d84(%ebx),%eax
c002ce70:	50                   	push   %eax
c002ce71:	e8 9c e1 ff ff       	call   c002b012 <fail>
c002ce76:	83 c4 10             	add    $0x10,%esp
c002ce79:	e9 72 ff ff ff       	jmp    c002cdf0 <test_mlfqs_load_1+0x102>
    fail ("load average fell below 0");
c002ce7e:	83 ec 0c             	sub    $0xc,%esp
c002ce81:	8d 83 88 81 ff ff    	lea    -0x7e78(%ebx),%eax
c002ce87:	50                   	push   %eax
c002ce88:	e8 85 e1 ff ff       	call   c002b012 <fail>
c002ce8d:	83 c4 10             	add    $0x10,%esp
c002ce90:	eb 99                	jmp    c002ce2b <test_mlfqs_load_1+0x13d>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002ce92:	83 ec 0c             	sub    $0xc,%esp
c002ce95:	8d 83 0c 83 ff ff    	lea    -0x7cf4(%ebx),%eax
c002ce9b:	50                   	push   %eax
c002ce9c:	e8 71 e1 ff ff       	call   c002b012 <fail>
c002cea1:	83 c4 10             	add    $0x10,%esp
c002cea4:	eb 8a                	jmp    c002ce30 <test_mlfqs_load_1+0x142>

c002cea6 <load_thread>:
    }
}

static void
load_thread (void *aux UNUSED) 
{
c002cea6:	57                   	push   %edi
c002cea7:	56                   	push   %esi
c002cea8:	53                   	push   %ebx
c002cea9:	e8 8d 0a 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002ceae:	81 c3 1e c6 00 00    	add    $0xc61e,%ebx
  int64_t sleep_time = 10 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
c002ceb4:	83 ec 0c             	sub    $0xc,%esp
c002ceb7:	6a 14                	push   $0x14
c002ceb9:	e8 9d 47 ff ff       	call   c002165b <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002cebe:	83 c4 08             	add    $0x8,%esp
c002cec1:	ff b3 00 24 00 00    	pushl  0x2400(%ebx)
c002cec7:	ff b3 fc 23 00 00    	pushl  0x23fc(%ebx)
c002cecd:	e8 c2 74 ff ff       	call   c0024394 <timer_elapsed>
c002ced2:	83 c4 08             	add    $0x8,%esp
c002ced5:	be e8 03 00 00       	mov    $0x3e8,%esi
c002ceda:	bf 00 00 00 00       	mov    $0x0,%edi
c002cedf:	29 c6                	sub    %eax,%esi
c002cee1:	19 d7                	sbb    %edx,%edi
c002cee3:	57                   	push   %edi
c002cee4:	56                   	push   %esi
c002cee5:	e8 c6 74 ff ff       	call   c00243b0 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002ceea:	83 c4 10             	add    $0x10,%esp
c002ceed:	83 ec 08             	sub    $0x8,%esp
c002cef0:	ff b3 00 24 00 00    	pushl  0x2400(%ebx)
c002cef6:	ff b3 fc 23 00 00    	pushl  0x23fc(%ebx)
c002cefc:	e8 93 74 ff ff       	call   c0024394 <timer_elapsed>
c002cf01:	83 c4 10             	add    $0x10,%esp
c002cf04:	85 d2                	test   %edx,%edx
c002cf06:	78 e5                	js     c002ceed <load_thread+0x47>
c002cf08:	85 d2                	test   %edx,%edx
c002cf0a:	7e 33                	jle    c002cf3f <load_thread+0x99>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002cf0c:	83 ec 08             	sub    $0x8,%esp
c002cf0f:	ff b3 00 24 00 00    	pushl  0x2400(%ebx)
c002cf15:	ff b3 fc 23 00 00    	pushl  0x23fc(%ebx)
c002cf1b:	e8 74 74 ff ff       	call   c0024394 <timer_elapsed>
c002cf20:	83 c4 08             	add    $0x8,%esp
c002cf23:	be c8 32 00 00       	mov    $0x32c8,%esi
c002cf28:	bf 00 00 00 00       	mov    $0x0,%edi
c002cf2d:	29 c6                	sub    %eax,%esi
c002cf2f:	19 d7                	sbb    %edx,%edi
c002cf31:	57                   	push   %edi
c002cf32:	56                   	push   %esi
c002cf33:	e8 78 74 ff ff       	call   c00243b0 <timer_sleep>
}
c002cf38:	83 c4 10             	add    $0x10,%esp
c002cf3b:	5b                   	pop    %ebx
c002cf3c:	5e                   	pop    %esi
c002cf3d:	5f                   	pop    %edi
c002cf3e:	c3                   	ret    
  while (timer_elapsed (start_time) < spin_time)
c002cf3f:	3d 57 1b 00 00       	cmp    $0x1b57,%eax
c002cf44:	76 a7                	jbe    c002ceed <load_thread+0x47>
c002cf46:	eb c4                	jmp    c002cf0c <load_thread+0x66>

c002cf48 <test_mlfqs_load_60>:
{
c002cf48:	55                   	push   %ebp
c002cf49:	57                   	push   %edi
c002cf4a:	56                   	push   %esi
c002cf4b:	53                   	push   %ebx
c002cf4c:	83 ec 2c             	sub    $0x2c,%esp
c002cf4f:	e8 e7 09 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002cf54:	81 c3 78 c5 00 00    	add    $0xc578,%ebx
  ASSERT (thread_mlfqs);
c002cf5a:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002cf60:	80 38 00             	cmpb   $0x0,(%eax)
c002cf63:	0f 84 29 01 00 00    	je     c002d092 <test_mlfqs_load_60+0x14a>
  start_time = timer_ticks ();
c002cf69:	e8 f3 73 ff ff       	call   c0024361 <timer_ticks>
c002cf6e:	89 83 fc 23 00 00    	mov    %eax,0x23fc(%ebx)
c002cf74:	89 93 00 24 00 00    	mov    %edx,0x2400(%ebx)
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002cf7a:	83 ec 08             	sub    $0x8,%esp
c002cf7d:	6a 3c                	push   $0x3c
c002cf7f:	8d 83 a0 83 ff ff    	lea    -0x7c60(%ebx),%eax
c002cf85:	50                   	push   %eax
c002cf86:	e8 bb df ff ff       	call   c002af46 <msg>
c002cf8b:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002cf8e:	be 00 00 00 00       	mov    $0x0,%esi
      snprintf(name, sizeof name, "load %d", i);
c002cf93:	8d ab 72 83 ff ff    	lea    -0x7c8e(%ebx),%ebp
c002cf99:	8d 7c 24 10          	lea    0x10(%esp),%edi
c002cf9d:	56                   	push   %esi
c002cf9e:	55                   	push   %ebp
c002cf9f:	6a 10                	push   $0x10
c002cfa1:	57                   	push   %edi
c002cfa2:	e8 72 ab ff ff       	call   c0027b19 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002cfa7:	6a 00                	push   $0x0
c002cfa9:	8d 83 da 39 ff ff    	lea    -0xc626(%ebx),%eax
c002cfaf:	50                   	push   %eax
c002cfb0:	6a 1f                	push   $0x1f
c002cfb2:	57                   	push   %edi
c002cfb3:	e8 a3 41 ff ff       	call   c002115b <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002cfb8:	83 c6 01             	add    $0x1,%esi
c002cfbb:	83 c4 20             	add    $0x20,%esp
c002cfbe:	83 fe 3c             	cmp    $0x3c,%esi
c002cfc1:	75 da                	jne    c002cf9d <test_mlfqs_load_60+0x55>
       timer_elapsed (start_time) / TIMER_FREQ);
c002cfc3:	83 ec 08             	sub    $0x8,%esp
c002cfc6:	ff b3 00 24 00 00    	pushl  0x2400(%ebx)
c002cfcc:	ff b3 fc 23 00 00    	pushl  0x23fc(%ebx)
c002cfd2:	e8 bd 73 ff ff       	call   c0024394 <timer_elapsed>
  msg ("Starting threads took %d seconds.",
c002cfd7:	6a 00                	push   $0x0
c002cfd9:	6a 64                	push   $0x64
c002cfdb:	52                   	push   %edx
c002cfdc:	50                   	push   %eax
c002cfdd:	e8 70 b9 ff ff       	call   c0028952 <__divdi3>
c002cfe2:	83 c4 1c             	add    $0x1c,%esp
c002cfe5:	52                   	push   %edx
c002cfe6:	50                   	push   %eax
c002cfe7:	8d 83 c4 83 ff ff    	lea    -0x7c3c(%ebx),%eax
c002cfed:	50                   	push   %eax
c002cfee:	e8 53 df ff ff       	call   c002af46 <msg>
c002cff3:	83 c4 10             	add    $0x10,%esp
c002cff6:	bd 00 00 00 00       	mov    $0x0,%ebp
c002cffb:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
c002d002:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002d009:	00 
      msg ("After %d seconds, load average=%d.%02d.",
c002d00a:	8d 83 e8 83 ff ff    	lea    -0x7c18(%ebx),%eax
c002d010:	89 44 24 0c          	mov    %eax,0xc(%esp)
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002d014:	8b 34 24             	mov    (%esp),%esi
c002d017:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002d01b:	03 b3 fc 23 00 00    	add    0x23fc(%ebx),%esi
c002d021:	13 bb 00 24 00 00    	adc    0x2400(%ebx),%edi
      timer_sleep (sleep_until - timer_ticks ());
c002d027:	e8 35 73 ff ff       	call   c0024361 <timer_ticks>
c002d02c:	83 ec 08             	sub    $0x8,%esp
c002d02f:	29 c6                	sub    %eax,%esi
c002d031:	19 d7                	sbb    %edx,%edi
c002d033:	57                   	push   %edi
c002d034:	56                   	push   %esi
c002d035:	e8 76 73 ff ff       	call   c00243b0 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002d03a:	e8 ec 3c ff ff       	call   c0020d2b <thread_get_load_avg>
c002d03f:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002d041:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d046:	f7 e9                	imul   %ecx
c002d048:	c1 fa 05             	sar    $0x5,%edx
c002d04b:	89 c8                	mov    %ecx,%eax
c002d04d:	c1 f8 1f             	sar    $0x1f,%eax
c002d050:	29 c2                	sub    %eax,%edx
c002d052:	6b c2 64             	imul   $0x64,%edx,%eax
c002d055:	29 c1                	sub    %eax,%ecx
c002d057:	51                   	push   %ecx
c002d058:	52                   	push   %edx
c002d059:	55                   	push   %ebp
c002d05a:	ff 74 24 28          	pushl  0x28(%esp)
c002d05e:	e8 e3 de ff ff       	call   c002af46 <msg>
c002d063:	81 44 24 20 c8 00 00 	addl   $0xc8,0x20(%esp)
c002d06a:	00 
c002d06b:	83 54 24 24 00       	adcl   $0x0,0x24(%esp)
c002d070:	83 c5 02             	add    $0x2,%ebp
  for (i = 0; i < 90; i++) 
c002d073:	83 c4 20             	add    $0x20,%esp
c002d076:	8b 14 24             	mov    (%esp),%edx
c002d079:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002d07d:	89 d0                	mov    %edx,%eax
c002d07f:	35 38 4a 00 00       	xor    $0x4a38,%eax
c002d084:	89 ca                	mov    %ecx,%edx
c002d086:	09 c2                	or     %eax,%edx
c002d088:	75 8a                	jne    c002d014 <test_mlfqs_load_60+0xcc>
}
c002d08a:	83 c4 2c             	add    $0x2c,%esp
c002d08d:	5b                   	pop    %ebx
c002d08e:	5e                   	pop    %esi
c002d08f:	5f                   	pop    %edi
c002d090:	5d                   	pop    %ebp
c002d091:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002d092:	83 ec 0c             	sub    $0xc,%esp
c002d095:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c002d09b:	50                   	push   %eax
c002d09c:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d0a2:	50                   	push   %eax
c002d0a3:	8d 83 20 55 ff ff    	lea    -0xaae0(%ebx),%eax
c002d0a9:	50                   	push   %eax
c002d0aa:	6a 77                	push   $0x77
c002d0ac:	8d 83 7c 83 ff ff    	lea    -0x7c84(%ebx),%eax
c002d0b2:	50                   	push   %eax
c002d0b3:	e8 d7 be ff ff       	call   c0028f8f <debug_panic>

c002d0b8 <load_thread>:
    }
}

static void
load_thread (void *seq_no_) 
{
c002d0b8:	55                   	push   %ebp
c002d0b9:	57                   	push   %edi
c002d0ba:	56                   	push   %esi
c002d0bb:	53                   	push   %ebx
c002d0bc:	83 ec 14             	sub    $0x14,%esp
c002d0bf:	e8 77 08 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d0c4:	81 c3 08 c4 00 00    	add    $0xc408,%ebx
  int seq_no = (int) seq_no_;
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002d0ca:	8b 44 24 28          	mov    0x28(%esp),%eax
c002d0ce:	8d 70 0a             	lea    0xa(%eax),%esi
c002d0d1:	6b f6 64             	imul   $0x64,%esi,%esi
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002d0d4:	8d ae 70 17 00 00    	lea    0x1770(%esi),%ebp
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002d0da:	ff b3 08 24 00 00    	pushl  0x2408(%ebx)
c002d0e0:	ff b3 04 24 00 00    	pushl  0x2404(%ebx)
c002d0e6:	e8 a9 72 ff ff       	call   c0024394 <timer_elapsed>
c002d0eb:	83 c4 08             	add    $0x8,%esp
c002d0ee:	89 f7                	mov    %esi,%edi
c002d0f0:	c1 ff 1f             	sar    $0x1f,%edi
c002d0f3:	29 c6                	sub    %eax,%esi
c002d0f5:	19 d7                	sbb    %edx,%edi
c002d0f7:	57                   	push   %edi
c002d0f8:	56                   	push   %esi
c002d0f9:	e8 b2 72 ff ff       	call   c00243b0 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002d0fe:	83 c4 10             	add    $0x10,%esp
c002d101:	89 ef                	mov    %ebp,%edi
c002d103:	c1 ff 1f             	sar    $0x1f,%edi
c002d106:	83 ec 08             	sub    $0x8,%esp
c002d109:	ff b3 08 24 00 00    	pushl  0x2408(%ebx)
c002d10f:	ff b3 04 24 00 00    	pushl  0x2404(%ebx)
c002d115:	e8 7a 72 ff ff       	call   c0024394 <timer_elapsed>
c002d11a:	83 c4 10             	add    $0x10,%esp
c002d11d:	39 fa                	cmp    %edi,%edx
c002d11f:	7c e5                	jl     c002d106 <load_thread+0x4e>
c002d121:	7f 04                	jg     c002d127 <load_thread+0x6f>
c002d123:	39 e8                	cmp    %ebp,%eax
c002d125:	72 df                	jb     c002d106 <load_thread+0x4e>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002d127:	83 ec 08             	sub    $0x8,%esp
c002d12a:	ff b3 08 24 00 00    	pushl  0x2408(%ebx)
c002d130:	ff b3 04 24 00 00    	pushl  0x2404(%ebx)
c002d136:	e8 59 72 ff ff       	call   c0024394 <timer_elapsed>
c002d13b:	83 c4 08             	add    $0x8,%esp
c002d13e:	be e0 2e 00 00       	mov    $0x2ee0,%esi
c002d143:	bf 00 00 00 00       	mov    $0x0,%edi
c002d148:	29 c6                	sub    %eax,%esi
c002d14a:	19 d7                	sbb    %edx,%edi
c002d14c:	57                   	push   %edi
c002d14d:	56                   	push   %esi
c002d14e:	e8 5d 72 ff ff       	call   c00243b0 <timer_sleep>
}
c002d153:	83 c4 1c             	add    $0x1c,%esp
c002d156:	5b                   	pop    %ebx
c002d157:	5e                   	pop    %esi
c002d158:	5f                   	pop    %edi
c002d159:	5d                   	pop    %ebp
c002d15a:	c3                   	ret    

c002d15b <test_mlfqs_load_avg>:
{
c002d15b:	55                   	push   %ebp
c002d15c:	57                   	push   %edi
c002d15d:	56                   	push   %esi
c002d15e:	53                   	push   %ebx
c002d15f:	83 ec 2c             	sub    $0x2c,%esp
c002d162:	e8 d4 07 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d167:	81 c3 65 c3 00 00    	add    $0xc365,%ebx
  ASSERT (thread_mlfqs);
c002d16d:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002d173:	80 38 00             	cmpb   $0x0,(%eax)
c002d176:	0f 84 34 01 00 00    	je     c002d2b0 <test_mlfqs_load_avg+0x155>
  start_time = timer_ticks ();
c002d17c:	e8 e0 71 ff ff       	call   c0024361 <timer_ticks>
c002d181:	89 83 04 24 00 00    	mov    %eax,0x2404(%ebx)
c002d187:	89 93 08 24 00 00    	mov    %edx,0x2408(%ebx)
  msg ("Starting %d load threads...", THREAD_CNT);
c002d18d:	83 ec 08             	sub    $0x8,%esp
c002d190:	6a 3c                	push   $0x3c
c002d192:	8d 83 10 84 ff ff    	lea    -0x7bf0(%ebx),%eax
c002d198:	50                   	push   %eax
c002d199:	e8 a8 dd ff ff       	call   c002af46 <msg>
c002d19e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d1a1:	be 00 00 00 00       	mov    $0x0,%esi
      snprintf(name, sizeof name, "load %d", i);
c002d1a6:	8d ab 72 83 ff ff    	lea    -0x7c8e(%ebx),%ebp
c002d1ac:	8d 7c 24 10          	lea    0x10(%esp),%edi
c002d1b0:	56                   	push   %esi
c002d1b1:	55                   	push   %ebp
c002d1b2:	6a 10                	push   $0x10
c002d1b4:	57                   	push   %edi
c002d1b5:	e8 5f a9 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002d1ba:	56                   	push   %esi
c002d1bb:	8d 83 ec 3b ff ff    	lea    -0xc414(%ebx),%eax
c002d1c1:	50                   	push   %eax
c002d1c2:	6a 1f                	push   $0x1f
c002d1c4:	57                   	push   %edi
c002d1c5:	e8 91 3f ff ff       	call   c002115b <thread_create>
  for (i = 0; i < THREAD_CNT; i++) 
c002d1ca:	83 c6 01             	add    $0x1,%esi
c002d1cd:	83 c4 20             	add    $0x20,%esp
c002d1d0:	83 fe 3c             	cmp    $0x3c,%esi
c002d1d3:	75 db                	jne    c002d1b0 <test_mlfqs_load_avg+0x55>
       timer_elapsed (start_time) / TIMER_FREQ);
c002d1d5:	83 ec 08             	sub    $0x8,%esp
c002d1d8:	ff b3 08 24 00 00    	pushl  0x2408(%ebx)
c002d1de:	ff b3 04 24 00 00    	pushl  0x2404(%ebx)
c002d1e4:	e8 ab 71 ff ff       	call   c0024394 <timer_elapsed>
  msg ("Starting threads took %d seconds.",
c002d1e9:	6a 00                	push   $0x0
c002d1eb:	6a 64                	push   $0x64
c002d1ed:	52                   	push   %edx
c002d1ee:	50                   	push   %eax
c002d1ef:	e8 5e b7 ff ff       	call   c0028952 <__divdi3>
c002d1f4:	83 c4 1c             	add    $0x1c,%esp
c002d1f7:	52                   	push   %edx
c002d1f8:	50                   	push   %eax
c002d1f9:	8d 83 c4 83 ff ff    	lea    -0x7c3c(%ebx),%eax
c002d1ff:	50                   	push   %eax
c002d200:	e8 41 dd ff ff       	call   c002af46 <msg>
  thread_set_nice (-20);
c002d205:	c7 04 24 ec ff ff ff 	movl   $0xffffffec,(%esp)
c002d20c:	e8 4a 44 ff ff       	call   c002165b <thread_set_nice>
c002d211:	83 c4 10             	add    $0x10,%esp
c002d214:	bd 00 00 00 00       	mov    $0x0,%ebp
c002d219:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
c002d220:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002d227:	00 
      msg ("After %d seconds, load average=%d.%02d.",
c002d228:	8d 83 e8 83 ff ff    	lea    -0x7c18(%ebx),%eax
c002d22e:	89 44 24 0c          	mov    %eax,0xc(%esp)
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002d232:	8b 34 24             	mov    (%esp),%esi
c002d235:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002d239:	03 b3 04 24 00 00    	add    0x2404(%ebx),%esi
c002d23f:	13 bb 08 24 00 00    	adc    0x2408(%ebx),%edi
      timer_sleep (sleep_until - timer_ticks ());
c002d245:	e8 17 71 ff ff       	call   c0024361 <timer_ticks>
c002d24a:	83 ec 08             	sub    $0x8,%esp
c002d24d:	29 c6                	sub    %eax,%esi
c002d24f:	19 d7                	sbb    %edx,%edi
c002d251:	57                   	push   %edi
c002d252:	56                   	push   %esi
c002d253:	e8 58 71 ff ff       	call   c00243b0 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002d258:	e8 ce 3a ff ff       	call   c0020d2b <thread_get_load_avg>
c002d25d:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002d25f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d264:	f7 e9                	imul   %ecx
c002d266:	c1 fa 05             	sar    $0x5,%edx
c002d269:	89 c8                	mov    %ecx,%eax
c002d26b:	c1 f8 1f             	sar    $0x1f,%eax
c002d26e:	29 c2                	sub    %eax,%edx
c002d270:	6b c2 64             	imul   $0x64,%edx,%eax
c002d273:	29 c1                	sub    %eax,%ecx
c002d275:	51                   	push   %ecx
c002d276:	52                   	push   %edx
c002d277:	55                   	push   %ebp
c002d278:	ff 74 24 28          	pushl  0x28(%esp)
c002d27c:	e8 c5 dc ff ff       	call   c002af46 <msg>
c002d281:	81 44 24 20 c8 00 00 	addl   $0xc8,0x20(%esp)
c002d288:	00 
c002d289:	83 54 24 24 00       	adcl   $0x0,0x24(%esp)
c002d28e:	83 c5 02             	add    $0x2,%ebp
  for (i = 0; i < 90; i++) 
c002d291:	83 c4 20             	add    $0x20,%esp
c002d294:	8b 14 24             	mov    (%esp),%edx
c002d297:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c002d29b:	89 d0                	mov    %edx,%eax
c002d29d:	35 38 4a 00 00       	xor    $0x4a38,%eax
c002d2a2:	89 ca                	mov    %ecx,%edx
c002d2a4:	09 c2                	or     %eax,%edx
c002d2a6:	75 8a                	jne    c002d232 <test_mlfqs_load_avg+0xd7>
}
c002d2a8:	83 c4 2c             	add    $0x2c,%esp
c002d2ab:	5b                   	pop    %ebx
c002d2ac:	5e                   	pop    %esi
c002d2ad:	5f                   	pop    %edi
c002d2ae:	5d                   	pop    %ebp
c002d2af:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002d2b0:	83 ec 0c             	sub    $0xc,%esp
c002d2b3:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c002d2b9:	50                   	push   %eax
c002d2ba:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d2c0:	50                   	push   %eax
c002d2c1:	8d 83 34 55 ff ff    	lea    -0xaacc(%ebx),%eax
c002d2c7:	50                   	push   %eax
c002d2c8:	68 82 00 00 00       	push   $0x82
c002d2cd:	8d 83 2c 84 ff ff    	lea    -0x7bd4(%ebx),%eax
c002d2d3:	50                   	push   %eax
c002d2d4:	e8 b6 bc ff ff       	call   c0028f8f <debug_panic>

c002d2d9 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002d2d9:	55                   	push   %ebp
c002d2da:	57                   	push   %edi
c002d2db:	56                   	push   %esi
c002d2dc:	53                   	push   %ebx
c002d2dd:	83 ec 1c             	sub    $0x1c,%esp
c002d2e0:	e8 56 06 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d2e5:	81 c3 e7 c1 00 00    	add    $0xc1e7,%ebx
  int64_t start_time;
  int last_elapsed = 0;
  
  ASSERT (thread_mlfqs);
c002d2eb:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002d2f1:	80 38 00             	cmpb   $0x0,(%eax)
c002d2f4:	74 6b                	je     c002d361 <test_mlfqs_recent_1+0x88>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002d2f6:	8d ab 7c 84 ff ff    	lea    -0x7b84(%ebx),%ebp
c002d2fc:	83 ec 0c             	sub    $0xc,%esp
c002d2ff:	55                   	push   %ebp
c002d300:	e8 41 dc ff ff       	call   c002af46 <msg>
      start_time = timer_ticks ();
c002d305:	e8 57 70 ff ff       	call   c0024361 <timer_ticks>
c002d30a:	89 c6                	mov    %eax,%esi
c002d30c:	89 d7                	mov    %edx,%edi
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002d30e:	83 c0 63             	add    $0x63,%eax
c002d311:	83 d2 00             	adc    $0x0,%edx
c002d314:	6a 00                	push   $0x0
c002d316:	6a 64                	push   $0x64
c002d318:	52                   	push   %edx
c002d319:	50                   	push   %eax
c002d31a:	e8 33 b6 ff ff       	call   c0028952 <__divdi3>
c002d31f:	83 c4 18             	add    $0x18,%esp
c002d322:	29 f0                	sub    %esi,%eax
c002d324:	19 fa                	sbb    %edi,%edx
c002d326:	05 e8 03 00 00       	add    $0x3e8,%eax
c002d32b:	83 d2 00             	adc    $0x0,%edx
c002d32e:	52                   	push   %edx
c002d32f:	50                   	push   %eax
c002d330:	e8 7b 70 ff ff       	call   c00243b0 <timer_sleep>
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002d335:	e8 1a 3a ff ff       	call   c0020d54 <thread_get_recent_cpu>
c002d33a:	83 c4 10             	add    $0x10,%esp
c002d33d:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002d342:	7f b8                	jg     c002d2fc <test_mlfqs_recent_1+0x23>

  start_time = timer_ticks ();
c002d344:	e8 18 70 ff ff       	call   c0024361 <timer_ticks>
c002d349:	89 c6                	mov    %eax,%esi
c002d34b:	89 d7                	mov    %edx,%edi
  int last_elapsed = 0;
c002d34d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c002d354:	00 
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
        {
          int recent_cpu = thread_get_recent_cpu ();
          int load_avg = thread_get_load_avg ();
          int elapsed_seconds = elapsed / TIMER_FREQ;
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002d355:	8d 83 c0 84 ff ff    	lea    -0x7b40(%ebx),%eax
c002d35b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002d35f:	eb 2a                	jmp    c002d38b <test_mlfqs_recent_1+0xb2>
  ASSERT (thread_mlfqs);
c002d361:	83 ec 0c             	sub    $0xc,%esp
c002d364:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c002d36a:	50                   	push   %eax
c002d36b:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d371:	50                   	push   %eax
c002d372:	8d 83 48 55 ff ff    	lea    -0xaab8(%ebx),%eax
c002d378:	50                   	push   %eax
c002d379:	6a 73                	push   $0x73
c002d37b:	8d 83 54 84 ff ff    	lea    -0x7bac(%ebx),%eax
c002d381:	50                   	push   %eax
c002d382:	e8 08 bc ff ff       	call   c0028f8f <debug_panic>
{
c002d387:	89 6c 24 04          	mov    %ebp,0x4(%esp)
      int elapsed = timer_elapsed (start_time);
c002d38b:	83 ec 08             	sub    $0x8,%esp
c002d38e:	57                   	push   %edi
c002d38f:	56                   	push   %esi
c002d390:	e8 ff 6f ff ff       	call   c0024394 <timer_elapsed>
c002d395:	89 c5                	mov    %eax,%ebp
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002d397:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d39c:	f7 ed                	imul   %ebp
c002d39e:	c1 fa 06             	sar    $0x6,%edx
c002d3a1:	89 e8                	mov    %ebp,%eax
c002d3a3:	c1 f8 1f             	sar    $0x1f,%eax
c002d3a6:	29 c2                	sub    %eax,%edx
c002d3a8:	69 d2 c8 00 00 00    	imul   $0xc8,%edx,%edx
c002d3ae:	83 c4 10             	add    $0x10,%esp
c002d3b1:	39 d5                	cmp    %edx,%ebp
c002d3b3:	75 d2                	jne    c002d387 <test_mlfqs_recent_1+0xae>
c002d3b5:	39 6c 24 04          	cmp    %ebp,0x4(%esp)
c002d3b9:	7d cc                	jge    c002d387 <test_mlfqs_recent_1+0xae>
          int recent_cpu = thread_get_recent_cpu ();
c002d3bb:	e8 94 39 ff ff       	call   c0020d54 <thread_get_recent_cpu>
c002d3c0:	89 44 24 08          	mov    %eax,0x8(%esp)
          int load_avg = thread_get_load_avg ();
c002d3c4:	e8 62 39 ff ff       	call   c0020d2b <thread_get_load_avg>
c002d3c9:	89 c1                	mov    %eax,%ecx
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002d3cb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d3d0:	f7 ed                	imul   %ebp
c002d3d2:	c1 fa 05             	sar    $0x5,%edx
c002d3d5:	89 e8                	mov    %ebp,%eax
c002d3d7:	c1 f8 1f             	sar    $0x1f,%eax
c002d3da:	29 c2                	sub    %eax,%edx
c002d3dc:	89 54 24 04          	mov    %edx,0x4(%esp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002d3e0:	83 ec 08             	sub    $0x8,%esp
c002d3e3:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d3e8:	f7 e9                	imul   %ecx
c002d3ea:	c1 fa 05             	sar    $0x5,%edx
c002d3ed:	89 c8                	mov    %ecx,%eax
c002d3ef:	c1 f8 1f             	sar    $0x1f,%eax
c002d3f2:	29 c2                	sub    %eax,%edx
c002d3f4:	6b c2 64             	imul   $0x64,%edx,%eax
c002d3f7:	29 c1                	sub    %eax,%ecx
c002d3f9:	51                   	push   %ecx
c002d3fa:	52                   	push   %edx
c002d3fb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d400:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c002d404:	f7 e9                	imul   %ecx
c002d406:	c1 fa 05             	sar    $0x5,%edx
c002d409:	89 c8                	mov    %ecx,%eax
c002d40b:	c1 f8 1f             	sar    $0x1f,%eax
c002d40e:	29 c2                	sub    %eax,%edx
c002d410:	6b c2 64             	imul   $0x64,%edx,%eax
c002d413:	29 c1                	sub    %eax,%ecx
c002d415:	51                   	push   %ecx
c002d416:	52                   	push   %edx
c002d417:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d41b:	ff 74 24 28          	pushl  0x28(%esp)
c002d41f:	e8 22 db ff ff       	call   c002af46 <msg>
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002d424:	83 c4 20             	add    $0x20,%esp
c002d427:	81 7c 24 04 b3 00 00 	cmpl   $0xb3,0x4(%esp)
c002d42e:	00 
c002d42f:	0f 8e 52 ff ff ff    	jle    c002d387 <test_mlfqs_recent_1+0xae>
            break;
        } 
      last_elapsed = elapsed;
    }
}
c002d435:	83 c4 1c             	add    $0x1c,%esp
c002d438:	5b                   	pop    %ebx
c002d439:	5e                   	pop    %esi
c002d43a:	5f                   	pop    %edi
c002d43b:	5d                   	pop    %ebp
c002d43c:	c3                   	ret    

c002d43d <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002d43d:	55                   	push   %ebp
c002d43e:	57                   	push   %edi
c002d43f:	56                   	push   %esi
c002d440:	53                   	push   %ebx
c002d441:	81 ec 7c 01 00 00    	sub    $0x17c,%esp
c002d447:	e8 ef 04 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d44c:	81 c3 80 c0 00 00    	add    $0xc080,%ebx
c002d452:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002d456:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002d45a:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002d460:	80 38 00             	cmpb   $0x0,(%eax)
c002d463:	0f 84 55 01 00 00    	je     c002d5be <test_mlfqs_fair+0x181>
c002d469:	89 d7                	mov    %edx,%edi
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002d46b:	83 7c 24 0c 14       	cmpl   $0x14,0xc(%esp)
c002d470:	0f 8f 6e 01 00 00    	jg     c002d5e4 <test_mlfqs_fair+0x1a7>
  ASSERT (nice_min >= -10);
c002d476:	83 fa f6             	cmp    $0xfffffff6,%edx
c002d479:	0f 8c 8b 01 00 00    	jl     c002d60a <test_mlfqs_fair+0x1cd>
  ASSERT (nice_step >= 0);
c002d47f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c002d484:	0f 88 a6 01 00 00    	js     c002d630 <test_mlfqs_fair+0x1f3>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002d48a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d48e:	83 e8 01             	sub    $0x1,%eax
c002d491:	0f af 44 24 18       	imul   0x18(%esp),%eax
c002d496:	01 d0                	add    %edx,%eax
c002d498:	83 f8 14             	cmp    $0x14,%eax
c002d49b:	0f 8f b5 01 00 00    	jg     c002d656 <test_mlfqs_fair+0x219>

  thread_set_nice (-20);
c002d4a1:	83 ec 0c             	sub    $0xc,%esp
c002d4a4:	6a ec                	push   $0xffffffec
c002d4a6:	e8 b0 41 ff ff       	call   c002165b <thread_set_nice>

  start_time = timer_ticks ();
c002d4ab:	e8 b1 6e ff ff       	call   c0024361 <timer_ticks>
c002d4b0:	89 44 24 20          	mov    %eax,0x20(%esp)
c002d4b4:	89 54 24 24          	mov    %edx,0x24(%esp)
  msg ("Starting %d threads...", thread_cnt);
c002d4b8:	83 c4 08             	add    $0x8,%esp
c002d4bb:	8b 74 24 14          	mov    0x14(%esp),%esi
c002d4bf:	56                   	push   %esi
c002d4c0:	8d 83 3a 85 ff ff    	lea    -0x7ac6(%ebx),%eax
c002d4c6:	50                   	push   %eax
c002d4c7:	e8 7a da ff ff       	call   c002af46 <msg>
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002d4cc:	83 c4 10             	add    $0x10,%esp
c002d4cf:	85 f6                	test   %esi,%esi
c002d4d1:	0f 8e a5 01 00 00    	jle    c002d67c <test_mlfqs_fair+0x23f>
c002d4d7:	8d 74 24 30          	lea    0x30(%esp),%esi
c002d4db:	bd 00 00 00 00       	mov    $0x0,%ebp

      ti->start_time = start_time;
      ti->tick_count = 0;
      ti->nice = nice;

      snprintf(name, sizeof name, "load %d", i);
c002d4e0:	8d 83 72 83 ff ff    	lea    -0x7c8e(%ebx),%eax
c002d4e6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002d4ea:	8d 44 24 20          	lea    0x20(%esp),%eax
c002d4ee:	89 44 24 08          	mov    %eax,0x8(%esp)
      ti->start_time = start_time;
c002d4f2:	8b 44 24 10          	mov    0x10(%esp),%eax
c002d4f6:	8b 54 24 14          	mov    0x14(%esp),%edx
c002d4fa:	89 06                	mov    %eax,(%esi)
c002d4fc:	89 56 04             	mov    %edx,0x4(%esi)
      ti->tick_count = 0;
c002d4ff:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
      ti->nice = nice;
c002d506:	89 7e 0c             	mov    %edi,0xc(%esi)
      snprintf(name, sizeof name, "load %d", i);
c002d509:	55                   	push   %ebp
c002d50a:	ff 74 24 20          	pushl  0x20(%esp)
c002d50e:	6a 10                	push   $0x10
c002d510:	ff 74 24 14          	pushl  0x14(%esp)
c002d514:	e8 00 a6 ff ff       	call   c0027b19 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002d519:	56                   	push   %esi
c002d51a:	8d 83 f6 41 ff ff    	lea    -0xbe0a(%ebx),%eax
c002d520:	50                   	push   %eax
c002d521:	6a 1f                	push   $0x1f
c002d523:	ff 74 24 24          	pushl  0x24(%esp)
c002d527:	e8 2f 3c ff ff       	call   c002115b <thread_create>

      nice += nice_step;
c002d52c:	03 7c 24 38          	add    0x38(%esp),%edi
  for (i = 0; i < thread_cnt; i++) 
c002d530:	83 c5 01             	add    $0x1,%ebp
c002d533:	83 c6 10             	add    $0x10,%esi
c002d536:	83 c4 20             	add    $0x20,%esp
c002d539:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c002d53d:	75 b3                	jne    c002d4f2 <test_mlfqs_fair+0xb5>
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002d53f:	83 ec 08             	sub    $0x8,%esp
c002d542:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d546:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d54a:	e8 45 6e ff ff       	call   c0024394 <timer_elapsed>
c002d54f:	83 c4 0c             	add    $0xc,%esp
c002d552:	52                   	push   %edx
c002d553:	50                   	push   %eax
c002d554:	8d 83 c4 85 ff ff    	lea    -0x7a3c(%ebx),%eax
c002d55a:	50                   	push   %eax
c002d55b:	e8 e6 d9 ff ff       	call   c002af46 <msg>

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002d560:	8d 83 e8 85 ff ff    	lea    -0x7a18(%ebx),%eax
c002d566:	89 04 24             	mov    %eax,(%esp)
c002d569:	e8 d8 d9 ff ff       	call   c002af46 <msg>
  timer_sleep (40 * TIMER_FREQ);
c002d56e:	83 c4 08             	add    $0x8,%esp
c002d571:	6a 00                	push   $0x0
c002d573:	68 a0 0f 00 00       	push   $0xfa0
c002d578:	e8 33 6e ff ff       	call   c00243b0 <timer_sleep>
c002d57d:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002d580:	be 00 00 00 00       	mov    $0x0,%esi
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002d585:	8d 44 24 38          	lea    0x38(%esp),%eax
c002d589:	89 44 24 08          	mov    %eax,0x8(%esp)
c002d58d:	8d bb 51 85 ff ff    	lea    -0x7aaf(%ebx),%edi
c002d593:	83 ec 04             	sub    $0x4,%esp
c002d596:	89 f0                	mov    %esi,%eax
c002d598:	c1 e0 04             	shl    $0x4,%eax
c002d59b:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c002d59f:	ff 34 01             	pushl  (%ecx,%eax,1)
c002d5a2:	56                   	push   %esi
c002d5a3:	57                   	push   %edi
c002d5a4:	e8 9d d9 ff ff       	call   c002af46 <msg>
  for (i = 0; i < thread_cnt; i++)
c002d5a9:	83 c6 01             	add    $0x1,%esi
c002d5ac:	83 c4 10             	add    $0x10,%esp
c002d5af:	39 ee                	cmp    %ebp,%esi
c002d5b1:	75 e0                	jne    c002d593 <test_mlfqs_fair+0x156>
}
c002d5b3:	81 c4 7c 01 00 00    	add    $0x17c,%esp
c002d5b9:	5b                   	pop    %ebx
c002d5ba:	5e                   	pop    %esi
c002d5bb:	5f                   	pop    %edi
c002d5bc:	5d                   	pop    %ebp
c002d5bd:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002d5be:	83 ec 0c             	sub    $0xc,%esp
c002d5c1:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c002d5c7:	50                   	push   %eax
c002d5c8:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d5ce:	50                   	push   %eax
c002d5cf:	8d 83 5c 55 ff ff    	lea    -0xaaa4(%ebx),%eax
c002d5d5:	50                   	push   %eax
c002d5d6:	6a 49                	push   $0x49
c002d5d8:	8d 83 70 85 ff ff    	lea    -0x7a90(%ebx),%eax
c002d5de:	50                   	push   %eax
c002d5df:	e8 ab b9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002d5e4:	83 ec 0c             	sub    $0xc,%esp
c002d5e7:	8d 83 fe 84 ff ff    	lea    -0x7b02(%ebx),%eax
c002d5ed:	50                   	push   %eax
c002d5ee:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d5f4:	50                   	push   %eax
c002d5f5:	8d 83 5c 55 ff ff    	lea    -0xaaa4(%ebx),%eax
c002d5fb:	50                   	push   %eax
c002d5fc:	6a 4a                	push   $0x4a
c002d5fe:	8d 83 70 85 ff ff    	lea    -0x7a90(%ebx),%eax
c002d604:	50                   	push   %eax
c002d605:	e8 85 b9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (nice_min >= -10);
c002d60a:	83 ec 0c             	sub    $0xc,%esp
c002d60d:	8d 83 1b 85 ff ff    	lea    -0x7ae5(%ebx),%eax
c002d613:	50                   	push   %eax
c002d614:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d61a:	50                   	push   %eax
c002d61b:	8d 83 5c 55 ff ff    	lea    -0xaaa4(%ebx),%eax
c002d621:	50                   	push   %eax
c002d622:	6a 4b                	push   $0x4b
c002d624:	8d 83 70 85 ff ff    	lea    -0x7a90(%ebx),%eax
c002d62a:	50                   	push   %eax
c002d62b:	e8 5f b9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (nice_step >= 0);
c002d630:	83 ec 0c             	sub    $0xc,%esp
c002d633:	8d 83 2b 85 ff ff    	lea    -0x7ad5(%ebx),%eax
c002d639:	50                   	push   %eax
c002d63a:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d640:	50                   	push   %eax
c002d641:	8d 83 5c 55 ff ff    	lea    -0xaaa4(%ebx),%eax
c002d647:	50                   	push   %eax
c002d648:	6a 4c                	push   $0x4c
c002d64a:	8d 83 70 85 ff ff    	lea    -0x7a90(%ebx),%eax
c002d650:	50                   	push   %eax
c002d651:	e8 39 b9 ff ff       	call   c0028f8f <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002d656:	83 ec 0c             	sub    $0xc,%esp
c002d659:	8d 83 94 85 ff ff    	lea    -0x7a6c(%ebx),%eax
c002d65f:	50                   	push   %eax
c002d660:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d666:	50                   	push   %eax
c002d667:	8d 83 5c 55 ff ff    	lea    -0xaaa4(%ebx),%eax
c002d66d:	50                   	push   %eax
c002d66e:	6a 4d                	push   $0x4d
c002d670:	8d 83 70 85 ff ff    	lea    -0x7a90(%ebx),%eax
c002d676:	50                   	push   %eax
c002d677:	e8 13 b9 ff ff       	call   c0028f8f <debug_panic>
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002d67c:	83 ec 08             	sub    $0x8,%esp
c002d67f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d683:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d687:	e8 08 6d ff ff       	call   c0024394 <timer_elapsed>
c002d68c:	83 c4 0c             	add    $0xc,%esp
c002d68f:	52                   	push   %edx
c002d690:	50                   	push   %eax
c002d691:	8d 83 c4 85 ff ff    	lea    -0x7a3c(%ebx),%eax
c002d697:	50                   	push   %eax
c002d698:	e8 a9 d8 ff ff       	call   c002af46 <msg>
  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002d69d:	8d 83 e8 85 ff ff    	lea    -0x7a18(%ebx),%eax
c002d6a3:	89 04 24             	mov    %eax,(%esp)
c002d6a6:	e8 9b d8 ff ff       	call   c002af46 <msg>
  timer_sleep (40 * TIMER_FREQ);
c002d6ab:	83 c4 08             	add    $0x8,%esp
c002d6ae:	6a 00                	push   $0x0
c002d6b0:	68 a0 0f 00 00       	push   $0xfa0
c002d6b5:	e8 f6 6c ff ff       	call   c00243b0 <timer_sleep>
c002d6ba:	83 c4 10             	add    $0x10,%esp
c002d6bd:	e9 f1 fe ff ff       	jmp    c002d5b3 <test_mlfqs_fair+0x176>

c002d6c2 <load_thread>:

static void
load_thread (void *ti_) 
{
c002d6c2:	55                   	push   %ebp
c002d6c3:	57                   	push   %edi
c002d6c4:	56                   	push   %esi
c002d6c5:	53                   	push   %ebx
c002d6c6:	83 ec 18             	sub    $0x18,%esp
c002d6c9:	e8 6d 02 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d6ce:	81 c3 fe bd 00 00    	add    $0xbdfe,%ebx
c002d6d4:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  struct thread_info *ti = ti_;
  int64_t sleep_time = 5 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
c002d6d8:	ff 75 0c             	pushl  0xc(%ebp)
c002d6db:	e8 7b 3f ff ff       	call   c002165b <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002d6e0:	83 c4 08             	add    $0x8,%esp
c002d6e3:	ff 75 04             	pushl  0x4(%ebp)
c002d6e6:	ff 75 00             	pushl  0x0(%ebp)
c002d6e9:	e8 a6 6c ff ff       	call   c0024394 <timer_elapsed>
c002d6ee:	83 c4 08             	add    $0x8,%esp
c002d6f1:	be f4 01 00 00       	mov    $0x1f4,%esi
c002d6f6:	bf 00 00 00 00       	mov    $0x0,%edi
c002d6fb:	29 c6                	sub    %eax,%esi
c002d6fd:	19 d7                	sbb    %edx,%edi
c002d6ff:	57                   	push   %edi
c002d700:	56                   	push   %esi
c002d701:	e8 aa 6c ff ff       	call   c00243b0 <timer_sleep>
  while (timer_elapsed (ti->start_time) < spin_time) 
c002d706:	83 c4 10             	add    $0x10,%esp
  int64_t last_time = 0;
c002d709:	bf 00 00 00 00       	mov    $0x0,%edi
c002d70e:	be 00 00 00 00       	mov    $0x0,%esi
  while (timer_elapsed (ti->start_time) < spin_time) 
c002d713:	eb 1c                	jmp    c002d731 <load_thread+0x6f>
c002d715:	3d ab 0d 00 00       	cmp    $0xdab,%eax
c002d71a:	77 2e                	ja     c002d74a <load_thread+0x88>
    {
      int64_t cur_time = timer_ticks ();
c002d71c:	e8 40 6c ff ff       	call   c0024361 <timer_ticks>
      if (cur_time != last_time)
c002d721:	31 c7                	xor    %eax,%edi
c002d723:	31 d6                	xor    %edx,%esi
c002d725:	09 fe                	or     %edi,%esi
c002d727:	74 04                	je     c002d72d <load_thread+0x6b>
        ti->tick_count++;
c002d729:	83 45 08 01          	addl   $0x1,0x8(%ebp)
{
c002d72d:	89 c7                	mov    %eax,%edi
c002d72f:	89 d6                	mov    %edx,%esi
  while (timer_elapsed (ti->start_time) < spin_time) 
c002d731:	83 ec 08             	sub    $0x8,%esp
c002d734:	ff 75 04             	pushl  0x4(%ebp)
c002d737:	ff 75 00             	pushl  0x0(%ebp)
c002d73a:	e8 55 6c ff ff       	call   c0024394 <timer_elapsed>
c002d73f:	83 c4 10             	add    $0x10,%esp
c002d742:	85 d2                	test   %edx,%edx
c002d744:	78 d6                	js     c002d71c <load_thread+0x5a>
c002d746:	85 d2                	test   %edx,%edx
c002d748:	7e cb                	jle    c002d715 <load_thread+0x53>
      last_time = cur_time;
    }
}
c002d74a:	83 c4 0c             	add    $0xc,%esp
c002d74d:	5b                   	pop    %ebx
c002d74e:	5e                   	pop    %esi
c002d74f:	5f                   	pop    %edi
c002d750:	5d                   	pop    %ebp
c002d751:	c3                   	ret    

c002d752 <test_mlfqs_fair_2>:
{
c002d752:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 0);
c002d755:	b9 00 00 00 00       	mov    $0x0,%ecx
c002d75a:	ba 00 00 00 00       	mov    $0x0,%edx
c002d75f:	b8 02 00 00 00       	mov    $0x2,%eax
c002d764:	e8 d4 fc ff ff       	call   c002d43d <test_mlfqs_fair>
}
c002d769:	83 c4 0c             	add    $0xc,%esp
c002d76c:	c3                   	ret    

c002d76d <test_mlfqs_fair_20>:
{
c002d76d:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (20, 0, 0);
c002d770:	b9 00 00 00 00       	mov    $0x0,%ecx
c002d775:	ba 00 00 00 00       	mov    $0x0,%edx
c002d77a:	b8 14 00 00 00       	mov    $0x14,%eax
c002d77f:	e8 b9 fc ff ff       	call   c002d43d <test_mlfqs_fair>
}
c002d784:	83 c4 0c             	add    $0xc,%esp
c002d787:	c3                   	ret    

c002d788 <test_mlfqs_nice_2>:
{
c002d788:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 5);
c002d78b:	b9 05 00 00 00       	mov    $0x5,%ecx
c002d790:	ba 00 00 00 00       	mov    $0x0,%edx
c002d795:	b8 02 00 00 00       	mov    $0x2,%eax
c002d79a:	e8 9e fc ff ff       	call   c002d43d <test_mlfqs_fair>
}
c002d79f:	83 c4 0c             	add    $0xc,%esp
c002d7a2:	c3                   	ret    

c002d7a3 <test_mlfqs_nice_10>:
{
c002d7a3:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (10, 0, 1);
c002d7a6:	b9 01 00 00 00       	mov    $0x1,%ecx
c002d7ab:	ba 00 00 00 00       	mov    $0x0,%edx
c002d7b0:	b8 0a 00 00 00       	mov    $0xa,%eax
c002d7b5:	e8 83 fc ff ff       	call   c002d43d <test_mlfqs_fair>
}
c002d7ba:	83 c4 0c             	add    $0xc,%esp
c002d7bd:	c3                   	ret    

c002d7be <block_thread>:
  msg ("Block thread should have already acquired lock.");
}

static void
block_thread (void *lock_) 
{
c002d7be:	57                   	push   %edi
c002d7bf:	56                   	push   %esi
c002d7c0:	53                   	push   %ebx
c002d7c1:	e8 75 01 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d7c6:	81 c3 06 bd 00 00    	add    $0xbd06,%ebx
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002d7cc:	83 ec 0c             	sub    $0xc,%esp
c002d7cf:	8d 83 20 86 ff ff    	lea    -0x79e0(%ebx),%eax
c002d7d5:	50                   	push   %eax
c002d7d6:	e8 6b d7 ff ff       	call   c002af46 <msg>
  start_time = timer_ticks ();
c002d7db:	e8 81 6b ff ff       	call   c0024361 <timer_ticks>
c002d7e0:	89 c6                	mov    %eax,%esi
c002d7e2:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002d7e4:	83 c4 10             	add    $0x10,%esp
c002d7e7:	83 ec 08             	sub    $0x8,%esp
c002d7ea:	57                   	push   %edi
c002d7eb:	56                   	push   %esi
c002d7ec:	e8 a3 6b ff ff       	call   c0024394 <timer_elapsed>
c002d7f1:	83 c4 10             	add    $0x10,%esp
c002d7f4:	85 d2                	test   %edx,%edx
c002d7f6:	78 ef                	js     c002d7e7 <block_thread+0x29>
c002d7f8:	85 d2                	test   %edx,%edx
c002d7fa:	7e 30                	jle    c002d82c <block_thread+0x6e>
    continue;

  msg ("Block thread acquiring lock...");
c002d7fc:	83 ec 0c             	sub    $0xc,%esp
c002d7ff:	8d 83 48 86 ff ff    	lea    -0x79b8(%ebx),%eax
c002d805:	50                   	push   %eax
c002d806:	e8 3b d7 ff ff       	call   c002af46 <msg>
  lock_acquire (lock);
c002d80b:	83 c4 04             	add    $0x4,%esp
c002d80e:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d812:	e8 26 58 ff ff       	call   c002303d <lock_acquire>

  msg ("...got it.");
c002d817:	8d 83 20 87 ff ff    	lea    -0x78e0(%ebx),%eax
c002d81d:	89 04 24             	mov    %eax,(%esp)
c002d820:	e8 21 d7 ff ff       	call   c002af46 <msg>
}
c002d825:	83 c4 10             	add    $0x10,%esp
c002d828:	5b                   	pop    %ebx
c002d829:	5e                   	pop    %esi
c002d82a:	5f                   	pop    %edi
c002d82b:	c3                   	ret    
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002d82c:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002d831:	76 b4                	jbe    c002d7e7 <block_thread+0x29>
c002d833:	eb c7                	jmp    c002d7fc <block_thread+0x3e>

c002d835 <test_mlfqs_block>:
{
c002d835:	57                   	push   %edi
c002d836:	56                   	push   %esi
c002d837:	53                   	push   %ebx
c002d838:	83 ec 30             	sub    $0x30,%esp
c002d83b:	e8 fb 00 00 00       	call   c002d93b <__x86.get_pc_thunk.bx>
c002d840:	81 c3 8c bc 00 00    	add    $0xbc8c,%ebx
  ASSERT (thread_mlfqs);
c002d846:	c7 c0 e0 b8 03 c0    	mov    $0xc003b8e0,%eax
c002d84c:	80 38 00             	cmpb   $0x0,(%eax)
c002d84f:	0f 84 b7 00 00 00    	je     c002d90c <test_mlfqs_block+0xd7>
  msg ("Main thread acquiring lock.");
c002d855:	83 ec 0c             	sub    $0xc,%esp
c002d858:	8d 83 2b 87 ff ff    	lea    -0x78d5(%ebx),%eax
c002d85e:	50                   	push   %eax
c002d85f:	e8 e2 d6 ff ff       	call   c002af46 <msg>
  lock_init (&lock);
c002d864:	83 c4 04             	add    $0x4,%esp
c002d867:	8d 74 24 18          	lea    0x18(%esp),%esi
c002d86b:	56                   	push   %esi
c002d86c:	e8 20 57 ff ff       	call   c0022f91 <lock_init>
  lock_acquire (&lock);
c002d871:	89 34 24             	mov    %esi,(%esp)
c002d874:	e8 c4 57 ff ff       	call   c002303d <lock_acquire>
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002d879:	8d 83 8c 86 ff ff    	lea    -0x7974(%ebx),%eax
c002d87f:	89 04 24             	mov    %eax,(%esp)
c002d882:	e8 bf d6 ff ff       	call   c002af46 <msg>
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002d887:	56                   	push   %esi
c002d888:	8d 83 f2 42 ff ff    	lea    -0xbd0e(%ebx),%eax
c002d88e:	50                   	push   %eax
c002d88f:	6a 1f                	push   $0x1f
c002d891:	8d 83 b2 74 ff ff    	lea    -0x8b4e(%ebx),%eax
c002d897:	50                   	push   %eax
c002d898:	e8 be 38 ff ff       	call   c002115b <thread_create>
  timer_sleep (25 * TIMER_FREQ);
c002d89d:	83 c4 18             	add    $0x18,%esp
c002d8a0:	6a 00                	push   $0x0
c002d8a2:	68 c4 09 00 00       	push   $0x9c4
c002d8a7:	e8 04 6b ff ff       	call   c00243b0 <timer_sleep>
  msg ("Main thread spinning for 5 seconds...");
c002d8ac:	8d 83 c8 86 ff ff    	lea    -0x7938(%ebx),%eax
c002d8b2:	89 04 24             	mov    %eax,(%esp)
c002d8b5:	e8 8c d6 ff ff       	call   c002af46 <msg>
  start_time = timer_ticks ();
c002d8ba:	e8 a2 6a ff ff       	call   c0024361 <timer_ticks>
c002d8bf:	89 c6                	mov    %eax,%esi
c002d8c1:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002d8c3:	83 c4 10             	add    $0x10,%esp
c002d8c6:	83 ec 08             	sub    $0x8,%esp
c002d8c9:	57                   	push   %edi
c002d8ca:	56                   	push   %esi
c002d8cb:	e8 c4 6a ff ff       	call   c0024394 <timer_elapsed>
c002d8d0:	83 c4 10             	add    $0x10,%esp
c002d8d3:	85 d2                	test   %edx,%edx
c002d8d5:	78 ef                	js     c002d8c6 <test_mlfqs_block+0x91>
c002d8d7:	85 d2                	test   %edx,%edx
c002d8d9:	7e 57                	jle    c002d932 <test_mlfqs_block+0xfd>
  msg ("Main thread releasing lock.");
c002d8db:	83 ec 0c             	sub    $0xc,%esp
c002d8de:	8d 83 47 87 ff ff    	lea    -0x78b9(%ebx),%eax
c002d8e4:	50                   	push   %eax
c002d8e5:	e8 5c d6 ff ff       	call   c002af46 <msg>
  lock_release (&lock);
c002d8ea:	83 c4 04             	add    $0x4,%esp
c002d8ed:	8d 44 24 18          	lea    0x18(%esp),%eax
c002d8f1:	50                   	push   %eax
c002d8f2:	e8 3e 59 ff ff       	call   c0023235 <lock_release>
  msg ("Block thread should have already acquired lock.");
c002d8f7:	8d 83 f0 86 ff ff    	lea    -0x7910(%ebx),%eax
c002d8fd:	89 04 24             	mov    %eax,(%esp)
c002d900:	e8 41 d6 ff ff       	call   c002af46 <msg>
}
c002d905:	83 c4 40             	add    $0x40,%esp
c002d908:	5b                   	pop    %ebx
c002d909:	5e                   	pop    %esi
c002d90a:	5f                   	pop    %edi
c002d90b:	c3                   	ret    
  ASSERT (thread_mlfqs);
c002d90c:	83 ec 0c             	sub    $0xc,%esp
c002d90f:	8d 83 b9 74 ff ff    	lea    -0x8b47(%ebx),%eax
c002d915:	50                   	push   %eax
c002d916:	8d 83 eb 55 ff ff    	lea    -0xaa15(%ebx),%eax
c002d91c:	50                   	push   %eax
c002d91d:	8d 83 6c 55 ff ff    	lea    -0xaa94(%ebx),%eax
c002d923:	50                   	push   %eax
c002d924:	6a 1c                	push   $0x1c
c002d926:	8d 83 68 86 ff ff    	lea    -0x7998(%ebx),%eax
c002d92c:	50                   	push   %eax
c002d92d:	e8 5d b6 ff ff       	call   c0028f8f <debug_panic>
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002d932:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002d937:	76 8d                	jbe    c002d8c6 <test_mlfqs_block+0x91>
c002d939:	eb a0                	jmp    c002d8db <test_mlfqs_block+0xa6>

Disassembly of section .text.__x86.get_pc_thunk.bx:

c002d93b <__x86.get_pc_thunk.bx>:
c002d93b:	8b 1c 24             	mov    (%esp),%ebx
c002d93e:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c002d93f <__x86.get_pc_thunk.ax>:
c002d93f:	8b 04 24             	mov    (%esp),%eax
c002d942:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c002d943 <__x86.get_pc_thunk.di>:
c002d943:	8b 3c 24             	mov    (%esp),%edi
c002d946:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.si:

c002d947 <__x86.get_pc_thunk.si>:
c002d947:	8b 34 24             	mov    (%esp),%esi
c002d94a:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c002d94b <__x86.get_pc_thunk.cx>:
c002d94b:	8b 0c 24             	mov    (%esp),%ecx
c002d94e:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c002d94f <__x86.get_pc_thunk.dx>:
c002d94f:	8b 14 24             	mov    (%esp),%edx
c002d952:	c3                   	ret    
