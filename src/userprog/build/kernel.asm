
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 2f 01 00 00       	call   c002028c <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c0020182:	55                   	push   %ebp
c0020183:	57                   	push   %edi
c0020184:	56                   	push   %esi
c0020185:	53                   	push   %ebx
c0020186:	83 ec 0c             	sub    $0xc,%esp
c0020189:	e8 f7 e8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002018e:	81 c3 26 ad 01 00    	add    $0x1ad26,%ebx
c0020194:	89 c7                	mov    %eax,%edi
  struct block *block = NULL;

  if (name != NULL)
c0020196:	85 d2                	test   %edx,%edx
c0020198:	74 70                	je     c002020a <locate_block_device+0x88>
c002019a:	89 d5                	mov    %edx,%ebp
    {
      block = block_get_by_name (name);
c002019c:	83 ec 0c             	sub    $0xc,%esp
c002019f:	52                   	push   %edx
c00201a0:	e8 10 51 00 00       	call   c00252b5 <block_get_by_name>
c00201a5:	89 c6                	mov    %eax,%esi
      if (block == NULL)
c00201a7:	83 c4 10             	add    $0x10,%esp
c00201aa:	85 c0                	test   %eax,%eax
c00201ac:	74 39                	je     c00201e7 <locate_block_device+0x65>
          break;
    }

  if (block != NULL)
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c00201ae:	83 ec 0c             	sub    $0xc,%esp
c00201b1:	56                   	push   %esi
c00201b2:	e8 18 52 00 00       	call   c00253cf <block_name>
c00201b7:	89 c5                	mov    %eax,%ebp
c00201b9:	89 3c 24             	mov    %edi,(%esp)
c00201bc:	e8 9d 4f 00 00       	call   c002515e <block_type_name>
c00201c1:	83 c4 0c             	add    $0xc,%esp
c00201c4:	55                   	push   %ebp
c00201c5:	50                   	push   %eax
c00201c6:	8d 83 c5 4d ff ff    	lea    -0xb23b(%ebx),%eax
c00201cc:	50                   	push   %eax
c00201cd:	e8 1e 73 00 00       	call   c00274f0 <printf>
      block_set_role (role, block);
c00201d2:	83 c4 08             	add    $0x8,%esp
c00201d5:	56                   	push   %esi
c00201d6:	57                   	push   %edi
c00201d7:	e8 16 50 00 00       	call   c00251f2 <block_set_role>
c00201dc:	83 c4 10             	add    $0x10,%esp
    }
}
c00201df:	83 c4 0c             	add    $0xc,%esp
c00201e2:	5b                   	pop    %ebx
c00201e3:	5e                   	pop    %esi
c00201e4:	5f                   	pop    %edi
c00201e5:	5d                   	pop    %ebp
c00201e6:	c3                   	ret    
        PANIC ("No such block device \"%s\"", name);
c00201e7:	83 ec 0c             	sub    $0xc,%esp
c00201ea:	55                   	push   %ebp
c00201eb:	8d 83 96 4d ff ff    	lea    -0xb26a(%ebx),%eax
c00201f1:	50                   	push   %eax
c00201f2:	8d 83 18 3c ff ff    	lea    -0xc3e8(%ebx),%eax
c00201f8:	50                   	push   %eax
c00201f9:	68 a2 01 00 00       	push   $0x1a2
c00201fe:	8d 83 b0 4d ff ff    	lea    -0xb250(%ebx),%eax
c0020204:	50                   	push   %eax
c0020205:	e8 7d 90 00 00       	call   c0029287 <debug_panic>
      for (block = block_first (); block != NULL; block = block_next (block))
c002020a:	e8 31 50 00 00       	call   c0025240 <block_first>
c002020f:	89 c6                	mov    %eax,%esi
c0020211:	85 c0                	test   %eax,%eax
c0020213:	74 ca                	je     c00201df <locate_block_device+0x5d>
        if (block_type (block) == role)
c0020215:	83 ec 0c             	sub    $0xc,%esp
c0020218:	56                   	push   %esi
c0020219:	e8 b9 51 00 00       	call   c00253d7 <block_type>
c002021e:	83 c4 10             	add    $0x10,%esp
c0020221:	39 f8                	cmp    %edi,%eax
c0020223:	74 14                	je     c0020239 <locate_block_device+0xb7>
      for (block = block_first (); block != NULL; block = block_next (block))
c0020225:	83 ec 0c             	sub    $0xc,%esp
c0020228:	56                   	push   %esi
c0020229:	e8 4c 50 00 00       	call   c002527a <block_next>
c002022e:	89 c6                	mov    %eax,%esi
c0020230:	83 c4 10             	add    $0x10,%esp
c0020233:	85 c0                	test   %eax,%eax
c0020235:	75 de                	jne    c0020215 <locate_block_device+0x93>
c0020237:	eb a6                	jmp    c00201df <locate_block_device+0x5d>
  if (block != NULL)
c0020239:	85 f6                	test   %esi,%esi
c002023b:	74 a2                	je     c00201df <locate_block_device+0x5d>
c002023d:	e9 6c ff ff ff       	jmp    c00201ae <locate_block_device+0x2c>

c0020242 <run_task>:
{
c0020242:	56                   	push   %esi
c0020243:	53                   	push   %ebx
c0020244:	83 ec 0c             	sub    $0xc,%esp
c0020247:	e8 39 e8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002024c:	81 c3 68 ac 01 00    	add    $0x1ac68,%ebx
  const char *task = argv[1];
c0020252:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020256:	8b 70 04             	mov    0x4(%eax),%esi
  printf ("Executing '%s':\n", task);
c0020259:	56                   	push   %esi
c002025a:	8d 83 d3 4d ff ff    	lea    -0xb22d(%ebx),%eax
c0020260:	50                   	push   %eax
c0020261:	e8 8a 72 00 00       	call   c00274f0 <printf>
  process_wait (process_execute (task));
c0020266:	89 34 24             	mov    %esi,(%esp)
c0020269:	e8 e7 b0 00 00       	call   c002b355 <process_execute>
c002026e:	89 04 24             	mov    %eax,(%esp)
c0020271:	e8 ad b1 00 00       	call   c002b423 <process_wait>
  printf ("Execution of '%s' complete.\n", task);
c0020276:	83 c4 08             	add    $0x8,%esp
c0020279:	56                   	push   %esi
c002027a:	8d 83 e4 4d ff ff    	lea    -0xb21c(%ebx),%eax
c0020280:	50                   	push   %eax
c0020281:	e8 6a 72 00 00       	call   c00274f0 <printf>
}
c0020286:	83 c4 14             	add    $0x14,%esp
c0020289:	5b                   	pop    %ebx
c002028a:	5e                   	pop    %esi
c002028b:	c3                   	ret    

c002028c <pintos_init>:
{
c002028c:	55                   	push   %ebp
c002028d:	57                   	push   %edi
c002028e:	56                   	push   %esi
c002028f:	53                   	push   %ebx
c0020290:	83 ec 40             	sub    $0x40,%esp
c0020293:	e8 ed e7 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020298:	81 c3 1c ac 01 00    	add    $0x1ac1c,%ebx
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c002029e:	c7 c2 d8 b4 03 c0    	mov    $0xc003b4d8,%edx
c00202a4:	c7 c0 45 d4 03 c0    	mov    $0xc003d445,%eax
c00202aa:	29 d0                	sub    %edx,%eax
c00202ac:	50                   	push   %eax
c00202ad:	6a 00                	push   $0x0
c00202af:	52                   	push   %edx
c00202b0:	e8 51 85 00 00       	call   c0028806 <memset>
  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00202b5:	a1 3a 7d 00 c0       	mov    0xc0007d3a,%eax
c00202ba:	89 44 24 14          	mov    %eax,0x14(%esp)
c00202be:	89 c5                	mov    %eax,%ebp
  for (i = 0; i < argc; i++) 
c00202c0:	83 c4 10             	add    $0x10,%esp
c00202c3:	bf 00 00 00 00       	mov    $0x0,%edi
  p = ptov (LOADER_ARGS);
c00202c8:	be 3e 7d 00 c0       	mov    $0xc0007d3e,%esi
  for (i = 0; i < argc; i++) 
c00202cd:	85 c0                	test   %eax,%eax
c00202cf:	7f 6a                	jg     c002033b <pintos_init+0xaf>
  argv[argc] = NULL;
c00202d1:	8b 44 24 04          	mov    0x4(%esp),%eax
c00202d5:	c7 84 83 2c 06 00 00 	movl   $0x0,0x62c(%ebx,%eax,4)
c00202dc:	00 00 00 00 
  printf ("Kernel command line:");
c00202e0:	83 ec 0c             	sub    $0xc,%esp
c00202e3:	8d 83 ad 4e ff ff    	lea    -0xb153(%ebx),%eax
c00202e9:	50                   	push   %eax
c00202ea:	e8 01 72 00 00       	call   c00274f0 <printf>
c00202ef:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c00202f2:	83 ec 0c             	sub    $0xc,%esp
c00202f5:	6a 0a                	push   $0xa
c00202f7:	e8 d6 af 00 00       	call   c002b2d2 <putchar>
  for (; *argv != NULL && **argv == '-'; argv++)
c00202fc:	8b 83 2c 06 00 00    	mov    0x62c(%ebx),%eax
c0020302:	83 c4 10             	add    $0x10,%esp
c0020305:	85 c0                	test   %eax,%eax
c0020307:	0f 84 f2 02 00 00    	je     c00205ff <pintos_init+0x373>
c002030d:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020310:	0f 85 8a 03 00 00    	jne    c00206a0 <pintos_init+0x414>
c0020316:	8d ab 2c 06 00 00    	lea    0x62c(%ebx),%ebp
      char *name = strtok_r (*argv, "=", &save_ptr);
c002031c:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
c0020320:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
        thread_mlfqs = true;
c0020324:	c7 c1 44 d4 03 c0    	mov    $0xc003d444,%ecx
c002032a:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c002032e:	e9 06 01 00 00       	jmp    c0020439 <pintos_init+0x1ad>
      if (p >= end)
c0020333:	81 fe bd 7d 00 c0    	cmp    $0xc0007dbd,%esi
c0020339:	77 66                	ja     c00203a1 <pintos_init+0x115>
      argv[i] = p;
c002033b:	89 b4 bb 2c 06 00 00 	mov    %esi,0x62c(%ebx,%edi,4)
      p += strnlen (p, end - p) + 1;
c0020342:	83 ec 08             	sub    $0x8,%esp
c0020345:	b8 be 7d 00 c0       	mov    $0xc0007dbe,%eax
c002034a:	29 f0                	sub    %esi,%eax
c002034c:	50                   	push   %eax
c002034d:	56                   	push   %esi
c002034e:	e8 5c 85 00 00       	call   c00288af <strnlen>
c0020353:	8d 74 06 01          	lea    0x1(%esi,%eax,1),%esi
  for (i = 0; i < argc; i++) 
c0020357:	83 c7 01             	add    $0x1,%edi
c002035a:	83 c4 10             	add    $0x10,%esp
c002035d:	39 fd                	cmp    %edi,%ebp
c002035f:	75 d2                	jne    c0020333 <pintos_init+0xa7>
  argv[argc] = NULL;
c0020361:	8d ab 2c 06 00 00    	lea    0x62c(%ebx),%ebp
c0020367:	c7 44 bd 00 00 00 00 	movl   $0x0,0x0(%ebp,%edi,4)
c002036e:	00 
  printf ("Kernel command line:");
c002036f:	83 ec 0c             	sub    $0xc,%esp
c0020372:	8d 83 ad 4e ff ff    	lea    -0xb153(%ebx),%eax
c0020378:	50                   	push   %eax
c0020379:	e8 72 71 00 00       	call   c00274f0 <printf>
c002037e:	89 ee                	mov    %ebp,%esi
c0020380:	8b 44 24 14          	mov    0x14(%esp),%eax
c0020384:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
c0020388:	83 c4 10             	add    $0x10,%esp
      printf (" '%s'", argv[i]);
c002038b:	8d 83 01 4e ff ff    	lea    -0xb1ff(%ebx),%eax
c0020391:	89 44 24 04          	mov    %eax,0x4(%esp)
      printf (" %s", argv[i]);
c0020395:	8d 83 67 5e ff ff    	lea    -0xa199(%ebx),%eax
c002039b:	89 44 24 08          	mov    %eax,0x8(%esp)
c002039f:	eb 3a                	jmp    c00203db <pintos_init+0x14f>
        PANIC ("command line arguments overflow");
c00203a1:	8d 83 dc 4e ff ff    	lea    -0xb124(%ebx),%eax
c00203a7:	50                   	push   %eax
c00203a8:	8d 83 50 3c ff ff    	lea    -0xc3b0(%ebx),%eax
c00203ae:	50                   	push   %eax
c00203af:	68 d3 00 00 00       	push   $0xd3
c00203b4:	8d 83 b0 4d ff ff    	lea    -0xb250(%ebx),%eax
c00203ba:	50                   	push   %eax
c00203bb:	e8 c7 8e 00 00       	call   c0029287 <debug_panic>
      printf (" %s", argv[i]);
c00203c0:	83 ec 08             	sub    $0x8,%esp
c00203c3:	57                   	push   %edi
c00203c4:	ff 74 24 14          	pushl  0x14(%esp)
c00203c8:	e8 23 71 00 00       	call   c00274f0 <printf>
c00203cd:	83 c4 10             	add    $0x10,%esp
c00203d0:	83 c6 04             	add    $0x4,%esi
  for (i = 0; i < argc; i++)
c00203d3:	39 ee                	cmp    %ebp,%esi
c00203d5:	0f 84 17 ff ff ff    	je     c00202f2 <pintos_init+0x66>
    if (strchr (argv[i], ' ') == NULL)
c00203db:	8b 3e                	mov    (%esi),%edi
c00203dd:	83 ec 08             	sub    $0x8,%esp
c00203e0:	6a 20                	push   $0x20
c00203e2:	57                   	push   %edi
c00203e3:	e8 d0 81 00 00       	call   c00285b8 <strchr>
c00203e8:	83 c4 10             	add    $0x10,%esp
c00203eb:	85 c0                	test   %eax,%eax
c00203ed:	74 d1                	je     c00203c0 <pintos_init+0x134>
      printf (" '%s'", argv[i]);
c00203ef:	83 ec 08             	sub    $0x8,%esp
c00203f2:	57                   	push   %edi
c00203f3:	ff 74 24 10          	pushl  0x10(%esp)
c00203f7:	e8 f4 70 00 00       	call   c00274f0 <printf>
c00203fc:	83 c4 10             	add    $0x10,%esp
c00203ff:	eb cf                	jmp    c00203d0 <pintos_init+0x144>
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020401:	83 ec 0c             	sub    $0xc,%esp
c0020404:	8d 83 fc 4e ff ff    	lea    -0xb104(%ebx),%eax
c002040a:	50                   	push   %eax
c002040b:	e8 50 ae 00 00       	call   c002b260 <puts>
  shutdown_power_off ();
c0020410:	e8 30 69 00 00       	call   c0026d45 <shutdown_power_off>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020415:	83 ec 0c             	sub    $0xc,%esp
c0020418:	6a 01                	push   $0x1
c002041a:	e8 95 68 00 00       	call   c0026cb4 <shutdown_configure>
c002041f:	83 c4 10             	add    $0x10,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020422:	83 c5 04             	add    $0x4,%ebp
c0020425:	8b 45 00             	mov    0x0(%ebp),%eax
c0020428:	85 c0                	test   %eax,%eax
c002042a:	0f 84 d5 01 00 00    	je     c0020605 <pintos_init+0x379>
c0020430:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020433:	0f 85 cc 01 00 00    	jne    c0020605 <pintos_init+0x379>
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020439:	83 ec 04             	sub    $0x4,%esp
c002043c:	8b 7c 24 10          	mov    0x10(%esp),%edi
c0020440:	57                   	push   %edi
c0020441:	8d 93 f9 5c ff ff    	lea    -0xa307(%ebx),%edx
c0020447:	52                   	push   %edx
c0020448:	50                   	push   %eax
c0020449:	e8 84 82 00 00       	call   c00286d2 <strtok_r>
c002044e:	89 c6                	mov    %eax,%esi
c0020450:	89 44 24 14          	mov    %eax,0x14(%esp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020454:	83 c4 0c             	add    $0xc,%esp
c0020457:	57                   	push   %edi
c0020458:	8d 83 98 6d ff ff    	lea    -0x9268(%ebx),%eax
c002045e:	50                   	push   %eax
c002045f:	6a 00                	push   $0x0
c0020461:	e8 6c 82 00 00       	call   c00286d2 <strtok_r>
c0020466:	89 44 24 18          	mov    %eax,0x18(%esp)
      if (!strcmp (name, "-h"))
c002046a:	b9 03 00 00 00       	mov    $0x3,%ecx
c002046f:	8d bb 07 4e ff ff    	lea    -0xb1f9(%ebx),%edi
c0020475:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020477:	0f 97 c0             	seta   %al
c002047a:	1c 00                	sbb    $0x0,%al
c002047c:	83 c4 10             	add    $0x10,%esp
c002047f:	84 c0                	test   %al,%al
c0020481:	0f 84 7a ff ff ff    	je     c0020401 <pintos_init+0x175>
      else if (!strcmp (name, "-q"))
c0020487:	b9 03 00 00 00       	mov    $0x3,%ecx
c002048c:	8d bb 0a 4e ff ff    	lea    -0xb1f6(%ebx),%edi
c0020492:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020496:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020498:	0f 97 c0             	seta   %al
c002049b:	1c 00                	sbb    $0x0,%al
c002049d:	84 c0                	test   %al,%al
c002049f:	0f 84 70 ff ff ff    	je     c0020415 <pintos_init+0x189>
      else if (!strcmp (name, "-r"))
c00204a5:	b9 03 00 00 00       	mov    $0x3,%ecx
c00204aa:	8d bb 0d 4e ff ff    	lea    -0xb1f3(%ebx),%edi
c00204b0:	8b 74 24 04          	mov    0x4(%esp),%esi
c00204b4:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204b6:	0f 97 c0             	seta   %al
c00204b9:	1c 00                	sbb    $0x0,%al
c00204bb:	84 c0                	test   %al,%al
c00204bd:	74 26                	je     c00204e5 <pintos_init+0x259>
      else if (!strcmp (name, "-f"))
c00204bf:	b9 03 00 00 00       	mov    $0x3,%ecx
c00204c4:	8d bb 10 4e ff ff    	lea    -0xb1f0(%ebx),%edi
c00204ca:	8b 74 24 04          	mov    0x4(%esp),%esi
c00204ce:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204d0:	0f 97 c0             	seta   %al
c00204d3:	1c 00                	sbb    $0x0,%al
c00204d5:	84 c0                	test   %al,%al
c00204d7:	75 1e                	jne    c00204f7 <pintos_init+0x26b>
        format_filesys = true;
c00204d9:	c6 83 38 07 00 00 01 	movb   $0x1,0x738(%ebx)
c00204e0:	e9 3d ff ff ff       	jmp    c0020422 <pintos_init+0x196>
        shutdown_configure (SHUTDOWN_REBOOT);
c00204e5:	83 ec 0c             	sub    $0xc,%esp
c00204e8:	6a 02                	push   $0x2
c00204ea:	e8 c5 67 00 00       	call   c0026cb4 <shutdown_configure>
c00204ef:	83 c4 10             	add    $0x10,%esp
c00204f2:	e9 2b ff ff ff       	jmp    c0020422 <pintos_init+0x196>
      else if (!strcmp (name, "-filesys"))
c00204f7:	b9 09 00 00 00       	mov    $0x9,%ecx
c00204fc:	8d bb 13 4e ff ff    	lea    -0xb1ed(%ebx),%edi
c0020502:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020506:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020508:	0f 97 c0             	seta   %al
c002050b:	1c 00                	sbb    $0x0,%al
c002050d:	84 c0                	test   %al,%al
c002050f:	75 0f                	jne    c0020520 <pintos_init+0x294>
        filesys_bdev_name = value;
c0020511:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020515:	89 83 34 07 00 00    	mov    %eax,0x734(%ebx)
c002051b:	e9 02 ff ff ff       	jmp    c0020422 <pintos_init+0x196>
      else if (!strcmp (name, "-scratch"))
c0020520:	b9 09 00 00 00       	mov    $0x9,%ecx
c0020525:	8d bb 1c 4e ff ff    	lea    -0xb1e4(%ebx),%edi
c002052b:	8b 74 24 04          	mov    0x4(%esp),%esi
c002052f:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020531:	0f 97 c0             	seta   %al
c0020534:	1c 00                	sbb    $0x0,%al
c0020536:	84 c0                	test   %al,%al
c0020538:	75 0f                	jne    c0020549 <pintos_init+0x2bd>
        scratch_bdev_name = value;
c002053a:	8b 44 24 08          	mov    0x8(%esp),%eax
c002053e:	89 83 30 07 00 00    	mov    %eax,0x730(%ebx)
c0020544:	e9 d9 fe ff ff       	jmp    c0020422 <pintos_init+0x196>
      else if (!strcmp (name, "-rs"))
c0020549:	b9 04 00 00 00       	mov    $0x4,%ecx
c002054e:	8d bb 25 4e ff ff    	lea    -0xb1db(%ebx),%edi
c0020554:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020558:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002055a:	0f 97 c0             	seta   %al
c002055d:	1c 00                	sbb    $0x0,%al
c002055f:	84 c0                	test   %al,%al
c0020561:	74 26                	je     c0020589 <pintos_init+0x2fd>
      else if (!strcmp (name, "-mlfqs"))
c0020563:	83 ec 08             	sub    $0x8,%esp
c0020566:	8d 83 29 4e ff ff    	lea    -0xb1d7(%ebx),%eax
c002056c:	50                   	push   %eax
c002056d:	ff 74 24 10          	pushl  0x10(%esp)
c0020571:	e8 d6 7f 00 00       	call   c002854c <strcmp>
c0020576:	83 c4 10             	add    $0x10,%esp
c0020579:	85 c0                	test   %eax,%eax
c002057b:	75 28                	jne    c00205a5 <pintos_init+0x319>
        thread_mlfqs = true;
c002057d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0020581:	c6 00 01             	movb   $0x1,(%eax)
c0020584:	e9 99 fe ff ff       	jmp    c0020422 <pintos_init+0x196>
        random_init (atoi (value));
c0020589:	83 ec 0c             	sub    $0xc,%esp
c002058c:	ff 74 24 14          	pushl  0x14(%esp)
c0020590:	e8 3c 7c 00 00       	call   c00281d1 <atoi>
c0020595:	89 04 24             	mov    %eax,(%esp)
c0020598:	e8 cf 69 00 00       	call   c0026f6c <random_init>
c002059d:	83 c4 10             	add    $0x10,%esp
c00205a0:	e9 7d fe ff ff       	jmp    c0020422 <pintos_init+0x196>
      else if (!strcmp (name, "-ul"))
c00205a5:	83 ec 08             	sub    $0x8,%esp
c00205a8:	8d 83 30 4e ff ff    	lea    -0xb1d0(%ebx),%eax
c00205ae:	50                   	push   %eax
c00205af:	ff 74 24 10          	pushl  0x10(%esp)
c00205b3:	e8 94 7f 00 00       	call   c002854c <strcmp>
c00205b8:	83 c4 10             	add    $0x10,%esp
c00205bb:	85 c0                	test   %eax,%eax
c00205bd:	75 1a                	jne    c00205d9 <pintos_init+0x34d>
        user_page_limit = atoi (value);
c00205bf:	83 ec 0c             	sub    $0xc,%esp
c00205c2:	ff 74 24 14          	pushl  0x14(%esp)
c00205c6:	e8 06 7c 00 00       	call   c00281d1 <atoi>
c00205cb:	89 83 e0 fb ff ff    	mov    %eax,-0x420(%ebx)
c00205d1:	83 c4 10             	add    $0x10,%esp
c00205d4:	e9 49 fe ff ff       	jmp    c0020422 <pintos_init+0x196>
        PANIC ("unknown option `%s' (use -h for help)", name);
c00205d9:	83 ec 0c             	sub    $0xc,%esp
c00205dc:	ff 74 24 10          	pushl  0x10(%esp)
c00205e0:	8d 83 24 53 ff ff    	lea    -0xacdc(%ebx),%eax
c00205e6:	50                   	push   %eax
c00205e7:	8d 83 40 3c ff ff    	lea    -0xc3c0(%ebx),%eax
c00205ed:	50                   	push   %eax
c00205ee:	68 0c 01 00 00       	push   $0x10c
c00205f3:	8d 83 b0 4d ff ff    	lea    -0xb250(%ebx),%eax
c00205f9:	50                   	push   %eax
c00205fa:	e8 88 8c 00 00       	call   c0029287 <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c00205ff:	8d ab 2c 06 00 00    	lea    0x62c(%ebx),%ebp
  random_init (rtc_get_time ());
c0020605:	e8 34 65 00 00       	call   c0026b3e <rtc_get_time>
c002060a:	83 ec 0c             	sub    $0xc,%esp
c002060d:	50                   	push   %eax
c002060e:	e8 59 69 00 00       	call   c0026f6c <random_init>
  thread_init ();
c0020613:	e8 60 05 00 00       	call   c0020b78 <thread_init>
  console_init ();  
c0020618:	e8 9b ab 00 00       	call   c002b1b8 <console_init>
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002061d:	83 c4 08             	add    $0x8,%esp
          init_ram_pages * PGSIZE / 1024);
c0020620:	c7 c6 7e 01 02 c0    	mov    $0xc002017e,%esi
c0020626:	8b 06                	mov    (%esi),%eax
c0020628:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002062b:	c1 e8 0a             	shr    $0xa,%eax
c002062e:	50                   	push   %eax
c002062f:	8d 83 4c 53 ff ff    	lea    -0xacb4(%ebx),%eax
c0020635:	50                   	push   %eax
c0020636:	e8 b5 6e 00 00       	call   c00274f0 <printf>
  palloc_init (user_page_limit);
c002063b:	83 c4 04             	add    $0x4,%esp
c002063e:	ff b3 e0 fb ff ff    	pushl  -0x420(%ebx)
c0020644:	e8 6c 33 00 00       	call   c00239b5 <palloc_init>
  malloc_init ();
c0020649:	e8 e8 37 00 00       	call   c0023e36 <malloc_init>
  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002064e:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0020655:	e8 b8 34 00 00       	call   c0023b12 <palloc_get_page>
c002065a:	89 c1                	mov    %eax,%ecx
c002065c:	89 44 24 20          	mov    %eax,0x20(%esp)
c0020660:	c7 c0 38 d4 03 c0    	mov    $0xc003d438,%eax
c0020666:	89 08                	mov    %ecx,(%eax)
  for (page = 0; page < init_ram_pages; page++)
c0020668:	83 c4 10             	add    $0x10,%esp
c002066b:	83 3e 00             	cmpl   $0x0,(%esi)
c002066e:	0f 84 6f 01 00 00    	je     c00207e3 <pintos_init+0x557>
c0020674:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
  pt = NULL;
c0020679:	b8 00 00 00 00       	mov    $0x0,%eax
  for (page = 0; page < init_ram_pages; page++)
c002067e:	be 00 00 00 00       	mov    $0x0,%esi
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020683:	c7 c1 00 30 03 c0    	mov    $0xc0033000,%ecx
c0020689:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002068d:	c7 c1 00 00 02 c0    	mov    $0xc0020000,%ecx
c0020693:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c0020697:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c002069b:	e9 a6 00 00 00       	jmp    c0020746 <pintos_init+0x4ba>
  for (; *argv != NULL && **argv == '-'; argv++)
c00206a0:	8d ab 2c 06 00 00    	lea    0x62c(%ebx),%ebp
c00206a6:	e9 5a ff ff ff       	jmp    c0020605 <pintos_init+0x379>
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
  ASSERT (pg_ofs (pt) == 0);
c00206ab:	83 ec 0c             	sub    $0xc,%esp
c00206ae:	8d 83 34 4e ff ff    	lea    -0xb1cc(%ebx),%eax
c00206b4:	50                   	push   %eax
c00206b5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00206bb:	50                   	push   %eax
c00206bc:	8d 83 34 3c ff ff    	lea    -0xc3cc(%ebx),%eax
c00206c2:	50                   	push   %eax
c00206c3:	6a 48                	push   $0x48
c00206c5:	8d 83 5c 4e ff ff    	lea    -0xb1a4(%ebx),%eax
c00206cb:	50                   	push   %eax
c00206cc:	e8 b6 8b 00 00       	call   c0029287 <debug_panic>
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
  ASSERT (is_kernel_vaddr (vaddr));
c00206d1:	83 ec 0c             	sub    $0xc,%esp
c00206d4:	8d 83 70 4e ff ff    	lea    -0xb190(%ebx),%eax
c00206da:	50                   	push   %eax
c00206db:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00206e1:	50                   	push   %eax
c00206e2:	8d 83 2c 3c ff ff    	lea    -0xc3d4(%ebx),%eax
c00206e8:	50                   	push   %eax
c00206e9:	6a 54                	push   $0x54
c00206eb:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c00206f1:	50                   	push   %eax
c00206f2:	e8 90 8b 00 00       	call   c0029287 <debug_panic>
      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c00206f7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c00206fb:	8d 0c 88             	lea    (%eax,%ecx,4),%ecx
c00206fe:	81 7c 24 0c ff ff ff 	cmpl   $0xbfffffff,0xc(%esp)
c0020705:	bf 
c0020706:	0f 86 ad 00 00 00    	jbe    c00207b9 <pintos_init+0x52d>
c002070c:	89 f2                	mov    %esi,%edx
c002070e:	c1 e2 0c             	shl    $0xc,%edx
c0020711:	89 54 24 08          	mov    %edx,0x8(%esp)
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
  ASSERT (pg_ofs (page) == 0);
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c0020715:	0f b6 6c 24 04       	movzbl 0x4(%esp),%ebp
c002071a:	83 f5 01             	xor    $0x1,%ebp
c002071d:	89 ea                	mov    %ebp,%edx
c002071f:	0f b6 ea             	movzbl %dl,%ebp
c0020722:	01 ed                	add    %ebp,%ebp
c0020724:	8b 54 24 08          	mov    0x8(%esp),%edx
c0020728:	83 ca 01             	or     $0x1,%edx
c002072b:	09 ea                	or     %ebp,%edx
c002072d:	89 11                	mov    %edx,(%ecx)
  for (page = 0; page < init_ram_pages; page++)
c002072f:	83 c6 01             	add    $0x1,%esi
c0020732:	81 c7 00 10 00 00    	add    $0x1000,%edi
c0020738:	c7 c2 7e 01 02 c0    	mov    $0xc002017e,%edx
c002073e:	3b 32                	cmp    (%edx),%esi
c0020740:	0f 83 99 00 00 00    	jae    c00207df <pintos_init+0x553>
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020746:	89 fa                	mov    %edi,%edx
c0020748:	c1 ea 0c             	shr    $0xc,%edx
c002074b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c0020751:	89 54 24 08          	mov    %edx,0x8(%esp)
c0020755:	89 7c 24 0c          	mov    %edi,0xc(%esp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020759:	3b 7c 24 14          	cmp    0x14(%esp),%edi
c002075d:	0f 92 c1             	setb   %cl
c0020760:	3b 7c 24 18          	cmp    0x18(%esp),%edi
c0020764:	0f 93 c2             	setae  %dl
c0020767:	21 d1                	and    %edx,%ecx
c0020769:	88 4c 24 04          	mov    %cl,0x4(%esp)
  return (uintptr_t) va >> PDSHIFT;
c002076d:	89 fa                	mov    %edi,%edx
c002076f:	c1 ea 16             	shr    $0x16,%edx
      if (pd[pde_idx] == 0)
c0020772:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0020776:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c0020779:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c002077d:	0f 85 74 ff ff ff    	jne    c00206f7 <pintos_init+0x46b>
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020783:	83 ec 0c             	sub    $0xc,%esp
c0020786:	6a 03                	push   $0x3
c0020788:	e8 85 33 00 00       	call   c0023b12 <palloc_get_page>
  return (uintptr_t) va & PGMASK;
c002078d:	89 c2                	mov    %eax,%edx
  ASSERT (pg_ofs (pt) == 0);
c002078f:	83 c4 10             	add    $0x10,%esp
c0020792:	a9 ff 0f 00 00       	test   $0xfff,%eax
c0020797:	0f 85 0e ff ff ff    	jne    c00206ab <pintos_init+0x41f>
  ASSERT (is_kernel_vaddr (vaddr));
c002079d:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00207a2:	0f 86 29 ff ff ff    	jbe    c00206d1 <pintos_init+0x445>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00207a8:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c00207ae:	83 ca 07             	or     $0x7,%edx
c00207b1:	89 55 00             	mov    %edx,0x0(%ebp)
c00207b4:	e9 3e ff ff ff       	jmp    c00206f7 <pintos_init+0x46b>
  ASSERT (is_kernel_vaddr (vaddr));
c00207b9:	83 ec 0c             	sub    $0xc,%esp
c00207bc:	8d 83 70 4e ff ff    	lea    -0xb190(%ebx),%eax
c00207c2:	50                   	push   %eax
c00207c3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00207c9:	50                   	push   %eax
c00207ca:	8d 83 2c 3c ff ff    	lea    -0xc3d4(%ebx),%eax
c00207d0:	50                   	push   %eax
c00207d1:	6a 54                	push   $0x54
c00207d3:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c00207d9:	50                   	push   %eax
c00207da:	e8 a8 8a 00 00       	call   c0029287 <debug_panic>
c00207df:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00207e3:	c7 c0 38 d4 03 c0    	mov    $0xc003d438,%eax
c00207e9:	8b 00                	mov    (%eax),%eax
c00207eb:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00207f0:	0f 86 a4 00 00 00    	jbe    c002089a <pintos_init+0x60e>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00207f6:	05 00 00 00 40       	add    $0x40000000,%eax
c00207fb:	0f 22 d8             	mov    %eax,%cr3
  tss_init ();
c00207fe:	e8 64 c7 00 00       	call   c002cf67 <tss_init>
  gdt_init ();
c0020803:	e8 f4 c5 00 00       	call   c002cdfc <gdt_init>
  intr_init ();
c0020808:	e8 43 16 00 00       	call   c0021e50 <intr_init>
  timer_init ();
c002080d:	e8 13 3d 00 00       	call   c0024525 <timer_init>
  kbd_init ();
c0020812:	e8 8b 42 00 00       	call   c0024aa2 <kbd_init>
  input_init ();
c0020817:	e8 b5 5d 00 00       	call   c00265d1 <input_init>
  exception_init ();
c002081c:	e8 b1 bc 00 00       	call   c002c4d2 <exception_init>
  syscall_init ();
c0020821:	e8 15 be 00 00       	call   c002c63b <syscall_init>
  thread_start ();
c0020826:	e8 60 0d 00 00       	call   c002158b <thread_start>
  serial_init_queue ();
c002082b:	e8 1c 47 00 00       	call   c0024f4c <serial_init_queue>
  timer_calibrate ();
c0020830:	e8 27 3d 00 00       	call   c002455c <timer_calibrate>
  ide_init ();
c0020835:	e8 5d 58 00 00       	call   c0026097 <ide_init>
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c002083a:	8b 93 34 07 00 00    	mov    0x734(%ebx),%edx
c0020840:	b8 01 00 00 00       	mov    $0x1,%eax
c0020845:	e8 38 f9 ff ff       	call   c0020182 <locate_block_device>
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c002084a:	8b 93 30 07 00 00    	mov    0x730(%ebx),%edx
c0020850:	b8 02 00 00 00       	mov    $0x2,%eax
c0020855:	e8 28 f9 ff ff       	call   c0020182 <locate_block_device>
  filesys_init (format_filesys);
c002085a:	83 ec 0c             	sub    $0xc,%esp
c002085d:	0f b6 83 38 07 00 00 	movzbl 0x738(%ebx),%eax
c0020864:	50                   	push   %eax
c0020865:	e8 2f c7 00 00       	call   c002cf99 <filesys_init>
  printf ("Boot complete.\n");
c002086a:	8d 83 9e 4e ff ff    	lea    -0xb162(%ebx),%eax
c0020870:	89 04 24             	mov    %eax,(%esp)
c0020873:	e8 e8 a9 00 00       	call   c002b260 <puts>
  if (*argv != NULL) {
c0020878:	8b 7d 00             	mov    0x0(%ebp),%edi
c002087b:	83 c4 10             	add    $0x10,%esp
        if (a->name == NULL)
c002087e:	8d 83 96 56 ff ff    	lea    -0xa96a(%ebx),%eax
c0020884:	89 44 24 04          	mov    %eax,0x4(%esp)
  if (*argv != NULL) {
c0020888:	85 ff                	test   %edi,%edi
c002088a:	0f 85 94 00 00 00    	jne    c0020924 <pintos_init+0x698>
  shutdown ();
c0020890:	e8 58 65 00 00       	call   c0026ded <shutdown>
  thread_exit ();
c0020895:	e8 47 09 00 00       	call   c00211e1 <thread_exit>
  ASSERT (is_kernel_vaddr (vaddr));
c002089a:	83 ec 0c             	sub    $0xc,%esp
c002089d:	8d 83 70 4e ff ff    	lea    -0xb190(%ebx),%eax
c00208a3:	50                   	push   %eax
c00208a4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00208aa:	50                   	push   %eax
c00208ab:	8d 83 2c 3c ff ff    	lea    -0xc3d4(%ebx),%eax
c00208b1:	50                   	push   %eax
c00208b2:	6a 54                	push   $0x54
c00208b4:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c00208ba:	50                   	push   %eax
c00208bb:	e8 c7 89 00 00       	call   c0029287 <debug_panic>
      for (i = 1; i < a->argc; i++)
c00208c0:	8b 56 04             	mov    0x4(%esi),%edx
c00208c3:	83 fa 01             	cmp    $0x1,%edx
c00208c6:	7e 40                	jle    c0020908 <pintos_init+0x67c>
        if (argv[i] == NULL)
c00208c8:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c00208cc:	74 13                	je     c00208e1 <pintos_init+0x655>
      for (i = 1; i < a->argc; i++)
c00208ce:	b8 01 00 00 00       	mov    $0x1,%eax
c00208d3:	83 c0 01             	add    $0x1,%eax
c00208d6:	39 c2                	cmp    %eax,%edx
c00208d8:	74 2e                	je     c0020908 <pintos_init+0x67c>
        if (argv[i] == NULL)
c00208da:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c00208df:	75 f2                	jne    c00208d3 <pintos_init+0x647>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00208e1:	83 ec 08             	sub    $0x8,%esp
c00208e4:	83 ea 01             	sub    $0x1,%edx
c00208e7:	52                   	push   %edx
c00208e8:	57                   	push   %edi
c00208e9:	8d 83 98 53 ff ff    	lea    -0xac68(%ebx),%eax
c00208ef:	50                   	push   %eax
c00208f0:	8d 83 0c 3c ff ff    	lea    -0xc3f4(%ebx),%eax
c00208f6:	50                   	push   %eax
c00208f7:	68 55 01 00 00       	push   $0x155
c00208fc:	8d 83 b0 4d ff ff    	lea    -0xb250(%ebx),%eax
c0020902:	50                   	push   %eax
c0020903:	e8 7f 89 00 00       	call   c0029287 <debug_panic>
      a->function (argv);
c0020908:	83 ec 0c             	sub    $0xc,%esp
c002090b:	55                   	push   %ebp
c002090c:	ff 56 08             	call   *0x8(%esi)
      argv += a->argc;
c002090f:	8b 46 04             	mov    0x4(%esi),%eax
c0020912:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
  while (*argv != NULL)
c0020916:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020919:	83 c4 10             	add    $0x10,%esp
c002091c:	85 ff                	test   %edi,%edi
c002091e:	0f 84 6c ff ff ff    	je     c0020890 <pintos_init+0x604>
        if (a->name == NULL)
c0020924:	8b 44 24 04          	mov    0x4(%esp),%eax
      for (a = actions; ; a++)
c0020928:	8d b3 0c 00 00 00    	lea    0xc(%ebx),%esi
        else if (!strcmp (*argv, a->name))
c002092e:	83 ec 08             	sub    $0x8,%esp
c0020931:	50                   	push   %eax
c0020932:	57                   	push   %edi
c0020933:	e8 14 7c 00 00       	call   c002854c <strcmp>
c0020938:	83 c4 10             	add    $0x10,%esp
c002093b:	85 c0                	test   %eax,%eax
c002093d:	74 81                	je     c00208c0 <pintos_init+0x634>
      for (a = actions; ; a++)
c002093f:	83 c6 0c             	add    $0xc,%esi
        if (a->name == NULL)
c0020942:	8b 06                	mov    (%esi),%eax
c0020944:	85 c0                	test   %eax,%eax
c0020946:	75 e6                	jne    c002092e <pintos_init+0x6a2>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020948:	83 ec 0c             	sub    $0xc,%esp
c002094b:	57                   	push   %edi
c002094c:	8d 83 70 53 ff ff    	lea    -0xac90(%ebx),%eax
c0020952:	50                   	push   %eax
c0020953:	8d 83 0c 3c ff ff    	lea    -0xc3f4(%ebx),%eax
c0020959:	50                   	push   %eax
c002095a:	68 4e 01 00 00       	push   $0x14e
c002095f:	8d 83 b0 4d ff ff    	lea    -0xb250(%ebx),%eax
c0020965:	50                   	push   %eax
c0020966:	e8 1c 89 00 00       	call   c0029287 <debug_panic>

c002096b <thread_cmp_priority>:
        thread_unblock(t);
  }
}

bool thread_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {
  return list_entry(a, struct thread, elem)->priority > list_entry(b, struct thread, elem)->priority;
c002096b:	8b 54 24 04          	mov    0x4(%esp),%edx
c002096f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020973:	8b 40 f4             	mov    -0xc(%eax),%eax
c0020976:	39 42 f4             	cmp    %eax,-0xc(%edx)
c0020979:	0f 9f c0             	setg   %al
}
c002097c:	c3                   	ret    

c002097d <alloc_frame>:
{
c002097d:	53                   	push   %ebx
c002097e:	83 ec 08             	sub    $0x8,%esp
c0020981:	e8 ff e0 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020986:	81 c3 2e a5 01 00    	add    $0x1a52e,%ebx
  return t != NULL && t->magic == THREAD_MAGIC;
c002098c:	85 c0                	test   %eax,%eax
c002098e:	74 09                	je     c0020999 <alloc_frame+0x1c>
c0020990:	81 78 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%eax)
c0020997:	74 52                	je     c00209eb <alloc_frame+0x6e>
  ASSERT (is_thread (t));
c0020999:	83 ec 0c             	sub    $0xc,%esp
c002099c:	8d 83 f1 53 ff ff    	lea    -0xac0f(%ebx),%eax
c00209a2:	50                   	push   %eax
c00209a3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00209a9:	50                   	push   %eax
c00209aa:	8d 83 74 3d ff ff    	lea    -0xc28c(%ebx),%eax
c00209b0:	50                   	push   %eax
c00209b1:	68 47 02 00 00       	push   $0x247
c00209b6:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c00209bc:	50                   	push   %eax
c00209bd:	e8 c5 88 00 00       	call   c0029287 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00209c2:	83 ec 0c             	sub    $0xc,%esp
c00209c5:	8d 83 bc 53 ff ff    	lea    -0xac44(%ebx),%eax
c00209cb:	50                   	push   %eax
c00209cc:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00209d2:	50                   	push   %eax
c00209d3:	8d 83 74 3d ff ff    	lea    -0xc28c(%ebx),%eax
c00209d9:	50                   	push   %eax
c00209da:	68 48 02 00 00       	push   $0x248
c00209df:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c00209e5:	50                   	push   %eax
c00209e6:	e8 9c 88 00 00       	call   c0029287 <debug_panic>
c00209eb:	f6 c2 03             	test   $0x3,%dl
c00209ee:	75 d2                	jne    c00209c2 <alloc_frame+0x45>
  t->stack -= size;
c00209f0:	8b 48 18             	mov    0x18(%eax),%ecx
c00209f3:	29 d1                	sub    %edx,%ecx
c00209f5:	89 48 18             	mov    %ecx,0x18(%eax)
}
c00209f8:	89 c8                	mov    %ecx,%eax
c00209fa:	83 c4 08             	add    $0x8,%esp
c00209fd:	5b                   	pop    %ebx
c00209fe:	c3                   	ret    

c00209ff <init_thread>:
{
c00209ff:	55                   	push   %ebp
c0020a00:	57                   	push   %edi
c0020a01:	56                   	push   %esi
c0020a02:	53                   	push   %ebx
c0020a03:	83 ec 0c             	sub    $0xc,%esp
c0020a06:	e8 7a e0 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020a0b:	81 c3 a9 a4 01 00    	add    $0x1a4a9,%ebx
  ASSERT (t != NULL);
c0020a11:	85 c0                	test   %eax,%eax
c0020a13:	0f 84 e4 00 00 00    	je     c0020afd <init_thread+0xfe>
c0020a19:	89 c6                	mov    %eax,%esi
c0020a1b:	89 cd                	mov    %ecx,%ebp
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020a1d:	83 f9 3f             	cmp    $0x3f,%ecx
c0020a20:	0f 87 00 01 00 00    	ja     c0020b26 <init_thread+0x127>
  ASSERT (name != NULL);
c0020a26:	85 d2                	test   %edx,%edx
c0020a28:	0f 84 21 01 00 00    	je     c0020b4f <init_thread+0x150>
  memset (t, 0, sizeof *t);
c0020a2e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0020a34:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
c0020a3b:	00 00 00 
c0020a3e:	8d 78 04             	lea    0x4(%eax),%edi
c0020a41:	83 e7 fc             	and    $0xfffffffc,%edi
c0020a44:	89 c1                	mov    %eax,%ecx
c0020a46:	29 f9                	sub    %edi,%ecx
c0020a48:	81 c1 ac 00 00 00    	add    $0xac,%ecx
c0020a4e:	c1 e9 02             	shr    $0x2,%ecx
c0020a51:	b8 00 00 00 00       	mov    $0x0,%eax
c0020a56:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c0020a58:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
  strlcpy (t->name, name, sizeof t->name);
c0020a5f:	83 ec 04             	sub    $0x4,%esp
c0020a62:	6a 10                	push   $0x10
c0020a64:	52                   	push   %edx
c0020a65:	8d 46 08             	lea    0x8(%esi),%eax
c0020a68:	50                   	push   %eax
c0020a69:	e8 6e 7e 00 00       	call   c00288dc <strlcpy>
  t->stack = (uint8_t *) t + PGSIZE;
c0020a6e:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
c0020a74:	89 46 18             	mov    %eax,0x18(%esi)
  t->priority = priority;
c0020a77:	89 6e 1c             	mov    %ebp,0x1c(%esi)
  t->base_priority = priority;
c0020a7a:	89 6e 3c             	mov    %ebp,0x3c(%esi)
  list_init(&t->locks);
c0020a7d:	8d 46 40             	lea    0x40(%esi),%eax
c0020a80:	89 04 24             	mov    %eax,(%esp)
c0020a83:	e8 cc 88 00 00       	call   c0029354 <list_init>
  t->lock_waiting = NULL;
c0020a88:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
  t->nice = 0;
c0020a8f:	c7 46 54 00 00 00 00 	movl   $0x0,0x54(%esi)
  t->recent_cpu = FP_CONST(0);
c0020a96:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
  t->magic = THREAD_MAGIC;
c0020a9d:	c7 46 30 4b bf 6a cd 	movl   $0xcd6abf4b,0x30(%esi)
  t->return_value = 0;
c0020aa4:	c7 46 5c 00 00 00 00 	movl   $0x0,0x5c(%esi)
  t->grandpa_died = false;
c0020aab:	c6 86 98 00 00 00 00 	movb   $0x0,0x98(%esi)
  list_init (&t->child_list);
c0020ab2:	8d 46 60             	lea    0x60(%esi),%eax
c0020ab5:	89 04 24             	mov    %eax,(%esp)
c0020ab8:	e8 97 88 00 00       	call   c0029354 <list_init>
  sema_init (&t->sema_finished, 0);
c0020abd:	83 c4 08             	add    $0x8,%esp
c0020ac0:	6a 00                	push   $0x0
c0020ac2:	8d 46 70             	lea    0x70(%esi),%eax
c0020ac5:	50                   	push   %eax
c0020ac6:	e8 d9 24 00 00       	call   c0022fa4 <sema_init>
  sema_init (&t->sema_started, 0);
c0020acb:	83 c4 08             	add    $0x8,%esp
c0020ace:	6a 00                	push   $0x0
c0020ad0:	8d 86 84 00 00 00    	lea    0x84(%esi),%eax
c0020ad6:	50                   	push   %eax
c0020ad7:	e8 c8 24 00 00       	call   c0022fa4 <sema_init>
  list_insert_ordered(&all_list, &t->allelem, (list_less_func *) &thread_cmp_priority, NULL);
c0020adc:	6a 00                	push   $0x0
c0020ade:	8d 83 b7 5a fe ff    	lea    -0x1a549(%ebx),%eax
c0020ae4:	50                   	push   %eax
c0020ae5:	83 c6 20             	add    $0x20,%esi
c0020ae8:	56                   	push   %esi
c0020ae9:	8d 83 98 07 00 00    	lea    0x798(%ebx),%eax
c0020aef:	50                   	push   %eax
c0020af0:	e8 57 93 00 00       	call   c0029e4c <list_insert_ordered>
}
c0020af5:	83 c4 2c             	add    $0x2c,%esp
c0020af8:	5b                   	pop    %ebx
c0020af9:	5e                   	pop    %esi
c0020afa:	5f                   	pop    %edi
c0020afb:	5d                   	pop    %ebp
c0020afc:	c3                   	ret    
  ASSERT (t != NULL);
c0020afd:	83 ec 0c             	sub    $0xc,%esp
c0020b00:	8d 83 bb 68 ff ff    	lea    -0x9745(%ebx),%eax
c0020b06:	50                   	push   %eax
c0020b07:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020b0d:	50                   	push   %eax
c0020b0e:	8d 83 a0 3d ff ff    	lea    -0xc260(%ebx),%eax
c0020b14:	50                   	push   %eax
c0020b15:	68 1f 02 00 00       	push   $0x21f
c0020b1a:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020b20:	50                   	push   %eax
c0020b21:	e8 61 87 00 00       	call   c0029287 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020b26:	83 ec 0c             	sub    $0xc,%esp
c0020b29:	8d 83 e8 54 ff ff    	lea    -0xab18(%ebx),%eax
c0020b2f:	50                   	push   %eax
c0020b30:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020b36:	50                   	push   %eax
c0020b37:	8d 83 a0 3d ff ff    	lea    -0xc260(%ebx),%eax
c0020b3d:	50                   	push   %eax
c0020b3e:	68 20 02 00 00       	push   $0x220
c0020b43:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020b49:	50                   	push   %eax
c0020b4a:	e8 38 87 00 00       	call   c0029287 <debug_panic>
  ASSERT (name != NULL);
c0020b4f:	83 ec 0c             	sub    $0xc,%esp
c0020b52:	8d 83 ff 53 ff ff    	lea    -0xac01(%ebx),%eax
c0020b58:	50                   	push   %eax
c0020b59:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020b5f:	50                   	push   %eax
c0020b60:	8d 83 a0 3d ff ff    	lea    -0xc260(%ebx),%eax
c0020b66:	50                   	push   %eax
c0020b67:	68 21 02 00 00       	push   $0x221
c0020b6c:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020b72:	50                   	push   %eax
c0020b73:	e8 0f 87 00 00       	call   c0029287 <debug_panic>

c0020b78 <thread_init>:
{
c0020b78:	55                   	push   %ebp
c0020b79:	57                   	push   %edi
c0020b7a:	56                   	push   %esi
c0020b7b:	53                   	push   %ebx
c0020b7c:	83 ec 0c             	sub    $0xc,%esp
c0020b7f:	e8 01 df 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020b84:	81 c3 30 a3 01 00    	add    $0x1a330,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0020b8a:	e8 4e 12 00 00       	call   c0021ddd <intr_get_level>
c0020b8f:	85 c0                	test   %eax,%eax
c0020b91:	0f 85 a6 00 00 00    	jne    c0020c3d <thread_init+0xc5>
  lock_init (&tid_lock);
c0020b97:	83 ec 0c             	sub    $0xc,%esp
c0020b9a:	8d b3 6c 07 00 00    	lea    0x76c(%ebx),%esi
c0020ba0:	56                   	push   %esi
c0020ba1:	e8 d4 26 00 00       	call   c002327a <lock_init>
  list_init (&ready_list);
c0020ba6:	8d 83 a8 07 00 00    	lea    0x7a8(%ebx),%eax
c0020bac:	89 04 24             	mov    %eax,(%esp)
c0020baf:	e8 a0 87 00 00       	call   c0029354 <list_init>
  list_init (&all_list);
c0020bb4:	8d 83 98 07 00 00    	lea    0x798(%ebx),%eax
c0020bba:	89 04 24             	mov    %eax,(%esp)
c0020bbd:	e8 92 87 00 00       	call   c0029354 <list_init>
  list_init(&children);
c0020bc2:	8d 83 c8 07 00 00    	lea    0x7c8(%ebx),%eax
c0020bc8:	89 04 24             	mov    %eax,(%esp)
c0020bcb:	e8 84 87 00 00       	call   c0029354 <list_init>
  list_init(&file_list);
c0020bd0:	8d 83 b8 07 00 00    	lea    0x7b8(%ebx),%eax
c0020bd6:	89 04 24             	mov    %eax,(%esp)
c0020bd9:	e8 76 87 00 00       	call   c0029354 <list_init>
  asm ("mov %%esp, %0" : "=g" (esp));
c0020bde:	89 e0                	mov    %esp,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c0020be0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  initial_thread = running_thread ();
c0020be5:	89 83 90 07 00 00    	mov    %eax,0x790(%ebx)
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020beb:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020bf0:	8d 93 2a 54 ff ff    	lea    -0xabd6(%ebx),%edx
c0020bf6:	e8 04 fe ff ff       	call   c00209ff <init_thread>
  initial_thread->status = THREAD_RUNNING;
c0020bfb:	8b bb 90 07 00 00    	mov    0x790(%ebx),%edi
c0020c01:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
  lock_acquire (&tid_lock);
c0020c08:	89 34 24             	mov    %esi,(%esp)
c0020c0b:	e8 16 27 00 00       	call   c0023326 <lock_acquire>
  tid = next_tid++;
c0020c10:	8b ab e4 fb ff ff    	mov    -0x41c(%ebx),%ebp
c0020c16:	8d 45 01             	lea    0x1(%ebp),%eax
c0020c19:	89 83 e4 fb ff ff    	mov    %eax,-0x41c(%ebx)
  lock_release (&tid_lock);
c0020c1f:	89 34 24             	mov    %esi,(%esp)
c0020c22:	e8 f7 28 00 00       	call   c002351e <lock_release>
  initial_thread->tid = allocate_tid ();
c0020c27:	89 2f                	mov    %ebp,(%edi)
  load_avg = FP_CONST(0);
c0020c29:	c7 c0 40 d4 03 c0    	mov    $0xc003d440,%eax
c0020c2f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c0020c35:	83 c4 1c             	add    $0x1c,%esp
c0020c38:	5b                   	pop    %ebx
c0020c39:	5e                   	pop    %esi
c0020c3a:	5f                   	pop    %edi
c0020c3b:	5d                   	pop    %ebp
c0020c3c:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020c3d:	83 ec 0c             	sub    $0xc,%esp
c0020c40:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0020c46:	50                   	push   %eax
c0020c47:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020c4d:	50                   	push   %eax
c0020c4e:	8d 83 ac 3d ff ff    	lea    -0xc254(%ebx),%eax
c0020c54:	50                   	push   %eax
c0020c55:	6a 68                	push   $0x68
c0020c57:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020c5d:	50                   	push   %eax
c0020c5e:	e8 24 86 00 00       	call   c0029287 <debug_panic>

c0020c63 <thread_print_stats>:
{
c0020c63:	53                   	push   %ebx
c0020c64:	83 ec 0c             	sub    $0xc,%esp
c0020c67:	e8 19 de 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020c6c:	81 c3 48 a2 01 00    	add    $0x1a248,%ebx
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020c72:	ff b3 58 07 00 00    	pushl  0x758(%ebx)
c0020c78:	ff b3 54 07 00 00    	pushl  0x754(%ebx)
c0020c7e:	ff b3 60 07 00 00    	pushl  0x760(%ebx)
c0020c84:	ff b3 5c 07 00 00    	pushl  0x75c(%ebx)
c0020c8a:	ff b3 68 07 00 00    	pushl  0x768(%ebx)
c0020c90:	ff b3 64 07 00 00    	pushl  0x764(%ebx)
c0020c96:	8d 83 14 55 ff ff    	lea    -0xaaec(%ebx),%eax
c0020c9c:	50                   	push   %eax
c0020c9d:	e8 4e 68 00 00       	call   c00274f0 <printf>
}
c0020ca2:	83 c4 28             	add    $0x28,%esp
c0020ca5:	5b                   	pop    %ebx
c0020ca6:	c3                   	ret    

c0020ca7 <thread_unblock>:
{
c0020ca7:	57                   	push   %edi
c0020ca8:	56                   	push   %esi
c0020ca9:	53                   	push   %ebx
c0020caa:	e8 d6 dd 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020caf:	81 c3 05 a2 01 00    	add    $0x1a205,%ebx
c0020cb5:	8b 74 24 10          	mov    0x10(%esp),%esi
  return t != NULL && t->magic == THREAD_MAGIC;
c0020cb9:	85 f6                	test   %esi,%esi
c0020cbb:	74 09                	je     c0020cc6 <thread_unblock+0x1f>
c0020cbd:	81 7e 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%esi)
c0020cc4:	74 52                	je     c0020d18 <thread_unblock+0x71>
  ASSERT (is_thread (t));
c0020cc6:	83 ec 0c             	sub    $0xc,%esp
c0020cc9:	8d 83 f1 53 ff ff    	lea    -0xac0f(%ebx),%eax
c0020ccf:	50                   	push   %eax
c0020cd0:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020cd6:	50                   	push   %eax
c0020cd7:	8d 83 48 3d ff ff    	lea    -0xc2b8(%ebx),%eax
c0020cdd:	50                   	push   %eax
c0020cde:	68 1f 01 00 00       	push   $0x11f
c0020ce3:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020ce9:	50                   	push   %eax
c0020cea:	e8 98 85 00 00       	call   c0029287 <debug_panic>
  ASSERT (t->status == THREAD_BLOCKED);
c0020cef:	83 ec 0c             	sub    $0xc,%esp
c0020cf2:	8d 83 2f 54 ff ff    	lea    -0xabd1(%ebx),%eax
c0020cf8:	50                   	push   %eax
c0020cf9:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020cff:	50                   	push   %eax
c0020d00:	8d 83 48 3d ff ff    	lea    -0xc2b8(%ebx),%eax
c0020d06:	50                   	push   %eax
c0020d07:	68 22 01 00 00       	push   $0x122
c0020d0c:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020d12:	50                   	push   %eax
c0020d13:	e8 6f 85 00 00       	call   c0029287 <debug_panic>
  old_level = intr_disable ();
c0020d18:	e8 12 11 00 00       	call   c0021e2f <intr_disable>
c0020d1d:	89 c7                	mov    %eax,%edi
  ASSERT (t->status == THREAD_BLOCKED);
c0020d1f:	83 7e 04 02          	cmpl   $0x2,0x4(%esi)
c0020d23:	75 ca                	jne    c0020cef <thread_unblock+0x48>
  list_insert_ordered(&ready_list, &t->elem, (list_less_func *) &thread_cmp_priority, NULL);
c0020d25:	6a 00                	push   $0x0
c0020d27:	8d 83 b7 5a fe ff    	lea    -0x1a549(%ebx),%eax
c0020d2d:	50                   	push   %eax
c0020d2e:	8d 46 28             	lea    0x28(%esi),%eax
c0020d31:	50                   	push   %eax
c0020d32:	8d 83 a8 07 00 00    	lea    0x7a8(%ebx),%eax
c0020d38:	50                   	push   %eax
c0020d39:	e8 0e 91 00 00       	call   c0029e4c <list_insert_ordered>
  t->status = THREAD_READY;
c0020d3e:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
  intr_set_level (old_level);
c0020d45:	89 3c 24             	mov    %edi,(%esp)
c0020d48:	e8 e9 10 00 00       	call   c0021e36 <intr_set_level>
}
c0020d4d:	83 c4 10             	add    $0x10,%esp
c0020d50:	5b                   	pop    %ebx
c0020d51:	5e                   	pop    %esi
c0020d52:	5f                   	pop    %edi
c0020d53:	c3                   	ret    

c0020d54 <thread_current>:
{
c0020d54:	53                   	push   %ebx
c0020d55:	83 ec 08             	sub    $0x8,%esp
c0020d58:	e8 28 dd 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020d5d:	81 c3 57 a1 01 00    	add    $0x1a157,%ebx
  asm ("mov %%esp, %0" : "=g" (esp));
c0020d63:	89 e0                	mov    %esp,%eax
  return t != NULL && t->magic == THREAD_MAGIC;
c0020d65:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0020d6a:	74 09                	je     c0020d75 <thread_current+0x21>
c0020d6c:	81 78 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%eax)
c0020d73:	74 52                	je     c0020dc7 <thread_current+0x73>
  ASSERT (is_thread (t));
c0020d75:	83 ec 0c             	sub    $0xc,%esp
c0020d78:	8d 83 f1 53 ff ff    	lea    -0xac0f(%ebx),%eax
c0020d7e:	50                   	push   %eax
c0020d7f:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020d85:	50                   	push   %eax
c0020d86:	8d 83 38 3d ff ff    	lea    -0xc2c8(%ebx),%eax
c0020d8c:	50                   	push   %eax
c0020d8d:	68 3d 01 00 00       	push   $0x13d
c0020d92:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020d98:	50                   	push   %eax
c0020d99:	e8 e9 84 00 00       	call   c0029287 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020d9e:	83 ec 0c             	sub    $0xc,%esp
c0020da1:	8d 83 4b 54 ff ff    	lea    -0xabb5(%ebx),%eax
c0020da7:	50                   	push   %eax
c0020da8:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020dae:	50                   	push   %eax
c0020daf:	8d 83 38 3d ff ff    	lea    -0xc2c8(%ebx),%eax
c0020db5:	50                   	push   %eax
c0020db6:	68 3e 01 00 00       	push   $0x13e
c0020dbb:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020dc1:	50                   	push   %eax
c0020dc2:	e8 c0 84 00 00       	call   c0029287 <debug_panic>
c0020dc7:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0020dcb:	75 d1                	jne    c0020d9e <thread_current+0x4a>
}
c0020dcd:	83 c4 08             	add    $0x8,%esp
c0020dd0:	5b                   	pop    %ebx
c0020dd1:	c3                   	ret    

c0020dd2 <thread_tick>:
{
c0020dd2:	53                   	push   %ebx
c0020dd3:	83 ec 08             	sub    $0x8,%esp
c0020dd6:	e8 aa dc 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020ddb:	81 c3 d9 a0 01 00    	add    $0x1a0d9,%ebx
  struct thread *t = thread_current ();
c0020de1:	e8 6e ff ff ff       	call   c0020d54 <thread_current>
  if (t == idle_thread)
c0020de6:	39 83 94 07 00 00    	cmp    %eax,0x794(%ebx)
c0020dec:	74 30                	je     c0020e1e <thread_tick+0x4c>
  else if (t->pagedir != NULL)
c0020dee:	83 b8 a0 00 00 00 00 	cmpl   $0x0,0xa0(%eax)
c0020df5:	74 37                	je     c0020e2e <thread_tick+0x5c>
    user_ticks++;
c0020df7:	83 83 54 07 00 00 01 	addl   $0x1,0x754(%ebx)
c0020dfe:	83 93 58 07 00 00 00 	adcl   $0x0,0x758(%ebx)
  if (++thread_ticks >= TIME_SLICE)
c0020e05:	8b 83 4c 07 00 00    	mov    0x74c(%ebx),%eax
c0020e0b:	83 c0 01             	add    $0x1,%eax
c0020e0e:	89 83 4c 07 00 00    	mov    %eax,0x74c(%ebx)
c0020e14:	83 f8 03             	cmp    $0x3,%eax
c0020e17:	77 25                	ja     c0020e3e <thread_tick+0x6c>
}
c0020e19:	83 c4 08             	add    $0x8,%esp
c0020e1c:	5b                   	pop    %ebx
c0020e1d:	c3                   	ret    
    idle_ticks++;
c0020e1e:	83 83 64 07 00 00 01 	addl   $0x1,0x764(%ebx)
c0020e25:	83 93 68 07 00 00 00 	adcl   $0x0,0x768(%ebx)
c0020e2c:	eb d7                	jmp    c0020e05 <thread_tick+0x33>
    kernel_ticks++;
c0020e2e:	83 83 5c 07 00 00 01 	addl   $0x1,0x75c(%ebx)
c0020e35:	83 93 60 07 00 00 00 	adcl   $0x0,0x760(%ebx)
c0020e3c:	eb c7                	jmp    c0020e05 <thread_tick+0x33>
    intr_yield_on_return ();
c0020e3e:	e8 a2 12 00 00       	call   c00220e5 <intr_yield_on_return>
}
c0020e43:	eb d4                	jmp    c0020e19 <thread_tick+0x47>

c0020e45 <thread_name>:
{
c0020e45:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->name;
c0020e48:	e8 07 ff ff ff       	call   c0020d54 <thread_current>
c0020e4d:	83 c0 08             	add    $0x8,%eax
}
c0020e50:	83 c4 0c             	add    $0xc,%esp
c0020e53:	c3                   	ret    

c0020e54 <thread_tid>:
{
c0020e54:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->tid;
c0020e57:	e8 f8 fe ff ff       	call   c0020d54 <thread_current>
c0020e5c:	8b 00                	mov    (%eax),%eax
}
c0020e5e:	83 c4 0c             	add    $0xc,%esp
c0020e61:	c3                   	ret    

c0020e62 <thread_foreach>:
{
c0020e62:	55                   	push   %ebp
c0020e63:	57                   	push   %edi
c0020e64:	56                   	push   %esi
c0020e65:	53                   	push   %ebx
c0020e66:	83 ec 0c             	sub    $0xc,%esp
c0020e69:	e8 17 dc 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020e6e:	81 c3 46 a0 01 00    	add    $0x1a046,%ebx
c0020e74:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  ASSERT (intr_get_level () == INTR_OFF);
c0020e78:	e8 60 0f 00 00       	call   c0021ddd <intr_get_level>
c0020e7d:	85 c0                	test   %eax,%eax
c0020e7f:	75 1c                	jne    c0020e9d <thread_foreach+0x3b>
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e81:	83 ec 0c             	sub    $0xc,%esp
c0020e84:	8d 83 98 07 00 00    	lea    0x798(%ebx),%eax
c0020e8a:	50                   	push   %eax
c0020e8b:	e8 1c 85 00 00       	call   c00293ac <list_begin>
c0020e90:	89 c6                	mov    %eax,%esi
c0020e92:	83 c4 10             	add    $0x10,%esp
c0020e95:	8d bb 98 07 00 00    	lea    0x798(%ebx),%edi
c0020e9b:	eb 42                	jmp    c0020edf <thread_foreach+0x7d>
  ASSERT (intr_get_level () == INTR_OFF);
c0020e9d:	83 ec 0c             	sub    $0xc,%esp
c0020ea0:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0020ea6:	50                   	push   %eax
c0020ea7:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020ead:	50                   	push   %eax
c0020eae:	8d 83 0c 3d ff ff    	lea    -0xc2f4(%ebx),%eax
c0020eb4:	50                   	push   %eax
c0020eb5:	68 8e 01 00 00       	push   $0x18e
c0020eba:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020ec0:	50                   	push   %eax
c0020ec1:	e8 c1 83 00 00       	call   c0029287 <debug_panic>
      func (t, aux);
c0020ec6:	83 ec 08             	sub    $0x8,%esp
c0020ec9:	55                   	push   %ebp
      struct thread *t = list_entry (e, struct thread, allelem);
c0020eca:	8d 46 e0             	lea    -0x20(%esi),%eax
      func (t, aux);
c0020ecd:	50                   	push   %eax
c0020ece:	ff 54 24 30          	call   *0x30(%esp)
       e = list_next (e))
c0020ed2:	89 34 24             	mov    %esi,(%esp)
c0020ed5:	e8 17 85 00 00       	call   c00293f1 <list_next>
c0020eda:	89 c6                	mov    %eax,%esi
c0020edc:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020edf:	83 ec 0c             	sub    $0xc,%esp
c0020ee2:	57                   	push   %edi
c0020ee3:	e8 66 85 00 00       	call   c002944e <list_end>
c0020ee8:	83 c4 10             	add    $0x10,%esp
c0020eeb:	39 f0                	cmp    %esi,%eax
c0020eed:	75 d7                	jne    c0020ec6 <thread_foreach+0x64>
}
c0020eef:	83 c4 0c             	add    $0xc,%esp
c0020ef2:	5b                   	pop    %ebx
c0020ef3:	5e                   	pop    %esi
c0020ef4:	5f                   	pop    %edi
c0020ef5:	5d                   	pop    %ebp
c0020ef6:	c3                   	ret    

c0020ef7 <thread_get_priority>:
{
c0020ef7:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->priority;
c0020efa:	e8 55 fe ff ff       	call   c0020d54 <thread_current>
c0020eff:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020f02:	83 c4 0c             	add    $0xc,%esp
c0020f05:	c3                   	ret    

c0020f06 <thread_get_nice>:
{
c0020f06:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->nice;
c0020f09:	e8 46 fe ff ff       	call   c0020d54 <thread_current>
c0020f0e:	8b 40 54             	mov    0x54(%eax),%eax
}
c0020f11:	83 c4 0c             	add    $0xc,%esp
c0020f14:	c3                   	ret    

c0020f15 <thread_get_load_avg>:
{
c0020f15:	e8 6f db 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0020f1a:	05 9a 9f 01 00       	add    $0x19f9a,%eax
  return FP_ROUND(FP_MULT_MIX(load_avg, 100));
c0020f1f:	c7 c0 40 d4 03 c0    	mov    $0xc003d440,%eax
c0020f25:	6b 00 64             	imul   $0x64,(%eax),%eax
c0020f28:	85 c0                	test   %eax,%eax
c0020f2a:	78 09                	js     c0020f35 <thread_get_load_avg+0x20>
c0020f2c:	05 00 80 00 00       	add    $0x8000,%eax
c0020f31:	c1 f8 10             	sar    $0x10,%eax
c0020f34:	c3                   	ret    
c0020f35:	2d 00 80 00 00       	sub    $0x8000,%eax
c0020f3a:	c1 f8 10             	sar    $0x10,%eax
}
c0020f3d:	c3                   	ret    

c0020f3e <thread_get_recent_cpu>:
{
c0020f3e:	83 ec 0c             	sub    $0xc,%esp
  return FP_ROUND(FP_MULT_MIX(thread_current()->recent_cpu, 100));
c0020f41:	e8 0e fe ff ff       	call   c0020d54 <thread_current>
c0020f46:	6b 40 58 64          	imul   $0x64,0x58(%eax),%eax
c0020f4a:	85 c0                	test   %eax,%eax
c0020f4c:	78 0c                	js     c0020f5a <thread_get_recent_cpu+0x1c>
c0020f4e:	05 00 80 00 00       	add    $0x8000,%eax
c0020f53:	c1 f8 10             	sar    $0x10,%eax
}
c0020f56:	83 c4 0c             	add    $0xc,%esp
c0020f59:	c3                   	ret    
  return FP_ROUND(FP_MULT_MIX(thread_current()->recent_cpu, 100));
c0020f5a:	2d 00 80 00 00       	sub    $0x8000,%eax
c0020f5f:	c1 f8 10             	sar    $0x10,%eax
c0020f62:	eb f2                	jmp    c0020f56 <thread_get_recent_cpu+0x18>

c0020f64 <thread_schedule_tail>:
{
c0020f64:	57                   	push   %edi
c0020f65:	56                   	push   %esi
c0020f66:	53                   	push   %ebx
c0020f67:	e8 19 db 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0020f6c:	81 c3 48 9f 01 00    	add    $0x19f48,%ebx
c0020f72:	8b 7c 24 10          	mov    0x10(%esp),%edi
  asm ("mov %%esp, %0" : "=g" (esp));
c0020f76:	89 e6                	mov    %esp,%esi
c0020f78:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0020f7e:	e8 5a 0e 00 00       	call   c0021ddd <intr_get_level>
c0020f83:	85 c0                	test   %eax,%eax
c0020f85:	75 24                	jne    c0020fab <thread_schedule_tail+0x47>
  cur->status = THREAD_RUNNING;
c0020f87:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
  thread_ticks = 0;
c0020f8e:	c7 83 4c 07 00 00 00 	movl   $0x0,0x74c(%ebx)
c0020f95:	00 00 00 
  process_activate ();
c0020f98:	e8 f0 a5 00 00       	call   c002b58d <process_activate>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0020f9d:	85 ff                	test   %edi,%edi
c0020f9f:	74 06                	je     c0020fa7 <thread_schedule_tail+0x43>
c0020fa1:	83 7f 04 03          	cmpl   $0x3,0x4(%edi)
c0020fa5:	74 2d                	je     c0020fd4 <thread_schedule_tail+0x70>
}
c0020fa7:	5b                   	pop    %ebx
c0020fa8:	5e                   	pop    %esi
c0020fa9:	5f                   	pop    %edi
c0020faa:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0020fab:	83 ec 0c             	sub    $0xc,%esp
c0020fae:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0020fb4:	50                   	push   %eax
c0020fb5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020fbb:	50                   	push   %eax
c0020fbc:	8d 83 f4 3c ff ff    	lea    -0xc30c(%ebx),%eax
c0020fc2:	50                   	push   %eax
c0020fc3:	68 71 02 00 00       	push   $0x271
c0020fc8:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0020fce:	50                   	push   %eax
c0020fcf:	e8 b3 82 00 00       	call   c0029287 <debug_panic>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0020fd4:	39 bb 90 07 00 00    	cmp    %edi,0x790(%ebx)
c0020fda:	74 cb                	je     c0020fa7 <thread_schedule_tail+0x43>
      ASSERT (prev != cur);
c0020fdc:	39 f7                	cmp    %esi,%edi
c0020fde:	74 0e                	je     c0020fee <thread_schedule_tail+0x8a>
      palloc_free_page (prev);
c0020fe0:	83 ec 0c             	sub    $0xc,%esp
c0020fe3:	57                   	push   %edi
c0020fe4:	e8 97 2c 00 00       	call   c0023c80 <palloc_free_page>
c0020fe9:	83 c4 10             	add    $0x10,%esp
}
c0020fec:	eb b9                	jmp    c0020fa7 <thread_schedule_tail+0x43>
      ASSERT (prev != cur);
c0020fee:	83 ec 0c             	sub    $0xc,%esp
c0020ff1:	8d 83 67 54 ff ff    	lea    -0xab99(%ebx),%eax
c0020ff7:	50                   	push   %eax
c0020ff8:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0020ffe:	50                   	push   %eax
c0020fff:	8d 83 f4 3c ff ff    	lea    -0xc30c(%ebx),%eax
c0021005:	50                   	push   %eax
c0021006:	68 85 02 00 00       	push   $0x285
c002100b:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0021011:	50                   	push   %eax
c0021012:	e8 70 82 00 00       	call   c0029287 <debug_panic>

c0021017 <schedule>:
{
c0021017:	57                   	push   %edi
c0021018:	56                   	push   %esi
c0021019:	53                   	push   %ebx
c002101a:	e8 66 da 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002101f:	81 c3 95 9e 01 00    	add    $0x19e95,%ebx
  asm ("mov %%esp, %0" : "=g" (esp));
c0021025:	89 e6                	mov    %esp,%esi
c0021027:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  if (list_empty (&ready_list))
c002102d:	83 ec 0c             	sub    $0xc,%esp
c0021030:	8d 83 a8 07 00 00    	lea    0x7a8(%ebx),%eax
c0021036:	50                   	push   %eax
c0021037:	e8 bd 89 00 00       	call   c00299f9 <list_empty>
c002103c:	83 c4 10             	add    $0x10,%esp
c002103f:	84 c0                	test   %al,%al
c0021041:	74 4f                	je     c0021092 <schedule+0x7b>
    return idle_thread;
c0021043:	8b bb 94 07 00 00    	mov    0x794(%ebx),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c0021049:	e8 8f 0d 00 00       	call   c0021ddd <intr_get_level>
c002104e:	85 c0                	test   %eax,%eax
c0021050:	75 57                	jne    c00210a9 <schedule+0x92>
  ASSERT (cur->status != THREAD_RUNNING);
c0021052:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0021056:	74 7a                	je     c00210d2 <schedule+0xbb>
  return t != NULL && t->magic == THREAD_MAGIC;
c0021058:	85 ff                	test   %edi,%edi
c002105a:	74 0d                	je     c0021069 <schedule+0x52>
c002105c:	81 7f 30 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x30(%edi)
c0021063:	0f 84 92 00 00 00    	je     c00210fb <schedule+0xe4>
  ASSERT (is_thread (next));
c0021069:	83 ec 0c             	sub    $0xc,%esp
c002106c:	8d 83 91 54 ff ff    	lea    -0xab6f(%ebx),%eax
c0021072:	50                   	push   %eax
c0021073:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021079:	50                   	push   %eax
c002107a:	8d 83 58 3d ff ff    	lea    -0xc2a8(%ebx),%eax
c0021080:	50                   	push   %eax
c0021081:	68 9a 02 00 00       	push   $0x29a
c0021086:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c002108c:	50                   	push   %eax
c002108d:	e8 f5 81 00 00       	call   c0029287 <debug_panic>
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0021092:	83 ec 0c             	sub    $0xc,%esp
c0021095:	8d 83 a8 07 00 00    	lea    0x7a8(%ebx),%eax
c002109b:	50                   	push   %eax
c002109c:	e8 cf 89 00 00       	call   c0029a70 <list_pop_front>
c00210a1:	8d 78 d8             	lea    -0x28(%eax),%edi
c00210a4:	83 c4 10             	add    $0x10,%esp
c00210a7:	eb a0                	jmp    c0021049 <schedule+0x32>
  ASSERT (intr_get_level () == INTR_OFF);
c00210a9:	83 ec 0c             	sub    $0xc,%esp
c00210ac:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c00210b2:	50                   	push   %eax
c00210b3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00210b9:	50                   	push   %eax
c00210ba:	8d 83 58 3d ff ff    	lea    -0xc2a8(%ebx),%eax
c00210c0:	50                   	push   %eax
c00210c1:	68 98 02 00 00       	push   $0x298
c00210c6:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c00210cc:	50                   	push   %eax
c00210cd:	e8 b5 81 00 00       	call   c0029287 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c00210d2:	83 ec 0c             	sub    $0xc,%esp
c00210d5:	8d 83 73 54 ff ff    	lea    -0xab8d(%ebx),%eax
c00210db:	50                   	push   %eax
c00210dc:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00210e2:	50                   	push   %eax
c00210e3:	8d 83 58 3d ff ff    	lea    -0xc2a8(%ebx),%eax
c00210e9:	50                   	push   %eax
c00210ea:	68 99 02 00 00       	push   $0x299
c00210ef:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c00210f5:	50                   	push   %eax
c00210f6:	e8 8c 81 00 00       	call   c0029287 <debug_panic>
  struct thread *prev = NULL;
c00210fb:	b8 00 00 00 00       	mov    $0x0,%eax
  if (cur != next)
c0021100:	39 f7                	cmp    %esi,%edi
c0021102:	74 0d                	je     c0021111 <schedule+0xfa>
    prev = switch_threads (cur, next);
c0021104:	83 ec 08             	sub    $0x8,%esp
c0021107:	57                   	push   %edi
c0021108:	56                   	push   %esi
c0021109:	e8 42 0b 00 00       	call   c0021c50 <switch_threads>
c002110e:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail (prev);
c0021111:	83 ec 0c             	sub    $0xc,%esp
c0021114:	50                   	push   %eax
c0021115:	e8 4a fe ff ff       	call   c0020f64 <thread_schedule_tail>
}
c002111a:	83 c4 10             	add    $0x10,%esp
c002111d:	5b                   	pop    %ebx
c002111e:	5e                   	pop    %esi
c002111f:	5f                   	pop    %edi
c0021120:	c3                   	ret    

c0021121 <thread_block>:
{
c0021121:	53                   	push   %ebx
c0021122:	83 ec 08             	sub    $0x8,%esp
c0021125:	e8 5b d9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002112a:	81 c3 8a 9d 01 00    	add    $0x19d8a,%ebx
  ASSERT (!intr_context ());
c0021130:	e8 9e 0f 00 00       	call   c00220d3 <intr_context>
c0021135:	84 c0                	test   %al,%al
c0021137:	75 1f                	jne    c0021158 <thread_block+0x37>
  ASSERT (intr_get_level () == INTR_OFF);
c0021139:	e8 9f 0c 00 00       	call   c0021ddd <intr_get_level>
c002113e:	85 c0                	test   %eax,%eax
c0021140:	75 3f                	jne    c0021181 <thread_block+0x60>
  thread_current ()->status = THREAD_BLOCKED;
c0021142:	e8 0d fc ff ff       	call   c0020d54 <thread_current>
c0021147:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c002114e:	e8 c4 fe ff ff       	call   c0021017 <schedule>
}
c0021153:	83 c4 08             	add    $0x8,%esp
c0021156:	5b                   	pop    %ebx
c0021157:	c3                   	ret    
  ASSERT (!intr_context ());
c0021158:	83 ec 0c             	sub    $0xc,%esp
c002115b:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0021161:	50                   	push   %eax
c0021162:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021168:	50                   	push   %eax
c0021169:	8d 83 64 3d ff ff    	lea    -0xc29c(%ebx),%eax
c002116f:	50                   	push   %eax
c0021170:	68 0b 01 00 00       	push   $0x10b
c0021175:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c002117b:	50                   	push   %eax
c002117c:	e8 06 81 00 00       	call   c0029287 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0021181:	83 ec 0c             	sub    $0xc,%esp
c0021184:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c002118a:	50                   	push   %eax
c002118b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021191:	50                   	push   %eax
c0021192:	8d 83 64 3d ff ff    	lea    -0xc29c(%ebx),%eax
c0021198:	50                   	push   %eax
c0021199:	68 0c 01 00 00       	push   $0x10c
c002119e:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c00211a4:	50                   	push   %eax
c00211a5:	e8 dd 80 00 00       	call   c0029287 <debug_panic>

c00211aa <idle>:
{
c00211aa:	53                   	push   %ebx
c00211ab:	83 ec 08             	sub    $0x8,%esp
c00211ae:	e8 d2 d8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00211b3:	81 c3 01 9d 01 00    	add    $0x19d01,%ebx
  idle_thread = thread_current ();
c00211b9:	e8 96 fb ff ff       	call   c0020d54 <thread_current>
c00211be:	89 83 94 07 00 00    	mov    %eax,0x794(%ebx)
  sema_up (idle_started);
c00211c4:	83 ec 0c             	sub    $0xc,%esp
c00211c7:	ff 74 24 1c          	pushl  0x1c(%esp)
c00211cb:	e8 50 1f 00 00       	call   c0023120 <sema_up>
c00211d0:	83 c4 10             	add    $0x10,%esp
      intr_disable ();
c00211d3:	e8 57 0c 00 00       	call   c0021e2f <intr_disable>
      thread_block ();
c00211d8:	e8 44 ff ff ff       	call   c0021121 <thread_block>
      asm volatile ("sti; hlt" : : : "memory");
c00211dd:	fb                   	sti    
c00211de:	f4                   	hlt    
c00211df:	eb f2                	jmp    c00211d3 <idle+0x29>

c00211e1 <thread_exit>:
{
c00211e1:	55                   	push   %ebp
c00211e2:	57                   	push   %edi
c00211e3:	56                   	push   %esi
c00211e4:	53                   	push   %ebx
c00211e5:	83 ec 1c             	sub    $0x1c,%esp
c00211e8:	e8 98 d8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00211ed:	81 c3 c7 9c 01 00    	add    $0x19cc7,%ebx
  ASSERT (!intr_context ());
c00211f3:	e8 db 0e 00 00       	call   c00220d3 <intr_context>
c00211f8:	84 c0                	test   %al,%al
c00211fa:	74 29                	je     c0021225 <thread_exit+0x44>
c00211fc:	83 ec 0c             	sub    $0xc,%esp
c00211ff:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0021205:	50                   	push   %eax
c0021206:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002120c:	50                   	push   %eax
c002120d:	8d 83 2c 3d ff ff    	lea    -0xc2d4(%ebx),%eax
c0021213:	50                   	push   %eax
c0021214:	68 4f 01 00 00       	push   $0x14f
c0021219:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c002121f:	50                   	push   %eax
c0021220:	e8 62 80 00 00       	call   c0029287 <debug_panic>
  process_exit ();
c0021225:	e8 a1 a2 00 00       	call   c002b4cb <process_exit>
  sema_up(&thread_current()->sema_finished);
c002122a:	e8 25 fb ff ff       	call   c0020d54 <thread_current>
c002122f:	83 ec 0c             	sub    $0xc,%esp
c0021232:	83 c0 70             	add    $0x70,%eax
c0021235:	50                   	push   %eax
c0021236:	e8 e5 1e 00 00       	call   c0023120 <sema_up>
  struct thread* cur = thread_current();
c002123b:	e8 14 fb ff ff       	call   c0020d54 <thread_current>
c0021240:	89 c7                	mov    %eax,%edi
  if (!list_empty(&file_list)) {
c0021242:	8d 83 b8 07 00 00    	lea    0x7b8(%ebx),%eax
c0021248:	89 04 24             	mov    %eax,(%esp)
c002124b:	e8 a9 87 00 00       	call   c00299f9 <list_empty>
c0021250:	83 c4 10             	add    $0x10,%esp
c0021253:	84 c0                	test   %al,%al
c0021255:	74 5c                	je     c00212b3 <thread_exit+0xd2>
  if(cur->exec_file != NULL){
c0021257:	8b 87 a4 00 00 00    	mov    0xa4(%edi),%eax
c002125d:	85 c0                	test   %eax,%eax
c002125f:	74 0c                	je     c002126d <thread_exit+0x8c>
    syscall_file_close(cur->exec_file);
c0021261:	83 ec 0c             	sub    $0xc,%esp
c0021264:	50                   	push   %eax
c0021265:	e8 0d b4 00 00       	call   c002c677 <syscall_file_close>
c002126a:	83 c4 10             	add    $0x10,%esp
  intr_disable ();
c002126d:	e8 bd 0b 00 00       	call   c0021e2f <intr_disable>
  list_remove (&thread_current()->allelem);
c0021272:	e8 dd fa ff ff       	call   c0020d54 <thread_current>
c0021277:	83 ec 0c             	sub    $0xc,%esp
c002127a:	83 c0 20             	add    $0x20,%eax
c002127d:	50                   	push   %eax
c002127e:	e8 d4 86 00 00       	call   c0029957 <list_remove>
  thread_current ()->status = THREAD_DYING;
c0021283:	e8 cc fa ff ff       	call   c0020d54 <thread_current>
c0021288:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c002128f:	e8 83 fd ff ff       	call   c0021017 <schedule>
  NOT_REACHED ();
c0021294:	8d 83 54 55 ff ff    	lea    -0xaaac(%ebx),%eax
c002129a:	50                   	push   %eax
c002129b:	8d 83 2c 3d ff ff    	lea    -0xc2d4(%ebx),%eax
c00212a1:	50                   	push   %eax
c00212a2:	68 70 01 00 00       	push   $0x170
c00212a7:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c00212ad:	50                   	push   %eax
c00212ae:	e8 d4 7f 00 00       	call   c0029287 <debug_panic>
    for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i)){
c00212b3:	83 ec 0c             	sub    $0xc,%esp
c00212b6:	8d 83 b8 07 00 00    	lea    0x7b8(%ebx),%eax
c00212bc:	50                   	push   %eax
c00212bd:	e8 ea 80 00 00       	call   c00293ac <list_begin>
c00212c2:	89 c6                	mov    %eax,%esi
c00212c4:	83 c4 10             	add    $0x10,%esp
c00212c7:	8d ab b8 07 00 00    	lea    0x7b8(%ebx),%ebp
c00212cd:	eb 0e                	jmp    c00212dd <thread_exit+0xfc>
c00212cf:	83 ec 0c             	sub    $0xc,%esp
c00212d2:	56                   	push   %esi
c00212d3:	e8 19 81 00 00       	call   c00293f1 <list_next>
c00212d8:	89 c6                	mov    %eax,%esi
c00212da:	83 c4 10             	add    $0x10,%esp
c00212dd:	83 ec 0c             	sub    $0xc,%esp
c00212e0:	55                   	push   %ebp
c00212e1:	e8 68 81 00 00       	call   c002944e <list_end>
c00212e6:	83 c4 10             	add    $0x10,%esp
c00212e9:	39 f0                	cmp    %esi,%eax
c00212eb:	0f 84 66 ff ff ff    	je     c0021257 <thread_exit+0x76>
      if (hd->owned_thread == cur){
c00212f1:	39 7e fc             	cmp    %edi,-0x4(%esi)
c00212f4:	75 d9                	jne    c00212cf <thread_exit+0xee>
        syscall_file_close(hd->opened_file);
c00212f6:	83 ec 0c             	sub    $0xc,%esp
c00212f9:	ff 76 f8             	pushl  -0x8(%esi)
c00212fc:	e8 76 b3 00 00       	call   c002c677 <syscall_file_close>
        i = list_prev(i);
c0021301:	89 34 24             	mov    %esi,(%esp)
c0021304:	e8 cf 81 00 00       	call   c00294d8 <list_prev>
c0021309:	89 44 24 18          	mov    %eax,0x18(%esp)
        list_remove(&(hd->elem));
c002130d:	8d 56 f4             	lea    -0xc(%esi),%edx
c0021310:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0021314:	89 34 24             	mov    %esi,(%esp)
c0021317:	e8 3b 86 00 00       	call   c0029957 <list_remove>
        free(hd);
c002131c:	83 c4 04             	add    $0x4,%esp
c002131f:	ff 74 24 18          	pushl  0x18(%esp)
c0021323:	e8 b5 2d 00 00       	call   c00240dd <free>
c0021328:	83 c4 10             	add    $0x10,%esp
        i = list_prev(i);
c002132b:	8b 74 24 08          	mov    0x8(%esp),%esi
c002132f:	eb 9e                	jmp    c00212cf <thread_exit+0xee>

c0021331 <kernel_thread>:
{
c0021331:	56                   	push   %esi
c0021332:	53                   	push   %ebx
c0021333:	83 ec 04             	sub    $0x4,%esp
c0021336:	e8 4a d7 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002133b:	81 c3 79 9b 01 00    	add    $0x19b79,%ebx
c0021341:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (function != NULL);
c0021345:	85 f6                	test   %esi,%esi
c0021347:	74 13                	je     c002135c <kernel_thread+0x2b>
  intr_enable ();       /* The scheduler runs with interrupts off. */
c0021349:	e8 98 0a 00 00       	call   c0021de6 <intr_enable>
  function (aux);       /* Execute the thread function. */
c002134e:	83 ec 0c             	sub    $0xc,%esp
c0021351:	ff 74 24 20          	pushl  0x20(%esp)
c0021355:	ff d6                	call   *%esi
  thread_exit ();       /* If function() returns, kill the thread. */
c0021357:	e8 85 fe ff ff       	call   c00211e1 <thread_exit>
  ASSERT (function != NULL);
c002135c:	83 ec 0c             	sub    $0xc,%esp
c002135f:	8d 83 b3 54 ff ff    	lea    -0xab4d(%ebx),%eax
c0021365:	50                   	push   %eax
c0021366:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002136c:	50                   	push   %eax
c002136d:	8d 83 80 3d ff ff    	lea    -0xc280(%ebx),%eax
c0021373:	50                   	push   %eax
c0021374:	68 fc 01 00 00       	push   $0x1fc
c0021379:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c002137f:	50                   	push   %eax
c0021380:	e8 02 7f 00 00       	call   c0029287 <debug_panic>

c0021385 <thread_yield>:
{
c0021385:	57                   	push   %edi
c0021386:	56                   	push   %esi
c0021387:	53                   	push   %ebx
c0021388:	e8 f8 d6 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002138d:	81 c3 27 9b 01 00    	add    $0x19b27,%ebx
  struct thread *cur = thread_current ();
c0021393:	e8 bc f9 ff ff       	call   c0020d54 <thread_current>
c0021398:	89 c6                	mov    %eax,%esi
  ASSERT (!intr_context ());
c002139a:	e8 34 0d 00 00       	call   c00220d3 <intr_context>
c002139f:	84 c0                	test   %al,%al
c00213a1:	75 47                	jne    c00213ea <thread_yield+0x65>
  old_level = intr_disable ();
c00213a3:	e8 87 0a 00 00       	call   c0021e2f <intr_disable>
c00213a8:	89 c7                	mov    %eax,%edi
  if (cur != idle_thread) 
c00213aa:	39 b3 94 07 00 00    	cmp    %esi,0x794(%ebx)
c00213b0:	74 1c                	je     c00213ce <thread_yield+0x49>
    list_insert_ordered(&ready_list, &cur->elem, (list_less_func *) &thread_cmp_priority, NULL);
c00213b2:	6a 00                	push   $0x0
c00213b4:	8d 83 b7 5a fe ff    	lea    -0x1a549(%ebx),%eax
c00213ba:	50                   	push   %eax
c00213bb:	8d 46 28             	lea    0x28(%esi),%eax
c00213be:	50                   	push   %eax
c00213bf:	8d 83 a8 07 00 00    	lea    0x7a8(%ebx),%eax
c00213c5:	50                   	push   %eax
c00213c6:	e8 81 8a 00 00       	call   c0029e4c <list_insert_ordered>
c00213cb:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c00213ce:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
  schedule ();
c00213d5:	e8 3d fc ff ff       	call   c0021017 <schedule>
  intr_set_level (old_level);
c00213da:	83 ec 0c             	sub    $0xc,%esp
c00213dd:	57                   	push   %edi
c00213de:	e8 53 0a 00 00       	call   c0021e36 <intr_set_level>
}
c00213e3:	83 c4 10             	add    $0x10,%esp
c00213e6:	5b                   	pop    %ebx
c00213e7:	5e                   	pop    %esi
c00213e8:	5f                   	pop    %edi
c00213e9:	c3                   	ret    
  ASSERT (!intr_context ());
c00213ea:	83 ec 0c             	sub    $0xc,%esp
c00213ed:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c00213f3:	50                   	push   %eax
c00213f4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00213fa:	50                   	push   %eax
c00213fb:	8d 83 1c 3d ff ff    	lea    -0xc2e4(%ebx),%eax
c0021401:	50                   	push   %eax
c0021402:	68 7b 01 00 00       	push   $0x17b
c0021407:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c002140d:	50                   	push   %eax
c002140e:	e8 74 7e 00 00       	call   c0029287 <debug_panic>

c0021413 <thread_create>:
{
c0021413:	55                   	push   %ebp
c0021414:	57                   	push   %edi
c0021415:	56                   	push   %esi
c0021416:	53                   	push   %ebx
c0021417:	83 ec 0c             	sub    $0xc,%esp
c002141a:	e8 66 d6 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002141f:	81 c3 95 9a 01 00    	add    $0x19a95,%ebx
  ASSERT (function != NULL);
c0021425:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c002142a:	0f 84 2b 01 00 00    	je     c002155b <thread_create+0x148>
  t = palloc_get_page (PAL_ZERO);
c0021430:	83 ec 0c             	sub    $0xc,%esp
c0021433:	6a 02                	push   $0x2
c0021435:	e8 d8 26 00 00       	call   c0023b12 <palloc_get_page>
c002143a:	89 c6                	mov    %eax,%esi
  if (t == NULL)
c002143c:	83 c4 10             	add    $0x10,%esp
c002143f:	85 c0                	test   %eax,%eax
c0021441:	0f 84 3d 01 00 00    	je     c0021584 <thread_create+0x171>
  init_thread (t, name, priority);
c0021447:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002144b:	8b 54 24 20          	mov    0x20(%esp),%edx
c002144f:	e8 ab f5 ff ff       	call   c00209ff <init_thread>
  lock_acquire (&tid_lock);
c0021454:	83 ec 0c             	sub    $0xc,%esp
c0021457:	8d bb 6c 07 00 00    	lea    0x76c(%ebx),%edi
c002145d:	57                   	push   %edi
c002145e:	e8 c3 1e 00 00       	call   c0023326 <lock_acquire>
  tid = next_tid++;
c0021463:	8b ab e4 fb ff ff    	mov    -0x41c(%ebx),%ebp
c0021469:	8d 45 01             	lea    0x1(%ebp),%eax
c002146c:	89 83 e4 fb ff ff    	mov    %eax,-0x41c(%ebx)
  lock_release (&tid_lock);
c0021472:	89 3c 24             	mov    %edi,(%esp)
c0021475:	e8 a4 20 00 00       	call   c002351e <lock_release>
  tid = t->tid = allocate_tid ();
c002147a:	89 2e                	mov    %ebp,(%esi)
  struct child_message *own = palloc_get_page(PAL_ZERO);
c002147c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0021483:	e8 8a 26 00 00       	call   c0023b12 <palloc_get_page>
c0021488:	89 c7                	mov    %eax,%edi
  own->tid = tid;
c002148a:	89 68 04             	mov    %ebp,0x4(%eax)
  own->tchild = t;
c002148d:	89 30                	mov    %esi,(%eax)
  own->exited = false;
c002148f:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  own->terminated = false;
c0021493:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  own->load_failed = false;
c0021497:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
  own->return_value = 0;
c002149b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  own->sema_finished = &t->sema_finished;
c00214a2:	8d 46 70             	lea    0x70(%esi),%eax
c00214a5:	89 47 10             	mov    %eax,0x10(%edi)
  own->sema_started = &t->sema_started;
c00214a8:	8d 86 84 00 00 00    	lea    0x84(%esi),%eax
c00214ae:	89 47 14             	mov    %eax,0x14(%edi)
  list_push_back(&children, &own->allelem);
c00214b1:	83 c4 08             	add    $0x8,%esp
c00214b4:	8d 47 20             	lea    0x20(%edi),%eax
c00214b7:	50                   	push   %eax
c00214b8:	8d 83 c8 07 00 00    	lea    0x7c8(%ebx),%eax
c00214be:	50                   	push   %eax
c00214bf:	e8 76 84 00 00       	call   c002993a <list_push_back>
  t->message_to_grandpa = own;
c00214c4:	89 be 9c 00 00 00    	mov    %edi,0x9c(%esi)
  old_level = intr_disable();
c00214ca:	e8 60 09 00 00       	call   c0021e2f <intr_disable>
c00214cf:	89 c7                	mov    %eax,%edi
  kf = alloc_frame (t, sizeof *kf);
c00214d1:	ba 0c 00 00 00       	mov    $0xc,%edx
c00214d6:	89 f0                	mov    %esi,%eax
c00214d8:	e8 a0 f4 ff ff       	call   c002097d <alloc_frame>
  kf->eip = NULL;
c00214dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c00214e3:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c00214e7:	89 48 04             	mov    %ecx,0x4(%eax)
  kf->aux = aux;
c00214ea:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c00214ee:	89 50 08             	mov    %edx,0x8(%eax)
  ef = alloc_frame (t, sizeof *ef);
c00214f1:	ba 04 00 00 00       	mov    $0x4,%edx
c00214f6:	89 f0                	mov    %esi,%eax
c00214f8:	e8 80 f4 ff ff       	call   c002097d <alloc_frame>
  ef->eip = (void (*) (void)) kernel_thread;
c00214fd:	8d 93 7d 64 fe ff    	lea    -0x19b83(%ebx),%edx
c0021503:	89 10                	mov    %edx,(%eax)
  sf = alloc_frame (t, sizeof *sf);
c0021505:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002150a:	89 f0                	mov    %esi,%eax
c002150c:	e8 6c f4 ff ff       	call   c002097d <alloc_frame>
  sf->eip = switch_entry;
c0021511:	c7 c2 6d 1c 02 c0    	mov    $0xc0021c6d,%edx
c0021517:	89 50 10             	mov    %edx,0x10(%eax)
  sf->ebp = 0;
c002151a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  t->exec_file = NULL;
c0021521:	c7 86 a4 00 00 00 00 	movl   $0x0,0xa4(%esi)
c0021528:	00 00 00 
  intr_set_level(old_level);
c002152b:	89 3c 24             	mov    %edi,(%esp)
c002152e:	e8 03 09 00 00       	call   c0021e36 <intr_set_level>
  t->ticks_blocked = 0;
c0021533:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
c002153a:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  thread_unblock (t);
c0021541:	89 34 24             	mov    %esi,(%esp)
c0021544:	e8 5e f7 ff ff       	call   c0020ca7 <thread_unblock>
  thread_yield();
c0021549:	e8 37 fe ff ff       	call   c0021385 <thread_yield>
  return tid;
c002154e:	83 c4 10             	add    $0x10,%esp
}
c0021551:	89 e8                	mov    %ebp,%eax
c0021553:	83 c4 0c             	add    $0xc,%esp
c0021556:	5b                   	pop    %ebx
c0021557:	5e                   	pop    %esi
c0021558:	5f                   	pop    %edi
c0021559:	5d                   	pop    %ebp
c002155a:	c3                   	ret    
  ASSERT (function != NULL);
c002155b:	83 ec 0c             	sub    $0xc,%esp
c002155e:	8d 83 b3 54 ff ff    	lea    -0xab4d(%ebx),%eax
c0021564:	50                   	push   %eax
c0021565:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002156b:	50                   	push   %eax
c002156c:	8d 83 90 3d ff ff    	lea    -0xc270(%ebx),%eax
c0021572:	50                   	push   %eax
c0021573:	68 c7 00 00 00       	push   $0xc7
c0021578:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c002157e:	50                   	push   %eax
c002157f:	e8 03 7d 00 00       	call   c0029287 <debug_panic>
    return TID_ERROR;
c0021584:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c0021589:	eb c6                	jmp    c0021551 <thread_create+0x13e>

c002158b <thread_start>:
{
c002158b:	56                   	push   %esi
c002158c:	53                   	push   %ebx
c002158d:	83 ec 2c             	sub    $0x2c,%esp
c0021590:	e8 f0 d4 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021595:	81 c3 1f 99 01 00    	add    $0x1991f,%ebx
  sema_init (&idle_started, 0);
c002159b:	6a 00                	push   $0x0
c002159d:	8d 74 24 18          	lea    0x18(%esp),%esi
c00215a1:	56                   	push   %esi
c00215a2:	e8 fd 19 00 00       	call   c0022fa4 <sema_init>
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c00215a7:	56                   	push   %esi
c00215a8:	8d 83 f6 62 fe ff    	lea    -0x19d0a(%ebx),%eax
c00215ae:	50                   	push   %eax
c00215af:	6a 00                	push   $0x0
c00215b1:	8d 83 c4 54 ff ff    	lea    -0xab3c(%ebx),%eax
c00215b7:	50                   	push   %eax
c00215b8:	e8 56 fe ff ff       	call   c0021413 <thread_create>
  intr_enable ();
c00215bd:	83 c4 20             	add    $0x20,%esp
c00215c0:	e8 21 08 00 00       	call   c0021de6 <intr_enable>
  sema_down (&idle_started);
c00215c5:	83 ec 0c             	sub    $0xc,%esp
c00215c8:	56                   	push   %esi
c00215c9:	e8 2a 1a 00 00       	call   c0022ff8 <sema_down>
}
c00215ce:	83 c4 34             	add    $0x34,%esp
c00215d1:	5b                   	pop    %ebx
c00215d2:	5e                   	pop    %esi
c00215d3:	c3                   	ret    

c00215d4 <thread_set_priority>:
{
c00215d4:	55                   	push   %ebp
c00215d5:	57                   	push   %edi
c00215d6:	56                   	push   %esi
c00215d7:	53                   	push   %ebx
c00215d8:	83 ec 0c             	sub    $0xc,%esp
c00215db:	e8 a5 d4 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00215e0:	81 c3 d4 98 01 00    	add    $0x198d4,%ebx
  if (thread_mlfqs)
c00215e6:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c00215ec:	80 38 00             	cmpb   $0x0,(%eax)
c00215ef:	74 08                	je     c00215f9 <thread_set_priority+0x25>
}
c00215f1:	83 c4 0c             	add    $0xc,%esp
c00215f4:	5b                   	pop    %ebx
c00215f5:	5e                   	pop    %esi
c00215f6:	5f                   	pop    %edi
c00215f7:	5d                   	pop    %ebp
c00215f8:	c3                   	ret    
  enum intr_level old_level = intr_disable();
c00215f9:	e8 31 08 00 00       	call   c0021e2f <intr_disable>
c00215fe:	89 c7                	mov    %eax,%edi
  struct thread *current_thread = thread_current();
c0021600:	e8 4f f7 ff ff       	call   c0020d54 <thread_current>
c0021605:	89 c6                	mov    %eax,%esi
  int old_priority = current_thread->priority;
c0021607:	8b 68 1c             	mov    0x1c(%eax),%ebp
  current_thread->base_priority = new_priority;
c002160a:	8b 44 24 20          	mov    0x20(%esp),%eax
c002160e:	89 46 3c             	mov    %eax,0x3c(%esi)
  if (list_empty (&current_thread->locks) || new_priority > old_priority) {
c0021611:	83 ec 0c             	sub    $0xc,%esp
c0021614:	8d 46 40             	lea    0x40(%esi),%eax
c0021617:	50                   	push   %eax
c0021618:	e8 dc 83 00 00       	call   c00299f9 <list_empty>
c002161d:	83 c4 10             	add    $0x10,%esp
c0021620:	3b 6c 24 20          	cmp    0x20(%esp),%ebp
c0021624:	7c 04                	jl     c002162a <thread_set_priority+0x56>
c0021626:	84 c0                	test   %al,%al
c0021628:	74 0c                	je     c0021636 <thread_set_priority+0x62>
    current_thread->priority = new_priority;
c002162a:	8b 44 24 20          	mov    0x20(%esp),%eax
c002162e:	89 46 1c             	mov    %eax,0x1c(%esi)
    thread_yield();
c0021631:	e8 4f fd ff ff       	call   c0021385 <thread_yield>
  intr_set_level(old_level);
c0021636:	83 ec 0c             	sub    $0xc,%esp
c0021639:	57                   	push   %edi
c002163a:	e8 f7 07 00 00       	call   c0021e36 <intr_set_level>
c002163f:	83 c4 10             	add    $0x10,%esp
c0021642:	eb ad                	jmp    c00215f1 <thread_set_priority+0x1d>

c0021644 <blocked_thread_check>:
void blocked_thread_check(struct thread *t, void *aux UNUSED) {
c0021644:	53                   	push   %ebx
c0021645:	83 ec 08             	sub    $0x8,%esp
c0021648:	8b 44 24 10          	mov    0x10(%esp),%eax
  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c002164c:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
c0021650:	74 05                	je     c0021657 <blocked_thread_check+0x13>
}
c0021652:	83 c4 08             	add    $0x8,%esp
c0021655:	5b                   	pop    %ebx
c0021656:	c3                   	ret    
  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c0021657:	8b 48 34             	mov    0x34(%eax),%ecx
c002165a:	8b 58 38             	mov    0x38(%eax),%ebx
c002165d:	85 db                	test   %ebx,%ebx
c002165f:	78 f1                	js     c0021652 <blocked_thread_check+0xe>
c0021661:	85 db                	test   %ebx,%ebx
c0021663:	7e 22                	jle    c0021687 <blocked_thread_check+0x43>
      t->ticks_blocked--;
c0021665:	83 c1 ff             	add    $0xffffffff,%ecx
c0021668:	83 d3 ff             	adc    $0xffffffff,%ebx
c002166b:	89 48 34             	mov    %ecx,0x34(%eax)
c002166e:	89 58 38             	mov    %ebx,0x38(%eax)
      if (t->ticks_blocked == 0)
c0021671:	89 ca                	mov    %ecx,%edx
c0021673:	89 d9                	mov    %ebx,%ecx
c0021675:	09 d1                	or     %edx,%ecx
c0021677:	75 d9                	jne    c0021652 <blocked_thread_check+0xe>
        thread_unblock(t);
c0021679:	83 ec 0c             	sub    $0xc,%esp
c002167c:	50                   	push   %eax
c002167d:	e8 25 f6 ff ff       	call   c0020ca7 <thread_unblock>
c0021682:	83 c4 10             	add    $0x10,%esp
}
c0021685:	eb cb                	jmp    c0021652 <blocked_thread_check+0xe>
  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0) {
c0021687:	83 f9 00             	cmp    $0x0,%ecx
c002168a:	76 c6                	jbe    c0021652 <blocked_thread_check+0xe>
c002168c:	eb d7                	jmp    c0021665 <blocked_thread_check+0x21>

c002168e <thread_hold_the_lock>:

void thread_hold_the_lock(struct lock *lock) {
c002168e:	57                   	push   %edi
c002168f:	56                   	push   %esi
c0021690:	53                   	push   %ebx
c0021691:	e8 ef d3 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021696:	81 c3 1e 98 01 00    	add    $0x1981e,%ebx
c002169c:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable();
c00216a0:	e8 8a 07 00 00       	call   c0021e2f <intr_disable>
c00216a5:	89 c7                	mov    %eax,%edi
  list_insert_ordered(&thread_current ()->locks, &lock->elem, lock_cmp_priority, NULL);
c00216a7:	e8 a8 f6 ff ff       	call   c0020d54 <thread_current>
c00216ac:	6a 00                	push   $0x0
c00216ae:	ff b3 fc ff ff ff    	pushl  -0x4(%ebx)
c00216b4:	8d 56 18             	lea    0x18(%esi),%edx
c00216b7:	52                   	push   %edx
c00216b8:	83 c0 40             	add    $0x40,%eax
c00216bb:	50                   	push   %eax
c00216bc:	e8 8b 87 00 00       	call   c0029e4c <list_insert_ordered>

  if (lock->max_priority > thread_current()->priority) {
c00216c1:	8b 76 20             	mov    0x20(%esi),%esi
c00216c4:	e8 8b f6 ff ff       	call   c0020d54 <thread_current>
c00216c9:	83 c4 10             	add    $0x10,%esp
c00216cc:	3b 70 1c             	cmp    0x1c(%eax),%esi
c00216cf:	7f 10                	jg     c00216e1 <thread_hold_the_lock+0x53>
    thread_current()->priority = lock->max_priority;
    thread_yield();
  }

  intr_set_level(old_level);
c00216d1:	83 ec 0c             	sub    $0xc,%esp
c00216d4:	57                   	push   %edi
c00216d5:	e8 5c 07 00 00       	call   c0021e36 <intr_set_level>
}
c00216da:	83 c4 10             	add    $0x10,%esp
c00216dd:	5b                   	pop    %ebx
c00216de:	5e                   	pop    %esi
c00216df:	5f                   	pop    %edi
c00216e0:	c3                   	ret    
    thread_current()->priority = lock->max_priority;
c00216e1:	89 70 1c             	mov    %esi,0x1c(%eax)
    thread_yield();
c00216e4:	e8 9c fc ff ff       	call   c0021385 <thread_yield>
c00216e9:	eb e6                	jmp    c00216d1 <thread_hold_the_lock+0x43>

c00216eb <thread_update_priority>:
    list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
  }
  intr_set_level(old_level);
}

void thread_update_priority (struct thread *t) {
c00216eb:	55                   	push   %ebp
c00216ec:	57                   	push   %edi
c00216ed:	56                   	push   %esi
c00216ee:	53                   	push   %ebx
c00216ef:	83 ec 1c             	sub    $0x1c,%esp
c00216f2:	e8 8e d3 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00216f7:	81 c3 bd 97 01 00    	add    $0x197bd,%ebx
c00216fd:	8b 74 24 30          	mov    0x30(%esp),%esi
  enum intr_level old_level = intr_disable();
c0021701:	e8 29 07 00 00       	call   c0021e2f <intr_disable>
c0021706:	89 44 24 0c          	mov    %eax,0xc(%esp)
  int max_priority = t->base_priority;
c002170a:	8b 7e 3c             	mov    0x3c(%esi),%edi
  int lock_priority;

  if (!list_empty(&t->locks)) {
c002170d:	8d 6e 40             	lea    0x40(%esi),%ebp
c0021710:	83 ec 0c             	sub    $0xc,%esp
c0021713:	55                   	push   %ebp
c0021714:	e8 e0 82 00 00       	call   c00299f9 <list_empty>
c0021719:	83 c4 10             	add    $0x10,%esp
c002171c:	84 c0                	test   %al,%al
c002171e:	74 17                	je     c0021737 <thread_update_priority+0x4c>
    lock_priority = list_entry(list_front (&t->locks), struct lock, elem)->max_priority;
    if (lock_priority > max_priority)
      max_priority = lock_priority;
  }

  t->priority = max_priority;
c0021720:	89 7e 1c             	mov    %edi,0x1c(%esi)
  intr_set_level(old_level);
c0021723:	83 ec 0c             	sub    $0xc,%esp
c0021726:	ff 74 24 18          	pushl  0x18(%esp)
c002172a:	e8 07 07 00 00       	call   c0021e36 <intr_set_level>
}
c002172f:	83 c4 2c             	add    $0x2c,%esp
c0021732:	5b                   	pop    %ebx
c0021733:	5e                   	pop    %esi
c0021734:	5f                   	pop    %edi
c0021735:	5d                   	pop    %ebp
c0021736:	c3                   	ret    
    list_sort(&t->locks, lock_cmp_priority, NULL);
c0021737:	83 ec 04             	sub    $0x4,%esp
c002173a:	6a 00                	push   $0x0
c002173c:	ff b3 fc ff ff ff    	pushl  -0x4(%ebx)
c0021742:	55                   	push   %ebp
c0021743:	e8 17 84 00 00       	call   c0029b5f <list_sort>
    lock_priority = list_entry(list_front (&t->locks), struct lock, elem)->max_priority;
c0021748:	89 2c 24             	mov    %ebp,(%esp)
c002174b:	e8 cd 82 00 00       	call   c0029a1d <list_front>
c0021750:	8b 40 08             	mov    0x8(%eax),%eax
c0021753:	83 c4 10             	add    $0x10,%esp
c0021756:	39 c7                	cmp    %eax,%edi
c0021758:	0f 4c f8             	cmovl  %eax,%edi
c002175b:	eb c3                	jmp    c0021720 <thread_update_priority+0x35>

c002175d <thread_remove_lock>:
void thread_remove_lock(struct lock *lock) {
c002175d:	56                   	push   %esi
c002175e:	53                   	push   %ebx
c002175f:	83 ec 04             	sub    $0x4,%esp
c0021762:	e8 1e d3 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021767:	81 c3 4d 97 01 00    	add    $0x1974d,%ebx
  enum intr_level old_level = intr_disable();
c002176d:	e8 bd 06 00 00       	call   c0021e2f <intr_disable>
c0021772:	89 c6                	mov    %eax,%esi
  list_remove(&lock->elem);
c0021774:	83 ec 0c             	sub    $0xc,%esp
c0021777:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002177b:	83 c0 18             	add    $0x18,%eax
c002177e:	50                   	push   %eax
c002177f:	e8 d3 81 00 00       	call   c0029957 <list_remove>
  thread_update_priority(thread_current());
c0021784:	e8 cb f5 ff ff       	call   c0020d54 <thread_current>
c0021789:	89 04 24             	mov    %eax,(%esp)
c002178c:	e8 5a ff ff ff       	call   c00216eb <thread_update_priority>
  intr_set_level(old_level);
c0021791:	89 34 24             	mov    %esi,(%esp)
c0021794:	e8 9d 06 00 00       	call   c0021e36 <intr_set_level>
}
c0021799:	83 c4 14             	add    $0x14,%esp
c002179c:	5b                   	pop    %ebx
c002179d:	5e                   	pop    %esi
c002179e:	c3                   	ret    

c002179f <thread_donate_priority>:
void thread_donate_priority (struct thread *t) {
c002179f:	57                   	push   %edi
c00217a0:	56                   	push   %esi
c00217a1:	53                   	push   %ebx
c00217a2:	e8 de d2 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00217a7:	81 c3 0d 97 01 00    	add    $0x1970d,%ebx
c00217ad:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable();
c00217b1:	e8 79 06 00 00       	call   c0021e2f <intr_disable>
c00217b6:	89 c7                	mov    %eax,%edi
  thread_update_priority(t);
c00217b8:	83 ec 0c             	sub    $0xc,%esp
c00217bb:	56                   	push   %esi
c00217bc:	e8 2a ff ff ff       	call   c00216eb <thread_update_priority>
  if (t->status == THREAD_READY) {
c00217c1:	83 c4 10             	add    $0x10,%esp
c00217c4:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
c00217c8:	74 10                	je     c00217da <thread_donate_priority+0x3b>
  intr_set_level(old_level);
c00217ca:	83 ec 0c             	sub    $0xc,%esp
c00217cd:	57                   	push   %edi
c00217ce:	e8 63 06 00 00       	call   c0021e36 <intr_set_level>
}
c00217d3:	83 c4 10             	add    $0x10,%esp
c00217d6:	5b                   	pop    %ebx
c00217d7:	5e                   	pop    %esi
c00217d8:	5f                   	pop    %edi
c00217d9:	c3                   	ret    
    list_remove(&t->elem);
c00217da:	83 c6 28             	add    $0x28,%esi
c00217dd:	83 ec 0c             	sub    $0xc,%esp
c00217e0:	56                   	push   %esi
c00217e1:	e8 71 81 00 00       	call   c0029957 <list_remove>
    list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);
c00217e6:	6a 00                	push   $0x0
c00217e8:	8d 83 b7 5a fe ff    	lea    -0x1a549(%ebx),%eax
c00217ee:	50                   	push   %eax
c00217ef:	56                   	push   %esi
c00217f0:	8d 83 a8 07 00 00    	lea    0x7a8(%ebx),%eax
c00217f6:	50                   	push   %eax
c00217f7:	e8 50 86 00 00       	call   c0029e4c <list_insert_ordered>
c00217fc:	83 c4 20             	add    $0x20,%esp
c00217ff:	eb c9                	jmp    c00217ca <thread_donate_priority+0x2b>

c0021801 <thread_mlfqs_increase_recent_cpu_by_one>:

void thread_mlfqs_increase_recent_cpu_by_one (void) {
c0021801:	53                   	push   %ebx
c0021802:	83 ec 08             	sub    $0x8,%esp
c0021805:	e8 7b d2 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002180a:	81 c3 aa 96 01 00    	add    $0x196aa,%ebx
  ASSERT(thread_mlfqs);
c0021810:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c0021816:	80 38 00             	cmpb   $0x0,(%eax)
c0021819:	74 22                	je     c002183d <thread_mlfqs_increase_recent_cpu_by_one+0x3c>
  ASSERT(intr_context());
c002181b:	e8 b3 08 00 00       	call   c00220d3 <intr_context>
c0021820:	84 c0                	test   %al,%al
c0021822:	74 42                	je     c0021866 <thread_mlfqs_increase_recent_cpu_by_one+0x65>

  struct thread *current_thread = thread_current();
c0021824:	e8 2b f5 ff ff       	call   c0020d54 <thread_current>
  if (current_thread == idle_thread)
c0021829:	39 83 94 07 00 00    	cmp    %eax,0x794(%ebx)
c002182f:	74 07                	je     c0021838 <thread_mlfqs_increase_recent_cpu_by_one+0x37>
    return;
  current_thread->recent_cpu = FP_ADD_MIX(current_thread->recent_cpu, 1);
c0021831:	81 40 58 00 00 01 00 	addl   $0x10000,0x58(%eax)
}
c0021838:	83 c4 08             	add    $0x8,%esp
c002183b:	5b                   	pop    %ebx
c002183c:	c3                   	ret    
  ASSERT(thread_mlfqs);
c002183d:	83 ec 0c             	sub    $0xc,%esp
c0021840:	8d 83 c9 54 ff ff    	lea    -0xab37(%ebx),%eax
c0021846:	50                   	push   %eax
c0021847:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002184d:	50                   	push   %eax
c002184e:	8d 83 cc 3c ff ff    	lea    -0xc334(%ebx),%eax
c0021854:	50                   	push   %eax
c0021855:	68 f1 02 00 00       	push   $0x2f1
c002185a:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0021860:	50                   	push   %eax
c0021861:	e8 21 7a 00 00       	call   c0029287 <debug_panic>
  ASSERT(intr_context());
c0021866:	83 ec 0c             	sub    $0xc,%esp
c0021869:	8d 83 d6 54 ff ff    	lea    -0xab2a(%ebx),%eax
c002186f:	50                   	push   %eax
c0021870:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021876:	50                   	push   %eax
c0021877:	8d 83 cc 3c ff ff    	lea    -0xc334(%ebx),%eax
c002187d:	50                   	push   %eax
c002187e:	68 f2 02 00 00       	push   $0x2f2
c0021883:	8d 83 da 53 ff ff    	lea    -0xac26(%ebx),%eax
c0021889:	50                   	push   %eax
c002188a:	e8 f8 79 00 00       	call   c0029287 <debug_panic>

c002188f <thread_mlfqs_update_priority>:

void thread_mlfqs_update_priority(struct thread *t) {
c002188f:	53                   	push   %ebx
c0021890:	83 ec 08             	sub    $0x8,%esp
c0021893:	e8 ed d1 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021898:	81 c3 1c 96 01 00    	add    $0x1961c,%ebx
c002189e:	8b 54 24 10          	mov    0x10(%esp),%edx
  if (t == idle_thread)
c00218a2:	39 93 94 07 00 00    	cmp    %edx,0x794(%ebx)
c00218a8:	74 45                	je     c00218ef <thread_mlfqs_update_priority+0x60>
    return;

  ASSERT(thread_mlfqs);
c00218aa:	c7 c1 44 d4 03 c0    	mov    $0xc003d444,%ecx
c00218b0:	80 39 00             	cmpb   $0x0,(%ecx)
c00218b3:	74 3f                	je     c00218f4 <thread_mlfqs_update_priority+0x65>
  ASSERT(t != idle_thread);

  t->priority = FP_INT_PART(FP_SUB_MIX(FP_SUB(FP_CONST(PRI_MAX), FP_DIV_MIX(t->recent_cpu, 4)), 2 * t->nice));
c00218b5:	8b 4a 58             	mov    0x58(%edx),%ecx
c00218b8:	8d 41 03             	lea    0x3(%ecx),%eax
c00218bb:	85 c9                	test   %ecx,%ecx
c00218bd:	0f 49 c1             	cmovns %ecx,%eax
c00218c0:	c1 f8 02             	sar    $0x2,%eax
c00218c3:	f7 d8                	neg    %eax
c00218c5:	05 00 00 3f 00       	add    $0x3f0000,%eax
c00218ca:	8b 4a 54             	mov    0x54(%edx),%ecx
c00218cd:	c1 e1 11             	shl    $0x11,%ecx
c00218d0:	29 c8                	sub    %ecx,%eax
c00218d2:	c1 f8 10             	sar    $0x10,%eax
c00218d5:	89 c1                	mov    %eax,%ecx
  t->priority = t->priority < PRI_MIN ? PRI_MIN : t->priority;
c00218d7:	85 c0                	test   %eax,%eax
c00218d9:	b8 00 00 00 00       	mov    $0x0,%eax
c00218de:	0f 49 c1             	cmovns %ecx,%eax
  t->priority = t->priority > PRI_MAX ? PRI_MAX : t->priority;
c00218e1:	83 f8 3f             	cmp    $0x3f,%eax
c00218e4:	b9 3f 00 00 00       	mov    $0x3f,%ecx
c00218e9:	0f 4f c1             	cmovg  %ecx,%eax
c00218ec:	89 42 1c             	mov    %eax,0x1c(%edx)
}
c00218ef:	83 c4 08             	add    $0x8,%esp
c00218f2:	5b                   	pop    %ebx
c00218f3:	c3                   	ret    
  ASSERT(thread_mlfqs);
c00218f4:	83 ec 0c             	sub    $0xc,%esp
c00218f7:	8d 93 c9 54 ff ff    	lea    -0xab37(%ebx),%edx
c00218fd:	52                   	push   %edx
c00218fe:	8d 93 45 4e ff ff    	lea    -0xb1bb(%ebx),%edx
c0021904:	52                   	push   %edx
c0021905:	8d 93 98 3c ff ff    	lea    -0xc368(%ebx),%edx
c002190b:	52                   	push   %edx
c002190c:	68 fe 02 00 00       	push   $0x2fe
c0021911:	8d 93 da 53 ff ff    	lea    -0xac26(%ebx),%edx
c0021917:	52                   	push   %edx
c0021918:	e8 6a 79 00 00       	call   c0029287 <debug_panic>

c002191d <thread_set_nice>:
{
c002191d:	83 ec 0c             	sub    $0xc,%esp
  thread_current()->nice = nice;
c0021920:	e8 2f f4 ff ff       	call   c0020d54 <thread_current>
c0021925:	8b 54 24 10          	mov    0x10(%esp),%edx
c0021929:	89 50 54             	mov    %edx,0x54(%eax)
  thread_mlfqs_update_priority(thread_current());
c002192c:	e8 23 f4 ff ff       	call   c0020d54 <thread_current>
c0021931:	83 ec 0c             	sub    $0xc,%esp
c0021934:	50                   	push   %eax
c0021935:	e8 55 ff ff ff       	call   c002188f <thread_mlfqs_update_priority>
  thread_yield();
c002193a:	e8 46 fa ff ff       	call   c0021385 <thread_yield>
}
c002193f:	83 c4 1c             	add    $0x1c,%esp
c0021942:	c3                   	ret    

c0021943 <thread_mlfqs_update_load_avg_and_recent_cpu>:

void thread_mlfqs_update_load_avg_and_recent_cpu(void) {
c0021943:	55                   	push   %ebp
c0021944:	57                   	push   %edi
c0021945:	56                   	push   %esi
c0021946:	53                   	push   %ebx
c0021947:	83 ec 2c             	sub    $0x2c,%esp
c002194a:	e8 3e d1 00 00       	call   c002ea8d <__x86.get_pc_thunk.di>
c002194f:	81 c7 65 95 01 00    	add    $0x19565,%edi
  ASSERT(thread_mlfqs);
c0021955:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c002195b:	80 38 00             	cmpb   $0x0,(%eax)
c002195e:	0f 84 91 00 00 00    	je     c00219f5 <thread_mlfqs_update_load_avg_and_recent_cpu+0xb2>
  ASSERT(intr_context());
c0021964:	89 fb                	mov    %edi,%ebx
c0021966:	e8 68 07 00 00       	call   c00220d3 <intr_context>
c002196b:	84 c0                	test   %al,%al
c002196d:	0f 84 ad 00 00 00    	je     c0021a20 <thread_mlfqs_update_load_avg_and_recent_cpu+0xdd>

  size_t ready_threads = list_size(&ready_list);
c0021973:	83 ec 0c             	sub    $0xc,%esp
c0021976:	8d 87 a8 07 00 00    	lea    0x7a8(%edi),%eax
c002197c:	50                   	push   %eax
c002197d:	e8 34 80 00 00       	call   c00299b6 <list_size>
c0021982:	89 c6                	mov    %eax,%esi
  if (thread_current() != idle_thread)
c0021984:	e8 cb f3 ff ff       	call   c0020d54 <thread_current>
    ready_threads++;
c0021989:	3b 87 94 07 00 00    	cmp    0x794(%edi),%eax
c002198f:	0f 95 c0             	setne  %al
c0021992:	0f b6 c0             	movzbl %al,%eax
c0021995:	01 c6                	add    %eax,%esi
  load_avg = FP_ADD(FP_DIV_MIX(FP_MULT_MIX(load_avg, 59), 60), FP_DIV_MIX(FP_CONST(ready_threads), 60));
c0021997:	c7 c1 40 d4 03 c0    	mov    $0xc003d440,%ecx
c002199d:	6b 29 3b             	imul   $0x3b,(%ecx),%ebp
c00219a0:	b8 89 88 88 88       	mov    $0x88888889,%eax
c00219a5:	f7 ed                	imul   %ebp
c00219a7:	8d 1c 2a             	lea    (%edx,%ebp,1),%ebx
c00219aa:	c1 fb 05             	sar    $0x5,%ebx
c00219ad:	c1 fd 1f             	sar    $0x1f,%ebp
c00219b0:	29 eb                	sub    %ebp,%ebx
c00219b2:	c1 e6 10             	shl    $0x10,%esi
c00219b5:	b8 89 88 88 88       	mov    $0x88888889,%eax
c00219ba:	f7 ee                	imul   %esi
c00219bc:	01 f2                	add    %esi,%edx
c00219be:	c1 fa 05             	sar    $0x5,%edx
c00219c1:	c1 fe 1f             	sar    $0x1f,%esi
c00219c4:	29 f2                	sub    %esi,%edx
c00219c6:	01 d3                	add    %edx,%ebx
c00219c8:	89 19                	mov    %ebx,(%ecx)

  struct thread *t;
  struct list_elem *e = list_begin(&all_list);
c00219ca:	8d 87 98 07 00 00    	lea    0x798(%edi),%eax
c00219d0:	89 04 24             	mov    %eax,(%esp)
c00219d3:	89 fb                	mov    %edi,%ebx
c00219d5:	e8 d2 79 00 00       	call   c00293ac <list_begin>
c00219da:	89 c5                	mov    %eax,%ebp

  for (; e != list_end(&all_list); e = list_next(e)) {
c00219dc:	83 c4 10             	add    $0x10,%esp
c00219df:	8d 87 98 07 00 00    	lea    0x798(%edi),%eax
c00219e5:	89 44 24 18          	mov    %eax,0x18(%esp)
    t = list_entry(e, struct thread, allelem);
    if (t != idle_thread) {
      t->recent_cpu = FP_ADD_MIX(FP_MULT(FP_DIV(FP_MULT_MIX(load_avg, 2), FP_ADD_MIX(FP_MULT_MIX(load_avg, 2), 1)), t->recent_cpu), t->nice);
c00219e9:	c7 c0 40 d4 03 c0    	mov    $0xc003d440,%eax
c00219ef:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  for (; e != list_end(&all_list); e = list_next(e)) {
c00219f3:	eb 64                	jmp    c0021a59 <thread_mlfqs_update_load_avg_and_recent_cpu+0x116>
  ASSERT(thread_mlfqs);
c00219f5:	83 ec 0c             	sub    $0xc,%esp
c00219f8:	8d 87 c9 54 ff ff    	lea    -0xab37(%edi),%eax
c00219fe:	50                   	push   %eax
c00219ff:	8d 87 45 4e ff ff    	lea    -0xb1bb(%edi),%eax
c0021a05:	50                   	push   %eax
c0021a06:	8d 87 6c 3c ff ff    	lea    -0xc394(%edi),%eax
c0021a0c:	50                   	push   %eax
c0021a0d:	68 07 03 00 00       	push   $0x307
c0021a12:	8d 87 da 53 ff ff    	lea    -0xac26(%edi),%eax
c0021a18:	50                   	push   %eax
c0021a19:	89 fb                	mov    %edi,%ebx
c0021a1b:	e8 67 78 00 00       	call   c0029287 <debug_panic>
  ASSERT(intr_context());
c0021a20:	83 ec 0c             	sub    $0xc,%esp
c0021a23:	8d 87 d6 54 ff ff    	lea    -0xab2a(%edi),%eax
c0021a29:	50                   	push   %eax
c0021a2a:	8d 87 45 4e ff ff    	lea    -0xb1bb(%edi),%eax
c0021a30:	50                   	push   %eax
c0021a31:	8d 87 6c 3c ff ff    	lea    -0xc394(%edi),%eax
c0021a37:	50                   	push   %eax
c0021a38:	68 08 03 00 00       	push   $0x308
c0021a3d:	8d 87 da 53 ff ff    	lea    -0xac26(%edi),%eax
c0021a43:	50                   	push   %eax
c0021a44:	e8 3e 78 00 00       	call   c0029287 <debug_panic>
  for (; e != list_end(&all_list); e = list_next(e)) {
c0021a49:	83 ec 0c             	sub    $0xc,%esp
c0021a4c:	55                   	push   %ebp
c0021a4d:	89 fb                	mov    %edi,%ebx
c0021a4f:	e8 9d 79 00 00       	call   c00293f1 <list_next>
c0021a54:	89 c5                	mov    %eax,%ebp
c0021a56:	83 c4 10             	add    $0x10,%esp
c0021a59:	83 ec 0c             	sub    $0xc,%esp
c0021a5c:	ff 74 24 24          	pushl  0x24(%esp)
c0021a60:	89 fb                	mov    %edi,%ebx
c0021a62:	e8 e7 79 00 00       	call   c002944e <list_end>
c0021a67:	83 c4 10             	add    $0x10,%esp
c0021a6a:	39 e8                	cmp    %ebp,%eax
c0021a6c:	0f 84 87 00 00 00    	je     c0021af9 <thread_mlfqs_update_load_avg_and_recent_cpu+0x1b6>
    t = list_entry(e, struct thread, allelem);
c0021a72:	8d 75 e0             	lea    -0x20(%ebp),%esi
    if (t != idle_thread) {
c0021a75:	39 b7 94 07 00 00    	cmp    %esi,0x794(%edi)
c0021a7b:	74 cc                	je     c0021a49 <thread_mlfqs_update_load_avg_and_recent_cpu+0x106>
      t->recent_cpu = FP_ADD_MIX(FP_MULT(FP_DIV(FP_MULT_MIX(load_avg, 2), FP_ADD_MIX(FP_MULT_MIX(load_avg, 2), 1)), t->recent_cpu), t->nice);
c0021a7d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0021a81:	8b 00                	mov    (%eax),%eax
c0021a83:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021a87:	01 c0                	add    %eax,%eax
c0021a89:	89 c1                	mov    %eax,%ecx
c0021a8b:	89 c3                	mov    %eax,%ebx
c0021a8d:	c1 fb 1f             	sar    $0x1f,%ebx
c0021a90:	0f a4 c3 10          	shld   $0x10,%eax,%ebx
c0021a94:	c1 e1 10             	shl    $0x10,%ecx
c0021a97:	05 00 00 01 00       	add    $0x10000,%eax
c0021a9c:	99                   	cltd   
c0021a9d:	52                   	push   %edx
c0021a9e:	50                   	push   %eax
c0021a9f:	53                   	push   %ebx
c0021aa0:	51                   	push   %ecx
c0021aa1:	89 fb                	mov    %edi,%ebx
c0021aa3:	e8 a2 71 00 00       	call   c0028c4a <__divdi3>
c0021aa8:	89 c1                	mov    %eax,%ecx
c0021aaa:	c1 f9 1f             	sar    $0x1f,%ecx
c0021aad:	89 44 24 20          	mov    %eax,0x20(%esp)
c0021ab1:	89 4c 24 24          	mov    %ecx,0x24(%esp)
c0021ab5:	8b 55 38             	mov    0x38(%ebp),%edx
c0021ab8:	89 d3                	mov    %edx,%ebx
c0021aba:	c1 fb 1f             	sar    $0x1f,%ebx
c0021abd:	89 54 24 18          	mov    %edx,0x18(%esp)
c0021ac1:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
c0021ac5:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021ac9:	0f af ca             	imul   %edx,%ecx
c0021acc:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c0021ad0:	0f af d8             	imul   %eax,%ebx
c0021ad3:	01 d9                	add    %ebx,%ecx
c0021ad5:	f7 e2                	mul    %edx
c0021ad7:	01 ca                	add    %ecx,%edx
c0021ad9:	0f ac d0 10          	shrd   $0x10,%edx,%eax
c0021add:	8b 55 34             	mov    0x34(%ebp),%edx
c0021ae0:	c1 e2 10             	shl    $0x10,%edx
c0021ae3:	8d 04 10             	lea    (%eax,%edx,1),%eax
c0021ae6:	89 45 38             	mov    %eax,0x38(%ebp)
      thread_mlfqs_update_priority(t);
c0021ae9:	89 34 24             	mov    %esi,(%esp)
c0021aec:	e8 9e fd ff ff       	call   c002188f <thread_mlfqs_update_priority>
c0021af1:	83 c4 10             	add    $0x10,%esp
c0021af4:	e9 50 ff ff ff       	jmp    c0021a49 <thread_mlfqs_update_load_avg_and_recent_cpu+0x106>
    }
  }
}
c0021af9:	83 c4 2c             	add    $0x2c,%esp
c0021afc:	5b                   	pop    %ebx
c0021afd:	5e                   	pop    %esi
c0021afe:	5f                   	pop    %edi
c0021aff:	5d                   	pop    %ebp
c0021b00:	c3                   	ret    

c0021b01 <thread_get_child_message>:

struct child_message *thread_get_child_message(tid_t tid) {
c0021b01:	55                   	push   %ebp
c0021b02:	57                   	push   %edi
c0021b03:	56                   	push   %esi
c0021b04:	53                   	push   %ebx
c0021b05:	83 ec 18             	sub    $0x18,%esp
c0021b08:	e8 78 cf 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021b0d:	81 c3 a7 93 01 00    	add    $0x193a7,%ebx
c0021b13:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  struct list_elem *e;
  struct child_message *l;
  for (e = list_rbegin(&children); e != list_rend(&children); e = list_prev(e)) {
c0021b17:	8d 83 c8 07 00 00    	lea    0x7c8(%ebx),%eax
c0021b1d:	50                   	push   %eax
c0021b1e:	e8 70 79 00 00       	call   c0029493 <list_rbegin>
c0021b23:	89 c6                	mov    %eax,%esi
c0021b25:	83 c4 10             	add    $0x10,%esp
c0021b28:	8d bb c8 07 00 00    	lea    0x7c8(%ebx),%edi
c0021b2e:	83 ec 0c             	sub    $0xc,%esp
c0021b31:	57                   	push   %edi
c0021b32:	e8 77 7b 00 00       	call   c00296ae <list_rend>
c0021b37:	83 c4 10             	add    $0x10,%esp
c0021b3a:	39 f0                	cmp    %esi,%eax
c0021b3c:	74 1a                	je     c0021b58 <thread_get_child_message+0x57>
    l = list_entry(e, struct child_message, allelem);
    if (l->tid == tid)
c0021b3e:	39 6e e4             	cmp    %ebp,-0x1c(%esi)
c0021b41:	74 10                	je     c0021b53 <thread_get_child_message+0x52>
  for (e = list_rbegin(&children); e != list_rend(&children); e = list_prev(e)) {
c0021b43:	83 ec 0c             	sub    $0xc,%esp
c0021b46:	56                   	push   %esi
c0021b47:	e8 8c 79 00 00       	call   c00294d8 <list_prev>
c0021b4c:	89 c6                	mov    %eax,%esi
c0021b4e:	83 c4 10             	add    $0x10,%esp
c0021b51:	eb db                	jmp    c0021b2e <thread_get_child_message+0x2d>
    l = list_entry(e, struct child_message, allelem);
c0021b53:	8d 46 e0             	lea    -0x20(%esi),%eax
c0021b56:	eb 05                	jmp    c0021b5d <thread_get_child_message+0x5c>
      return l;
  }
  return NULL;
c0021b58:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021b5d:	83 c4 0c             	add    $0xc,%esp
c0021b60:	5b                   	pop    %ebx
c0021b61:	5e                   	pop    %esi
c0021b62:	5f                   	pop    %edi
c0021b63:	5d                   	pop    %ebp
c0021b64:	c3                   	ret    

c0021b65 <thread_exit_with_return_value>:

void thread_exit_with_return_value(struct intr_frame *f, int return_value) {
c0021b65:	53                   	push   %ebx
c0021b66:	83 ec 08             	sub    $0x8,%esp
c0021b69:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct thread *cur = thread_current();
c0021b6d:	e8 e2 f1 ff ff       	call   c0020d54 <thread_current>
  cur->return_value = return_value;
c0021b72:	89 58 5c             	mov    %ebx,0x5c(%eax)
  f->eax = (uint32_t)return_value;
c0021b75:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021b79:	89 58 1c             	mov    %ebx,0x1c(%eax)
  thread_exit();
c0021b7c:	e8 60 f6 ff ff       	call   c00211e1 <thread_exit>

c0021b81 <thread_file_list_inster>:
}

void thread_file_list_inster(struct file_handle* fh) {
c0021b81:	53                   	push   %ebx
c0021b82:	83 ec 10             	sub    $0x10,%esp
c0021b85:	e8 fb ce 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021b8a:	81 c3 2a 93 01 00    	add    $0x1932a,%ebx
  list_push_back(&file_list, &(fh->elem));
c0021b90:	8b 44 24 18          	mov    0x18(%esp),%eax
c0021b94:	83 c0 0c             	add    $0xc,%eax
c0021b97:	50                   	push   %eax
c0021b98:	8d 83 b8 07 00 00    	lea    0x7b8(%ebx),%eax
c0021b9e:	50                   	push   %eax
c0021b9f:	e8 96 7d 00 00       	call   c002993a <list_push_back>
}
c0021ba4:	83 c4 18             	add    $0x18,%esp
c0021ba7:	5b                   	pop    %ebx
c0021ba8:	c3                   	ret    

c0021ba9 <syscall_get_file_handle>:

struct file_handle* syscall_get_file_handle(int fd) {
c0021ba9:	55                   	push   %ebp
c0021baa:	57                   	push   %edi
c0021bab:	56                   	push   %esi
c0021bac:	53                   	push   %ebx
c0021bad:	83 ec 1c             	sub    $0x1c,%esp
c0021bb0:	e8 d0 ce 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021bb5:	81 c3 ff 92 01 00    	add    $0x192ff,%ebx
c0021bbb:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  struct thread* cur =  thread_current();
c0021bbf:	e8 90 f1 ff ff       	call   c0020d54 <thread_current>
c0021bc4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  struct list_elem* i;
  for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i)) {
c0021bc8:	83 ec 0c             	sub    $0xc,%esp
c0021bcb:	8d 83 b8 07 00 00    	lea    0x7b8(%ebx),%eax
c0021bd1:	50                   	push   %eax
c0021bd2:	e8 d5 77 00 00       	call   c00293ac <list_begin>
c0021bd7:	89 c6                	mov    %eax,%esi
c0021bd9:	83 c4 10             	add    $0x10,%esp
c0021bdc:	8d bb b8 07 00 00    	lea    0x7b8(%ebx),%edi
c0021be2:	83 ec 0c             	sub    $0xc,%esp
c0021be5:	57                   	push   %edi
c0021be6:	e8 63 78 00 00       	call   c002944e <list_end>
c0021beb:	83 c4 10             	add    $0x10,%esp
c0021bee:	39 f0                	cmp    %esi,%eax
c0021bf0:	74 23                	je     c0021c15 <syscall_get_file_handle+0x6c>
    struct file_handle* t;
    t = list_entry(i, struct file_handle, elem);
    if (t->fd == fd){
c0021bf2:	39 6e f4             	cmp    %ebp,-0xc(%esi)
c0021bf5:	74 10                	je     c0021c07 <syscall_get_file_handle+0x5e>
  for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i)) {
c0021bf7:	83 ec 0c             	sub    $0xc,%esp
c0021bfa:	56                   	push   %esi
c0021bfb:	e8 f1 77 00 00       	call   c00293f1 <list_next>
c0021c00:	89 c6                	mov    %eax,%esi
c0021c02:	83 c4 10             	add    $0x10,%esp
c0021c05:	eb db                	jmp    c0021be2 <syscall_get_file_handle+0x39>
      if (t->owned_thread != cur)
c0021c07:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0021c0b:	39 46 fc             	cmp    %eax,-0x4(%esi)
c0021c0e:	75 12                	jne    c0021c22 <syscall_get_file_handle+0x79>
    t = list_entry(i, struct file_handle, elem);
c0021c10:	8d 46 f4             	lea    -0xc(%esi),%eax
        return NULL;
      else
        return t;
c0021c13:	eb 05                	jmp    c0021c1a <syscall_get_file_handle+0x71>
    }
  }
  return NULL;
c0021c15:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021c1a:	83 c4 1c             	add    $0x1c,%esp
c0021c1d:	5b                   	pop    %ebx
c0021c1e:	5e                   	pop    %esi
c0021c1f:	5f                   	pop    %edi
c0021c20:	5d                   	pop    %ebp
c0021c21:	c3                   	ret    
        return NULL;
c0021c22:	b8 00 00 00 00       	mov    $0x0,%eax
c0021c27:	eb f1                	jmp    c0021c1a <syscall_get_file_handle+0x71>

c0021c29 <set_main_thread_dir>:

#ifdef FILESYS
/* Set main thread's current directory */
void set_main_thread_dir() {
c0021c29:	56                   	push   %esi
c0021c2a:	53                   	push   %ebx
c0021c2b:	83 ec 04             	sub    $0x4,%esp
c0021c2e:	e8 52 ce 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021c33:	81 c3 81 92 01 00    	add    $0x19281,%ebx
  initial_thread->current_dir = dir_open_root();
c0021c39:	8b b3 90 07 00 00    	mov    0x790(%ebx),%esi
c0021c3f:	e8 e7 bc 00 00       	call   c002d92b <dir_open_root>
c0021c44:	89 86 a8 00 00 00    	mov    %eax,0xa8(%esi)
}
c0021c4a:	83 c4 04             	add    $0x4,%esp
c0021c4d:	5b                   	pop    %ebx
c0021c4e:	5e                   	pop    %esi
c0021c4f:	c3                   	ret    

c0021c50 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021c50:	53                   	push   %ebx
	pushl %ebp
c0021c51:	55                   	push   %ebp
	pushl %esi
c0021c52:	56                   	push   %esi
	pushl %edi
c0021c53:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021c54:	8b 15 9c aa 03 c0    	mov    0xc003aa9c,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021c5a:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021c5e:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021c61:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021c65:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021c68:	5f                   	pop    %edi
	popl %esi
c0021c69:	5e                   	pop    %esi
	popl %ebp
c0021c6a:	5d                   	pop    %ebp
	popl %ebx
c0021c6b:	5b                   	pop    %ebx
        ret
c0021c6c:	c3                   	ret    

c0021c6d <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021c6d:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021c70:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021c71:	e8 ee f2 ff ff       	call   c0020f64 <thread_schedule_tail>
	addl $4, %esp
c0021c76:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021c79:	c3                   	ret    

c0021c7a <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c0021c7a:	53                   	push   %ebx
c0021c7b:	83 ec 08             	sub    $0x8,%esp
c0021c7e:	e8 02 ce 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021c83:	81 c3 31 92 01 00    	add    $0x19231,%ebx
  uint32_t e0, e1;

  ASSERT (function != NULL);
c0021c89:	85 c0                	test   %eax,%eax
c0021c8b:	74 2a                	je     c0021cb7 <make_gate+0x3d>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021c8d:	83 fa 03             	cmp    $0x3,%edx
c0021c90:	77 4e                	ja     c0021ce0 <make_gate+0x66>
  ASSERT (type >= 0 && type <= 15);
c0021c92:	83 f9 0f             	cmp    $0xf,%ecx
c0021c95:	77 72                	ja     c0021d09 <make_gate+0x8f>

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021c97:	c1 e1 08             	shl    $0x8,%ecx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021c9a:	80 cd 80             	or     $0x80,%ch
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c0021c9d:	c1 e2 0d             	shl    $0xd,%edx
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021ca0:	09 ca                	or     %ecx,%edx
c0021ca2:	89 c1                	mov    %eax,%ecx
c0021ca4:	66 b9 00 00          	mov    $0x0,%cx
c0021ca8:	09 ca                	or     %ecx,%edx
  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021caa:	0f b7 c0             	movzwl %ax,%eax
c0021cad:	0d 00 00 08 00       	or     $0x80000,%eax

  return e0 | ((uint64_t) e1 << 32);
}
c0021cb2:	83 c4 08             	add    $0x8,%esp
c0021cb5:	5b                   	pop    %ebx
c0021cb6:	c3                   	ret    
  ASSERT (function != NULL);
c0021cb7:	83 ec 0c             	sub    $0xc,%esp
c0021cba:	8d 83 b3 54 ff ff    	lea    -0xab4d(%ebx),%eax
c0021cc0:	50                   	push   %eax
c0021cc1:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021cc7:	50                   	push   %eax
c0021cc8:	8d 83 34 3e ff ff    	lea    -0xc1cc(%ebx),%eax
c0021cce:	50                   	push   %eax
c0021ccf:	68 2a 01 00 00       	push   $0x12a
c0021cd4:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c0021cda:	50                   	push   %eax
c0021cdb:	e8 a7 75 00 00       	call   c0029287 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021ce0:	83 ec 0c             	sub    $0xc,%esp
c0021ce3:	8d 83 90 55 ff ff    	lea    -0xaa70(%ebx),%eax
c0021ce9:	50                   	push   %eax
c0021cea:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021cf0:	50                   	push   %eax
c0021cf1:	8d 83 34 3e ff ff    	lea    -0xc1cc(%ebx),%eax
c0021cf7:	50                   	push   %eax
c0021cf8:	68 2b 01 00 00       	push   $0x12b
c0021cfd:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c0021d03:	50                   	push   %eax
c0021d04:	e8 7e 75 00 00       	call   c0029287 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021d09:	83 ec 0c             	sub    $0xc,%esp
c0021d0c:	8d 83 a5 55 ff ff    	lea    -0xaa5b(%ebx),%eax
c0021d12:	50                   	push   %eax
c0021d13:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021d19:	50                   	push   %eax
c0021d1a:	8d 83 34 3e ff ff    	lea    -0xc1cc(%ebx),%eax
c0021d20:	50                   	push   %eax
c0021d21:	68 2c 01 00 00       	push   $0x12c
c0021d26:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c0021d2c:	50                   	push   %eax
c0021d2d:	e8 55 75 00 00       	call   c0029287 <debug_panic>

c0021d32 <register_handler>:
{
c0021d32:	56                   	push   %esi
c0021d33:	53                   	push   %ebx
c0021d34:	83 ec 04             	sub    $0x4,%esp
c0021d37:	e8 49 cd 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021d3c:	81 c3 78 91 01 00    	add    $0x19178,%ebx
  ASSERT (intr_handlers[vec_no] == NULL);
c0021d42:	0f b6 f0             	movzbl %al,%esi
c0021d45:	83 bc b3 0c 10 00 00 	cmpl   $0x0,0x100c(%ebx,%esi,4)
c0021d4c:	00 
c0021d4d:	75 42                	jne    c0021d91 <register_handler+0x5f>
  if (level == INTR_ON)
c0021d4f:	83 f9 01             	cmp    $0x1,%ecx
c0021d52:	74 66                	je     c0021dba <register_handler+0x88>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021d54:	c7 c0 a0 aa 03 c0    	mov    $0xc003aaa0,%eax
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c0021d5a:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021d5d:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021d62:	e8 13 ff ff ff       	call   c0021c7a <make_gate>
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021d67:	89 84 f3 0c 14 00 00 	mov    %eax,0x140c(%ebx,%esi,8)
c0021d6e:	89 94 f3 10 14 00 00 	mov    %edx,0x1410(%ebx,%esi,8)
  intr_handlers[vec_no] = handler;
c0021d75:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021d79:	89 84 b3 0c 10 00 00 	mov    %eax,0x100c(%ebx,%esi,4)
  intr_names[vec_no] = name;
c0021d80:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021d84:	89 84 b3 0c 0c 00 00 	mov    %eax,0xc0c(%ebx,%esi,4)
}
c0021d8b:	83 c4 04             	add    $0x4,%esp
c0021d8e:	5b                   	pop    %ebx
c0021d8f:	5e                   	pop    %esi
c0021d90:	c3                   	ret    
  ASSERT (intr_handlers[vec_no] == NULL);
c0021d91:	83 ec 0c             	sub    $0xc,%esp
c0021d94:	8d 83 bd 55 ff ff    	lea    -0xaa43(%ebx),%eax
c0021d9a:	50                   	push   %eax
c0021d9b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021da1:	50                   	push   %eax
c0021da2:	8d 83 0c 3e ff ff    	lea    -0xc1f4(%ebx),%eax
c0021da8:	50                   	push   %eax
c0021da9:	68 a8 00 00 00       	push   $0xa8
c0021dae:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c0021db4:	50                   	push   %eax
c0021db5:	e8 cd 74 00 00       	call   c0029287 <debug_panic>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021dba:	c7 c0 a0 aa 03 c0    	mov    $0xc003aaa0,%eax
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
c0021dc0:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021dc3:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021dc8:	e8 ad fe ff ff       	call   c0021c7a <make_gate>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021dcd:	89 84 f3 0c 14 00 00 	mov    %eax,0x140c(%ebx,%esi,8)
c0021dd4:	89 94 f3 10 14 00 00 	mov    %edx,0x1410(%ebx,%esi,8)
c0021ddb:	eb 98                	jmp    c0021d75 <register_handler+0x43>

c0021ddd <intr_get_level>:
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021ddd:	9c                   	pushf  
c0021dde:	58                   	pop    %eax
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021ddf:	c1 e8 09             	shr    $0x9,%eax
c0021de2:	83 e0 01             	and    $0x1,%eax
}
c0021de5:	c3                   	ret    

c0021de6 <intr_enable>:
{
c0021de6:	53                   	push   %ebx
c0021de7:	83 ec 08             	sub    $0x8,%esp
c0021dea:	e8 96 cc 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0021def:	81 c3 c5 90 01 00    	add    $0x190c5,%ebx
  enum intr_level old_level = intr_get_level ();
c0021df5:	e8 e3 ff ff ff       	call   c0021ddd <intr_get_level>
  ASSERT (!intr_context ());
c0021dfa:	80 bb ed 07 00 00 00 	cmpb   $0x0,0x7ed(%ebx)
c0021e01:	75 06                	jne    c0021e09 <intr_enable+0x23>
  asm volatile ("sti");
c0021e03:	fb                   	sti    
}
c0021e04:	83 c4 08             	add    $0x8,%esp
c0021e07:	5b                   	pop    %ebx
c0021e08:	c3                   	ret    
  ASSERT (!intr_context ());
c0021e09:	83 ec 0c             	sub    $0xc,%esp
c0021e0c:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0021e12:	50                   	push   %eax
c0021e13:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0021e19:	50                   	push   %eax
c0021e1a:	8d 83 40 3e ff ff    	lea    -0xc1c0(%ebx),%eax
c0021e20:	50                   	push   %eax
c0021e21:	6a 5b                	push   $0x5b
c0021e23:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c0021e29:	50                   	push   %eax
c0021e2a:	e8 58 74 00 00       	call   c0029287 <debug_panic>

c0021e2f <intr_disable>:
  enum intr_level old_level = intr_get_level ();
c0021e2f:	e8 a9 ff ff ff       	call   c0021ddd <intr_get_level>
  asm volatile ("cli" : : : "memory");
c0021e34:	fa                   	cli    
}
c0021e35:	c3                   	ret    

c0021e36 <intr_set_level>:
{
c0021e36:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021e39:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021e3e:	74 09                	je     c0021e49 <intr_set_level+0x13>
c0021e40:	e8 ea ff ff ff       	call   c0021e2f <intr_disable>
}
c0021e45:	83 c4 0c             	add    $0xc,%esp
c0021e48:	c3                   	ret    
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021e49:	e8 98 ff ff ff       	call   c0021de6 <intr_enable>
c0021e4e:	eb f5                	jmp    c0021e45 <intr_set_level+0xf>

c0021e50 <intr_init>:
{
c0021e50:	57                   	push   %edi
c0021e51:	56                   	push   %esi
c0021e52:	53                   	push   %ebx
c0021e53:	83 ec 10             	sub    $0x10,%esp
c0021e56:	e8 36 cc 00 00       	call   c002ea91 <__x86.get_pc_thunk.si>
c0021e5b:	81 c6 59 90 01 00    	add    $0x19059,%esi
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021e61:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021e66:	e6 21                	out    %al,$0x21
c0021e68:	e6 a1                	out    %al,$0xa1
c0021e6a:	b9 11 00 00 00       	mov    $0x11,%ecx
c0021e6f:	89 c8                	mov    %ecx,%eax
c0021e71:	e6 20                	out    %al,$0x20
c0021e73:	b8 20 00 00 00       	mov    $0x20,%eax
c0021e78:	e6 21                	out    %al,$0x21
c0021e7a:	b8 04 00 00 00       	mov    $0x4,%eax
c0021e7f:	e6 21                	out    %al,$0x21
c0021e81:	ba 01 00 00 00       	mov    $0x1,%edx
c0021e86:	89 d0                	mov    %edx,%eax
c0021e88:	e6 21                	out    %al,$0x21
c0021e8a:	89 c8                	mov    %ecx,%eax
c0021e8c:	e6 a0                	out    %al,$0xa0
c0021e8e:	b8 28 00 00 00       	mov    $0x28,%eax
c0021e93:	e6 a1                	out    %al,$0xa1
c0021e95:	b8 02 00 00 00       	mov    $0x2,%eax
c0021e9a:	e6 a1                	out    %al,$0xa1
c0021e9c:	89 d0                	mov    %edx,%eax
c0021e9e:	e6 a1                	out    %al,$0xa1
c0021ea0:	b8 00 00 00 00       	mov    $0x0,%eax
c0021ea5:	e6 21                	out    %al,$0x21
c0021ea7:	e6 a1                	out    %al,$0xa1
  for (i = 0; i < INTR_CNT; i++)
c0021ea9:	bb 00 00 00 00       	mov    $0x0,%ebx
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021eae:	c7 c7 a0 aa 03 c0    	mov    $0xc003aaa0,%edi
  return make_gate (function, dpl, 14);
c0021eb4:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
c0021eb7:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021ebc:	ba 00 00 00 00       	mov    $0x0,%edx
c0021ec1:	e8 b4 fd ff ff       	call   c0021c7a <make_gate>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021ec6:	89 84 de 0c 14 00 00 	mov    %eax,0x140c(%esi,%ebx,8)
c0021ecd:	89 94 de 10 14 00 00 	mov    %edx,0x1410(%esi,%ebx,8)
  for (i = 0; i < INTR_CNT; i++)
c0021ed4:	83 c3 01             	add    $0x1,%ebx
c0021ed7:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
c0021edd:	75 d5                	jne    c0021eb4 <intr_init+0x64>
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021edf:	8d 86 0c 14 00 00    	lea    0x140c(%esi),%eax
c0021ee5:	ba 00 00 00 00       	mov    $0x0,%edx
c0021eea:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021eee:	c1 e0 10             	shl    $0x10,%eax
c0021ef1:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021ef6:	89 44 24 08          	mov    %eax,0x8(%esp)
c0021efa:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021efe:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c0021f03:	8d 86 0c 0c 00 00    	lea    0xc0c(%esi),%eax
c0021f09:	8d 8e 0c 10 00 00    	lea    0x100c(%esi),%ecx
    intr_names[i] = "unknown";
c0021f0f:	8d 96 db 55 ff ff    	lea    -0xaa25(%esi),%edx
c0021f15:	89 10                	mov    %edx,(%eax)
c0021f17:	83 c0 04             	add    $0x4,%eax
  for (i = 0; i < INTR_CNT; i++)
c0021f1a:	39 c1                	cmp    %eax,%ecx
c0021f1c:	75 f7                	jne    c0021f15 <intr_init+0xc5>
  intr_names[0] = "#DE Divide Error";
c0021f1e:	8d 86 e3 55 ff ff    	lea    -0xaa1d(%esi),%eax
c0021f24:	89 86 0c 0c 00 00    	mov    %eax,0xc0c(%esi)
  intr_names[1] = "#DB Debug Exception";
c0021f2a:	8d 86 f4 55 ff ff    	lea    -0xaa0c(%esi),%eax
c0021f30:	89 86 10 0c 00 00    	mov    %eax,0xc10(%esi)
  intr_names[2] = "NMI Interrupt";
c0021f36:	8d 86 08 56 ff ff    	lea    -0xa9f8(%esi),%eax
c0021f3c:	89 86 14 0c 00 00    	mov    %eax,0xc14(%esi)
  intr_names[3] = "#BP Breakpoint Exception";
c0021f42:	8d 86 16 56 ff ff    	lea    -0xa9ea(%esi),%eax
c0021f48:	89 86 18 0c 00 00    	mov    %eax,0xc18(%esi)
  intr_names[4] = "#OF Overflow Exception";
c0021f4e:	8d 86 2f 56 ff ff    	lea    -0xa9d1(%esi),%eax
c0021f54:	89 86 1c 0c 00 00    	mov    %eax,0xc1c(%esi)
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021f5a:	8d 86 6c 57 ff ff    	lea    -0xa894(%esi),%eax
c0021f60:	89 86 20 0c 00 00    	mov    %eax,0xc20(%esi)
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021f66:	8d 86 46 56 ff ff    	lea    -0xa9ba(%esi),%eax
c0021f6c:	89 86 24 0c 00 00    	mov    %eax,0xc24(%esi)
  intr_names[7] = "#NM Device Not Available Exception";
c0021f72:	8d 86 90 57 ff ff    	lea    -0xa870(%esi),%eax
c0021f78:	89 86 28 0c 00 00    	mov    %eax,0xc28(%esi)
  intr_names[8] = "#DF Double Fault Exception";
c0021f7e:	8d 86 63 56 ff ff    	lea    -0xa99d(%esi),%eax
c0021f84:	89 86 2c 0c 00 00    	mov    %eax,0xc2c(%esi)
  intr_names[9] = "Coprocessor Segment Overrun";
c0021f8a:	8d 86 7e 56 ff ff    	lea    -0xa982(%esi),%eax
c0021f90:	89 86 30 0c 00 00    	mov    %eax,0xc30(%esi)
  intr_names[10] = "#TS Invalid TSS Exception";
c0021f96:	8d 86 9a 56 ff ff    	lea    -0xa966(%esi),%eax
c0021f9c:	89 86 34 0c 00 00    	mov    %eax,0xc34(%esi)
  intr_names[11] = "#NP Segment Not Present";
c0021fa2:	8d 86 b4 56 ff ff    	lea    -0xa94c(%esi),%eax
c0021fa8:	89 86 38 0c 00 00    	mov    %eax,0xc38(%esi)
  intr_names[12] = "#SS Stack Fault Exception";
c0021fae:	8d 86 cc 56 ff ff    	lea    -0xa934(%esi),%eax
c0021fb4:	89 86 3c 0c 00 00    	mov    %eax,0xc3c(%esi)
  intr_names[13] = "#GP General Protection Exception";
c0021fba:	8d 86 b4 57 ff ff    	lea    -0xa84c(%esi),%eax
c0021fc0:	89 86 40 0c 00 00    	mov    %eax,0xc40(%esi)
  intr_names[14] = "#PF Page-Fault Exception";
c0021fc6:	8d 86 e6 56 ff ff    	lea    -0xa91a(%esi),%eax
c0021fcc:	89 86 44 0c 00 00    	mov    %eax,0xc44(%esi)
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021fd2:	8d 86 d8 57 ff ff    	lea    -0xa828(%esi),%eax
c0021fd8:	89 86 4c 0c 00 00    	mov    %eax,0xc4c(%esi)
  intr_names[17] = "#AC Alignment Check Exception";
c0021fde:	8d 86 ff 56 ff ff    	lea    -0xa901(%esi),%eax
c0021fe4:	89 86 50 0c 00 00    	mov    %eax,0xc50(%esi)
  intr_names[18] = "#MC Machine-Check Exception";
c0021fea:	8d 86 1d 57 ff ff    	lea    -0xa8e3(%esi),%eax
c0021ff0:	89 86 54 0c 00 00    	mov    %eax,0xc54(%esi)
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021ff6:	8d 86 fc 57 ff ff    	lea    -0xa804(%esi),%eax
c0021ffc:	89 86 58 0c 00 00    	mov    %eax,0xc58(%esi)
}
c0022002:	83 c4 10             	add    $0x10,%esp
c0022005:	5b                   	pop    %ebx
c0022006:	5e                   	pop    %esi
c0022007:	5f                   	pop    %edi
c0022008:	c3                   	ret    

c0022009 <intr_register_ext>:
{
c0022009:	53                   	push   %ebx
c002200a:	83 ec 08             	sub    $0x8,%esp
c002200d:	e8 73 ca 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0022012:	81 c3 a2 8e 01 00    	add    $0x18ea2,%ebx
c0022018:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c002201c:	8d 50 e0             	lea    -0x20(%eax),%edx
c002201f:	80 fa 0f             	cmp    $0xf,%dl
c0022022:	77 22                	ja     c0022046 <intr_register_ext+0x3d>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0022024:	0f b6 c0             	movzbl %al,%eax
c0022027:	83 ec 08             	sub    $0x8,%esp
c002202a:	ff 74 24 20          	pushl  0x20(%esp)
c002202e:	ff 74 24 20          	pushl  0x20(%esp)
c0022032:	b9 00 00 00 00       	mov    $0x0,%ecx
c0022037:	ba 00 00 00 00       	mov    $0x0,%edx
c002203c:	e8 f1 fc ff ff       	call   c0021d32 <register_handler>
}
c0022041:	83 c4 18             	add    $0x18,%esp
c0022044:	5b                   	pop    %ebx
c0022045:	c3                   	ret    
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0022046:	83 ec 0c             	sub    $0xc,%esp
c0022049:	8d 83 20 58 ff ff    	lea    -0xa7e0(%ebx),%eax
c002204f:	50                   	push   %eax
c0022050:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0022056:	50                   	push   %eax
c0022057:	8d 83 20 3e ff ff    	lea    -0xc1e0(%ebx),%eax
c002205d:	50                   	push   %eax
c002205e:	68 b8 00 00 00       	push   $0xb8
c0022063:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c0022069:	50                   	push   %eax
c002206a:	e8 18 72 00 00       	call   c0029287 <debug_panic>

c002206f <intr_register_int>:
{
c002206f:	53                   	push   %ebx
c0022070:	83 ec 08             	sub    $0x8,%esp
c0022073:	e8 0d ca 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0022078:	81 c3 3c 8e 01 00    	add    $0x18e3c,%ebx
c002207e:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0022082:	8d 50 e0             	lea    -0x20(%eax),%edx
c0022085:	80 fa 0f             	cmp    $0xf,%dl
c0022088:	76 20                	jbe    c00220aa <intr_register_int+0x3b>
  register_handler (vec_no, dpl, level, handler, name);
c002208a:	0f b6 c0             	movzbl %al,%eax
c002208d:	83 ec 08             	sub    $0x8,%esp
c0022090:	ff 74 24 28          	pushl  0x28(%esp)
c0022094:	ff 74 24 28          	pushl  0x28(%esp)
c0022098:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c002209c:	8b 54 24 24          	mov    0x24(%esp),%edx
c00220a0:	e8 8d fc ff ff       	call   c0021d32 <register_handler>
}
c00220a5:	83 c4 18             	add    $0x18,%esp
c00220a8:	5b                   	pop    %ebx
c00220a9:	c3                   	ret    
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c00220aa:	83 ec 0c             	sub    $0xc,%esp
c00220ad:	8d 83 44 58 ff ff    	lea    -0xa7bc(%ebx),%eax
c00220b3:	50                   	push   %eax
c00220b4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00220ba:	50                   	push   %eax
c00220bb:	8d 83 f8 3d ff ff    	lea    -0xc208(%ebx),%eax
c00220c1:	50                   	push   %eax
c00220c2:	68 cd 00 00 00       	push   $0xcd
c00220c7:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c00220cd:	50                   	push   %eax
c00220ce:	e8 b4 71 00 00       	call   c0029287 <debug_panic>

c00220d3 <intr_context>:
{
c00220d3:	e8 b1 c9 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c00220d8:	05 dc 8d 01 00       	add    $0x18ddc,%eax
  return in_external_intr;
c00220dd:	0f b6 80 ed 07 00 00 	movzbl 0x7ed(%eax),%eax
}
c00220e4:	c3                   	ret    

c00220e5 <intr_yield_on_return>:
{
c00220e5:	53                   	push   %ebx
c00220e6:	83 ec 08             	sub    $0x8,%esp
c00220e9:	e8 97 c9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00220ee:	81 c3 c6 8d 01 00    	add    $0x18dc6,%ebx
  ASSERT (intr_context ());
c00220f4:	80 bb ed 07 00 00 00 	cmpb   $0x0,0x7ed(%ebx)
c00220fb:	74 0c                	je     c0022109 <intr_yield_on_return+0x24>
  yield_on_return = true;
c00220fd:	c6 83 ec 07 00 00 01 	movb   $0x1,0x7ec(%ebx)
}
c0022104:	83 c4 08             	add    $0x8,%esp
c0022107:	5b                   	pop    %ebx
c0022108:	c3                   	ret    
  ASSERT (intr_context ());
c0022109:	83 ec 0c             	sub    $0xc,%esp
c002210c:	8d 93 a3 54 ff ff    	lea    -0xab5d(%ebx),%edx
c0022112:	52                   	push   %edx
c0022113:	8d 93 45 4e ff ff    	lea    -0xb1bb(%ebx),%edx
c0022119:	52                   	push   %edx
c002211a:	8d 93 e0 3d ff ff    	lea    -0xc220(%ebx),%edx
c0022120:	52                   	push   %edx
c0022121:	68 e0 00 00 00       	push   $0xe0
c0022126:	8d 93 76 55 ff ff    	lea    -0xaa8a(%ebx),%edx
c002212c:	52                   	push   %edx
c002212d:	e8 55 71 00 00       	call   c0029287 <debug_panic>

c0022132 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0022132:	55                   	push   %ebp
c0022133:	57                   	push   %edi
c0022134:	56                   	push   %esi
c0022135:	53                   	push   %ebx
c0022136:	83 ec 0c             	sub    $0xc,%esp
c0022139:	e8 47 c9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002213e:	81 c3 76 8d 01 00    	add    $0x18d76,%ebx
c0022144:	8b 7c 24 20          	mov    0x20(%esp),%edi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0022148:	8b 47 30             	mov    0x30(%edi),%eax
c002214b:	8d 70 e0             	lea    -0x20(%eax),%esi
  if (external) 
c002214e:	83 fe 0f             	cmp    $0xf,%esi
c0022151:	76 2c                	jbe    c002217f <intr_handler+0x4d>
      in_external_intr = true;
      yield_on_return = false;
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0022153:	8b 57 30             	mov    0x30(%edi),%edx
c0022156:	8b 84 93 0c 10 00 00 	mov    0x100c(%ebx,%edx,4),%eax
  if (handler != NULL)
c002215d:	85 c0                	test   %eax,%eax
c002215f:	0f 84 8e 00 00 00    	je     c00221f3 <intr_handler+0xc1>
    handler (frame);
c0022165:	83 ec 0c             	sub    $0xc,%esp
c0022168:	57                   	push   %edi
c0022169:	ff d0                	call   *%eax
c002216b:	83 c4 10             	add    $0x10,%esp
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
c002216e:	83 fe 0f             	cmp    $0xf,%esi
c0022171:	0f 86 c2 00 00 00    	jbe    c0022239 <intr_handler+0x107>
      pic_end_of_interrupt (frame->vec_no); 

      if (yield_on_return) 
        thread_yield (); 
    }
}
c0022177:	83 c4 0c             	add    $0xc,%esp
c002217a:	5b                   	pop    %ebx
c002217b:	5e                   	pop    %esi
c002217c:	5f                   	pop    %edi
c002217d:	5d                   	pop    %ebp
c002217e:	c3                   	ret    
      ASSERT (intr_get_level () == INTR_OFF);
c002217f:	e8 59 fc ff ff       	call   c0021ddd <intr_get_level>
c0022184:	85 c0                	test   %eax,%eax
c0022186:	75 19                	jne    c00221a1 <intr_handler+0x6f>
      ASSERT (!intr_context ());
c0022188:	80 bb ed 07 00 00 00 	cmpb   $0x0,0x7ed(%ebx)
c002218f:	75 39                	jne    c00221ca <intr_handler+0x98>
      in_external_intr = true;
c0022191:	c6 83 ed 07 00 00 01 	movb   $0x1,0x7ed(%ebx)
      yield_on_return = false;
c0022198:	c6 83 ec 07 00 00 00 	movb   $0x0,0x7ec(%ebx)
c002219f:	eb b2                	jmp    c0022153 <intr_handler+0x21>
      ASSERT (intr_get_level () == INTR_OFF);
c00221a1:	83 ec 0c             	sub    $0xc,%esp
c00221a4:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c00221aa:	50                   	push   %eax
c00221ab:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00221b1:	50                   	push   %eax
c00221b2:	8d 83 d0 3d ff ff    	lea    -0xc230(%ebx),%eax
c00221b8:	50                   	push   %eax
c00221b9:	68 65 01 00 00       	push   $0x165
c00221be:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c00221c4:	50                   	push   %eax
c00221c5:	e8 bd 70 00 00       	call   c0029287 <debug_panic>
      ASSERT (!intr_context ());
c00221ca:	83 ec 0c             	sub    $0xc,%esp
c00221cd:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c00221d3:	50                   	push   %eax
c00221d4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00221da:	50                   	push   %eax
c00221db:	8d 83 d0 3d ff ff    	lea    -0xc230(%ebx),%eax
c00221e1:	50                   	push   %eax
c00221e2:	68 66 01 00 00       	push   $0x166
c00221e7:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c00221ed:	50                   	push   %eax
c00221ee:	e8 94 70 00 00       	call   c0029287 <debug_panic>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c00221f3:	89 d0                	mov    %edx,%eax
c00221f5:	83 e0 f7             	and    $0xfffffff7,%eax
c00221f8:	83 f8 27             	cmp    $0x27,%eax
c00221fb:	0f 84 6d ff ff ff    	je     c002216e <intr_handler+0x3c>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0022201:	8d ab 0c 08 00 00    	lea    0x80c(%ebx),%ebp
c0022207:	8b 4c 95 00          	mov    0x0(%ebp,%edx,4),%ecx
c002220b:	8d 41 01             	lea    0x1(%ecx),%eax
c002220e:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0022212:	85 c1                	test   %eax,%ecx
c0022214:	0f 85 54 ff ff ff    	jne    c002216e <intr_handler+0x3c>
    printf ("Unexpected interrupt %#04x (%s)\n",
c002221a:	83 ec 04             	sub    $0x4,%esp
c002221d:	ff b4 93 0c 0c 00 00 	pushl  0xc0c(%ebx,%edx,4)
c0022224:	52                   	push   %edx
c0022225:	8d 83 64 58 ff ff    	lea    -0xa79c(%ebx),%eax
c002222b:	50                   	push   %eax
c002222c:	e8 bf 52 00 00       	call   c00274f0 <printf>
c0022231:	83 c4 10             	add    $0x10,%esp
c0022234:	e9 35 ff ff ff       	jmp    c002216e <intr_handler+0x3c>
      ASSERT (intr_get_level () == INTR_OFF);
c0022239:	e8 9f fb ff ff       	call   c0021ddd <intr_get_level>
c002223e:	85 c0                	test   %eax,%eax
c0022240:	75 40                	jne    c0022282 <intr_handler+0x150>
      ASSERT (intr_context ());
c0022242:	80 bb ed 07 00 00 00 	cmpb   $0x0,0x7ed(%ebx)
c0022249:	74 60                	je     c00222ab <intr_handler+0x179>
      in_external_intr = false;
c002224b:	c6 83 ed 07 00 00 00 	movb   $0x0,0x7ed(%ebx)
      pic_end_of_interrupt (frame->vec_no); 
c0022252:	8b 57 30             	mov    0x30(%edi),%edx
  ASSERT (irq >= 0x20 && irq < 0x30);
c0022255:	8d 42 e0             	lea    -0x20(%edx),%eax
c0022258:	83 f8 0f             	cmp    $0xf,%eax
c002225b:	77 77                	ja     c00222d4 <intr_handler+0x1a2>
c002225d:	b8 20 00 00 00       	mov    $0x20,%eax
c0022262:	e6 20                	out    %al,$0x20
  if (irq >= 0x28)
c0022264:	83 fa 27             	cmp    $0x27,%edx
c0022267:	7e 02                	jle    c002226b <intr_handler+0x139>
c0022269:	e6 a0                	out    %al,$0xa0
      if (yield_on_return) 
c002226b:	80 bb ec 07 00 00 00 	cmpb   $0x0,0x7ec(%ebx)
c0022272:	0f 84 ff fe ff ff    	je     c0022177 <intr_handler+0x45>
        thread_yield (); 
c0022278:	e8 08 f1 ff ff       	call   c0021385 <thread_yield>
}
c002227d:	e9 f5 fe ff ff       	jmp    c0022177 <intr_handler+0x45>
      ASSERT (intr_get_level () == INTR_OFF);
c0022282:	83 ec 0c             	sub    $0xc,%esp
c0022285:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c002228b:	50                   	push   %eax
c002228c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0022292:	50                   	push   %eax
c0022293:	8d 83 d0 3d ff ff    	lea    -0xc230(%ebx),%eax
c0022299:	50                   	push   %eax
c002229a:	68 7c 01 00 00       	push   $0x17c
c002229f:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c00222a5:	50                   	push   %eax
c00222a6:	e8 dc 6f 00 00       	call   c0029287 <debug_panic>
      ASSERT (intr_context ());
c00222ab:	83 ec 0c             	sub    $0xc,%esp
c00222ae:	8d 83 a3 54 ff ff    	lea    -0xab5d(%ebx),%eax
c00222b4:	50                   	push   %eax
c00222b5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00222bb:	50                   	push   %eax
c00222bc:	8d 83 d0 3d ff ff    	lea    -0xc230(%ebx),%eax
c00222c2:	50                   	push   %eax
c00222c3:	68 7d 01 00 00       	push   $0x17d
c00222c8:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c00222ce:	50                   	push   %eax
c00222cf:	e8 b3 6f 00 00       	call   c0029287 <debug_panic>
  ASSERT (irq >= 0x20 && irq < 0x30);
c00222d4:	83 ec 0c             	sub    $0xc,%esp
c00222d7:	8d 83 39 57 ff ff    	lea    -0xa8c7(%ebx),%eax
c00222dd:	50                   	push   %eax
c00222de:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00222e4:	50                   	push   %eax
c00222e5:	8d 83 b8 3d ff ff    	lea    -0xc248(%ebx),%eax
c00222eb:	50                   	push   %eax
c00222ec:	68 0b 01 00 00       	push   $0x10b
c00222f1:	8d 83 76 55 ff ff    	lea    -0xaa8a(%ebx),%eax
c00222f7:	50                   	push   %eax
c00222f8:	e8 8a 6f 00 00       	call   c0029287 <debug_panic>

c00222fd <intr_dump_frame>:
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c00222fd:	57                   	push   %edi
c00222fe:	56                   	push   %esi
c00222ff:	53                   	push   %ebx
c0022300:	e8 80 c7 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0022305:	81 c3 af 8b 01 00    	add    $0x18baf,%ebx
c002230b:	8b 74 24 10          	mov    0x10(%esp),%esi
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c002230f:	0f 20 d7             	mov    %cr2,%edi

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c0022312:	8b 46 30             	mov    0x30(%esi),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0022315:	ff 76 3c             	pushl  0x3c(%esi)
c0022318:	ff b4 83 0c 0c 00 00 	pushl  0xc0c(%ebx,%eax,4)
c002231f:	50                   	push   %eax
c0022320:	8d 83 88 58 ff ff    	lea    -0xa778(%ebx),%eax
c0022326:	50                   	push   %eax
c0022327:	e8 c4 51 00 00       	call   c00274f0 <printf>
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c002232c:	83 c4 0c             	add    $0xc,%esp
c002232f:	ff 76 34             	pushl  0x34(%esi)
c0022332:	57                   	push   %edi
c0022333:	8d 83 53 57 ff ff    	lea    -0xa8ad(%ebx),%eax
c0022339:	50                   	push   %eax
c002233a:	e8 b1 51 00 00       	call   c00274f0 <printf>
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c002233f:	83 c4 04             	add    $0x4,%esp
c0022342:	ff 76 14             	pushl  0x14(%esi)
c0022345:	ff 76 18             	pushl  0x18(%esi)
c0022348:	ff 76 10             	pushl  0x10(%esi)
c002234b:	ff 76 1c             	pushl  0x1c(%esi)
c002234e:	8d 83 a8 58 ff ff    	lea    -0xa758(%ebx),%eax
c0022354:	50                   	push   %eax
c0022355:	e8 96 51 00 00       	call   c00274f0 <printf>
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002235a:	83 c4 14             	add    $0x14,%esp
c002235d:	ff 76 08             	pushl  0x8(%esi)
c0022360:	ff 76 48             	pushl  0x48(%esi)
c0022363:	ff 36                	pushl  (%esi)
c0022365:	ff 76 04             	pushl  0x4(%esi)
c0022368:	8d 83 d0 58 ff ff    	lea    -0xa730(%ebx),%eax
c002236e:	50                   	push   %eax
c002236f:	e8 7c 51 00 00       	call   c00274f0 <printf>
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022374:	83 c4 14             	add    $0x14,%esp
c0022377:	0f b7 46 4c          	movzwl 0x4c(%esi),%eax
c002237b:	50                   	push   %eax
c002237c:	0f b7 46 28          	movzwl 0x28(%esi),%eax
c0022380:	50                   	push   %eax
c0022381:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
c0022385:	50                   	push   %eax
c0022386:	0f b7 46 40          	movzwl 0x40(%esi),%eax
c002238a:	50                   	push   %eax
c002238b:	8d 83 f8 58 ff ff    	lea    -0xa708(%ebx),%eax
c0022391:	50                   	push   %eax
c0022392:	e8 59 51 00 00       	call   c00274f0 <printf>
          f->cs, f->ds, f->es, f->ss);
}
c0022397:	83 c4 20             	add    $0x20,%esp
c002239a:	5b                   	pop    %ebx
c002239b:	5e                   	pop    %esi
c002239c:	5f                   	pop    %edi
c002239d:	c3                   	ret    

c002239e <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c002239e:	e8 e6 c6 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c00223a3:	05 11 8b 01 00       	add    $0x18b11,%eax
  return intr_names[vec];
c00223a8:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c00223ad:	8b 84 90 0c 0c 00 00 	mov    0xc0c(%eax,%edx,4),%eax
}
c00223b4:	c3                   	ret    

c00223b5 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c00223b5:	1e                   	push   %ds
	pushl %es
c00223b6:	06                   	push   %es
	pushl %fs
c00223b7:	0f a0                	push   %fs
	pushl %gs
c00223b9:	0f a8                	push   %gs
	pushal
c00223bb:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c00223bc:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c00223bd:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00223c2:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00223c4:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00223c6:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00223ca:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c00223cb:	e8 62 fd ff ff       	call   c0022132 <intr_handler>
	addl $4, %esp
c00223d0:	83 c4 04             	add    $0x4,%esp

c00223d3 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c00223d3:	61                   	popa   
	popl %gs
c00223d4:	0f a9                	pop    %gs
	popl %fs
c00223d6:	0f a1                	pop    %fs
	popl %es
c00223d8:	07                   	pop    %es
	popl %ds
c00223d9:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c00223da:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c00223dd:	cf                   	iret   

c00223de <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c00223de:	55                   	push   %ebp
c00223df:	6a 00                	push   $0x0
c00223e1:	6a 00                	push   $0x0
c00223e3:	eb d0                	jmp    c00223b5 <intr_entry>

c00223e5 <intr01_stub>:
c00223e5:	55                   	push   %ebp
c00223e6:	6a 00                	push   $0x0
c00223e8:	6a 01                	push   $0x1
c00223ea:	eb c9                	jmp    c00223b5 <intr_entry>

c00223ec <intr02_stub>:
c00223ec:	55                   	push   %ebp
c00223ed:	6a 00                	push   $0x0
c00223ef:	6a 02                	push   $0x2
c00223f1:	eb c2                	jmp    c00223b5 <intr_entry>

c00223f3 <intr03_stub>:
c00223f3:	55                   	push   %ebp
c00223f4:	6a 00                	push   $0x0
c00223f6:	6a 03                	push   $0x3
c00223f8:	eb bb                	jmp    c00223b5 <intr_entry>

c00223fa <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c00223fa:	55                   	push   %ebp
c00223fb:	6a 00                	push   $0x0
c00223fd:	6a 04                	push   $0x4
c00223ff:	eb b4                	jmp    c00223b5 <intr_entry>

c0022401 <intr05_stub>:
c0022401:	55                   	push   %ebp
c0022402:	6a 00                	push   $0x0
c0022404:	6a 05                	push   $0x5
c0022406:	eb ad                	jmp    c00223b5 <intr_entry>

c0022408 <intr06_stub>:
c0022408:	55                   	push   %ebp
c0022409:	6a 00                	push   $0x0
c002240b:	6a 06                	push   $0x6
c002240d:	eb a6                	jmp    c00223b5 <intr_entry>

c002240f <intr07_stub>:
c002240f:	55                   	push   %ebp
c0022410:	6a 00                	push   $0x0
c0022412:	6a 07                	push   $0x7
c0022414:	eb 9f                	jmp    c00223b5 <intr_entry>

c0022416 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0022416:	ff 34 24             	pushl  (%esp)
c0022419:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002241d:	6a 08                	push   $0x8
c002241f:	eb 94                	jmp    c00223b5 <intr_entry>

c0022421 <intr09_stub>:
c0022421:	55                   	push   %ebp
c0022422:	6a 00                	push   $0x0
c0022424:	6a 09                	push   $0x9
c0022426:	eb 8d                	jmp    c00223b5 <intr_entry>

c0022428 <intr0a_stub>:
c0022428:	ff 34 24             	pushl  (%esp)
c002242b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002242f:	6a 0a                	push   $0xa
c0022431:	eb 82                	jmp    c00223b5 <intr_entry>

c0022433 <intr0b_stub>:
c0022433:	ff 34 24             	pushl  (%esp)
c0022436:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002243a:	6a 0b                	push   $0xb
c002243c:	e9 74 ff ff ff       	jmp    c00223b5 <intr_entry>

c0022441 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0022441:	55                   	push   %ebp
c0022442:	6a 00                	push   $0x0
c0022444:	6a 0c                	push   $0xc
c0022446:	e9 6a ff ff ff       	jmp    c00223b5 <intr_entry>

c002244b <intr0d_stub>:
c002244b:	ff 34 24             	pushl  (%esp)
c002244e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022452:	6a 0d                	push   $0xd
c0022454:	e9 5c ff ff ff       	jmp    c00223b5 <intr_entry>

c0022459 <intr0e_stub>:
c0022459:	ff 34 24             	pushl  (%esp)
c002245c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022460:	6a 0e                	push   $0xe
c0022462:	e9 4e ff ff ff       	jmp    c00223b5 <intr_entry>

c0022467 <intr0f_stub>:
c0022467:	55                   	push   %ebp
c0022468:	6a 00                	push   $0x0
c002246a:	6a 0f                	push   $0xf
c002246c:	e9 44 ff ff ff       	jmp    c00223b5 <intr_entry>

c0022471 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0022471:	55                   	push   %ebp
c0022472:	6a 00                	push   $0x0
c0022474:	6a 10                	push   $0x10
c0022476:	e9 3a ff ff ff       	jmp    c00223b5 <intr_entry>

c002247b <intr11_stub>:
c002247b:	ff 34 24             	pushl  (%esp)
c002247e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022482:	6a 11                	push   $0x11
c0022484:	e9 2c ff ff ff       	jmp    c00223b5 <intr_entry>

c0022489 <intr12_stub>:
c0022489:	55                   	push   %ebp
c002248a:	6a 00                	push   $0x0
c002248c:	6a 12                	push   $0x12
c002248e:	e9 22 ff ff ff       	jmp    c00223b5 <intr_entry>

c0022493 <intr13_stub>:
c0022493:	55                   	push   %ebp
c0022494:	6a 00                	push   $0x0
c0022496:	6a 13                	push   $0x13
c0022498:	e9 18 ff ff ff       	jmp    c00223b5 <intr_entry>

c002249d <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c002249d:	55                   	push   %ebp
c002249e:	6a 00                	push   $0x0
c00224a0:	6a 14                	push   $0x14
c00224a2:	e9 0e ff ff ff       	jmp    c00223b5 <intr_entry>

c00224a7 <intr15_stub>:
c00224a7:	55                   	push   %ebp
c00224a8:	6a 00                	push   $0x0
c00224aa:	6a 15                	push   $0x15
c00224ac:	e9 04 ff ff ff       	jmp    c00223b5 <intr_entry>

c00224b1 <intr16_stub>:
c00224b1:	55                   	push   %ebp
c00224b2:	6a 00                	push   $0x0
c00224b4:	6a 16                	push   $0x16
c00224b6:	e9 fa fe ff ff       	jmp    c00223b5 <intr_entry>

c00224bb <intr17_stub>:
c00224bb:	55                   	push   %ebp
c00224bc:	6a 00                	push   $0x0
c00224be:	6a 17                	push   $0x17
c00224c0:	e9 f0 fe ff ff       	jmp    c00223b5 <intr_entry>

c00224c5 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00224c5:	ff 34 24             	pushl  (%esp)
c00224c8:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00224cc:	6a 18                	push   $0x18
c00224ce:	e9 e2 fe ff ff       	jmp    c00223b5 <intr_entry>

c00224d3 <intr19_stub>:
c00224d3:	55                   	push   %ebp
c00224d4:	6a 00                	push   $0x0
c00224d6:	6a 19                	push   $0x19
c00224d8:	e9 d8 fe ff ff       	jmp    c00223b5 <intr_entry>

c00224dd <intr1a_stub>:
c00224dd:	ff 34 24             	pushl  (%esp)
c00224e0:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00224e4:	6a 1a                	push   $0x1a
c00224e6:	e9 ca fe ff ff       	jmp    c00223b5 <intr_entry>

c00224eb <intr1b_stub>:
c00224eb:	ff 34 24             	pushl  (%esp)
c00224ee:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00224f2:	6a 1b                	push   $0x1b
c00224f4:	e9 bc fe ff ff       	jmp    c00223b5 <intr_entry>

c00224f9 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c00224f9:	55                   	push   %ebp
c00224fa:	6a 00                	push   $0x0
c00224fc:	6a 1c                	push   $0x1c
c00224fe:	e9 b2 fe ff ff       	jmp    c00223b5 <intr_entry>

c0022503 <intr1d_stub>:
c0022503:	ff 34 24             	pushl  (%esp)
c0022506:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002250a:	6a 1d                	push   $0x1d
c002250c:	e9 a4 fe ff ff       	jmp    c00223b5 <intr_entry>

c0022511 <intr1e_stub>:
c0022511:	ff 34 24             	pushl  (%esp)
c0022514:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022518:	6a 1e                	push   $0x1e
c002251a:	e9 96 fe ff ff       	jmp    c00223b5 <intr_entry>

c002251f <intr1f_stub>:
c002251f:	55                   	push   %ebp
c0022520:	6a 00                	push   $0x0
c0022522:	6a 1f                	push   $0x1f
c0022524:	e9 8c fe ff ff       	jmp    c00223b5 <intr_entry>

c0022529 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0022529:	55                   	push   %ebp
c002252a:	6a 00                	push   $0x0
c002252c:	6a 20                	push   $0x20
c002252e:	e9 82 fe ff ff       	jmp    c00223b5 <intr_entry>

c0022533 <intr21_stub>:
c0022533:	55                   	push   %ebp
c0022534:	6a 00                	push   $0x0
c0022536:	6a 21                	push   $0x21
c0022538:	e9 78 fe ff ff       	jmp    c00223b5 <intr_entry>

c002253d <intr22_stub>:
c002253d:	55                   	push   %ebp
c002253e:	6a 00                	push   $0x0
c0022540:	6a 22                	push   $0x22
c0022542:	e9 6e fe ff ff       	jmp    c00223b5 <intr_entry>

c0022547 <intr23_stub>:
c0022547:	55                   	push   %ebp
c0022548:	6a 00                	push   $0x0
c002254a:	6a 23                	push   $0x23
c002254c:	e9 64 fe ff ff       	jmp    c00223b5 <intr_entry>

c0022551 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0022551:	55                   	push   %ebp
c0022552:	6a 00                	push   $0x0
c0022554:	6a 24                	push   $0x24
c0022556:	e9 5a fe ff ff       	jmp    c00223b5 <intr_entry>

c002255b <intr25_stub>:
c002255b:	55                   	push   %ebp
c002255c:	6a 00                	push   $0x0
c002255e:	6a 25                	push   $0x25
c0022560:	e9 50 fe ff ff       	jmp    c00223b5 <intr_entry>

c0022565 <intr26_stub>:
c0022565:	55                   	push   %ebp
c0022566:	6a 00                	push   $0x0
c0022568:	6a 26                	push   $0x26
c002256a:	e9 46 fe ff ff       	jmp    c00223b5 <intr_entry>

c002256f <intr27_stub>:
c002256f:	55                   	push   %ebp
c0022570:	6a 00                	push   $0x0
c0022572:	6a 27                	push   $0x27
c0022574:	e9 3c fe ff ff       	jmp    c00223b5 <intr_entry>

c0022579 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0022579:	55                   	push   %ebp
c002257a:	6a 00                	push   $0x0
c002257c:	6a 28                	push   $0x28
c002257e:	e9 32 fe ff ff       	jmp    c00223b5 <intr_entry>

c0022583 <intr29_stub>:
c0022583:	55                   	push   %ebp
c0022584:	6a 00                	push   $0x0
c0022586:	6a 29                	push   $0x29
c0022588:	e9 28 fe ff ff       	jmp    c00223b5 <intr_entry>

c002258d <intr2a_stub>:
c002258d:	55                   	push   %ebp
c002258e:	6a 00                	push   $0x0
c0022590:	6a 2a                	push   $0x2a
c0022592:	e9 1e fe ff ff       	jmp    c00223b5 <intr_entry>

c0022597 <intr2b_stub>:
c0022597:	55                   	push   %ebp
c0022598:	6a 00                	push   $0x0
c002259a:	6a 2b                	push   $0x2b
c002259c:	e9 14 fe ff ff       	jmp    c00223b5 <intr_entry>

c00225a1 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c00225a1:	55                   	push   %ebp
c00225a2:	6a 00                	push   $0x0
c00225a4:	6a 2c                	push   $0x2c
c00225a6:	e9 0a fe ff ff       	jmp    c00223b5 <intr_entry>

c00225ab <intr2d_stub>:
c00225ab:	55                   	push   %ebp
c00225ac:	6a 00                	push   $0x0
c00225ae:	6a 2d                	push   $0x2d
c00225b0:	e9 00 fe ff ff       	jmp    c00223b5 <intr_entry>

c00225b5 <intr2e_stub>:
c00225b5:	55                   	push   %ebp
c00225b6:	6a 00                	push   $0x0
c00225b8:	6a 2e                	push   $0x2e
c00225ba:	e9 f6 fd ff ff       	jmp    c00223b5 <intr_entry>

c00225bf <intr2f_stub>:
c00225bf:	55                   	push   %ebp
c00225c0:	6a 00                	push   $0x0
c00225c2:	6a 2f                	push   $0x2f
c00225c4:	e9 ec fd ff ff       	jmp    c00223b5 <intr_entry>

c00225c9 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00225c9:	55                   	push   %ebp
c00225ca:	6a 00                	push   $0x0
c00225cc:	6a 30                	push   $0x30
c00225ce:	e9 e2 fd ff ff       	jmp    c00223b5 <intr_entry>

c00225d3 <intr31_stub>:
c00225d3:	55                   	push   %ebp
c00225d4:	6a 00                	push   $0x0
c00225d6:	6a 31                	push   $0x31
c00225d8:	e9 d8 fd ff ff       	jmp    c00223b5 <intr_entry>

c00225dd <intr32_stub>:
c00225dd:	55                   	push   %ebp
c00225de:	6a 00                	push   $0x0
c00225e0:	6a 32                	push   $0x32
c00225e2:	e9 ce fd ff ff       	jmp    c00223b5 <intr_entry>

c00225e7 <intr33_stub>:
c00225e7:	55                   	push   %ebp
c00225e8:	6a 00                	push   $0x0
c00225ea:	6a 33                	push   $0x33
c00225ec:	e9 c4 fd ff ff       	jmp    c00223b5 <intr_entry>

c00225f1 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c00225f1:	55                   	push   %ebp
c00225f2:	6a 00                	push   $0x0
c00225f4:	6a 34                	push   $0x34
c00225f6:	e9 ba fd ff ff       	jmp    c00223b5 <intr_entry>

c00225fb <intr35_stub>:
c00225fb:	55                   	push   %ebp
c00225fc:	6a 00                	push   $0x0
c00225fe:	6a 35                	push   $0x35
c0022600:	e9 b0 fd ff ff       	jmp    c00223b5 <intr_entry>

c0022605 <intr36_stub>:
c0022605:	55                   	push   %ebp
c0022606:	6a 00                	push   $0x0
c0022608:	6a 36                	push   $0x36
c002260a:	e9 a6 fd ff ff       	jmp    c00223b5 <intr_entry>

c002260f <intr37_stub>:
c002260f:	55                   	push   %ebp
c0022610:	6a 00                	push   $0x0
c0022612:	6a 37                	push   $0x37
c0022614:	e9 9c fd ff ff       	jmp    c00223b5 <intr_entry>

c0022619 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0022619:	55                   	push   %ebp
c002261a:	6a 00                	push   $0x0
c002261c:	6a 38                	push   $0x38
c002261e:	e9 92 fd ff ff       	jmp    c00223b5 <intr_entry>

c0022623 <intr39_stub>:
c0022623:	55                   	push   %ebp
c0022624:	6a 00                	push   $0x0
c0022626:	6a 39                	push   $0x39
c0022628:	e9 88 fd ff ff       	jmp    c00223b5 <intr_entry>

c002262d <intr3a_stub>:
c002262d:	55                   	push   %ebp
c002262e:	6a 00                	push   $0x0
c0022630:	6a 3a                	push   $0x3a
c0022632:	e9 7e fd ff ff       	jmp    c00223b5 <intr_entry>

c0022637 <intr3b_stub>:
c0022637:	55                   	push   %ebp
c0022638:	6a 00                	push   $0x0
c002263a:	6a 3b                	push   $0x3b
c002263c:	e9 74 fd ff ff       	jmp    c00223b5 <intr_entry>

c0022641 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0022641:	55                   	push   %ebp
c0022642:	6a 00                	push   $0x0
c0022644:	6a 3c                	push   $0x3c
c0022646:	e9 6a fd ff ff       	jmp    c00223b5 <intr_entry>

c002264b <intr3d_stub>:
c002264b:	55                   	push   %ebp
c002264c:	6a 00                	push   $0x0
c002264e:	6a 3d                	push   $0x3d
c0022650:	e9 60 fd ff ff       	jmp    c00223b5 <intr_entry>

c0022655 <intr3e_stub>:
c0022655:	55                   	push   %ebp
c0022656:	6a 00                	push   $0x0
c0022658:	6a 3e                	push   $0x3e
c002265a:	e9 56 fd ff ff       	jmp    c00223b5 <intr_entry>

c002265f <intr3f_stub>:
c002265f:	55                   	push   %ebp
c0022660:	6a 00                	push   $0x0
c0022662:	6a 3f                	push   $0x3f
c0022664:	e9 4c fd ff ff       	jmp    c00223b5 <intr_entry>

c0022669 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0022669:	55                   	push   %ebp
c002266a:	6a 00                	push   $0x0
c002266c:	6a 40                	push   $0x40
c002266e:	e9 42 fd ff ff       	jmp    c00223b5 <intr_entry>

c0022673 <intr41_stub>:
c0022673:	55                   	push   %ebp
c0022674:	6a 00                	push   $0x0
c0022676:	6a 41                	push   $0x41
c0022678:	e9 38 fd ff ff       	jmp    c00223b5 <intr_entry>

c002267d <intr42_stub>:
c002267d:	55                   	push   %ebp
c002267e:	6a 00                	push   $0x0
c0022680:	6a 42                	push   $0x42
c0022682:	e9 2e fd ff ff       	jmp    c00223b5 <intr_entry>

c0022687 <intr43_stub>:
c0022687:	55                   	push   %ebp
c0022688:	6a 00                	push   $0x0
c002268a:	6a 43                	push   $0x43
c002268c:	e9 24 fd ff ff       	jmp    c00223b5 <intr_entry>

c0022691 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0022691:	55                   	push   %ebp
c0022692:	6a 00                	push   $0x0
c0022694:	6a 44                	push   $0x44
c0022696:	e9 1a fd ff ff       	jmp    c00223b5 <intr_entry>

c002269b <intr45_stub>:
c002269b:	55                   	push   %ebp
c002269c:	6a 00                	push   $0x0
c002269e:	6a 45                	push   $0x45
c00226a0:	e9 10 fd ff ff       	jmp    c00223b5 <intr_entry>

c00226a5 <intr46_stub>:
c00226a5:	55                   	push   %ebp
c00226a6:	6a 00                	push   $0x0
c00226a8:	6a 46                	push   $0x46
c00226aa:	e9 06 fd ff ff       	jmp    c00223b5 <intr_entry>

c00226af <intr47_stub>:
c00226af:	55                   	push   %ebp
c00226b0:	6a 00                	push   $0x0
c00226b2:	6a 47                	push   $0x47
c00226b4:	e9 fc fc ff ff       	jmp    c00223b5 <intr_entry>

c00226b9 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00226b9:	55                   	push   %ebp
c00226ba:	6a 00                	push   $0x0
c00226bc:	6a 48                	push   $0x48
c00226be:	e9 f2 fc ff ff       	jmp    c00223b5 <intr_entry>

c00226c3 <intr49_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	6a 49                	push   $0x49
c00226c8:	e9 e8 fc ff ff       	jmp    c00223b5 <intr_entry>

c00226cd <intr4a_stub>:
c00226cd:	55                   	push   %ebp
c00226ce:	6a 00                	push   $0x0
c00226d0:	6a 4a                	push   $0x4a
c00226d2:	e9 de fc ff ff       	jmp    c00223b5 <intr_entry>

c00226d7 <intr4b_stub>:
c00226d7:	55                   	push   %ebp
c00226d8:	6a 00                	push   $0x0
c00226da:	6a 4b                	push   $0x4b
c00226dc:	e9 d4 fc ff ff       	jmp    c00223b5 <intr_entry>

c00226e1 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c00226e1:	55                   	push   %ebp
c00226e2:	6a 00                	push   $0x0
c00226e4:	6a 4c                	push   $0x4c
c00226e6:	e9 ca fc ff ff       	jmp    c00223b5 <intr_entry>

c00226eb <intr4d_stub>:
c00226eb:	55                   	push   %ebp
c00226ec:	6a 00                	push   $0x0
c00226ee:	6a 4d                	push   $0x4d
c00226f0:	e9 c0 fc ff ff       	jmp    c00223b5 <intr_entry>

c00226f5 <intr4e_stub>:
c00226f5:	55                   	push   %ebp
c00226f6:	6a 00                	push   $0x0
c00226f8:	6a 4e                	push   $0x4e
c00226fa:	e9 b6 fc ff ff       	jmp    c00223b5 <intr_entry>

c00226ff <intr4f_stub>:
c00226ff:	55                   	push   %ebp
c0022700:	6a 00                	push   $0x0
c0022702:	6a 4f                	push   $0x4f
c0022704:	e9 ac fc ff ff       	jmp    c00223b5 <intr_entry>

c0022709 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022709:	55                   	push   %ebp
c002270a:	6a 00                	push   $0x0
c002270c:	6a 50                	push   $0x50
c002270e:	e9 a2 fc ff ff       	jmp    c00223b5 <intr_entry>

c0022713 <intr51_stub>:
c0022713:	55                   	push   %ebp
c0022714:	6a 00                	push   $0x0
c0022716:	6a 51                	push   $0x51
c0022718:	e9 98 fc ff ff       	jmp    c00223b5 <intr_entry>

c002271d <intr52_stub>:
c002271d:	55                   	push   %ebp
c002271e:	6a 00                	push   $0x0
c0022720:	6a 52                	push   $0x52
c0022722:	e9 8e fc ff ff       	jmp    c00223b5 <intr_entry>

c0022727 <intr53_stub>:
c0022727:	55                   	push   %ebp
c0022728:	6a 00                	push   $0x0
c002272a:	6a 53                	push   $0x53
c002272c:	e9 84 fc ff ff       	jmp    c00223b5 <intr_entry>

c0022731 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0022731:	55                   	push   %ebp
c0022732:	6a 00                	push   $0x0
c0022734:	6a 54                	push   $0x54
c0022736:	e9 7a fc ff ff       	jmp    c00223b5 <intr_entry>

c002273b <intr55_stub>:
c002273b:	55                   	push   %ebp
c002273c:	6a 00                	push   $0x0
c002273e:	6a 55                	push   $0x55
c0022740:	e9 70 fc ff ff       	jmp    c00223b5 <intr_entry>

c0022745 <intr56_stub>:
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	6a 56                	push   $0x56
c002274a:	e9 66 fc ff ff       	jmp    c00223b5 <intr_entry>

c002274f <intr57_stub>:
c002274f:	55                   	push   %ebp
c0022750:	6a 00                	push   $0x0
c0022752:	6a 57                	push   $0x57
c0022754:	e9 5c fc ff ff       	jmp    c00223b5 <intr_entry>

c0022759 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0022759:	55                   	push   %ebp
c002275a:	6a 00                	push   $0x0
c002275c:	6a 58                	push   $0x58
c002275e:	e9 52 fc ff ff       	jmp    c00223b5 <intr_entry>

c0022763 <intr59_stub>:
c0022763:	55                   	push   %ebp
c0022764:	6a 00                	push   $0x0
c0022766:	6a 59                	push   $0x59
c0022768:	e9 48 fc ff ff       	jmp    c00223b5 <intr_entry>

c002276d <intr5a_stub>:
c002276d:	55                   	push   %ebp
c002276e:	6a 00                	push   $0x0
c0022770:	6a 5a                	push   $0x5a
c0022772:	e9 3e fc ff ff       	jmp    c00223b5 <intr_entry>

c0022777 <intr5b_stub>:
c0022777:	55                   	push   %ebp
c0022778:	6a 00                	push   $0x0
c002277a:	6a 5b                	push   $0x5b
c002277c:	e9 34 fc ff ff       	jmp    c00223b5 <intr_entry>

c0022781 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0022781:	55                   	push   %ebp
c0022782:	6a 00                	push   $0x0
c0022784:	6a 5c                	push   $0x5c
c0022786:	e9 2a fc ff ff       	jmp    c00223b5 <intr_entry>

c002278b <intr5d_stub>:
c002278b:	55                   	push   %ebp
c002278c:	6a 00                	push   $0x0
c002278e:	6a 5d                	push   $0x5d
c0022790:	e9 20 fc ff ff       	jmp    c00223b5 <intr_entry>

c0022795 <intr5e_stub>:
c0022795:	55                   	push   %ebp
c0022796:	6a 00                	push   $0x0
c0022798:	6a 5e                	push   $0x5e
c002279a:	e9 16 fc ff ff       	jmp    c00223b5 <intr_entry>

c002279f <intr5f_stub>:
c002279f:	55                   	push   %ebp
c00227a0:	6a 00                	push   $0x0
c00227a2:	6a 5f                	push   $0x5f
c00227a4:	e9 0c fc ff ff       	jmp    c00223b5 <intr_entry>

c00227a9 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c00227a9:	55                   	push   %ebp
c00227aa:	6a 00                	push   $0x0
c00227ac:	6a 60                	push   $0x60
c00227ae:	e9 02 fc ff ff       	jmp    c00223b5 <intr_entry>

c00227b3 <intr61_stub>:
c00227b3:	55                   	push   %ebp
c00227b4:	6a 00                	push   $0x0
c00227b6:	6a 61                	push   $0x61
c00227b8:	e9 f8 fb ff ff       	jmp    c00223b5 <intr_entry>

c00227bd <intr62_stub>:
c00227bd:	55                   	push   %ebp
c00227be:	6a 00                	push   $0x0
c00227c0:	6a 62                	push   $0x62
c00227c2:	e9 ee fb ff ff       	jmp    c00223b5 <intr_entry>

c00227c7 <intr63_stub>:
c00227c7:	55                   	push   %ebp
c00227c8:	6a 00                	push   $0x0
c00227ca:	6a 63                	push   $0x63
c00227cc:	e9 e4 fb ff ff       	jmp    c00223b5 <intr_entry>

c00227d1 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00227d1:	55                   	push   %ebp
c00227d2:	6a 00                	push   $0x0
c00227d4:	6a 64                	push   $0x64
c00227d6:	e9 da fb ff ff       	jmp    c00223b5 <intr_entry>

c00227db <intr65_stub>:
c00227db:	55                   	push   %ebp
c00227dc:	6a 00                	push   $0x0
c00227de:	6a 65                	push   $0x65
c00227e0:	e9 d0 fb ff ff       	jmp    c00223b5 <intr_entry>

c00227e5 <intr66_stub>:
c00227e5:	55                   	push   %ebp
c00227e6:	6a 00                	push   $0x0
c00227e8:	6a 66                	push   $0x66
c00227ea:	e9 c6 fb ff ff       	jmp    c00223b5 <intr_entry>

c00227ef <intr67_stub>:
c00227ef:	55                   	push   %ebp
c00227f0:	6a 00                	push   $0x0
c00227f2:	6a 67                	push   $0x67
c00227f4:	e9 bc fb ff ff       	jmp    c00223b5 <intr_entry>

c00227f9 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c00227f9:	55                   	push   %ebp
c00227fa:	6a 00                	push   $0x0
c00227fc:	6a 68                	push   $0x68
c00227fe:	e9 b2 fb ff ff       	jmp    c00223b5 <intr_entry>

c0022803 <intr69_stub>:
c0022803:	55                   	push   %ebp
c0022804:	6a 00                	push   $0x0
c0022806:	6a 69                	push   $0x69
c0022808:	e9 a8 fb ff ff       	jmp    c00223b5 <intr_entry>

c002280d <intr6a_stub>:
c002280d:	55                   	push   %ebp
c002280e:	6a 00                	push   $0x0
c0022810:	6a 6a                	push   $0x6a
c0022812:	e9 9e fb ff ff       	jmp    c00223b5 <intr_entry>

c0022817 <intr6b_stub>:
c0022817:	55                   	push   %ebp
c0022818:	6a 00                	push   $0x0
c002281a:	6a 6b                	push   $0x6b
c002281c:	e9 94 fb ff ff       	jmp    c00223b5 <intr_entry>

c0022821 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022821:	55                   	push   %ebp
c0022822:	6a 00                	push   $0x0
c0022824:	6a 6c                	push   $0x6c
c0022826:	e9 8a fb ff ff       	jmp    c00223b5 <intr_entry>

c002282b <intr6d_stub>:
c002282b:	55                   	push   %ebp
c002282c:	6a 00                	push   $0x0
c002282e:	6a 6d                	push   $0x6d
c0022830:	e9 80 fb ff ff       	jmp    c00223b5 <intr_entry>

c0022835 <intr6e_stub>:
c0022835:	55                   	push   %ebp
c0022836:	6a 00                	push   $0x0
c0022838:	6a 6e                	push   $0x6e
c002283a:	e9 76 fb ff ff       	jmp    c00223b5 <intr_entry>

c002283f <intr6f_stub>:
c002283f:	55                   	push   %ebp
c0022840:	6a 00                	push   $0x0
c0022842:	6a 6f                	push   $0x6f
c0022844:	e9 6c fb ff ff       	jmp    c00223b5 <intr_entry>

c0022849 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c0022849:	55                   	push   %ebp
c002284a:	6a 00                	push   $0x0
c002284c:	6a 70                	push   $0x70
c002284e:	e9 62 fb ff ff       	jmp    c00223b5 <intr_entry>

c0022853 <intr71_stub>:
c0022853:	55                   	push   %ebp
c0022854:	6a 00                	push   $0x0
c0022856:	6a 71                	push   $0x71
c0022858:	e9 58 fb ff ff       	jmp    c00223b5 <intr_entry>

c002285d <intr72_stub>:
c002285d:	55                   	push   %ebp
c002285e:	6a 00                	push   $0x0
c0022860:	6a 72                	push   $0x72
c0022862:	e9 4e fb ff ff       	jmp    c00223b5 <intr_entry>

c0022867 <intr73_stub>:
c0022867:	55                   	push   %ebp
c0022868:	6a 00                	push   $0x0
c002286a:	6a 73                	push   $0x73
c002286c:	e9 44 fb ff ff       	jmp    c00223b5 <intr_entry>

c0022871 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022871:	55                   	push   %ebp
c0022872:	6a 00                	push   $0x0
c0022874:	6a 74                	push   $0x74
c0022876:	e9 3a fb ff ff       	jmp    c00223b5 <intr_entry>

c002287b <intr75_stub>:
c002287b:	55                   	push   %ebp
c002287c:	6a 00                	push   $0x0
c002287e:	6a 75                	push   $0x75
c0022880:	e9 30 fb ff ff       	jmp    c00223b5 <intr_entry>

c0022885 <intr76_stub>:
c0022885:	55                   	push   %ebp
c0022886:	6a 00                	push   $0x0
c0022888:	6a 76                	push   $0x76
c002288a:	e9 26 fb ff ff       	jmp    c00223b5 <intr_entry>

c002288f <intr77_stub>:
c002288f:	55                   	push   %ebp
c0022890:	6a 00                	push   $0x0
c0022892:	6a 77                	push   $0x77
c0022894:	e9 1c fb ff ff       	jmp    c00223b5 <intr_entry>

c0022899 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c0022899:	55                   	push   %ebp
c002289a:	6a 00                	push   $0x0
c002289c:	6a 78                	push   $0x78
c002289e:	e9 12 fb ff ff       	jmp    c00223b5 <intr_entry>

c00228a3 <intr79_stub>:
c00228a3:	55                   	push   %ebp
c00228a4:	6a 00                	push   $0x0
c00228a6:	6a 79                	push   $0x79
c00228a8:	e9 08 fb ff ff       	jmp    c00223b5 <intr_entry>

c00228ad <intr7a_stub>:
c00228ad:	55                   	push   %ebp
c00228ae:	6a 00                	push   $0x0
c00228b0:	6a 7a                	push   $0x7a
c00228b2:	e9 fe fa ff ff       	jmp    c00223b5 <intr_entry>

c00228b7 <intr7b_stub>:
c00228b7:	55                   	push   %ebp
c00228b8:	6a 00                	push   $0x0
c00228ba:	6a 7b                	push   $0x7b
c00228bc:	e9 f4 fa ff ff       	jmp    c00223b5 <intr_entry>

c00228c1 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00228c1:	55                   	push   %ebp
c00228c2:	6a 00                	push   $0x0
c00228c4:	6a 7c                	push   $0x7c
c00228c6:	e9 ea fa ff ff       	jmp    c00223b5 <intr_entry>

c00228cb <intr7d_stub>:
c00228cb:	55                   	push   %ebp
c00228cc:	6a 00                	push   $0x0
c00228ce:	6a 7d                	push   $0x7d
c00228d0:	e9 e0 fa ff ff       	jmp    c00223b5 <intr_entry>

c00228d5 <intr7e_stub>:
c00228d5:	55                   	push   %ebp
c00228d6:	6a 00                	push   $0x0
c00228d8:	6a 7e                	push   $0x7e
c00228da:	e9 d6 fa ff ff       	jmp    c00223b5 <intr_entry>

c00228df <intr7f_stub>:
c00228df:	55                   	push   %ebp
c00228e0:	6a 00                	push   $0x0
c00228e2:	6a 7f                	push   $0x7f
c00228e4:	e9 cc fa ff ff       	jmp    c00223b5 <intr_entry>

c00228e9 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c00228e9:	55                   	push   %ebp
c00228ea:	6a 00                	push   $0x0
c00228ec:	68 80 00 00 00       	push   $0x80
c00228f1:	e9 bf fa ff ff       	jmp    c00223b5 <intr_entry>

c00228f6 <intr81_stub>:
c00228f6:	55                   	push   %ebp
c00228f7:	6a 00                	push   $0x0
c00228f9:	68 81 00 00 00       	push   $0x81
c00228fe:	e9 b2 fa ff ff       	jmp    c00223b5 <intr_entry>

c0022903 <intr82_stub>:
c0022903:	55                   	push   %ebp
c0022904:	6a 00                	push   $0x0
c0022906:	68 82 00 00 00       	push   $0x82
c002290b:	e9 a5 fa ff ff       	jmp    c00223b5 <intr_entry>

c0022910 <intr83_stub>:
c0022910:	55                   	push   %ebp
c0022911:	6a 00                	push   $0x0
c0022913:	68 83 00 00 00       	push   $0x83
c0022918:	e9 98 fa ff ff       	jmp    c00223b5 <intr_entry>

c002291d <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c002291d:	55                   	push   %ebp
c002291e:	6a 00                	push   $0x0
c0022920:	68 84 00 00 00       	push   $0x84
c0022925:	e9 8b fa ff ff       	jmp    c00223b5 <intr_entry>

c002292a <intr85_stub>:
c002292a:	55                   	push   %ebp
c002292b:	6a 00                	push   $0x0
c002292d:	68 85 00 00 00       	push   $0x85
c0022932:	e9 7e fa ff ff       	jmp    c00223b5 <intr_entry>

c0022937 <intr86_stub>:
c0022937:	55                   	push   %ebp
c0022938:	6a 00                	push   $0x0
c002293a:	68 86 00 00 00       	push   $0x86
c002293f:	e9 71 fa ff ff       	jmp    c00223b5 <intr_entry>

c0022944 <intr87_stub>:
c0022944:	55                   	push   %ebp
c0022945:	6a 00                	push   $0x0
c0022947:	68 87 00 00 00       	push   $0x87
c002294c:	e9 64 fa ff ff       	jmp    c00223b5 <intr_entry>

c0022951 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022951:	55                   	push   %ebp
c0022952:	6a 00                	push   $0x0
c0022954:	68 88 00 00 00       	push   $0x88
c0022959:	e9 57 fa ff ff       	jmp    c00223b5 <intr_entry>

c002295e <intr89_stub>:
c002295e:	55                   	push   %ebp
c002295f:	6a 00                	push   $0x0
c0022961:	68 89 00 00 00       	push   $0x89
c0022966:	e9 4a fa ff ff       	jmp    c00223b5 <intr_entry>

c002296b <intr8a_stub>:
c002296b:	55                   	push   %ebp
c002296c:	6a 00                	push   $0x0
c002296e:	68 8a 00 00 00       	push   $0x8a
c0022973:	e9 3d fa ff ff       	jmp    c00223b5 <intr_entry>

c0022978 <intr8b_stub>:
c0022978:	55                   	push   %ebp
c0022979:	6a 00                	push   $0x0
c002297b:	68 8b 00 00 00       	push   $0x8b
c0022980:	e9 30 fa ff ff       	jmp    c00223b5 <intr_entry>

c0022985 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c0022985:	55                   	push   %ebp
c0022986:	6a 00                	push   $0x0
c0022988:	68 8c 00 00 00       	push   $0x8c
c002298d:	e9 23 fa ff ff       	jmp    c00223b5 <intr_entry>

c0022992 <intr8d_stub>:
c0022992:	55                   	push   %ebp
c0022993:	6a 00                	push   $0x0
c0022995:	68 8d 00 00 00       	push   $0x8d
c002299a:	e9 16 fa ff ff       	jmp    c00223b5 <intr_entry>

c002299f <intr8e_stub>:
c002299f:	55                   	push   %ebp
c00229a0:	6a 00                	push   $0x0
c00229a2:	68 8e 00 00 00       	push   $0x8e
c00229a7:	e9 09 fa ff ff       	jmp    c00223b5 <intr_entry>

c00229ac <intr8f_stub>:
c00229ac:	55                   	push   %ebp
c00229ad:	6a 00                	push   $0x0
c00229af:	68 8f 00 00 00       	push   $0x8f
c00229b4:	e9 fc f9 ff ff       	jmp    c00223b5 <intr_entry>

c00229b9 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00229b9:	55                   	push   %ebp
c00229ba:	6a 00                	push   $0x0
c00229bc:	68 90 00 00 00       	push   $0x90
c00229c1:	e9 ef f9 ff ff       	jmp    c00223b5 <intr_entry>

c00229c6 <intr91_stub>:
c00229c6:	55                   	push   %ebp
c00229c7:	6a 00                	push   $0x0
c00229c9:	68 91 00 00 00       	push   $0x91
c00229ce:	e9 e2 f9 ff ff       	jmp    c00223b5 <intr_entry>

c00229d3 <intr92_stub>:
c00229d3:	55                   	push   %ebp
c00229d4:	6a 00                	push   $0x0
c00229d6:	68 92 00 00 00       	push   $0x92
c00229db:	e9 d5 f9 ff ff       	jmp    c00223b5 <intr_entry>

c00229e0 <intr93_stub>:
c00229e0:	55                   	push   %ebp
c00229e1:	6a 00                	push   $0x0
c00229e3:	68 93 00 00 00       	push   $0x93
c00229e8:	e9 c8 f9 ff ff       	jmp    c00223b5 <intr_entry>

c00229ed <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c00229ed:	55                   	push   %ebp
c00229ee:	6a 00                	push   $0x0
c00229f0:	68 94 00 00 00       	push   $0x94
c00229f5:	e9 bb f9 ff ff       	jmp    c00223b5 <intr_entry>

c00229fa <intr95_stub>:
c00229fa:	55                   	push   %ebp
c00229fb:	6a 00                	push   $0x0
c00229fd:	68 95 00 00 00       	push   $0x95
c0022a02:	e9 ae f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a07 <intr96_stub>:
c0022a07:	55                   	push   %ebp
c0022a08:	6a 00                	push   $0x0
c0022a0a:	68 96 00 00 00       	push   $0x96
c0022a0f:	e9 a1 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a14 <intr97_stub>:
c0022a14:	55                   	push   %ebp
c0022a15:	6a 00                	push   $0x0
c0022a17:	68 97 00 00 00       	push   $0x97
c0022a1c:	e9 94 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a21 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022a21:	55                   	push   %ebp
c0022a22:	6a 00                	push   $0x0
c0022a24:	68 98 00 00 00       	push   $0x98
c0022a29:	e9 87 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a2e <intr99_stub>:
c0022a2e:	55                   	push   %ebp
c0022a2f:	6a 00                	push   $0x0
c0022a31:	68 99 00 00 00       	push   $0x99
c0022a36:	e9 7a f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a3b <intr9a_stub>:
c0022a3b:	55                   	push   %ebp
c0022a3c:	6a 00                	push   $0x0
c0022a3e:	68 9a 00 00 00       	push   $0x9a
c0022a43:	e9 6d f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a48 <intr9b_stub>:
c0022a48:	55                   	push   %ebp
c0022a49:	6a 00                	push   $0x0
c0022a4b:	68 9b 00 00 00       	push   $0x9b
c0022a50:	e9 60 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a55 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022a55:	55                   	push   %ebp
c0022a56:	6a 00                	push   $0x0
c0022a58:	68 9c 00 00 00       	push   $0x9c
c0022a5d:	e9 53 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a62 <intr9d_stub>:
c0022a62:	55                   	push   %ebp
c0022a63:	6a 00                	push   $0x0
c0022a65:	68 9d 00 00 00       	push   $0x9d
c0022a6a:	e9 46 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a6f <intr9e_stub>:
c0022a6f:	55                   	push   %ebp
c0022a70:	6a 00                	push   $0x0
c0022a72:	68 9e 00 00 00       	push   $0x9e
c0022a77:	e9 39 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a7c <intr9f_stub>:
c0022a7c:	55                   	push   %ebp
c0022a7d:	6a 00                	push   $0x0
c0022a7f:	68 9f 00 00 00       	push   $0x9f
c0022a84:	e9 2c f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a89 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c0022a89:	55                   	push   %ebp
c0022a8a:	6a 00                	push   $0x0
c0022a8c:	68 a0 00 00 00       	push   $0xa0
c0022a91:	e9 1f f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022a96 <intra1_stub>:
c0022a96:	55                   	push   %ebp
c0022a97:	6a 00                	push   $0x0
c0022a99:	68 a1 00 00 00       	push   $0xa1
c0022a9e:	e9 12 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022aa3 <intra2_stub>:
c0022aa3:	55                   	push   %ebp
c0022aa4:	6a 00                	push   $0x0
c0022aa6:	68 a2 00 00 00       	push   $0xa2
c0022aab:	e9 05 f9 ff ff       	jmp    c00223b5 <intr_entry>

c0022ab0 <intra3_stub>:
c0022ab0:	55                   	push   %ebp
c0022ab1:	6a 00                	push   $0x0
c0022ab3:	68 a3 00 00 00       	push   $0xa3
c0022ab8:	e9 f8 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022abd <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022abd:	55                   	push   %ebp
c0022abe:	6a 00                	push   $0x0
c0022ac0:	68 a4 00 00 00       	push   $0xa4
c0022ac5:	e9 eb f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022aca <intra5_stub>:
c0022aca:	55                   	push   %ebp
c0022acb:	6a 00                	push   $0x0
c0022acd:	68 a5 00 00 00       	push   $0xa5
c0022ad2:	e9 de f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022ad7 <intra6_stub>:
c0022ad7:	55                   	push   %ebp
c0022ad8:	6a 00                	push   $0x0
c0022ada:	68 a6 00 00 00       	push   $0xa6
c0022adf:	e9 d1 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022ae4 <intra7_stub>:
c0022ae4:	55                   	push   %ebp
c0022ae5:	6a 00                	push   $0x0
c0022ae7:	68 a7 00 00 00       	push   $0xa7
c0022aec:	e9 c4 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022af1 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022af1:	55                   	push   %ebp
c0022af2:	6a 00                	push   $0x0
c0022af4:	68 a8 00 00 00       	push   $0xa8
c0022af9:	e9 b7 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022afe <intra9_stub>:
c0022afe:	55                   	push   %ebp
c0022aff:	6a 00                	push   $0x0
c0022b01:	68 a9 00 00 00       	push   $0xa9
c0022b06:	e9 aa f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b0b <intraa_stub>:
c0022b0b:	55                   	push   %ebp
c0022b0c:	6a 00                	push   $0x0
c0022b0e:	68 aa 00 00 00       	push   $0xaa
c0022b13:	e9 9d f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b18 <intrab_stub>:
c0022b18:	55                   	push   %ebp
c0022b19:	6a 00                	push   $0x0
c0022b1b:	68 ab 00 00 00       	push   $0xab
c0022b20:	e9 90 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b25 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022b25:	55                   	push   %ebp
c0022b26:	6a 00                	push   $0x0
c0022b28:	68 ac 00 00 00       	push   $0xac
c0022b2d:	e9 83 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b32 <intrad_stub>:
c0022b32:	55                   	push   %ebp
c0022b33:	6a 00                	push   $0x0
c0022b35:	68 ad 00 00 00       	push   $0xad
c0022b3a:	e9 76 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b3f <intrae_stub>:
c0022b3f:	55                   	push   %ebp
c0022b40:	6a 00                	push   $0x0
c0022b42:	68 ae 00 00 00       	push   $0xae
c0022b47:	e9 69 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b4c <intraf_stub>:
c0022b4c:	55                   	push   %ebp
c0022b4d:	6a 00                	push   $0x0
c0022b4f:	68 af 00 00 00       	push   $0xaf
c0022b54:	e9 5c f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b59 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022b59:	55                   	push   %ebp
c0022b5a:	6a 00                	push   $0x0
c0022b5c:	68 b0 00 00 00       	push   $0xb0
c0022b61:	e9 4f f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b66 <intrb1_stub>:
c0022b66:	55                   	push   %ebp
c0022b67:	6a 00                	push   $0x0
c0022b69:	68 b1 00 00 00       	push   $0xb1
c0022b6e:	e9 42 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b73 <intrb2_stub>:
c0022b73:	55                   	push   %ebp
c0022b74:	6a 00                	push   $0x0
c0022b76:	68 b2 00 00 00       	push   $0xb2
c0022b7b:	e9 35 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b80 <intrb3_stub>:
c0022b80:	55                   	push   %ebp
c0022b81:	6a 00                	push   $0x0
c0022b83:	68 b3 00 00 00       	push   $0xb3
c0022b88:	e9 28 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b8d <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022b8d:	55                   	push   %ebp
c0022b8e:	6a 00                	push   $0x0
c0022b90:	68 b4 00 00 00       	push   $0xb4
c0022b95:	e9 1b f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022b9a <intrb5_stub>:
c0022b9a:	55                   	push   %ebp
c0022b9b:	6a 00                	push   $0x0
c0022b9d:	68 b5 00 00 00       	push   $0xb5
c0022ba2:	e9 0e f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022ba7 <intrb6_stub>:
c0022ba7:	55                   	push   %ebp
c0022ba8:	6a 00                	push   $0x0
c0022baa:	68 b6 00 00 00       	push   $0xb6
c0022baf:	e9 01 f8 ff ff       	jmp    c00223b5 <intr_entry>

c0022bb4 <intrb7_stub>:
c0022bb4:	55                   	push   %ebp
c0022bb5:	6a 00                	push   $0x0
c0022bb7:	68 b7 00 00 00       	push   $0xb7
c0022bbc:	e9 f4 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022bc1 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022bc1:	55                   	push   %ebp
c0022bc2:	6a 00                	push   $0x0
c0022bc4:	68 b8 00 00 00       	push   $0xb8
c0022bc9:	e9 e7 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022bce <intrb9_stub>:
c0022bce:	55                   	push   %ebp
c0022bcf:	6a 00                	push   $0x0
c0022bd1:	68 b9 00 00 00       	push   $0xb9
c0022bd6:	e9 da f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022bdb <intrba_stub>:
c0022bdb:	55                   	push   %ebp
c0022bdc:	6a 00                	push   $0x0
c0022bde:	68 ba 00 00 00       	push   $0xba
c0022be3:	e9 cd f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022be8 <intrbb_stub>:
c0022be8:	55                   	push   %ebp
c0022be9:	6a 00                	push   $0x0
c0022beb:	68 bb 00 00 00       	push   $0xbb
c0022bf0:	e9 c0 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022bf5 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022bf5:	55                   	push   %ebp
c0022bf6:	6a 00                	push   $0x0
c0022bf8:	68 bc 00 00 00       	push   $0xbc
c0022bfd:	e9 b3 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c02 <intrbd_stub>:
c0022c02:	55                   	push   %ebp
c0022c03:	6a 00                	push   $0x0
c0022c05:	68 bd 00 00 00       	push   $0xbd
c0022c0a:	e9 a6 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c0f <intrbe_stub>:
c0022c0f:	55                   	push   %ebp
c0022c10:	6a 00                	push   $0x0
c0022c12:	68 be 00 00 00       	push   $0xbe
c0022c17:	e9 99 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c1c <intrbf_stub>:
c0022c1c:	55                   	push   %ebp
c0022c1d:	6a 00                	push   $0x0
c0022c1f:	68 bf 00 00 00       	push   $0xbf
c0022c24:	e9 8c f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c29 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022c29:	55                   	push   %ebp
c0022c2a:	6a 00                	push   $0x0
c0022c2c:	68 c0 00 00 00       	push   $0xc0
c0022c31:	e9 7f f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c36 <intrc1_stub>:
c0022c36:	55                   	push   %ebp
c0022c37:	6a 00                	push   $0x0
c0022c39:	68 c1 00 00 00       	push   $0xc1
c0022c3e:	e9 72 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c43 <intrc2_stub>:
c0022c43:	55                   	push   %ebp
c0022c44:	6a 00                	push   $0x0
c0022c46:	68 c2 00 00 00       	push   $0xc2
c0022c4b:	e9 65 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c50 <intrc3_stub>:
c0022c50:	55                   	push   %ebp
c0022c51:	6a 00                	push   $0x0
c0022c53:	68 c3 00 00 00       	push   $0xc3
c0022c58:	e9 58 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c5d <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022c5d:	55                   	push   %ebp
c0022c5e:	6a 00                	push   $0x0
c0022c60:	68 c4 00 00 00       	push   $0xc4
c0022c65:	e9 4b f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c6a <intrc5_stub>:
c0022c6a:	55                   	push   %ebp
c0022c6b:	6a 00                	push   $0x0
c0022c6d:	68 c5 00 00 00       	push   $0xc5
c0022c72:	e9 3e f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c77 <intrc6_stub>:
c0022c77:	55                   	push   %ebp
c0022c78:	6a 00                	push   $0x0
c0022c7a:	68 c6 00 00 00       	push   $0xc6
c0022c7f:	e9 31 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c84 <intrc7_stub>:
c0022c84:	55                   	push   %ebp
c0022c85:	6a 00                	push   $0x0
c0022c87:	68 c7 00 00 00       	push   $0xc7
c0022c8c:	e9 24 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c91 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022c91:	55                   	push   %ebp
c0022c92:	6a 00                	push   $0x0
c0022c94:	68 c8 00 00 00       	push   $0xc8
c0022c99:	e9 17 f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022c9e <intrc9_stub>:
c0022c9e:	55                   	push   %ebp
c0022c9f:	6a 00                	push   $0x0
c0022ca1:	68 c9 00 00 00       	push   $0xc9
c0022ca6:	e9 0a f7 ff ff       	jmp    c00223b5 <intr_entry>

c0022cab <intrca_stub>:
c0022cab:	55                   	push   %ebp
c0022cac:	6a 00                	push   $0x0
c0022cae:	68 ca 00 00 00       	push   $0xca
c0022cb3:	e9 fd f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022cb8 <intrcb_stub>:
c0022cb8:	55                   	push   %ebp
c0022cb9:	6a 00                	push   $0x0
c0022cbb:	68 cb 00 00 00       	push   $0xcb
c0022cc0:	e9 f0 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022cc5 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022cc5:	55                   	push   %ebp
c0022cc6:	6a 00                	push   $0x0
c0022cc8:	68 cc 00 00 00       	push   $0xcc
c0022ccd:	e9 e3 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022cd2 <intrcd_stub>:
c0022cd2:	55                   	push   %ebp
c0022cd3:	6a 00                	push   $0x0
c0022cd5:	68 cd 00 00 00       	push   $0xcd
c0022cda:	e9 d6 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022cdf <intrce_stub>:
c0022cdf:	55                   	push   %ebp
c0022ce0:	6a 00                	push   $0x0
c0022ce2:	68 ce 00 00 00       	push   $0xce
c0022ce7:	e9 c9 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022cec <intrcf_stub>:
c0022cec:	55                   	push   %ebp
c0022ced:	6a 00                	push   $0x0
c0022cef:	68 cf 00 00 00       	push   $0xcf
c0022cf4:	e9 bc f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022cf9 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022cf9:	55                   	push   %ebp
c0022cfa:	6a 00                	push   $0x0
c0022cfc:	68 d0 00 00 00       	push   $0xd0
c0022d01:	e9 af f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d06 <intrd1_stub>:
c0022d06:	55                   	push   %ebp
c0022d07:	6a 00                	push   $0x0
c0022d09:	68 d1 00 00 00       	push   $0xd1
c0022d0e:	e9 a2 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d13 <intrd2_stub>:
c0022d13:	55                   	push   %ebp
c0022d14:	6a 00                	push   $0x0
c0022d16:	68 d2 00 00 00       	push   $0xd2
c0022d1b:	e9 95 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d20 <intrd3_stub>:
c0022d20:	55                   	push   %ebp
c0022d21:	6a 00                	push   $0x0
c0022d23:	68 d3 00 00 00       	push   $0xd3
c0022d28:	e9 88 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d2d <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022d2d:	55                   	push   %ebp
c0022d2e:	6a 00                	push   $0x0
c0022d30:	68 d4 00 00 00       	push   $0xd4
c0022d35:	e9 7b f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d3a <intrd5_stub>:
c0022d3a:	55                   	push   %ebp
c0022d3b:	6a 00                	push   $0x0
c0022d3d:	68 d5 00 00 00       	push   $0xd5
c0022d42:	e9 6e f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d47 <intrd6_stub>:
c0022d47:	55                   	push   %ebp
c0022d48:	6a 00                	push   $0x0
c0022d4a:	68 d6 00 00 00       	push   $0xd6
c0022d4f:	e9 61 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d54 <intrd7_stub>:
c0022d54:	55                   	push   %ebp
c0022d55:	6a 00                	push   $0x0
c0022d57:	68 d7 00 00 00       	push   $0xd7
c0022d5c:	e9 54 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d61 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022d61:	55                   	push   %ebp
c0022d62:	6a 00                	push   $0x0
c0022d64:	68 d8 00 00 00       	push   $0xd8
c0022d69:	e9 47 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d6e <intrd9_stub>:
c0022d6e:	55                   	push   %ebp
c0022d6f:	6a 00                	push   $0x0
c0022d71:	68 d9 00 00 00       	push   $0xd9
c0022d76:	e9 3a f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d7b <intrda_stub>:
c0022d7b:	55                   	push   %ebp
c0022d7c:	6a 00                	push   $0x0
c0022d7e:	68 da 00 00 00       	push   $0xda
c0022d83:	e9 2d f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d88 <intrdb_stub>:
c0022d88:	55                   	push   %ebp
c0022d89:	6a 00                	push   $0x0
c0022d8b:	68 db 00 00 00       	push   $0xdb
c0022d90:	e9 20 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022d95 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022d95:	55                   	push   %ebp
c0022d96:	6a 00                	push   $0x0
c0022d98:	68 dc 00 00 00       	push   $0xdc
c0022d9d:	e9 13 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022da2 <intrdd_stub>:
c0022da2:	55                   	push   %ebp
c0022da3:	6a 00                	push   $0x0
c0022da5:	68 dd 00 00 00       	push   $0xdd
c0022daa:	e9 06 f6 ff ff       	jmp    c00223b5 <intr_entry>

c0022daf <intrde_stub>:
c0022daf:	55                   	push   %ebp
c0022db0:	6a 00                	push   $0x0
c0022db2:	68 de 00 00 00       	push   $0xde
c0022db7:	e9 f9 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022dbc <intrdf_stub>:
c0022dbc:	55                   	push   %ebp
c0022dbd:	6a 00                	push   $0x0
c0022dbf:	68 df 00 00 00       	push   $0xdf
c0022dc4:	e9 ec f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022dc9 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022dc9:	55                   	push   %ebp
c0022dca:	6a 00                	push   $0x0
c0022dcc:	68 e0 00 00 00       	push   $0xe0
c0022dd1:	e9 df f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022dd6 <intre1_stub>:
c0022dd6:	55                   	push   %ebp
c0022dd7:	6a 00                	push   $0x0
c0022dd9:	68 e1 00 00 00       	push   $0xe1
c0022dde:	e9 d2 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022de3 <intre2_stub>:
c0022de3:	55                   	push   %ebp
c0022de4:	6a 00                	push   $0x0
c0022de6:	68 e2 00 00 00       	push   $0xe2
c0022deb:	e9 c5 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022df0 <intre3_stub>:
c0022df0:	55                   	push   %ebp
c0022df1:	6a 00                	push   $0x0
c0022df3:	68 e3 00 00 00       	push   $0xe3
c0022df8:	e9 b8 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022dfd <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022dfd:	55                   	push   %ebp
c0022dfe:	6a 00                	push   $0x0
c0022e00:	68 e4 00 00 00       	push   $0xe4
c0022e05:	e9 ab f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e0a <intre5_stub>:
c0022e0a:	55                   	push   %ebp
c0022e0b:	6a 00                	push   $0x0
c0022e0d:	68 e5 00 00 00       	push   $0xe5
c0022e12:	e9 9e f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e17 <intre6_stub>:
c0022e17:	55                   	push   %ebp
c0022e18:	6a 00                	push   $0x0
c0022e1a:	68 e6 00 00 00       	push   $0xe6
c0022e1f:	e9 91 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e24 <intre7_stub>:
c0022e24:	55                   	push   %ebp
c0022e25:	6a 00                	push   $0x0
c0022e27:	68 e7 00 00 00       	push   $0xe7
c0022e2c:	e9 84 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e31 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022e31:	55                   	push   %ebp
c0022e32:	6a 00                	push   $0x0
c0022e34:	68 e8 00 00 00       	push   $0xe8
c0022e39:	e9 77 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e3e <intre9_stub>:
c0022e3e:	55                   	push   %ebp
c0022e3f:	6a 00                	push   $0x0
c0022e41:	68 e9 00 00 00       	push   $0xe9
c0022e46:	e9 6a f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e4b <intrea_stub>:
c0022e4b:	55                   	push   %ebp
c0022e4c:	6a 00                	push   $0x0
c0022e4e:	68 ea 00 00 00       	push   $0xea
c0022e53:	e9 5d f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e58 <intreb_stub>:
c0022e58:	55                   	push   %ebp
c0022e59:	6a 00                	push   $0x0
c0022e5b:	68 eb 00 00 00       	push   $0xeb
c0022e60:	e9 50 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e65 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022e65:	55                   	push   %ebp
c0022e66:	6a 00                	push   $0x0
c0022e68:	68 ec 00 00 00       	push   $0xec
c0022e6d:	e9 43 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e72 <intred_stub>:
c0022e72:	55                   	push   %ebp
c0022e73:	6a 00                	push   $0x0
c0022e75:	68 ed 00 00 00       	push   $0xed
c0022e7a:	e9 36 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e7f <intree_stub>:
c0022e7f:	55                   	push   %ebp
c0022e80:	6a 00                	push   $0x0
c0022e82:	68 ee 00 00 00       	push   $0xee
c0022e87:	e9 29 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e8c <intref_stub>:
c0022e8c:	55                   	push   %ebp
c0022e8d:	6a 00                	push   $0x0
c0022e8f:	68 ef 00 00 00       	push   $0xef
c0022e94:	e9 1c f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022e99 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022e99:	55                   	push   %ebp
c0022e9a:	6a 00                	push   $0x0
c0022e9c:	68 f0 00 00 00       	push   $0xf0
c0022ea1:	e9 0f f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022ea6 <intrf1_stub>:
c0022ea6:	55                   	push   %ebp
c0022ea7:	6a 00                	push   $0x0
c0022ea9:	68 f1 00 00 00       	push   $0xf1
c0022eae:	e9 02 f5 ff ff       	jmp    c00223b5 <intr_entry>

c0022eb3 <intrf2_stub>:
c0022eb3:	55                   	push   %ebp
c0022eb4:	6a 00                	push   $0x0
c0022eb6:	68 f2 00 00 00       	push   $0xf2
c0022ebb:	e9 f5 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022ec0 <intrf3_stub>:
c0022ec0:	55                   	push   %ebp
c0022ec1:	6a 00                	push   $0x0
c0022ec3:	68 f3 00 00 00       	push   $0xf3
c0022ec8:	e9 e8 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022ecd <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022ecd:	55                   	push   %ebp
c0022ece:	6a 00                	push   $0x0
c0022ed0:	68 f4 00 00 00       	push   $0xf4
c0022ed5:	e9 db f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022eda <intrf5_stub>:
c0022eda:	55                   	push   %ebp
c0022edb:	6a 00                	push   $0x0
c0022edd:	68 f5 00 00 00       	push   $0xf5
c0022ee2:	e9 ce f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022ee7 <intrf6_stub>:
c0022ee7:	55                   	push   %ebp
c0022ee8:	6a 00                	push   $0x0
c0022eea:	68 f6 00 00 00       	push   $0xf6
c0022eef:	e9 c1 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022ef4 <intrf7_stub>:
c0022ef4:	55                   	push   %ebp
c0022ef5:	6a 00                	push   $0x0
c0022ef7:	68 f7 00 00 00       	push   $0xf7
c0022efc:	e9 b4 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f01 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022f01:	55                   	push   %ebp
c0022f02:	6a 00                	push   $0x0
c0022f04:	68 f8 00 00 00       	push   $0xf8
c0022f09:	e9 a7 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f0e <intrf9_stub>:
c0022f0e:	55                   	push   %ebp
c0022f0f:	6a 00                	push   $0x0
c0022f11:	68 f9 00 00 00       	push   $0xf9
c0022f16:	e9 9a f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f1b <intrfa_stub>:
c0022f1b:	55                   	push   %ebp
c0022f1c:	6a 00                	push   $0x0
c0022f1e:	68 fa 00 00 00       	push   $0xfa
c0022f23:	e9 8d f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f28 <intrfb_stub>:
c0022f28:	55                   	push   %ebp
c0022f29:	6a 00                	push   $0x0
c0022f2b:	68 fb 00 00 00       	push   $0xfb
c0022f30:	e9 80 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f35 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022f35:	55                   	push   %ebp
c0022f36:	6a 00                	push   $0x0
c0022f38:	68 fc 00 00 00       	push   $0xfc
c0022f3d:	e9 73 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f42 <intrfd_stub>:
c0022f42:	55                   	push   %ebp
c0022f43:	6a 00                	push   $0x0
c0022f45:	68 fd 00 00 00       	push   $0xfd
c0022f4a:	e9 66 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f4f <intrfe_stub>:
c0022f4f:	55                   	push   %ebp
c0022f50:	6a 00                	push   $0x0
c0022f52:	68 fe 00 00 00       	push   $0xfe
c0022f57:	e9 59 f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f5c <intrff_stub>:
c0022f5c:	55                   	push   %ebp
c0022f5d:	6a 00                	push   $0x0
c0022f5f:	68 ff 00 00 00       	push   $0xff
c0022f64:	e9 4c f4 ff ff       	jmp    c00223b5 <intr_entry>

c0022f69 <cond_sema_cmp_priority>:

bool lock_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {
  return list_entry(a, struct lock, elem)->max_priority > list_entry(b, struct lock, elem)->max_priority;
}

bool cond_sema_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {
c0022f69:	56                   	push   %esi
c0022f6a:	53                   	push   %ebx
c0022f6b:	83 ec 10             	sub    $0x10,%esp
c0022f6e:	e8 12 bb 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0022f73:	81 c3 41 7f 01 00    	add    $0x17f41,%ebx
  struct semaphore_elem *sa = list_entry(a, struct semaphore_elem, elem);
  struct semaphore_elem *sb = list_entry(b, struct semaphore_elem, elem);
  return list_entry(list_front(&sa->semaphore.waiters), struct thread, elem)->priority > list_entry(list_front(&sb->semaphore.waiters), struct thread, elem)->priority;
c0022f79:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0022f7d:	83 c0 0c             	add    $0xc,%eax
c0022f80:	50                   	push   %eax
c0022f81:	e8 97 6a 00 00       	call   c0029a1d <list_front>
c0022f86:	8b 70 f4             	mov    -0xc(%eax),%esi
c0022f89:	8b 44 24 24          	mov    0x24(%esp),%eax
c0022f8d:	83 c0 0c             	add    $0xc,%eax
c0022f90:	89 04 24             	mov    %eax,(%esp)
c0022f93:	e8 85 6a 00 00       	call   c0029a1d <list_front>
c0022f98:	3b 70 f4             	cmp    -0xc(%eax),%esi
c0022f9b:	0f 9f c0             	setg   %al
c0022f9e:	83 c4 14             	add    $0x14,%esp
c0022fa1:	5b                   	pop    %ebx
c0022fa2:	5e                   	pop    %esi
c0022fa3:	c3                   	ret    

c0022fa4 <sema_init>:
{
c0022fa4:	53                   	push   %ebx
c0022fa5:	83 ec 08             	sub    $0x8,%esp
c0022fa8:	e8 d8 ba 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0022fad:	81 c3 07 7f 01 00    	add    $0x17f07,%ebx
c0022fb3:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (sema != NULL);
c0022fb7:	85 c0                	test   %eax,%eax
c0022fb9:	74 17                	je     c0022fd2 <sema_init+0x2e>
  sema->value = value;
c0022fbb:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022fbf:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022fc1:	83 ec 0c             	sub    $0xc,%esp
c0022fc4:	83 c0 04             	add    $0x4,%eax
c0022fc7:	50                   	push   %eax
c0022fc8:	e8 87 63 00 00       	call   c0029354 <list_init>
}
c0022fcd:	83 c4 18             	add    $0x18,%esp
c0022fd0:	5b                   	pop    %ebx
c0022fd1:	c3                   	ret    
  ASSERT (sema != NULL);
c0022fd2:	83 ec 0c             	sub    $0xc,%esp
c0022fd5:	8d 83 1e 59 ff ff    	lea    -0xa6e2(%ebx),%eax
c0022fdb:	50                   	push   %eax
c0022fdc:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0022fe2:	50                   	push   %eax
c0022fe3:	8d 83 00 3f ff ff    	lea    -0xc100(%ebx),%eax
c0022fe9:	50                   	push   %eax
c0022fea:	6a 2f                	push   $0x2f
c0022fec:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c0022ff2:	50                   	push   %eax
c0022ff3:	e8 8f 62 00 00       	call   c0029287 <debug_panic>

c0022ff8 <sema_down>:
{
c0022ff8:	55                   	push   %ebp
c0022ff9:	57                   	push   %edi
c0022ffa:	56                   	push   %esi
c0022ffb:	53                   	push   %ebx
c0022ffc:	83 ec 1c             	sub    $0x1c,%esp
c0022fff:	e8 81 ba 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023004:	81 c3 b0 7e 01 00    	add    $0x17eb0,%ebx
c002300a:	8b 74 24 30          	mov    0x30(%esp),%esi
  ASSERT (sema != NULL);
c002300e:	85 f6                	test   %esi,%esi
c0023010:	74 5a                	je     c002306c <sema_down+0x74>
  ASSERT (!intr_context ());
c0023012:	e8 bc f0 ff ff       	call   c00220d3 <intr_context>
c0023017:	84 c0                	test   %al,%al
c0023019:	75 77                	jne    c0023092 <sema_down+0x9a>
  old_level = intr_disable ();
c002301b:	e8 0f ee ff ff       	call   c0021e2f <intr_disable>
c0023020:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (sema->value == 0) 
c0023024:	8b 06                	mov    (%esi),%eax
c0023026:	85 c0                	test   %eax,%eax
c0023028:	75 29                	jne    c0023053 <sema_down+0x5b>
      list_insert_ordered(&sema->waiters, &thread_current()->elem, thread_cmp_priority, NULL);
c002302a:	c7 c5 6b 09 02 c0    	mov    $0xc002096b,%ebp
c0023030:	8d 7e 04             	lea    0x4(%esi),%edi
c0023033:	e8 1c dd ff ff       	call   c0020d54 <thread_current>
c0023038:	6a 00                	push   $0x0
c002303a:	55                   	push   %ebp
c002303b:	83 c0 28             	add    $0x28,%eax
c002303e:	50                   	push   %eax
c002303f:	57                   	push   %edi
c0023040:	e8 07 6e 00 00       	call   c0029e4c <list_insert_ordered>
      thread_block ();
c0023045:	e8 d7 e0 ff ff       	call   c0021121 <thread_block>
  while (sema->value == 0) 
c002304a:	8b 06                	mov    (%esi),%eax
c002304c:	83 c4 10             	add    $0x10,%esp
c002304f:	85 c0                	test   %eax,%eax
c0023051:	74 e0                	je     c0023033 <sema_down+0x3b>
  sema->value--;
c0023053:	83 e8 01             	sub    $0x1,%eax
c0023056:	89 06                	mov    %eax,(%esi)
  intr_set_level (old_level);
c0023058:	83 ec 0c             	sub    $0xc,%esp
c002305b:	ff 74 24 18          	pushl  0x18(%esp)
c002305f:	e8 d2 ed ff ff       	call   c0021e36 <intr_set_level>
}
c0023064:	83 c4 2c             	add    $0x2c,%esp
c0023067:	5b                   	pop    %ebx
c0023068:	5e                   	pop    %esi
c0023069:	5f                   	pop    %edi
c002306a:	5d                   	pop    %ebp
c002306b:	c3                   	ret    
  ASSERT (sema != NULL);
c002306c:	83 ec 0c             	sub    $0xc,%esp
c002306f:	8d 83 1e 59 ff ff    	lea    -0xa6e2(%ebx),%eax
c0023075:	50                   	push   %eax
c0023076:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002307c:	50                   	push   %eax
c002307d:	8d 83 f4 3e ff ff    	lea    -0xc10c(%ebx),%eax
c0023083:	50                   	push   %eax
c0023084:	6a 41                	push   $0x41
c0023086:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002308c:	50                   	push   %eax
c002308d:	e8 f5 61 00 00       	call   c0029287 <debug_panic>
  ASSERT (!intr_context ());
c0023092:	83 ec 0c             	sub    $0xc,%esp
c0023095:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c002309b:	50                   	push   %eax
c002309c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00230a2:	50                   	push   %eax
c00230a3:	8d 83 f4 3e ff ff    	lea    -0xc10c(%ebx),%eax
c00230a9:	50                   	push   %eax
c00230aa:	6a 42                	push   $0x42
c00230ac:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00230b2:	50                   	push   %eax
c00230b3:	e8 cf 61 00 00       	call   c0029287 <debug_panic>

c00230b8 <sema_try_down>:
{
c00230b8:	57                   	push   %edi
c00230b9:	56                   	push   %esi
c00230ba:	53                   	push   %ebx
c00230bb:	e8 c5 b9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00230c0:	81 c3 f4 7d 01 00    	add    $0x17df4,%ebx
c00230c6:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (sema != NULL);
c00230ca:	85 f6                	test   %esi,%esi
c00230cc:	74 2c                	je     c00230fa <sema_try_down+0x42>
  old_level = intr_disable ();
c00230ce:	e8 5c ed ff ff       	call   c0021e2f <intr_disable>
  if (sema->value > 0) 
c00230d3:	8b 16                	mov    (%esi),%edx
    success = false;
c00230d5:	bf 00 00 00 00       	mov    $0x0,%edi
  if (sema->value > 0) 
c00230da:	85 d2                	test   %edx,%edx
c00230dc:	74 0a                	je     c00230e8 <sema_try_down+0x30>
      sema->value--;
c00230de:	83 ea 01             	sub    $0x1,%edx
c00230e1:	89 16                	mov    %edx,(%esi)
      success = true; 
c00230e3:	bf 01 00 00 00       	mov    $0x1,%edi
  intr_set_level (old_level);
c00230e8:	83 ec 0c             	sub    $0xc,%esp
c00230eb:	50                   	push   %eax
c00230ec:	e8 45 ed ff ff       	call   c0021e36 <intr_set_level>
  return success;
c00230f1:	83 c4 10             	add    $0x10,%esp
}
c00230f4:	89 f8                	mov    %edi,%eax
c00230f6:	5b                   	pop    %ebx
c00230f7:	5e                   	pop    %esi
c00230f8:	5f                   	pop    %edi
c00230f9:	c3                   	ret    
  ASSERT (sema != NULL);
c00230fa:	83 ec 0c             	sub    $0xc,%esp
c00230fd:	8d 83 1e 59 ff ff    	lea    -0xa6e2(%ebx),%eax
c0023103:	50                   	push   %eax
c0023104:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002310a:	50                   	push   %eax
c002310b:	8d 83 e4 3e ff ff    	lea    -0xc11c(%ebx),%eax
c0023111:	50                   	push   %eax
c0023112:	6a 5a                	push   $0x5a
c0023114:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002311a:	50                   	push   %eax
c002311b:	e8 67 61 00 00       	call   c0029287 <debug_panic>

c0023120 <sema_up>:
{
c0023120:	55                   	push   %ebp
c0023121:	57                   	push   %edi
c0023122:	56                   	push   %esi
c0023123:	53                   	push   %ebx
c0023124:	83 ec 0c             	sub    $0xc,%esp
c0023127:	e8 59 b9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002312c:	81 c3 88 7d 01 00    	add    $0x17d88,%ebx
c0023132:	8b 74 24 20          	mov    0x20(%esp),%esi
  ASSERT (sema != NULL);
c0023136:	85 f6                	test   %esi,%esi
c0023138:	74 33                	je     c002316d <sema_up+0x4d>
  old_level = intr_disable ();
c002313a:	e8 f0 ec ff ff       	call   c0021e2f <intr_disable>
c002313f:	89 c5                	mov    %eax,%ebp
  if (!list_empty (&sema->waiters)) {
c0023141:	8d 7e 04             	lea    0x4(%esi),%edi
c0023144:	83 ec 0c             	sub    $0xc,%esp
c0023147:	57                   	push   %edi
c0023148:	e8 ac 68 00 00       	call   c00299f9 <list_empty>
c002314d:	83 c4 10             	add    $0x10,%esp
c0023150:	84 c0                	test   %al,%al
c0023152:	74 3f                	je     c0023193 <sema_up+0x73>
  sema->value++;
c0023154:	83 06 01             	addl   $0x1,(%esi)
  thread_yield();
c0023157:	e8 29 e2 ff ff       	call   c0021385 <thread_yield>
  intr_set_level (old_level);
c002315c:	83 ec 0c             	sub    $0xc,%esp
c002315f:	55                   	push   %ebp
c0023160:	e8 d1 ec ff ff       	call   c0021e36 <intr_set_level>
}
c0023165:	83 c4 1c             	add    $0x1c,%esp
c0023168:	5b                   	pop    %ebx
c0023169:	5e                   	pop    %esi
c002316a:	5f                   	pop    %edi
c002316b:	5d                   	pop    %ebp
c002316c:	c3                   	ret    
  ASSERT (sema != NULL);
c002316d:	83 ec 0c             	sub    $0xc,%esp
c0023170:	8d 83 1e 59 ff ff    	lea    -0xa6e2(%ebx),%eax
c0023176:	50                   	push   %eax
c0023177:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002317d:	50                   	push   %eax
c002317e:	8d 83 dc 3e ff ff    	lea    -0xc124(%ebx),%eax
c0023184:	50                   	push   %eax
c0023185:	6a 72                	push   $0x72
c0023187:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002318d:	50                   	push   %eax
c002318e:	e8 f4 60 00 00       	call   c0029287 <debug_panic>
    list_sort(&sema->waiters, thread_cmp_priority, NULL);
c0023193:	83 ec 04             	sub    $0x4,%esp
c0023196:	6a 00                	push   $0x0
c0023198:	ff b3 f8 ff ff ff    	pushl  -0x8(%ebx)
c002319e:	57                   	push   %edi
c002319f:	e8 bb 69 00 00       	call   c0029b5f <list_sort>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c00231a4:	89 3c 24             	mov    %edi,(%esp)
c00231a7:	e8 c4 68 00 00       	call   c0029a70 <list_pop_front>
c00231ac:	83 e8 28             	sub    $0x28,%eax
c00231af:	89 04 24             	mov    %eax,(%esp)
c00231b2:	e8 f0 da ff ff       	call   c0020ca7 <thread_unblock>
c00231b7:	83 c4 10             	add    $0x10,%esp
c00231ba:	eb 98                	jmp    c0023154 <sema_up+0x34>

c00231bc <sema_test_helper>:
{
c00231bc:	57                   	push   %edi
c00231bd:	56                   	push   %esi
c00231be:	53                   	push   %ebx
c00231bf:	8b 74 24 10          	mov    0x10(%esp),%esi
c00231c3:	bb 0a 00 00 00       	mov    $0xa,%ebx
      sema_up (&sema[1]);
c00231c8:	8d 7e 14             	lea    0x14(%esi),%edi
      sema_down (&sema[0]);
c00231cb:	83 ec 0c             	sub    $0xc,%esp
c00231ce:	56                   	push   %esi
c00231cf:	e8 24 fe ff ff       	call   c0022ff8 <sema_down>
      sema_up (&sema[1]);
c00231d4:	89 3c 24             	mov    %edi,(%esp)
c00231d7:	e8 44 ff ff ff       	call   c0023120 <sema_up>
  for (i = 0; i < 10; i++) 
c00231dc:	83 c4 10             	add    $0x10,%esp
c00231df:	83 eb 01             	sub    $0x1,%ebx
c00231e2:	75 e7                	jne    c00231cb <sema_test_helper+0xf>
}
c00231e4:	5b                   	pop    %ebx
c00231e5:	5e                   	pop    %esi
c00231e6:	5f                   	pop    %edi
c00231e7:	c3                   	ret    

c00231e8 <sema_self_test>:
{
c00231e8:	55                   	push   %ebp
c00231e9:	57                   	push   %edi
c00231ea:	56                   	push   %esi
c00231eb:	53                   	push   %ebx
c00231ec:	83 ec 48             	sub    $0x48,%esp
c00231ef:	e8 91 b8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00231f4:	81 c3 c0 7c 01 00    	add    $0x17cc0,%ebx
  printf ("Testing semaphores...");
c00231fa:	8d 83 41 59 ff ff    	lea    -0xa6bf(%ebx),%eax
c0023200:	50                   	push   %eax
c0023201:	e8 ea 42 00 00       	call   c00274f0 <printf>
  sema_init (&sema[0], 0);
c0023206:	83 c4 08             	add    $0x8,%esp
c0023209:	6a 00                	push   $0x0
c002320b:	8d 74 24 14          	lea    0x14(%esp),%esi
c002320f:	56                   	push   %esi
c0023210:	e8 8f fd ff ff       	call   c0022fa4 <sema_init>
  sema_init (&sema[1], 0);
c0023215:	83 c4 08             	add    $0x8,%esp
c0023218:	6a 00                	push   $0x0
c002321a:	8d 44 24 28          	lea    0x28(%esp),%eax
c002321e:	50                   	push   %eax
c002321f:	e8 80 fd ff ff       	call   c0022fa4 <sema_init>
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0023224:	56                   	push   %esi
c0023225:	8d 83 08 83 fe ff    	lea    -0x17cf8(%ebx),%eax
c002322b:	50                   	push   %eax
c002322c:	6a 1f                	push   $0x1f
c002322e:	8d 83 57 59 ff ff    	lea    -0xa6a9(%ebx),%eax
c0023234:	50                   	push   %eax
c0023235:	e8 d9 e1 ff ff       	call   c0021413 <thread_create>
c002323a:	83 c4 20             	add    $0x20,%esp
c002323d:	be 0a 00 00 00       	mov    $0xa,%esi
      sema_up (&sema[0]);
c0023242:	8d 6c 24 08          	lea    0x8(%esp),%ebp
      sema_down (&sema[1]);
c0023246:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
      sema_up (&sema[0]);
c002324a:	83 ec 0c             	sub    $0xc,%esp
c002324d:	55                   	push   %ebp
c002324e:	e8 cd fe ff ff       	call   c0023120 <sema_up>
      sema_down (&sema[1]);
c0023253:	89 3c 24             	mov    %edi,(%esp)
c0023256:	e8 9d fd ff ff       	call   c0022ff8 <sema_down>
  for (i = 0; i < 10; i++) 
c002325b:	83 c4 10             	add    $0x10,%esp
c002325e:	83 ee 01             	sub    $0x1,%esi
c0023261:	75 e7                	jne    c002324a <sema_self_test+0x62>
  printf ("done.\n");
c0023263:	83 ec 0c             	sub    $0xc,%esp
c0023266:	8d 83 61 59 ff ff    	lea    -0xa69f(%ebx),%eax
c002326c:	50                   	push   %eax
c002326d:	e8 ee 7f 00 00       	call   c002b260 <puts>
}
c0023272:	83 c4 4c             	add    $0x4c,%esp
c0023275:	5b                   	pop    %ebx
c0023276:	5e                   	pop    %esi
c0023277:	5f                   	pop    %edi
c0023278:	5d                   	pop    %ebp
c0023279:	c3                   	ret    

c002327a <lock_init>:
{
c002327a:	53                   	push   %ebx
c002327b:	83 ec 08             	sub    $0x8,%esp
c002327e:	e8 02 b8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023283:	81 c3 31 7c 01 00    	add    $0x17c31,%ebx
c0023289:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c002328d:	85 c0                	test   %eax,%eax
c002328f:	74 19                	je     c00232aa <lock_init+0x30>
  lock->holder = NULL;
c0023291:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0023297:	83 ec 08             	sub    $0x8,%esp
c002329a:	6a 01                	push   $0x1
c002329c:	83 c0 04             	add    $0x4,%eax
c002329f:	50                   	push   %eax
c00232a0:	e8 ff fc ff ff       	call   c0022fa4 <sema_init>
}
c00232a5:	83 c4 18             	add    $0x18,%esp
c00232a8:	5b                   	pop    %ebx
c00232a9:	c3                   	ret    
  ASSERT (lock != NULL);
c00232aa:	83 ec 0c             	sub    $0xc,%esp
c00232ad:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c00232b3:	50                   	push   %eax
c00232b4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00232ba:	50                   	push   %eax
c00232bb:	8d 83 d0 3e ff ff    	lea    -0xc130(%ebx),%eax
c00232c1:	50                   	push   %eax
c00232c2:	68 b6 00 00 00       	push   $0xb6
c00232c7:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00232cd:	50                   	push   %eax
c00232ce:	e8 b4 5f 00 00       	call   c0029287 <debug_panic>

c00232d3 <lock_held_by_current_thread>:
{
c00232d3:	56                   	push   %esi
c00232d4:	53                   	push   %ebx
c00232d5:	83 ec 04             	sub    $0x4,%esp
c00232d8:	e8 a8 b7 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00232dd:	81 c3 d7 7b 01 00    	add    $0x17bd7,%ebx
c00232e3:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c00232e7:	85 c0                	test   %eax,%eax
c00232e9:	74 12                	je     c00232fd <lock_held_by_current_thread+0x2a>
  return lock->holder == thread_current ();
c00232eb:	8b 30                	mov    (%eax),%esi
c00232ed:	e8 62 da ff ff       	call   c0020d54 <thread_current>
c00232f2:	39 c6                	cmp    %eax,%esi
c00232f4:	0f 94 c0             	sete   %al
}
c00232f7:	83 c4 04             	add    $0x4,%esp
c00232fa:	5b                   	pop    %ebx
c00232fb:	5e                   	pop    %esi
c00232fc:	c3                   	ret    
  ASSERT (lock != NULL);
c00232fd:	83 ec 0c             	sub    $0xc,%esp
c0023300:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c0023306:	50                   	push   %eax
c0023307:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002330d:	50                   	push   %eax
c002330e:	8d 83 80 3e ff ff    	lea    -0xc180(%ebx),%eax
c0023314:	50                   	push   %eax
c0023315:	68 1a 01 00 00       	push   $0x11a
c002331a:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c0023320:	50                   	push   %eax
c0023321:	e8 61 5f 00 00       	call   c0029287 <debug_panic>

c0023326 <lock_acquire>:
{
c0023326:	55                   	push   %ebp
c0023327:	57                   	push   %edi
c0023328:	56                   	push   %esi
c0023329:	53                   	push   %ebx
c002332a:	83 ec 0c             	sub    $0xc,%esp
c002332d:	e8 53 b7 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023332:	81 c3 82 7b 01 00    	add    $0x17b82,%ebx
c0023338:	8b 7c 24 20          	mov    0x20(%esp),%edi
  struct thread *current_thread = thread_current ();
c002333c:	e8 13 da ff ff       	call   c0020d54 <thread_current>
  ASSERT (lock != NULL);
c0023341:	85 ff                	test   %edi,%edi
c0023343:	0f 84 a0 00 00 00    	je     c00233e9 <lock_acquire+0xc3>
c0023349:	89 c5                	mov    %eax,%ebp
  ASSERT (!intr_context ());
c002334b:	e8 83 ed ff ff       	call   c00220d3 <intr_context>
c0023350:	84 c0                	test   %al,%al
c0023352:	0f 85 ba 00 00 00    	jne    c0023412 <lock_acquire+0xec>
  ASSERT (!lock_held_by_current_thread (lock));
c0023358:	83 ec 0c             	sub    $0xc,%esp
c002335b:	57                   	push   %edi
c002335c:	e8 72 ff ff ff       	call   c00232d3 <lock_held_by_current_thread>
c0023361:	83 c4 10             	add    $0x10,%esp
c0023364:	84 c0                	test   %al,%al
c0023366:	0f 85 cf 00 00 00    	jne    c002343b <lock_acquire+0x115>
  if (lock->holder != NULL && !thread_mlfqs) {
c002336c:	83 3f 00             	cmpl   $0x0,(%edi)
c002336f:	74 39                	je     c00233aa <lock_acquire+0x84>
c0023371:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c0023377:	80 38 00             	cmpb   $0x0,(%eax)
c002337a:	75 2e                	jne    c00233aa <lock_acquire+0x84>
    current_thread->lock_waiting = lock;
c002337c:	89 7d 50             	mov    %edi,0x50(%ebp)
    while (l && current_thread->priority > l->max_priority) {
c002337f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0023382:	3b 47 20             	cmp    0x20(%edi),%eax
c0023385:	7e 23                	jle    c00233aa <lock_acquire+0x84>
    l = lock;
c0023387:	89 fe                	mov    %edi,%esi
      l->max_priority = current_thread->priority;
c0023389:	89 46 20             	mov    %eax,0x20(%esi)
      thread_donate_priority(l->holder);
c002338c:	83 ec 0c             	sub    $0xc,%esp
c002338f:	ff 36                	pushl  (%esi)
c0023391:	e8 09 e4 ff ff       	call   c002179f <thread_donate_priority>
      l = l->holder->lock_waiting;
c0023396:	8b 06                	mov    (%esi),%eax
c0023398:	8b 70 50             	mov    0x50(%eax),%esi
    while (l && current_thread->priority > l->max_priority) {
c002339b:	83 c4 10             	add    $0x10,%esp
c002339e:	85 f6                	test   %esi,%esi
c00233a0:	74 08                	je     c00233aa <lock_acquire+0x84>
c00233a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00233a5:	3b 46 20             	cmp    0x20(%esi),%eax
c00233a8:	7f df                	jg     c0023389 <lock_acquire+0x63>
  sema_down (&lock->semaphore);
c00233aa:	83 ec 0c             	sub    $0xc,%esp
c00233ad:	8d 47 04             	lea    0x4(%edi),%eax
c00233b0:	50                   	push   %eax
c00233b1:	e8 42 fc ff ff       	call   c0022ff8 <sema_down>
  old_level = intr_disable();
c00233b6:	e8 74 ea ff ff       	call   c0021e2f <intr_disable>
c00233bb:	89 c5                	mov    %eax,%ebp
  current_thread = thread_current();
c00233bd:	e8 92 d9 ff ff       	call   c0020d54 <thread_current>
c00233c2:	89 c6                	mov    %eax,%esi
  if (!thread_mlfqs) {
c00233c4:	83 c4 10             	add    $0x10,%esp
c00233c7:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c00233cd:	80 38 00             	cmpb   $0x0,(%eax)
c00233d0:	0f 84 8e 00 00 00    	je     c0023464 <lock_acquire+0x13e>
  lock->holder = current_thread;
c00233d6:	89 37                	mov    %esi,(%edi)
  intr_set_level(old_level);
c00233d8:	83 ec 0c             	sub    $0xc,%esp
c00233db:	55                   	push   %ebp
c00233dc:	e8 55 ea ff ff       	call   c0021e36 <intr_set_level>
}
c00233e1:	83 c4 1c             	add    $0x1c,%esp
c00233e4:	5b                   	pop    %ebx
c00233e5:	5e                   	pop    %esi
c00233e6:	5f                   	pop    %edi
c00233e7:	5d                   	pop    %ebp
c00233e8:	c3                   	ret    
  ASSERT (lock != NULL);
c00233e9:	83 ec 0c             	sub    $0xc,%esp
c00233ec:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c00233f2:	50                   	push   %eax
c00233f3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00233f9:	50                   	push   %eax
c00233fa:	8d 83 c0 3e ff ff    	lea    -0xc140(%ebx),%eax
c0023400:	50                   	push   %eax
c0023401:	68 cb 00 00 00       	push   $0xcb
c0023406:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002340c:	50                   	push   %eax
c002340d:	e8 75 5e 00 00       	call   c0029287 <debug_panic>
  ASSERT (!intr_context ());
c0023412:	83 ec 0c             	sub    $0xc,%esp
c0023415:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c002341b:	50                   	push   %eax
c002341c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023422:	50                   	push   %eax
c0023423:	8d 83 c0 3e ff ff    	lea    -0xc140(%ebx),%eax
c0023429:	50                   	push   %eax
c002342a:	68 cc 00 00 00       	push   $0xcc
c002342f:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c0023435:	50                   	push   %eax
c0023436:	e8 4c 5e 00 00       	call   c0029287 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c002343b:	83 ec 0c             	sub    $0xc,%esp
c002343e:	8d 83 84 59 ff ff    	lea    -0xa67c(%ebx),%eax
c0023444:	50                   	push   %eax
c0023445:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002344b:	50                   	push   %eax
c002344c:	8d 83 c0 3e ff ff    	lea    -0xc140(%ebx),%eax
c0023452:	50                   	push   %eax
c0023453:	68 cd 00 00 00       	push   $0xcd
c0023458:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002345e:	50                   	push   %eax
c002345f:	e8 23 5e 00 00       	call   c0029287 <debug_panic>
    current_thread->lock_waiting = NULL;
c0023464:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
    lock->max_priority = current_thread->priority;
c002346b:	8b 46 1c             	mov    0x1c(%esi),%eax
c002346e:	89 47 20             	mov    %eax,0x20(%edi)
    thread_hold_the_lock(lock);
c0023471:	83 ec 0c             	sub    $0xc,%esp
c0023474:	57                   	push   %edi
c0023475:	e8 14 e2 ff ff       	call   c002168e <thread_hold_the_lock>
c002347a:	83 c4 10             	add    $0x10,%esp
c002347d:	e9 54 ff ff ff       	jmp    c00233d6 <lock_acquire+0xb0>

c0023482 <lock_try_acquire>:
{
c0023482:	57                   	push   %edi
c0023483:	56                   	push   %esi
c0023484:	53                   	push   %ebx
c0023485:	e8 fb b5 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002348a:	81 c3 2a 7a 01 00    	add    $0x17a2a,%ebx
c0023490:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (lock != NULL);
c0023494:	85 f6                	test   %esi,%esi
c0023496:	74 2b                	je     c00234c3 <lock_try_acquire+0x41>
  ASSERT (!lock_held_by_current_thread (lock));
c0023498:	83 ec 0c             	sub    $0xc,%esp
c002349b:	56                   	push   %esi
c002349c:	e8 32 fe ff ff       	call   c00232d3 <lock_held_by_current_thread>
c00234a1:	83 c4 10             	add    $0x10,%esp
c00234a4:	84 c0                	test   %al,%al
c00234a6:	75 44                	jne    c00234ec <lock_try_acquire+0x6a>
  success = sema_try_down (&lock->semaphore);
c00234a8:	83 ec 0c             	sub    $0xc,%esp
c00234ab:	8d 46 04             	lea    0x4(%esi),%eax
c00234ae:	50                   	push   %eax
c00234af:	e8 04 fc ff ff       	call   c00230b8 <sema_try_down>
c00234b4:	89 c7                	mov    %eax,%edi
  if (success)
c00234b6:	83 c4 10             	add    $0x10,%esp
c00234b9:	84 c0                	test   %al,%al
c00234bb:	75 58                	jne    c0023515 <lock_try_acquire+0x93>
}
c00234bd:	89 f8                	mov    %edi,%eax
c00234bf:	5b                   	pop    %ebx
c00234c0:	5e                   	pop    %esi
c00234c1:	5f                   	pop    %edi
c00234c2:	c3                   	ret    
  ASSERT (lock != NULL);
c00234c3:	83 ec 0c             	sub    $0xc,%esp
c00234c6:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c00234cc:	50                   	push   %eax
c00234cd:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00234d3:	50                   	push   %eax
c00234d4:	8d 83 ac 3e ff ff    	lea    -0xc154(%ebx),%eax
c00234da:	50                   	push   %eax
c00234db:	68 f3 00 00 00       	push   $0xf3
c00234e0:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00234e6:	50                   	push   %eax
c00234e7:	e8 9b 5d 00 00       	call   c0029287 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c00234ec:	83 ec 0c             	sub    $0xc,%esp
c00234ef:	8d 83 84 59 ff ff    	lea    -0xa67c(%ebx),%eax
c00234f5:	50                   	push   %eax
c00234f6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00234fc:	50                   	push   %eax
c00234fd:	8d 83 ac 3e ff ff    	lea    -0xc154(%ebx),%eax
c0023503:	50                   	push   %eax
c0023504:	68 f4 00 00 00       	push   $0xf4
c0023509:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002350f:	50                   	push   %eax
c0023510:	e8 72 5d 00 00       	call   c0029287 <debug_panic>
    lock->holder = thread_current ();
c0023515:	e8 3a d8 ff ff       	call   c0020d54 <thread_current>
c002351a:	89 06                	mov    %eax,(%esi)
  return success;
c002351c:	eb 9f                	jmp    c00234bd <lock_try_acquire+0x3b>

c002351e <lock_release>:
{
c002351e:	57                   	push   %edi
c002351f:	56                   	push   %esi
c0023520:	53                   	push   %ebx
c0023521:	e8 5f b5 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023526:	81 c3 8e 79 01 00    	add    $0x1798e,%ebx
c002352c:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (lock != NULL);
c0023530:	85 f6                	test   %esi,%esi
c0023532:	74 43                	je     c0023577 <lock_release+0x59>
  ASSERT (lock_held_by_current_thread (lock));
c0023534:	83 ec 0c             	sub    $0xc,%esp
c0023537:	56                   	push   %esi
c0023538:	e8 96 fd ff ff       	call   c00232d3 <lock_held_by_current_thread>
c002353d:	83 c4 10             	add    $0x10,%esp
c0023540:	84 c0                	test   %al,%al
c0023542:	74 5c                	je     c00235a0 <lock_release+0x82>
  old_level = intr_disable();
c0023544:	e8 e6 e8 ff ff       	call   c0021e2f <intr_disable>
c0023549:	89 c7                	mov    %eax,%edi
  if (!thread_mlfqs)
c002354b:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c0023551:	80 38 00             	cmpb   $0x0,(%eax)
c0023554:	74 73                	je     c00235c9 <lock_release+0xab>
  lock->holder = NULL;
c0023556:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  sema_up (&lock->semaphore);
c002355c:	83 ec 0c             	sub    $0xc,%esp
c002355f:	83 c6 04             	add    $0x4,%esi
c0023562:	56                   	push   %esi
c0023563:	e8 b8 fb ff ff       	call   c0023120 <sema_up>
  intr_set_level(old_level);
c0023568:	89 3c 24             	mov    %edi,(%esp)
c002356b:	e8 c6 e8 ff ff       	call   c0021e36 <intr_set_level>
}
c0023570:	83 c4 10             	add    $0x10,%esp
c0023573:	5b                   	pop    %ebx
c0023574:	5e                   	pop    %esi
c0023575:	5f                   	pop    %edi
c0023576:	c3                   	ret    
  ASSERT (lock != NULL);
c0023577:	83 ec 0c             	sub    $0xc,%esp
c002357a:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c0023580:	50                   	push   %eax
c0023581:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023587:	50                   	push   %eax
c0023588:	8d 83 9c 3e ff ff    	lea    -0xc164(%ebx),%eax
c002358e:	50                   	push   %eax
c002358f:	68 06 01 00 00       	push   $0x106
c0023594:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002359a:	50                   	push   %eax
c002359b:	e8 e7 5c 00 00       	call   c0029287 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00235a0:	83 ec 0c             	sub    $0xc,%esp
c00235a3:	8d 83 a8 59 ff ff    	lea    -0xa658(%ebx),%eax
c00235a9:	50                   	push   %eax
c00235aa:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00235b0:	50                   	push   %eax
c00235b1:	8d 83 9c 3e ff ff    	lea    -0xc164(%ebx),%eax
c00235b7:	50                   	push   %eax
c00235b8:	68 07 01 00 00       	push   $0x107
c00235bd:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00235c3:	50                   	push   %eax
c00235c4:	e8 be 5c 00 00       	call   c0029287 <debug_panic>
    thread_remove_lock(lock);
c00235c9:	83 ec 0c             	sub    $0xc,%esp
c00235cc:	56                   	push   %esi
c00235cd:	e8 8b e1 ff ff       	call   c002175d <thread_remove_lock>
c00235d2:	83 c4 10             	add    $0x10,%esp
c00235d5:	e9 7c ff ff ff       	jmp    c0023556 <lock_release+0x38>

c00235da <cond_init>:
{
c00235da:	53                   	push   %ebx
c00235db:	83 ec 08             	sub    $0x8,%esp
c00235de:	e8 a2 b4 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00235e3:	81 c3 d1 78 01 00    	add    $0x178d1,%ebx
c00235e9:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (cond != NULL);
c00235ed:	85 c0                	test   %eax,%eax
c00235ef:	74 0e                	je     c00235ff <cond_init+0x25>
  list_init (&cond->waiters);
c00235f1:	83 ec 0c             	sub    $0xc,%esp
c00235f4:	50                   	push   %eax
c00235f5:	e8 5a 5d 00 00       	call   c0029354 <list_init>
}
c00235fa:	83 c4 18             	add    $0x18,%esp
c00235fd:	5b                   	pop    %ebx
c00235fe:	c3                   	ret    
  ASSERT (cond != NULL);
c00235ff:	83 ec 0c             	sub    $0xc,%esp
c0023602:	8d 83 74 59 ff ff    	lea    -0xa68c(%ebx),%eax
c0023608:	50                   	push   %eax
c0023609:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002360f:	50                   	push   %eax
c0023610:	8d 83 74 3e ff ff    	lea    -0xc18c(%ebx),%eax
c0023616:	50                   	push   %eax
c0023617:	68 2c 01 00 00       	push   $0x12c
c002361c:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c0023622:	50                   	push   %eax
c0023623:	e8 5f 5c 00 00       	call   c0029287 <debug_panic>

c0023628 <cond_wait>:
{
c0023628:	55                   	push   %ebp
c0023629:	57                   	push   %edi
c002362a:	56                   	push   %esi
c002362b:	53                   	push   %ebx
c002362c:	83 ec 2c             	sub    $0x2c,%esp
c002362f:	e8 51 b4 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023634:	81 c3 80 78 01 00    	add    $0x17880,%ebx
c002363a:	8b 74 24 44          	mov    0x44(%esp),%esi
  ASSERT (cond != NULL);
c002363e:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c0023643:	74 69                	je     c00236ae <cond_wait+0x86>
  ASSERT (lock != NULL);
c0023645:	85 f6                	test   %esi,%esi
c0023647:	0f 84 8a 00 00 00    	je     c00236d7 <cond_wait+0xaf>
  ASSERT (!intr_context ());
c002364d:	e8 81 ea ff ff       	call   c00220d3 <intr_context>
c0023652:	84 c0                	test   %al,%al
c0023654:	0f 85 a6 00 00 00    	jne    c0023700 <cond_wait+0xd8>
  ASSERT (lock_held_by_current_thread (lock));
c002365a:	83 ec 0c             	sub    $0xc,%esp
c002365d:	56                   	push   %esi
c002365e:	e8 70 fc ff ff       	call   c00232d3 <lock_held_by_current_thread>
c0023663:	83 c4 10             	add    $0x10,%esp
c0023666:	84 c0                	test   %al,%al
c0023668:	0f 84 bb 00 00 00    	je     c0023729 <cond_wait+0x101>
  sema_init (&waiter.semaphore, 0);
c002366e:	83 ec 08             	sub    $0x8,%esp
c0023671:	6a 00                	push   $0x0
c0023673:	8d 7c 24 10          	lea    0x10(%esp),%edi
c0023677:	8d 6c 24 18          	lea    0x18(%esp),%ebp
c002367b:	55                   	push   %ebp
c002367c:	e8 23 f9 ff ff       	call   c0022fa4 <sema_init>
  list_push_back (&cond->waiters, &waiter.elem);
c0023681:	83 c4 08             	add    $0x8,%esp
c0023684:	57                   	push   %edi
c0023685:	ff 74 24 4c          	pushl  0x4c(%esp)
c0023689:	e8 ac 62 00 00       	call   c002993a <list_push_back>
  lock_release (lock);
c002368e:	89 34 24             	mov    %esi,(%esp)
c0023691:	e8 88 fe ff ff       	call   c002351e <lock_release>
  sema_down (&waiter.semaphore);
c0023696:	89 2c 24             	mov    %ebp,(%esp)
c0023699:	e8 5a f9 ff ff       	call   c0022ff8 <sema_down>
  lock_acquire (lock);
c002369e:	89 34 24             	mov    %esi,(%esp)
c00236a1:	e8 80 fc ff ff       	call   c0023326 <lock_acquire>
}
c00236a6:	83 c4 3c             	add    $0x3c,%esp
c00236a9:	5b                   	pop    %ebx
c00236aa:	5e                   	pop    %esi
c00236ab:	5f                   	pop    %edi
c00236ac:	5d                   	pop    %ebp
c00236ad:	c3                   	ret    
  ASSERT (cond != NULL);
c00236ae:	83 ec 0c             	sub    $0xc,%esp
c00236b1:	8d 83 74 59 ff ff    	lea    -0xa68c(%ebx),%eax
c00236b7:	50                   	push   %eax
c00236b8:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00236be:	50                   	push   %eax
c00236bf:	8d 83 68 3e ff ff    	lea    -0xc198(%ebx),%eax
c00236c5:	50                   	push   %eax
c00236c6:	68 4a 01 00 00       	push   $0x14a
c00236cb:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00236d1:	50                   	push   %eax
c00236d2:	e8 b0 5b 00 00       	call   c0029287 <debug_panic>
  ASSERT (lock != NULL);
c00236d7:	83 ec 0c             	sub    $0xc,%esp
c00236da:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c00236e0:	50                   	push   %eax
c00236e1:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00236e7:	50                   	push   %eax
c00236e8:	8d 83 68 3e ff ff    	lea    -0xc198(%ebx),%eax
c00236ee:	50                   	push   %eax
c00236ef:	68 4b 01 00 00       	push   $0x14b
c00236f4:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00236fa:	50                   	push   %eax
c00236fb:	e8 87 5b 00 00       	call   c0029287 <debug_panic>
  ASSERT (!intr_context ());
c0023700:	83 ec 0c             	sub    $0xc,%esp
c0023703:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0023709:	50                   	push   %eax
c002370a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023710:	50                   	push   %eax
c0023711:	8d 83 68 3e ff ff    	lea    -0xc198(%ebx),%eax
c0023717:	50                   	push   %eax
c0023718:	68 4c 01 00 00       	push   $0x14c
c002371d:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c0023723:	50                   	push   %eax
c0023724:	e8 5e 5b 00 00       	call   c0029287 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023729:	83 ec 0c             	sub    $0xc,%esp
c002372c:	8d 83 a8 59 ff ff    	lea    -0xa658(%ebx),%eax
c0023732:	50                   	push   %eax
c0023733:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023739:	50                   	push   %eax
c002373a:	8d 83 68 3e ff ff    	lea    -0xc198(%ebx),%eax
c0023740:	50                   	push   %eax
c0023741:	68 4d 01 00 00       	push   $0x14d
c0023746:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002374c:	50                   	push   %eax
c002374d:	e8 35 5b 00 00       	call   c0029287 <debug_panic>

c0023752 <cond_signal>:
{
c0023752:	57                   	push   %edi
c0023753:	56                   	push   %esi
c0023754:	53                   	push   %ebx
c0023755:	e8 2b b3 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002375a:	81 c3 5a 77 01 00    	add    $0x1775a,%ebx
c0023760:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023764:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (cond != NULL);
c0023768:	85 f6                	test   %esi,%esi
c002376a:	74 39                	je     c00237a5 <cond_signal+0x53>
  ASSERT (lock != NULL);
c002376c:	85 ff                	test   %edi,%edi
c002376e:	74 5e                	je     c00237ce <cond_signal+0x7c>
  ASSERT (!intr_context ());
c0023770:	e8 5e e9 ff ff       	call   c00220d3 <intr_context>
c0023775:	84 c0                	test   %al,%al
c0023777:	75 7e                	jne    c00237f7 <cond_signal+0xa5>
  ASSERT (lock_held_by_current_thread (lock));
c0023779:	83 ec 0c             	sub    $0xc,%esp
c002377c:	57                   	push   %edi
c002377d:	e8 51 fb ff ff       	call   c00232d3 <lock_held_by_current_thread>
c0023782:	83 c4 10             	add    $0x10,%esp
c0023785:	84 c0                	test   %al,%al
c0023787:	0f 84 93 00 00 00    	je     c0023820 <cond_signal+0xce>
  if (!list_empty(&cond->waiters)) {
c002378d:	83 ec 0c             	sub    $0xc,%esp
c0023790:	56                   	push   %esi
c0023791:	e8 63 62 00 00       	call   c00299f9 <list_empty>
c0023796:	83 c4 10             	add    $0x10,%esp
c0023799:	84 c0                	test   %al,%al
c002379b:	0f 84 a8 00 00 00    	je     c0023849 <cond_signal+0xf7>
}
c00237a1:	5b                   	pop    %ebx
c00237a2:	5e                   	pop    %esi
c00237a3:	5f                   	pop    %edi
c00237a4:	c3                   	ret    
  ASSERT (cond != NULL);
c00237a5:	83 ec 0c             	sub    $0xc,%esp
c00237a8:	8d 83 74 59 ff ff    	lea    -0xa68c(%ebx),%eax
c00237ae:	50                   	push   %eax
c00237af:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00237b5:	50                   	push   %eax
c00237b6:	8d 83 5c 3e ff ff    	lea    -0xc1a4(%ebx),%eax
c00237bc:	50                   	push   %eax
c00237bd:	68 60 01 00 00       	push   $0x160
c00237c2:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00237c8:	50                   	push   %eax
c00237c9:	e8 b9 5a 00 00       	call   c0029287 <debug_panic>
  ASSERT (lock != NULL);
c00237ce:	83 ec 0c             	sub    $0xc,%esp
c00237d1:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c00237d7:	50                   	push   %eax
c00237d8:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00237de:	50                   	push   %eax
c00237df:	8d 83 5c 3e ff ff    	lea    -0xc1a4(%ebx),%eax
c00237e5:	50                   	push   %eax
c00237e6:	68 61 01 00 00       	push   $0x161
c00237eb:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00237f1:	50                   	push   %eax
c00237f2:	e8 90 5a 00 00       	call   c0029287 <debug_panic>
  ASSERT (!intr_context ());
c00237f7:	83 ec 0c             	sub    $0xc,%esp
c00237fa:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0023800:	50                   	push   %eax
c0023801:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023807:	50                   	push   %eax
c0023808:	8d 83 5c 3e ff ff    	lea    -0xc1a4(%ebx),%eax
c002380e:	50                   	push   %eax
c002380f:	68 62 01 00 00       	push   $0x162
c0023814:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c002381a:	50                   	push   %eax
c002381b:	e8 67 5a 00 00       	call   c0029287 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023820:	83 ec 0c             	sub    $0xc,%esp
c0023823:	8d 83 a8 59 ff ff    	lea    -0xa658(%ebx),%eax
c0023829:	50                   	push   %eax
c002382a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023830:	50                   	push   %eax
c0023831:	8d 83 5c 3e ff ff    	lea    -0xc1a4(%ebx),%eax
c0023837:	50                   	push   %eax
c0023838:	68 63 01 00 00       	push   $0x163
c002383d:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c0023843:	50                   	push   %eax
c0023844:	e8 3e 5a 00 00       	call   c0029287 <debug_panic>
    list_sort(&cond->waiters, cond_sema_cmp_priority, NULL);
c0023849:	83 ec 04             	sub    $0x4,%esp
c002384c:	6a 00                	push   $0x0
c002384e:	8d 83 b5 80 fe ff    	lea    -0x17f4b(%ebx),%eax
c0023854:	50                   	push   %eax
c0023855:	56                   	push   %esi
c0023856:	e8 04 63 00 00       	call   c0029b5f <list_sort>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c002385b:	89 34 24             	mov    %esi,(%esp)
c002385e:	e8 0d 62 00 00       	call   c0029a70 <list_pop_front>
c0023863:	83 c0 08             	add    $0x8,%eax
c0023866:	89 04 24             	mov    %eax,(%esp)
c0023869:	e8 b2 f8 ff ff       	call   c0023120 <sema_up>
c002386e:	83 c4 10             	add    $0x10,%esp
}
c0023871:	e9 2b ff ff ff       	jmp    c00237a1 <cond_signal+0x4f>

c0023876 <cond_broadcast>:
{
c0023876:	57                   	push   %edi
c0023877:	56                   	push   %esi
c0023878:	53                   	push   %ebx
c0023879:	e8 07 b2 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002387e:	81 c3 36 76 01 00    	add    $0x17636,%ebx
c0023884:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023888:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (cond != NULL);
c002388c:	85 f6                	test   %esi,%esi
c002388e:	74 2d                	je     c00238bd <cond_broadcast+0x47>
  ASSERT (lock != NULL);
c0023890:	85 ff                	test   %edi,%edi
c0023892:	75 5f                	jne    c00238f3 <cond_broadcast+0x7d>
c0023894:	83 ec 0c             	sub    $0xc,%esp
c0023897:	8d 83 67 59 ff ff    	lea    -0xa699(%ebx),%eax
c002389d:	50                   	push   %eax
c002389e:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00238a4:	50                   	push   %eax
c00238a5:	8d 83 4c 3e ff ff    	lea    -0xc1b4(%ebx),%eax
c00238ab:	50                   	push   %eax
c00238ac:	68 76 01 00 00       	push   $0x176
c00238b1:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00238b7:	50                   	push   %eax
c00238b8:	e8 ca 59 00 00       	call   c0029287 <debug_panic>
  ASSERT (cond != NULL);
c00238bd:	83 ec 0c             	sub    $0xc,%esp
c00238c0:	8d 83 74 59 ff ff    	lea    -0xa68c(%ebx),%eax
c00238c6:	50                   	push   %eax
c00238c7:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00238cd:	50                   	push   %eax
c00238ce:	8d 83 4c 3e ff ff    	lea    -0xc1b4(%ebx),%eax
c00238d4:	50                   	push   %eax
c00238d5:	68 75 01 00 00       	push   $0x175
c00238da:	8d 83 2b 59 ff ff    	lea    -0xa6d5(%ebx),%eax
c00238e0:	50                   	push   %eax
c00238e1:	e8 a1 59 00 00       	call   c0029287 <debug_panic>
    cond_signal (cond, lock);
c00238e6:	83 ec 08             	sub    $0x8,%esp
c00238e9:	57                   	push   %edi
c00238ea:	56                   	push   %esi
c00238eb:	e8 62 fe ff ff       	call   c0023752 <cond_signal>
c00238f0:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c00238f3:	83 ec 0c             	sub    $0xc,%esp
c00238f6:	56                   	push   %esi
c00238f7:	e8 fd 60 00 00       	call   c00299f9 <list_empty>
c00238fc:	83 c4 10             	add    $0x10,%esp
c00238ff:	84 c0                	test   %al,%al
c0023901:	74 e3                	je     c00238e6 <cond_broadcast+0x70>
}
c0023903:	5b                   	pop    %ebx
c0023904:	5e                   	pop    %esi
c0023905:	5f                   	pop    %edi
c0023906:	c3                   	ret    

c0023907 <lock_cmp_priority>:
  return list_entry(a, struct lock, elem)->max_priority > list_entry(b, struct lock, elem)->max_priority;
c0023907:	8b 54 24 04          	mov    0x4(%esp),%edx
c002390b:	8b 44 24 08          	mov    0x8(%esp),%eax
c002390f:	8b 40 08             	mov    0x8(%eax),%eax
c0023912:	39 42 08             	cmp    %eax,0x8(%edx)
c0023915:	0f 9f c0             	setg   %al
}
c0023918:	c3                   	ret    

c0023919 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023919:	55                   	push   %ebp
c002391a:	57                   	push   %edi
c002391b:	56                   	push   %esi
c002391c:	53                   	push   %ebx
c002391d:	83 ec 28             	sub    $0x28,%esp
c0023920:	e8 60 b1 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023925:	81 c3 8f 75 01 00    	add    $0x1758f,%ebx
c002392b:	89 c5                	mov    %eax,%ebp
c002392d:	89 54 24 18          	mov    %edx,0x18(%esp)
c0023931:	89 cf                	mov    %ecx,%edi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c0023933:	51                   	push   %ecx
c0023934:	e8 f9 67 00 00       	call   c002a132 <bitmap_buf_size>
c0023939:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
c002393f:	89 f0                	mov    %esi,%eax
c0023941:	c1 e8 0c             	shr    $0xc,%eax
  if (bm_pages > page_cnt)
c0023944:	83 c4 10             	add    $0x10,%esp
c0023947:	39 c7                	cmp    %eax,%edi
c0023949:	72 44                	jb     c002398f <init_pool+0x76>
    PANIC ("Not enough memory in %s for bitmap.", name);
  page_cnt -= bm_pages;
c002394b:	29 c7                	sub    %eax,%edi

  printf ("%zu pages available in %s.\n", page_cnt, name);
c002394d:	83 ec 04             	sub    $0x4,%esp
c0023950:	ff 74 24 34          	pushl  0x34(%esp)
c0023954:	57                   	push   %edi
c0023955:	8d 83 37 5a ff ff    	lea    -0xa5c9(%ebx),%eax
c002395b:	50                   	push   %eax
c002395c:	e8 8f 3b 00 00       	call   c00274f0 <printf>

  /* Initialize the pool. */
  lock_init (&p->lock);
c0023961:	89 2c 24             	mov    %ebp,(%esp)
c0023964:	e8 11 f9 ff ff       	call   c002327a <lock_init>
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0023969:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c002396f:	83 c4 0c             	add    $0xc,%esp
c0023972:	56                   	push   %esi
c0023973:	ff 74 24 14          	pushl  0x14(%esp)
c0023977:	57                   	push   %edi
c0023978:	e8 1e 6b 00 00       	call   c002a49b <bitmap_create_in_buf>
c002397d:	89 45 24             	mov    %eax,0x24(%ebp)
  p->base = base + bm_pages * PGSIZE;
c0023980:	03 74 24 1c          	add    0x1c(%esp),%esi
c0023984:	89 75 28             	mov    %esi,0x28(%ebp)
}
c0023987:	83 c4 2c             	add    $0x2c,%esp
c002398a:	5b                   	pop    %ebx
c002398b:	5e                   	pop    %esi
c002398c:	5f                   	pop    %edi
c002398d:	5d                   	pop    %ebp
c002398e:	c3                   	ret    
    PANIC ("Not enough memory in %s for bitmap.", name);
c002398f:	83 ec 0c             	sub    $0xc,%esp
c0023992:	ff 74 24 3c          	pushl  0x3c(%esp)
c0023996:	8d 83 cc 59 ff ff    	lea    -0xa634(%ebx),%eax
c002399c:	50                   	push   %eax
c002399d:	8d 83 38 3f ff ff    	lea    -0xc0c8(%ebx),%eax
c00239a3:	50                   	push   %eax
c00239a4:	68 a1 00 00 00       	push   $0xa1
c00239a9:	8d 83 20 5a ff ff    	lea    -0xa5e0(%ebx),%eax
c00239af:	50                   	push   %eax
c00239b0:	e8 d2 58 00 00       	call   c0029287 <debug_panic>

c00239b5 <palloc_init>:
{
c00239b5:	57                   	push   %edi
c00239b6:	56                   	push   %esi
c00239b7:	53                   	push   %ebx
c00239b8:	e8 c8 b0 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00239bd:	81 c3 f7 74 01 00    	add    $0x174f7,%ebx
c00239c3:	8b 54 24 10          	mov    0x10(%esp),%edx
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c00239c7:	c7 c0 7e 01 02 c0    	mov    $0xc002017e,%eax
c00239cd:	8b 00                	mov    (%eax),%eax
c00239cf:	c1 e0 0c             	shl    $0xc,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c00239d2:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00239d7:	77 5e                	ja     c0023a37 <palloc_init+0x82>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c00239d9:	8d b0 ff 0f f0 ff    	lea    -0xff001(%eax),%esi
c00239df:	2d 00 00 10 00       	sub    $0x100000,%eax
c00239e4:	0f 49 f0             	cmovns %eax,%esi
c00239e7:	c1 fe 0c             	sar    $0xc,%esi
  size_t user_pages = free_pages / 2;
c00239ea:	89 f7                	mov    %esi,%edi
c00239ec:	d1 ef                	shr    %edi
c00239ee:	39 d7                	cmp    %edx,%edi
c00239f0:	0f 47 fa             	cmova  %edx,%edi
  kernel_pages = free_pages - user_pages;
c00239f3:	29 fe                	sub    %edi,%esi
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c00239f5:	83 ec 0c             	sub    $0xc,%esp
c00239f8:	8d 83 6e 5a ff ff    	lea    -0xa592(%ebx),%eax
c00239fe:	50                   	push   %eax
c00239ff:	89 f1                	mov    %esi,%ecx
c0023a01:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c0023a06:	8d 83 4c 1c 00 00    	lea    0x1c4c(%ebx),%eax
c0023a0c:	e8 08 ff ff ff       	call   c0023919 <init_pool>
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0023a11:	c1 e6 0c             	shl    $0xc,%esi
c0023a14:	8d 96 00 00 10 c0    	lea    -0x3ff00000(%esi),%edx
c0023a1a:	8d 83 7a 5a ff ff    	lea    -0xa586(%ebx),%eax
c0023a20:	89 04 24             	mov    %eax,(%esp)
c0023a23:	89 f9                	mov    %edi,%ecx
c0023a25:	8d 83 0c 1c 00 00    	lea    0x1c0c(%ebx),%eax
c0023a2b:	e8 e9 fe ff ff       	call   c0023919 <init_pool>
}
c0023a30:	83 c4 10             	add    $0x10,%esp
c0023a33:	5b                   	pop    %ebx
c0023a34:	5e                   	pop    %esi
c0023a35:	5f                   	pop    %edi
c0023a36:	c3                   	ret    
c0023a37:	83 ec 0c             	sub    $0xc,%esp
c0023a3a:	8d 83 53 5a ff ff    	lea    -0xa5ad(%ebx),%eax
c0023a40:	50                   	push   %eax
c0023a41:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023a47:	50                   	push   %eax
c0023a48:	8d 83 44 3f ff ff    	lea    -0xc0bc(%ebx),%eax
c0023a4e:	50                   	push   %eax
c0023a4f:	6a 4a                	push   $0x4a
c0023a51:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c0023a57:	50                   	push   %eax
c0023a58:	e8 2a 58 00 00       	call   c0029287 <debug_panic>

c0023a5d <palloc_get_multiple>:
{
c0023a5d:	55                   	push   %ebp
c0023a5e:	57                   	push   %edi
c0023a5f:	56                   	push   %esi
c0023a60:	53                   	push   %ebx
c0023a61:	83 ec 0c             	sub    $0xc,%esp
c0023a64:	e8 1c b0 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023a69:	81 c3 4b 74 01 00    	add    $0x1744b,%ebx
c0023a6f:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023a73:	8b 44 24 20          	mov    0x20(%esp),%eax
c0023a77:	83 e0 04             	and    $0x4,%eax
c0023a7a:	8d b3 0c 1c 00 00    	lea    0x1c0c(%ebx),%esi
c0023a80:	8d 83 4c 1c 00 00    	lea    0x1c4c(%ebx),%eax
c0023a86:	0f 44 f0             	cmove  %eax,%esi
  if (page_cnt == 0)
c0023a89:	85 ed                	test   %ebp,%ebp
c0023a8b:	74 7e                	je     c0023b0b <palloc_get_multiple+0xae>
  lock_acquire (&pool->lock);
c0023a8d:	83 ec 0c             	sub    $0xc,%esp
c0023a90:	56                   	push   %esi
c0023a91:	e8 90 f8 ff ff       	call   c0023326 <lock_acquire>
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c0023a96:	6a 00                	push   $0x0
c0023a98:	55                   	push   %ebp
c0023a99:	6a 00                	push   $0x0
c0023a9b:	ff 76 24             	pushl  0x24(%esi)
c0023a9e:	e8 65 6d 00 00       	call   c002a808 <bitmap_scan_and_flip>
c0023aa3:	89 c7                	mov    %eax,%edi
  lock_release (&pool->lock);
c0023aa5:	83 c4 14             	add    $0x14,%esp
c0023aa8:	56                   	push   %esi
c0023aa9:	e8 70 fa ff ff       	call   c002351e <lock_release>
  if (page_idx != BITMAP_ERROR)
c0023aae:	83 c4 10             	add    $0x10,%esp
c0023ab1:	83 ff ff             	cmp    $0xffffffff,%edi
c0023ab4:	74 23                	je     c0023ad9 <palloc_get_multiple+0x7c>
    pages = pool->base + PGSIZE * page_idx;
c0023ab6:	c1 e7 0c             	shl    $0xc,%edi
  if (pages != NULL) 
c0023ab9:	03 7e 28             	add    0x28(%esi),%edi
c0023abc:	74 1b                	je     c0023ad9 <palloc_get_multiple+0x7c>
      if (flags & PAL_ZERO)
c0023abe:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c0023ac3:	74 20                	je     c0023ae5 <palloc_get_multiple+0x88>
        memset (pages, 0, PGSIZE * page_cnt);
c0023ac5:	c1 e5 0c             	shl    $0xc,%ebp
c0023ac8:	83 ec 04             	sub    $0x4,%esp
c0023acb:	55                   	push   %ebp
c0023acc:	6a 00                	push   $0x0
c0023ace:	57                   	push   %edi
c0023acf:	e8 32 4d 00 00       	call   c0028806 <memset>
c0023ad4:	83 c4 10             	add    $0x10,%esp
c0023ad7:	eb 0c                	jmp    c0023ae5 <palloc_get_multiple+0x88>
      if (flags & PAL_ASSERT)
c0023ad9:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c0023ade:	75 0f                	jne    c0023aef <palloc_get_multiple+0x92>
c0023ae0:	bf 00 00 00 00       	mov    $0x0,%edi
}
c0023ae5:	89 f8                	mov    %edi,%eax
c0023ae7:	83 c4 0c             	add    $0xc,%esp
c0023aea:	5b                   	pop    %ebx
c0023aeb:	5e                   	pop    %esi
c0023aec:	5f                   	pop    %edi
c0023aed:	5d                   	pop    %ebp
c0023aee:	c3                   	ret    
        PANIC ("palloc_get: out of pages");
c0023aef:	8d 83 84 5a ff ff    	lea    -0xa57c(%ebx),%eax
c0023af5:	50                   	push   %eax
c0023af6:	8d 83 24 3f ff ff    	lea    -0xc0dc(%ebx),%eax
c0023afc:	50                   	push   %eax
c0023afd:	6a 61                	push   $0x61
c0023aff:	8d 83 20 5a ff ff    	lea    -0xa5e0(%ebx),%eax
c0023b05:	50                   	push   %eax
c0023b06:	e8 7c 57 00 00       	call   c0029287 <debug_panic>
    return NULL;
c0023b0b:	bf 00 00 00 00       	mov    $0x0,%edi
c0023b10:	eb d3                	jmp    c0023ae5 <palloc_get_multiple+0x88>

c0023b12 <palloc_get_page>:
{
c0023b12:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple (flags, 1);
c0023b15:	6a 01                	push   $0x1
c0023b17:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023b1b:	e8 3d ff ff ff       	call   c0023a5d <palloc_get_multiple>
}
c0023b20:	83 c4 1c             	add    $0x1c,%esp
c0023b23:	c3                   	ret    

c0023b24 <palloc_free_multiple>:
{
c0023b24:	55                   	push   %ebp
c0023b25:	57                   	push   %edi
c0023b26:	56                   	push   %esi
c0023b27:	53                   	push   %ebx
c0023b28:	83 ec 0c             	sub    $0xc,%esp
c0023b2b:	e8 55 af 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023b30:	81 c3 84 73 01 00    	add    $0x17384,%ebx
c0023b36:	8b 74 24 20          	mov    0x20(%esp),%esi
  ASSERT (pg_ofs (pages) == 0);
c0023b3a:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c0023b40:	0f 85 9d 00 00 00    	jne    c0023be3 <palloc_free_multiple+0xbf>
  if (pages == NULL || page_cnt == 0)
c0023b46:	85 f6                	test   %esi,%esi
c0023b48:	0f 84 8d 00 00 00    	je     c0023bdb <palloc_free_multiple+0xb7>
c0023b4e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0023b53:	0f 84 82 00 00 00    	je     c0023bdb <palloc_free_multiple+0xb7>
  return (uintptr_t) va >> PGBITS;
c0023b59:	89 f7                	mov    %esi,%edi
c0023b5b:	c1 ef 0c             	shr    $0xc,%edi
c0023b5e:	8b 83 74 1c 00 00    	mov    0x1c74(%ebx),%eax
c0023b64:	c1 e8 0c             	shr    $0xc,%eax
c0023b67:	89 c5                	mov    %eax,%ebp
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023b69:	83 ec 0c             	sub    $0xc,%esp
c0023b6c:	ff b3 70 1c 00 00    	pushl  0x1c70(%ebx)
c0023b72:	e8 01 66 00 00       	call   c002a178 <bitmap_size>
c0023b77:	89 ea                	mov    %ebp,%edx
c0023b79:	01 e8                	add    %ebp,%eax

  return page_no >= start_page && page_no < end_page;
c0023b7b:	83 c4 10             	add    $0x10,%esp
  if (page_from_pool (&kernel_pool, pages))
c0023b7e:	39 c7                	cmp    %eax,%edi
c0023b80:	0f 83 83 00 00 00    	jae    c0023c09 <palloc_free_multiple+0xe5>
    pool = &kernel_pool;
c0023b86:	8d ab 4c 1c 00 00    	lea    0x1c4c(%ebx),%ebp
  if (page_from_pool (&kernel_pool, pages))
c0023b8c:	39 d7                	cmp    %edx,%edi
c0023b8e:	72 79                	jb     c0023c09 <palloc_free_multiple+0xe5>
c0023b90:	8b 45 28             	mov    0x28(%ebp),%eax
c0023b93:	c1 e8 0c             	shr    $0xc,%eax
  page_idx = pg_no (pages) - pg_no (pool->base);
c0023b96:	29 c7                	sub    %eax,%edi
  memset (pages, 0xcc, PGSIZE * page_cnt);
c0023b98:	83 ec 04             	sub    $0x4,%esp
c0023b9b:	8b 44 24 28          	mov    0x28(%esp),%eax
c0023b9f:	c1 e0 0c             	shl    $0xc,%eax
c0023ba2:	50                   	push   %eax
c0023ba3:	68 cc 00 00 00       	push   $0xcc
c0023ba8:	56                   	push   %esi
c0023ba9:	e8 58 4c 00 00       	call   c0028806 <memset>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023bae:	83 c4 0c             	add    $0xc,%esp
c0023bb1:	ff 74 24 28          	pushl  0x28(%esp)
c0023bb5:	57                   	push   %edi
c0023bb6:	ff 75 24             	pushl  0x24(%ebp)
c0023bb9:	e8 5d 6b 00 00       	call   c002a71b <bitmap_all>
c0023bbe:	83 c4 10             	add    $0x10,%esp
c0023bc1:	84 c0                	test   %al,%al
c0023bc3:	0f 84 8e 00 00 00    	je     c0023c57 <palloc_free_multiple+0x133>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023bc9:	6a 00                	push   $0x0
c0023bcb:	ff 74 24 28          	pushl  0x28(%esp)
c0023bcf:	57                   	push   %edi
c0023bd0:	ff 75 24             	pushl  0x24(%ebp)
c0023bd3:	e8 25 67 00 00       	call   c002a2fd <bitmap_set_multiple>
c0023bd8:	83 c4 10             	add    $0x10,%esp
}
c0023bdb:	83 c4 0c             	add    $0xc,%esp
c0023bde:	5b                   	pop    %ebx
c0023bdf:	5e                   	pop    %esi
c0023be0:	5f                   	pop    %edi
c0023be1:	5d                   	pop    %ebp
c0023be2:	c3                   	ret    
  ASSERT (pg_ofs (pages) == 0);
c0023be3:	83 ec 0c             	sub    $0xc,%esp
c0023be6:	8d 83 9d 5a ff ff    	lea    -0xa563(%ebx),%eax
c0023bec:	50                   	push   %eax
c0023bed:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023bf3:	50                   	push   %eax
c0023bf4:	8d 83 0c 3f ff ff    	lea    -0xc0f4(%ebx),%eax
c0023bfa:	50                   	push   %eax
c0023bfb:	6a 7b                	push   $0x7b
c0023bfd:	8d 83 20 5a ff ff    	lea    -0xa5e0(%ebx),%eax
c0023c03:	50                   	push   %eax
c0023c04:	e8 7e 56 00 00       	call   c0029287 <debug_panic>
c0023c09:	8b ab 34 1c 00 00    	mov    0x1c34(%ebx),%ebp
c0023c0f:	c1 ed 0c             	shr    $0xc,%ebp
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023c12:	83 ec 0c             	sub    $0xc,%esp
c0023c15:	ff b3 30 1c 00 00    	pushl  0x1c30(%ebx)
c0023c1b:	e8 58 65 00 00       	call   c002a178 <bitmap_size>
c0023c20:	01 e8                	add    %ebp,%eax
  return page_no >= start_page && page_no < end_page;
c0023c22:	83 c4 10             	add    $0x10,%esp
  else if (page_from_pool (&user_pool, pages))
c0023c25:	39 c7                	cmp    %eax,%edi
c0023c27:	73 0f                	jae    c0023c38 <palloc_free_multiple+0x114>
c0023c29:	39 ef                	cmp    %ebp,%edi
c0023c2b:	72 0b                	jb     c0023c38 <palloc_free_multiple+0x114>
    pool = &user_pool;
c0023c2d:	8d ab 0c 1c 00 00    	lea    0x1c0c(%ebx),%ebp
c0023c33:	e9 58 ff ff ff       	jmp    c0023b90 <palloc_free_multiple+0x6c>
    NOT_REACHED ();
c0023c38:	8d 83 54 55 ff ff    	lea    -0xaaac(%ebx),%eax
c0023c3e:	50                   	push   %eax
c0023c3f:	8d 83 0c 3f ff ff    	lea    -0xc0f4(%ebx),%eax
c0023c45:	50                   	push   %eax
c0023c46:	68 84 00 00 00       	push   $0x84
c0023c4b:	8d 83 20 5a ff ff    	lea    -0xa5e0(%ebx),%eax
c0023c51:	50                   	push   %eax
c0023c52:	e8 30 56 00 00       	call   c0029287 <debug_panic>
  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023c57:	83 ec 0c             	sub    $0xc,%esp
c0023c5a:	8d 83 f0 59 ff ff    	lea    -0xa610(%ebx),%eax
c0023c60:	50                   	push   %eax
c0023c61:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023c67:	50                   	push   %eax
c0023c68:	8d 83 0c 3f ff ff    	lea    -0xc0f4(%ebx),%eax
c0023c6e:	50                   	push   %eax
c0023c6f:	68 8c 00 00 00       	push   $0x8c
c0023c74:	8d 83 20 5a ff ff    	lea    -0xa5e0(%ebx),%eax
c0023c7a:	50                   	push   %eax
c0023c7b:	e8 07 56 00 00       	call   c0029287 <debug_panic>

c0023c80 <palloc_free_page>:
{
c0023c80:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple (page, 1);
c0023c83:	6a 01                	push   $0x1
c0023c85:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023c89:	e8 96 fe ff ff       	call   c0023b24 <palloc_free_multiple>
}
c0023c8e:	83 c4 1c             	add    $0x1c,%esp
c0023c91:	c3                   	ret    

c0023c92 <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023c92:	53                   	push   %ebx
c0023c93:	83 ec 08             	sub    $0x8,%esp
c0023c96:	e8 ea ad 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023c9b:	81 c3 19 72 01 00    	add    $0x17219,%ebx
  ASSERT (a != NULL);
c0023ca1:	85 c0                	test   %eax,%eax
c0023ca3:	74 1c                	je     c0023cc1 <arena_to_block+0x2f>
  ASSERT (a->magic == ARENA_MAGIC);
c0023ca5:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c0023cab:	75 3d                	jne    c0023cea <arena_to_block+0x58>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023cad:	8b 48 04             	mov    0x4(%eax),%ecx
c0023cb0:	39 51 04             	cmp    %edx,0x4(%ecx)
c0023cb3:	76 5e                	jbe    c0023d13 <arena_to_block+0x81>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023cb5:	0f af 11             	imul   (%ecx),%edx
  return (struct block *) ((uint8_t *) a
c0023cb8:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c0023cbc:	83 c4 08             	add    $0x8,%esp
c0023cbf:	5b                   	pop    %ebx
c0023cc0:	c3                   	ret    
  ASSERT (a != NULL);
c0023cc1:	83 ec 0c             	sub    $0xc,%esp
c0023cc4:	8d 83 21 59 ff ff    	lea    -0xa6df(%ebx),%eax
c0023cca:	50                   	push   %eax
c0023ccb:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023cd1:	50                   	push   %eax
c0023cd2:	8d 83 64 3f ff ff    	lea    -0xc09c(%ebx),%eax
c0023cd8:	50                   	push   %eax
c0023cd9:	68 20 01 00 00       	push   $0x120
c0023cde:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023ce4:	50                   	push   %eax
c0023ce5:	e8 9d 55 00 00       	call   c0029287 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023cea:	83 ec 0c             	sub    $0xc,%esp
c0023ced:	8d 83 c8 5a ff ff    	lea    -0xa538(%ebx),%eax
c0023cf3:	50                   	push   %eax
c0023cf4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023cfa:	50                   	push   %eax
c0023cfb:	8d 83 64 3f ff ff    	lea    -0xc09c(%ebx),%eax
c0023d01:	50                   	push   %eax
c0023d02:	68 21 01 00 00       	push   $0x121
c0023d07:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023d0d:	50                   	push   %eax
c0023d0e:	e8 74 55 00 00       	call   c0029287 <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023d13:	83 ec 0c             	sub    $0xc,%esp
c0023d16:	8d 83 e0 5a ff ff    	lea    -0xa520(%ebx),%eax
c0023d1c:	50                   	push   %eax
c0023d1d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023d23:	50                   	push   %eax
c0023d24:	8d 83 64 3f ff ff    	lea    -0xc09c(%ebx),%eax
c0023d2a:	50                   	push   %eax
c0023d2b:	68 22 01 00 00       	push   $0x122
c0023d30:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023d36:	50                   	push   %eax
c0023d37:	e8 4b 55 00 00       	call   c0029287 <debug_panic>

c0023d3c <block_to_arena>:
{
c0023d3c:	56                   	push   %esi
c0023d3d:	53                   	push   %ebx
c0023d3e:	83 ec 04             	sub    $0x4,%esp
c0023d41:	e8 3f ad 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023d46:	81 c3 6e 71 01 00    	add    $0x1716e,%ebx
  ASSERT (a != NULL);
c0023d4c:	89 c1                	mov    %eax,%ecx
c0023d4e:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0023d54:	74 2e                	je     c0023d84 <block_to_arena+0x48>
  ASSERT (a->magic == ARENA_MAGIC);
c0023d56:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023d5c:	75 4f                	jne    c0023dad <block_to_arena+0x71>
  ASSERT (a->desc == NULL
c0023d5e:	8b 71 04             	mov    0x4(%ecx),%esi
c0023d61:	85 f6                	test   %esi,%esi
c0023d63:	0f 84 96 00 00 00    	je     c0023dff <block_to_arena+0xc3>
  return (uintptr_t) va & PGMASK;
c0023d69:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023d6e:	83 e8 0c             	sub    $0xc,%eax
c0023d71:	ba 00 00 00 00       	mov    $0x0,%edx
c0023d76:	f7 36                	divl   (%esi)
c0023d78:	85 d2                	test   %edx,%edx
c0023d7a:	75 5a                	jne    c0023dd6 <block_to_arena+0x9a>
}
c0023d7c:	89 c8                	mov    %ecx,%eax
c0023d7e:	83 c4 04             	add    $0x4,%esp
c0023d81:	5b                   	pop    %ebx
c0023d82:	5e                   	pop    %esi
c0023d83:	c3                   	ret    
  ASSERT (a != NULL);
c0023d84:	83 ec 0c             	sub    $0xc,%esp
c0023d87:	8d 83 21 59 ff ff    	lea    -0xa6df(%ebx),%eax
c0023d8d:	50                   	push   %eax
c0023d8e:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023d94:	50                   	push   %eax
c0023d95:	8d 83 54 3f ff ff    	lea    -0xc0ac(%ebx),%eax
c0023d9b:	50                   	push   %eax
c0023d9c:	68 11 01 00 00       	push   $0x111
c0023da1:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023da7:	50                   	push   %eax
c0023da8:	e8 da 54 00 00       	call   c0029287 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023dad:	83 ec 0c             	sub    $0xc,%esp
c0023db0:	8d 83 c8 5a ff ff    	lea    -0xa538(%ebx),%eax
c0023db6:	50                   	push   %eax
c0023db7:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023dbd:	50                   	push   %eax
c0023dbe:	8d 83 54 3f ff ff    	lea    -0xc0ac(%ebx),%eax
c0023dc4:	50                   	push   %eax
c0023dc5:	68 12 01 00 00       	push   $0x112
c0023dca:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023dd0:	50                   	push   %eax
c0023dd1:	e8 b1 54 00 00       	call   c0029287 <debug_panic>
  ASSERT (a->desc == NULL
c0023dd6:	83 ec 0c             	sub    $0xc,%esp
c0023dd9:	8d 83 00 5b ff ff    	lea    -0xa500(%ebx),%eax
c0023ddf:	50                   	push   %eax
c0023de0:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023de6:	50                   	push   %eax
c0023de7:	8d 83 54 3f ff ff    	lea    -0xc0ac(%ebx),%eax
c0023ded:	50                   	push   %eax
c0023dee:	68 16 01 00 00       	push   $0x116
c0023df3:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023df9:	50                   	push   %eax
c0023dfa:	e8 88 54 00 00       	call   c0029287 <debug_panic>
c0023dff:	25 ff 0f 00 00       	and    $0xfff,%eax
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023e04:	83 f8 0c             	cmp    $0xc,%eax
c0023e07:	0f 84 6f ff ff ff    	je     c0023d7c <block_to_arena+0x40>
c0023e0d:	83 ec 0c             	sub    $0xc,%esp
c0023e10:	8d 83 48 5b ff ff    	lea    -0xa4b8(%ebx),%eax
c0023e16:	50                   	push   %eax
c0023e17:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023e1d:	50                   	push   %eax
c0023e1e:	8d 83 54 3f ff ff    	lea    -0xc0ac(%ebx),%eax
c0023e24:	50                   	push   %eax
c0023e25:	68 17 01 00 00       	push   $0x117
c0023e2a:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023e30:	50                   	push   %eax
c0023e31:	e8 51 54 00 00       	call   c0029287 <debug_panic>

c0023e36 <malloc_init>:
{
c0023e36:	55                   	push   %ebp
c0023e37:	57                   	push   %edi
c0023e38:	56                   	push   %esi
c0023e39:	53                   	push   %ebx
c0023e3a:	83 ec 0c             	sub    $0xc,%esp
c0023e3d:	e8 43 ac 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023e42:	81 c3 72 70 01 00    	add    $0x17072,%ebx
      struct desc *d = &descs[desc_cnt++];
c0023e48:	8b b3 8c 1c 00 00    	mov    0x1c8c(%ebx),%esi
c0023e4e:	8d 46 01             	lea    0x1(%esi),%eax
c0023e51:	89 83 8c 1c 00 00    	mov    %eax,0x1c8c(%ebx)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023e57:	83 f8 0a             	cmp    $0xa,%eax
c0023e5a:	0f 87 a1 00 00 00    	ja     c0023f01 <malloc_init+0xcb>
      d->block_size = block_size;
c0023e60:	8d bb ac 1c 00 00    	lea    0x1cac(%ebx),%edi
c0023e66:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023e69:	c7 84 33 ac 1c 00 00 	movl   $0x10,0x1cac(%ebx,%esi,1)
c0023e70:	10 00 00 00 
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023e74:	c7 84 33 b0 1c 00 00 	movl   $0xff,0x1cb0(%ebx,%esi,1)
c0023e7b:	ff 00 00 00 
      list_init (&d->free_list);
c0023e7f:	83 ec 0c             	sub    $0xc,%esp
c0023e82:	8d 44 37 08          	lea    0x8(%edi,%esi,1),%eax
c0023e86:	50                   	push   %eax
c0023e87:	e8 c8 54 00 00       	call   c0029354 <list_init>
      lock_init (&d->lock);
c0023e8c:	8d 44 37 18          	lea    0x18(%edi,%esi,1),%eax
c0023e90:	89 04 24             	mov    %eax,(%esp)
c0023e93:	e8 e2 f3 ff ff       	call   c002327a <lock_init>
c0023e98:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023e9b:	bf 20 00 00 00       	mov    $0x20,%edi
      d->block_size = block_size;
c0023ea0:	8d ab ac 1c 00 00    	lea    0x1cac(%ebx),%ebp
      struct desc *d = &descs[desc_cnt++];
c0023ea6:	8b b3 8c 1c 00 00    	mov    0x1c8c(%ebx),%esi
c0023eac:	8d 46 01             	lea    0x1(%esi),%eax
c0023eaf:	89 83 8c 1c 00 00    	mov    %eax,0x1c8c(%ebx)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023eb5:	83 f8 0a             	cmp    $0xa,%eax
c0023eb8:	77 47                	ja     c0023f01 <malloc_init+0xcb>
      d->block_size = block_size;
c0023eba:	6b f6 3c             	imul   $0x3c,%esi,%esi
c0023ebd:	89 3c 2e             	mov    %edi,(%esi,%ebp,1)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023ec0:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023ec5:	ba 00 00 00 00       	mov    $0x0,%edx
c0023eca:	f7 f7                	div    %edi
c0023ecc:	89 84 33 b0 1c 00 00 	mov    %eax,0x1cb0(%ebx,%esi,1)
      list_init (&d->free_list);
c0023ed3:	83 ec 0c             	sub    $0xc,%esp
c0023ed6:	8d 44 2e 08          	lea    0x8(%esi,%ebp,1),%eax
c0023eda:	50                   	push   %eax
c0023edb:	e8 74 54 00 00       	call   c0029354 <list_init>
      lock_init (&d->lock);
c0023ee0:	8d 44 2e 18          	lea    0x18(%esi,%ebp,1),%eax
c0023ee4:	89 04 24             	mov    %eax,(%esp)
c0023ee7:	e8 8e f3 ff ff       	call   c002327a <lock_init>
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023eec:	01 ff                	add    %edi,%edi
c0023eee:	83 c4 10             	add    $0x10,%esp
c0023ef1:	81 ff ff 07 00 00    	cmp    $0x7ff,%edi
c0023ef7:	76 ad                	jbe    c0023ea6 <malloc_init+0x70>
}
c0023ef9:	83 c4 0c             	add    $0xc,%esp
c0023efc:	5b                   	pop    %ebx
c0023efd:	5e                   	pop    %esi
c0023efe:	5f                   	pop    %edi
c0023eff:	5d                   	pop    %ebp
c0023f00:	c3                   	ret    
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023f01:	83 ec 0c             	sub    $0xc,%esp
c0023f04:	8d 83 74 5b ff ff    	lea    -0xa48c(%ebx),%eax
c0023f0a:	50                   	push   %eax
c0023f0b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0023f11:	50                   	push   %eax
c0023f12:	8d 83 74 3f ff ff    	lea    -0xc08c(%ebx),%eax
c0023f18:	50                   	push   %eax
c0023f19:	6a 4f                	push   $0x4f
c0023f1b:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c0023f21:	50                   	push   %eax
c0023f22:	e8 60 53 00 00       	call   c0029287 <debug_panic>

c0023f27 <malloc>:
{
c0023f27:	55                   	push   %ebp
c0023f28:	57                   	push   %edi
c0023f29:	56                   	push   %esi
c0023f2a:	53                   	push   %ebx
c0023f2b:	83 ec 1c             	sub    $0x1c,%esp
c0023f2e:	e8 52 ab 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0023f33:	81 c3 81 6f 01 00    	add    $0x16f81,%ebx
c0023f39:	8b 54 24 30          	mov    0x30(%esp),%edx
  if (size == 0)
c0023f3d:	85 d2                	test   %edx,%edx
c0023f3f:	0f 84 2e 01 00 00    	je     c0024073 <malloc+0x14c>
  for (d = descs; d < descs + desc_cnt; d++)
c0023f45:	6b 83 8c 1c 00 00 3c 	imul   $0x3c,0x1c8c(%ebx),%eax
c0023f4c:	8d 8b ac 1c 00 00    	lea    0x1cac(%ebx),%ecx
c0023f52:	01 c8                	add    %ecx,%eax
c0023f54:	39 c8                	cmp    %ecx,%eax
c0023f56:	0f 86 c3 00 00 00    	jbe    c002401f <malloc+0xf8>
    if (d->block_size >= size)
c0023f5c:	3b 93 ac 1c 00 00    	cmp    0x1cac(%ebx),%edx
c0023f62:	0f 86 19 01 00 00    	jbe    c0024081 <malloc+0x15a>
  for (d = descs; d < descs + desc_cnt; d++)
c0023f68:	89 ce                	mov    %ecx,%esi
c0023f6a:	83 c6 3c             	add    $0x3c,%esi
c0023f6d:	39 c6                	cmp    %eax,%esi
c0023f6f:	0f 83 b0 00 00 00    	jae    c0024025 <malloc+0xfe>
    if (d->block_size >= size)
c0023f75:	39 16                	cmp    %edx,(%esi)
c0023f77:	72 f1                	jb     c0023f6a <malloc+0x43>
  lock_acquire (&d->lock);
c0023f79:	8d 46 18             	lea    0x18(%esi),%eax
c0023f7c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023f80:	83 ec 0c             	sub    $0xc,%esp
c0023f83:	50                   	push   %eax
c0023f84:	e8 9d f3 ff ff       	call   c0023326 <lock_acquire>
  if (list_empty (&d->free_list))
c0023f89:	8d 6e 08             	lea    0x8(%esi),%ebp
c0023f8c:	89 2c 24             	mov    %ebp,(%esp)
c0023f8f:	e8 65 5a 00 00       	call   c00299f9 <list_empty>
c0023f94:	83 c4 10             	add    $0x10,%esp
c0023f97:	84 c0                	test   %al,%al
c0023f99:	74 57                	je     c0023ff2 <malloc+0xcb>
      a = palloc_get_page (0);
c0023f9b:	83 ec 0c             	sub    $0xc,%esp
c0023f9e:	6a 00                	push   $0x0
c0023fa0:	e8 6d fb ff ff       	call   c0023b12 <palloc_get_page>
c0023fa5:	89 44 24 18          	mov    %eax,0x18(%esp)
      if (a == NULL) 
c0023fa9:	83 c4 10             	add    $0x10,%esp
c0023fac:	85 c0                	test   %eax,%eax
c0023fae:	0f 84 a9 00 00 00    	je     c002405d <malloc+0x136>
      a->magic = ARENA_MAGIC;
c0023fb4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0023fb8:	c7 01 ed 8e 54 9a    	movl   $0x9a548eed,(%ecx)
      a->desc = d;
c0023fbe:	89 71 04             	mov    %esi,0x4(%ecx)
      a->free_cnt = d->blocks_per_arena;
c0023fc1:	8b 46 04             	mov    0x4(%esi),%eax
c0023fc4:	89 41 08             	mov    %eax,0x8(%ecx)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023fc7:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0023fcb:	74 25                	je     c0023ff2 <malloc+0xcb>
c0023fcd:	bf 00 00 00 00       	mov    $0x0,%edi
          struct block *b = arena_to_block (a, i);
c0023fd2:	89 fa                	mov    %edi,%edx
c0023fd4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023fd8:	e8 b5 fc ff ff       	call   c0023c92 <arena_to_block>
          list_push_back (&d->free_list, &b->free_elem);
c0023fdd:	83 ec 08             	sub    $0x8,%esp
c0023fe0:	50                   	push   %eax
c0023fe1:	55                   	push   %ebp
c0023fe2:	e8 53 59 00 00       	call   c002993a <list_push_back>
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023fe7:	83 c7 01             	add    $0x1,%edi
c0023fea:	83 c4 10             	add    $0x10,%esp
c0023fed:	39 7e 04             	cmp    %edi,0x4(%esi)
c0023ff0:	77 e0                	ja     c0023fd2 <malloc+0xab>
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023ff2:	83 ec 0c             	sub    $0xc,%esp
c0023ff5:	55                   	push   %ebp
c0023ff6:	e8 75 5a 00 00       	call   c0029a70 <list_pop_front>
c0023ffb:	89 c6                	mov    %eax,%esi
  a = block_to_arena (b);
c0023ffd:	e8 3a fd ff ff       	call   c0023d3c <block_to_arena>
  a->free_cnt--;
c0024002:	83 68 08 01          	subl   $0x1,0x8(%eax)
  lock_release (&d->lock);
c0024006:	83 c4 04             	add    $0x4,%esp
c0024009:	ff 74 24 18          	pushl  0x18(%esp)
c002400d:	e8 0c f5 ff ff       	call   c002351e <lock_release>
  return b;
c0024012:	83 c4 10             	add    $0x10,%esp
}
c0024015:	89 f0                	mov    %esi,%eax
c0024017:	83 c4 1c             	add    $0x1c,%esp
c002401a:	5b                   	pop    %ebx
c002401b:	5e                   	pop    %esi
c002401c:	5f                   	pop    %edi
c002401d:	5d                   	pop    %ebp
c002401e:	c3                   	ret    
  for (d = descs; d < descs + desc_cnt; d++)
c002401f:	8d b3 ac 1c 00 00    	lea    0x1cac(%ebx),%esi
  if (d == descs + desc_cnt) 
c0024025:	39 f0                	cmp    %esi,%eax
c0024027:	0f 85 4c ff ff ff    	jne    c0023f79 <malloc+0x52>
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c002402d:	8d b2 0b 10 00 00    	lea    0x100b(%edx),%esi
c0024033:	c1 ee 0c             	shr    $0xc,%esi
      a = palloc_get_multiple (0, page_cnt);
c0024036:	83 ec 08             	sub    $0x8,%esp
c0024039:	56                   	push   %esi
c002403a:	6a 00                	push   $0x0
c002403c:	e8 1c fa ff ff       	call   c0023a5d <palloc_get_multiple>
      if (a == NULL)
c0024041:	83 c4 10             	add    $0x10,%esp
c0024044:	85 c0                	test   %eax,%eax
c0024046:	74 32                	je     c002407a <malloc+0x153>
      a->magic = ARENA_MAGIC;
c0024048:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c002404e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0024055:	89 70 08             	mov    %esi,0x8(%eax)
      return a + 1;
c0024058:	8d 70 0c             	lea    0xc(%eax),%esi
c002405b:	eb b8                	jmp    c0024015 <malloc+0xee>
          lock_release (&d->lock);
c002405d:	83 ec 0c             	sub    $0xc,%esp
c0024060:	ff 74 24 18          	pushl  0x18(%esp)
c0024064:	e8 b5 f4 ff ff       	call   c002351e <lock_release>
          return NULL; 
c0024069:	83 c4 10             	add    $0x10,%esp
c002406c:	be 00 00 00 00       	mov    $0x0,%esi
c0024071:	eb a2                	jmp    c0024015 <malloc+0xee>
    return NULL;
c0024073:	be 00 00 00 00       	mov    $0x0,%esi
c0024078:	eb 9b                	jmp    c0024015 <malloc+0xee>
        return NULL;
c002407a:	be 00 00 00 00       	mov    $0x0,%esi
c002407f:	eb 94                	jmp    c0024015 <malloc+0xee>
  for (d = descs; d < descs + desc_cnt; d++)
c0024081:	8d b3 ac 1c 00 00    	lea    0x1cac(%ebx),%esi
c0024087:	e9 ed fe ff ff       	jmp    c0023f79 <malloc+0x52>

c002408c <calloc>:
{
c002408c:	57                   	push   %edi
c002408d:	56                   	push   %esi
c002408e:	53                   	push   %ebx
c002408f:	e8 f1 a9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024094:	81 c3 20 6e 01 00    	add    $0x16e20,%ebx
c002409a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002409e:	8b 54 24 14          	mov    0x14(%esp),%edx
  size = a * b;
c00240a2:	89 c6                	mov    %eax,%esi
c00240a4:	0f af f2             	imul   %edx,%esi
  if (size < a || size < b)
c00240a7:	39 f0                	cmp    %esi,%eax
c00240a9:	77 2b                	ja     c00240d6 <calloc+0x4a>
c00240ab:	39 f2                	cmp    %esi,%edx
c00240ad:	77 27                	ja     c00240d6 <calloc+0x4a>
  p = malloc (size);
c00240af:	83 ec 0c             	sub    $0xc,%esp
c00240b2:	56                   	push   %esi
c00240b3:	e8 6f fe ff ff       	call   c0023f27 <malloc>
c00240b8:	89 c7                	mov    %eax,%edi
  if (p != NULL)
c00240ba:	83 c4 10             	add    $0x10,%esp
c00240bd:	85 c0                	test   %eax,%eax
c00240bf:	74 0f                	je     c00240d0 <calloc+0x44>
    memset (p, 0, size);
c00240c1:	83 ec 04             	sub    $0x4,%esp
c00240c4:	56                   	push   %esi
c00240c5:	6a 00                	push   $0x0
c00240c7:	50                   	push   %eax
c00240c8:	e8 39 47 00 00       	call   c0028806 <memset>
c00240cd:	83 c4 10             	add    $0x10,%esp
}
c00240d0:	89 f8                	mov    %edi,%eax
c00240d2:	5b                   	pop    %ebx
c00240d3:	5e                   	pop    %esi
c00240d4:	5f                   	pop    %edi
c00240d5:	c3                   	ret    
    return NULL;
c00240d6:	bf 00 00 00 00       	mov    $0x0,%edi
c00240db:	eb f3                	jmp    c00240d0 <calloc+0x44>

c00240dd <free>:
{
c00240dd:	55                   	push   %ebp
c00240de:	57                   	push   %edi
c00240df:	56                   	push   %esi
c00240e0:	53                   	push   %ebx
c00240e1:	83 ec 1c             	sub    $0x1c,%esp
c00240e4:	e8 9c a9 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00240e9:	81 c3 cb 6d 01 00    	add    $0x16dcb,%ebx
c00240ef:	8b 74 24 30          	mov    0x30(%esp),%esi
  if (p != NULL)
c00240f3:	85 f6                	test   %esi,%esi
c00240f5:	0f 84 98 00 00 00    	je     c0024193 <free+0xb6>
      struct arena *a = block_to_arena (b);
c00240fb:	89 f0                	mov    %esi,%eax
c00240fd:	e8 3a fc ff ff       	call   c0023d3c <block_to_arena>
c0024102:	89 c5                	mov    %eax,%ebp
      struct desc *d = a->desc;
c0024104:	8b 78 04             	mov    0x4(%eax),%edi
      if (d != NULL) 
c0024107:	85 ff                	test   %edi,%edi
c0024109:	0f 84 b5 00 00 00    	je     c00241c4 <free+0xe7>
          memset (b, 0xcc, d->block_size);
c002410f:	83 ec 04             	sub    $0x4,%esp
c0024112:	ff 37                	pushl  (%edi)
c0024114:	68 cc 00 00 00       	push   $0xcc
c0024119:	56                   	push   %esi
c002411a:	e8 e7 46 00 00       	call   c0028806 <memset>
          lock_acquire (&d->lock);
c002411f:	8d 47 18             	lea    0x18(%edi),%eax
c0024122:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0024126:	89 04 24             	mov    %eax,(%esp)
c0024129:	e8 f8 f1 ff ff       	call   c0023326 <lock_acquire>
          list_push_front (&d->free_list, &b->free_elem);
c002412e:	83 c4 08             	add    $0x8,%esp
c0024131:	56                   	push   %esi
c0024132:	8d 47 08             	lea    0x8(%edi),%eax
c0024135:	50                   	push   %eax
c0024136:	e8 e2 57 00 00       	call   c002991d <list_push_front>
          if (++a->free_cnt >= d->blocks_per_arena) 
c002413b:	8b 45 08             	mov    0x8(%ebp),%eax
c002413e:	83 c0 01             	add    $0x1,%eax
c0024141:	89 45 08             	mov    %eax,0x8(%ebp)
c0024144:	8b 57 04             	mov    0x4(%edi),%edx
c0024147:	83 c4 10             	add    $0x10,%esp
c002414a:	39 d0                	cmp    %edx,%eax
c002414c:	72 36                	jb     c0024184 <free+0xa7>
              ASSERT (a->free_cnt == d->blocks_per_arena);
c002414e:	39 d0                	cmp    %edx,%eax
c0024150:	75 49                	jne    c002419b <free+0xbe>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0024152:	be 00 00 00 00       	mov    $0x0,%esi
c0024157:	85 c0                	test   %eax,%eax
c0024159:	74 1d                	je     c0024178 <free+0x9b>
                  struct block *b = arena_to_block (a, i);
c002415b:	89 f2                	mov    %esi,%edx
c002415d:	89 e8                	mov    %ebp,%eax
c002415f:	e8 2e fb ff ff       	call   c0023c92 <arena_to_block>
                  list_remove (&b->free_elem);
c0024164:	83 ec 0c             	sub    $0xc,%esp
c0024167:	50                   	push   %eax
c0024168:	e8 ea 57 00 00       	call   c0029957 <list_remove>
              for (i = 0; i < d->blocks_per_arena; i++) 
c002416d:	83 c6 01             	add    $0x1,%esi
c0024170:	83 c4 10             	add    $0x10,%esp
c0024173:	39 77 04             	cmp    %esi,0x4(%edi)
c0024176:	77 e3                	ja     c002415b <free+0x7e>
              palloc_free_page (a);
c0024178:	83 ec 0c             	sub    $0xc,%esp
c002417b:	55                   	push   %ebp
c002417c:	e8 ff fa ff ff       	call   c0023c80 <palloc_free_page>
c0024181:	83 c4 10             	add    $0x10,%esp
          lock_release (&d->lock);
c0024184:	83 ec 0c             	sub    $0xc,%esp
c0024187:	ff 74 24 18          	pushl  0x18(%esp)
c002418b:	e8 8e f3 ff ff       	call   c002351e <lock_release>
c0024190:	83 c4 10             	add    $0x10,%esp
}
c0024193:	83 c4 1c             	add    $0x1c,%esp
c0024196:	5b                   	pop    %ebx
c0024197:	5e                   	pop    %esi
c0024198:	5f                   	pop    %edi
c0024199:	5d                   	pop    %ebp
c002419a:	c3                   	ret    
              ASSERT (a->free_cnt == d->blocks_per_arena);
c002419b:	83 ec 0c             	sub    $0xc,%esp
c002419e:	8d 83 a0 5b ff ff    	lea    -0xa460(%ebx),%eax
c00241a4:	50                   	push   %eax
c00241a5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00241ab:	50                   	push   %eax
c00241ac:	8d 83 4c 3f ff ff    	lea    -0xc0b4(%ebx),%eax
c00241b2:	50                   	push   %eax
c00241b3:	68 f6 00 00 00       	push   $0xf6
c00241b8:	8d 83 b1 5a ff ff    	lea    -0xa54f(%ebx),%eax
c00241be:	50                   	push   %eax
c00241bf:	e8 c3 50 00 00       	call   c0029287 <debug_panic>
          palloc_free_multiple (a, a->free_cnt);
c00241c4:	83 ec 08             	sub    $0x8,%esp
c00241c7:	ff 70 08             	pushl  0x8(%eax)
c00241ca:	50                   	push   %eax
c00241cb:	e8 54 f9 ff ff       	call   c0023b24 <palloc_free_multiple>
          return;
c00241d0:	83 c4 10             	add    $0x10,%esp
c00241d3:	eb be                	jmp    c0024193 <free+0xb6>

c00241d5 <realloc>:
{
c00241d5:	55                   	push   %ebp
c00241d6:	57                   	push   %edi
c00241d7:	56                   	push   %esi
c00241d8:	53                   	push   %ebx
c00241d9:	83 ec 0c             	sub    $0xc,%esp
c00241dc:	e8 a4 a8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00241e1:	81 c3 d3 6c 01 00    	add    $0x16cd3,%ebx
c00241e7:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00241eb:	8b 74 24 24          	mov    0x24(%esp),%esi
  if (new_size == 0) 
c00241ef:	85 f6                	test   %esi,%esi
c00241f1:	74 4b                	je     c002423e <realloc+0x69>
      void *new_block = malloc (new_size);
c00241f3:	83 ec 0c             	sub    $0xc,%esp
c00241f6:	56                   	push   %esi
c00241f7:	e8 2b fd ff ff       	call   c0023f27 <malloc>
c00241fc:	89 c5                	mov    %eax,%ebp
      if (old_block != NULL && new_block != NULL)
c00241fe:	83 c4 10             	add    $0x10,%esp
c0024201:	85 ff                	test   %edi,%edi
c0024203:	74 2f                	je     c0024234 <realloc+0x5f>
c0024205:	85 c0                	test   %eax,%eax
c0024207:	74 2b                	je     c0024234 <realloc+0x5f>
  struct arena *a = block_to_arena (b);
c0024209:	89 f8                	mov    %edi,%eax
c002420b:	e8 2c fb ff ff       	call   c0023d3c <block_to_arena>
  struct desc *d = a->desc;
c0024210:	8b 50 04             	mov    0x4(%eax),%edx
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0024213:	85 d2                	test   %edx,%edx
c0024215:	74 3a                	je     c0024251 <realloc+0x7c>
c0024217:	8b 02                	mov    (%edx),%eax
          size_t min_size = new_size < old_size ? new_size : old_size;
c0024219:	39 c6                	cmp    %eax,%esi
c002421b:	0f 47 f0             	cmova  %eax,%esi
          memcpy (new_block, old_block, min_size);
c002421e:	83 ec 04             	sub    $0x4,%esp
c0024221:	56                   	push   %esi
c0024222:	57                   	push   %edi
c0024223:	55                   	push   %ebp
c0024224:	e8 5a 42 00 00       	call   c0028483 <memcpy>
          free (old_block);
c0024229:	89 3c 24             	mov    %edi,(%esp)
c002422c:	e8 ac fe ff ff       	call   c00240dd <free>
c0024231:	83 c4 10             	add    $0x10,%esp
}
c0024234:	89 e8                	mov    %ebp,%eax
c0024236:	83 c4 0c             	add    $0xc,%esp
c0024239:	5b                   	pop    %ebx
c002423a:	5e                   	pop    %esi
c002423b:	5f                   	pop    %edi
c002423c:	5d                   	pop    %ebp
c002423d:	c3                   	ret    
      free (old_block);
c002423e:	83 ec 0c             	sub    $0xc,%esp
c0024241:	57                   	push   %edi
c0024242:	e8 96 fe ff ff       	call   c00240dd <free>
      return NULL;
c0024247:	83 c4 10             	add    $0x10,%esp
c002424a:	bd 00 00 00 00       	mov    $0x0,%ebp
c002424f:	eb e3                	jmp    c0024234 <realloc+0x5f>
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0024251:	8b 40 08             	mov    0x8(%eax),%eax
c0024254:	c1 e0 0c             	shl    $0xc,%eax
c0024257:	89 fa                	mov    %edi,%edx
c0024259:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c002425f:	29 d0                	sub    %edx,%eax
c0024261:	eb b6                	jmp    c0024219 <realloc+0x44>

c0024263 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0024263:	55                   	push   %ebp
c0024264:	57                   	push   %edi
c0024265:	56                   	push   %esi
c0024266:	53                   	push   %ebx
c0024267:	83 ec 0c             	sub    $0xc,%esp
c002426a:	e8 16 a8 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002426f:	81 c3 45 6c 01 00    	add    $0x16c45,%ebx
c0024275:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0024279:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002427d:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0024281:	f7 c5 fd ff ff ff    	test   $0xfffffffd,%ebp
c0024287:	75 6a                	jne    c00242f3 <pit_configure_channel+0x90>
  ASSERT (mode == 2 || mode == 3);
c0024289:	8d 47 fe             	lea    -0x2(%edi),%eax
c002428c:	83 f8 01             	cmp    $0x1,%eax
c002428f:	0f 87 84 00 00 00    	ja     c0024319 <pit_configure_channel+0xb6>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0024295:	be 00 00 00 00       	mov    $0x0,%esi
  if (frequency < 19)
c002429a:	83 f9 12             	cmp    $0x12,%ecx
c002429d:	7e 20                	jle    c00242bf <pit_configure_channel+0x5c>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c002429f:	be 02 00 00 00       	mov    $0x2,%esi
  else if (frequency > PIT_HZ)
c00242a4:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c00242aa:	7f 13                	jg     c00242bf <pit_configure_channel+0x5c>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c00242ac:	89 c8                	mov    %ecx,%eax
c00242ae:	c1 e8 1f             	shr    $0x1f,%eax
c00242b1:	01 c8                	add    %ecx,%eax
c00242b3:	d1 f8                	sar    %eax
c00242b5:	05 dc 34 12 00       	add    $0x1234dc,%eax
c00242ba:	99                   	cltd   
c00242bb:	f7 f9                	idiv   %ecx
c00242bd:	89 c6                	mov    %eax,%esi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c00242bf:	e8 6b db ff ff       	call   c0021e2f <intr_disable>
c00242c4:	89 c1                	mov    %eax,%ecx
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c00242c6:	8d 04 3f             	lea    (%edi,%edi,1),%eax
c00242c9:	83 c8 30             	or     $0x30,%eax
c00242cc:	89 ef                	mov    %ebp,%edi
c00242ce:	c1 e7 06             	shl    $0x6,%edi
c00242d1:	09 f8                	or     %edi,%eax
c00242d3:	e6 43                	out    %al,$0x43
  outb (PIT_PORT_COUNTER (channel), count);
c00242d5:	8d 55 40             	lea    0x40(%ebp),%edx
c00242d8:	89 f0                	mov    %esi,%eax
c00242da:	ee                   	out    %al,(%dx)
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c00242db:	89 f0                	mov    %esi,%eax
c00242dd:	66 c1 e8 08          	shr    $0x8,%ax
c00242e1:	ee                   	out    %al,(%dx)
  intr_set_level (old_level);
c00242e2:	83 ec 0c             	sub    $0xc,%esp
c00242e5:	51                   	push   %ecx
c00242e6:	e8 4b db ff ff       	call   c0021e36 <intr_set_level>
}
c00242eb:	83 c4 1c             	add    $0x1c,%esp
c00242ee:	5b                   	pop    %ebx
c00242ef:	5e                   	pop    %esi
c00242f0:	5f                   	pop    %edi
c00242f1:	5d                   	pop    %ebp
c00242f2:	c3                   	ret    
  ASSERT (channel == 0 || channel == 2);
c00242f3:	83 ec 0c             	sub    $0xc,%esp
c00242f6:	8d 83 c3 5b ff ff    	lea    -0xa43d(%ebx),%eax
c00242fc:	50                   	push   %eax
c00242fd:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0024303:	50                   	push   %eax
c0024304:	8d 83 80 3f ff ff    	lea    -0xc080(%ebx),%eax
c002430a:	50                   	push   %eax
c002430b:	6a 33                	push   $0x33
c002430d:	8d 83 e0 5b ff ff    	lea    -0xa420(%ebx),%eax
c0024313:	50                   	push   %eax
c0024314:	e8 6e 4f 00 00       	call   c0029287 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0024319:	83 ec 0c             	sub    $0xc,%esp
c002431c:	8d 83 f4 5b ff ff    	lea    -0xa40c(%ebx),%eax
c0024322:	50                   	push   %eax
c0024323:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0024329:	50                   	push   %eax
c002432a:	8d 83 80 3f ff ff    	lea    -0xc080(%ebx),%eax
c0024330:	50                   	push   %eax
c0024331:	6a 34                	push   $0x34
c0024333:	8d 83 e0 5b ff ff    	lea    -0xa420(%ebx),%eax
c0024339:	50                   	push   %eax
c002433a:	e8 48 4f 00 00       	call   c0029287 <debug_panic>

c002433f <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c002433f:	53                   	push   %ebx
  while (loops-- > 0)
c0024340:	89 c1                	mov    %eax,%ecx
c0024342:	89 d3                	mov    %edx,%ebx
c0024344:	83 c1 ff             	add    $0xffffffff,%ecx
c0024347:	83 d3 ff             	adc    $0xffffffff,%ebx
c002434a:	85 d2                	test   %edx,%edx
c002434c:	78 13                	js     c0024361 <busy_wait+0x22>
c002434e:	85 d2                	test   %edx,%edx
c0024350:	7e 11                	jle    c0024363 <busy_wait+0x24>
c0024352:	83 c1 ff             	add    $0xffffffff,%ecx
c0024355:	83 d3 ff             	adc    $0xffffffff,%ebx
c0024358:	89 d8                	mov    %ebx,%eax
c002435a:	21 c8                	and    %ecx,%eax
c002435c:	83 f8 ff             	cmp    $0xffffffff,%eax
c002435f:	75 f1                	jne    c0024352 <busy_wait+0x13>
    barrier ();
}
c0024361:	5b                   	pop    %ebx
c0024362:	c3                   	ret    
  while (loops-- > 0)
c0024363:	83 f8 00             	cmp    $0x0,%eax
c0024366:	76 f9                	jbe    c0024361 <busy_wait+0x22>
c0024368:	eb e8                	jmp    c0024352 <busy_wait+0x13>

c002436a <too_many_loops>:
{
c002436a:	55                   	push   %ebp
c002436b:	57                   	push   %edi
c002436c:	56                   	push   %esi
c002436d:	53                   	push   %ebx
c002436e:	83 ec 0c             	sub    $0xc,%esp
c0024371:	e8 0f a7 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024376:	81 c3 3e 6b 01 00    	add    $0x16b3e,%ebx
c002437c:	89 44 24 04          	mov    %eax,0x4(%esp)
  int64_t start = ticks;
c0024380:	8b ab 0c 1f 00 00    	mov    0x1f0c(%ebx),%ebp
c0024386:	8b 8b 10 1f 00 00    	mov    0x1f10(%ebx),%ecx
  while (ticks == start)
c002438c:	8b bb 0c 1f 00 00    	mov    0x1f0c(%ebx),%edi
c0024392:	8b b3 10 1f 00 00    	mov    0x1f10(%ebx),%esi
c0024398:	89 f8                	mov    %edi,%eax
c002439a:	31 e8                	xor    %ebp,%eax
c002439c:	89 f2                	mov    %esi,%edx
c002439e:	31 ca                	xor    %ecx,%edx
c00243a0:	09 c2                	or     %eax,%edx
c00243a2:	74 e8                	je     c002438c <too_many_loops+0x22>
  busy_wait (loops);
c00243a4:	8b 44 24 04          	mov    0x4(%esp),%eax
c00243a8:	ba 00 00 00 00       	mov    $0x0,%edx
c00243ad:	e8 8d ff ff ff       	call   c002433f <busy_wait>
  return start != ticks;
c00243b2:	33 bb 0c 1f 00 00    	xor    0x1f0c(%ebx),%edi
c00243b8:	33 b3 10 1f 00 00    	xor    0x1f10(%ebx),%esi
c00243be:	09 f7                	or     %esi,%edi
c00243c0:	0f 95 c0             	setne  %al
}
c00243c3:	83 c4 0c             	add    $0xc,%esp
c00243c6:	5b                   	pop    %ebx
c00243c7:	5e                   	pop    %esi
c00243c8:	5f                   	pop    %edi
c00243c9:	5d                   	pop    %ebp
c00243ca:	c3                   	ret    

c00243cb <timer_interrupt>:
{
c00243cb:	55                   	push   %ebp
c00243cc:	57                   	push   %edi
c00243cd:	56                   	push   %esi
c00243ce:	53                   	push   %ebx
c00243cf:	83 ec 0c             	sub    $0xc,%esp
c00243d2:	e8 ae a6 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00243d7:	81 c3 dd 6a 01 00    	add    $0x16add,%ebx
  ticks++;
c00243dd:	83 83 0c 1f 00 00 01 	addl   $0x1,0x1f0c(%ebx)
c00243e4:	83 93 10 1f 00 00 00 	adcl   $0x0,0x1f10(%ebx)
  enum intr_level old_level = intr_disable();
c00243eb:	e8 3f da ff ff       	call   c0021e2f <intr_disable>
c00243f0:	89 c5                	mov    %eax,%ebp
  if (thread_mlfqs) {
c00243f2:	c7 c0 44 d4 03 c0    	mov    $0xc003d444,%eax
c00243f8:	80 38 00             	cmpb   $0x0,(%eax)
c00243fb:	75 25                	jne    c0024422 <timer_interrupt+0x57>
  thread_tick ();
c00243fd:	e8 d0 c9 ff ff       	call   c0020dd2 <thread_tick>
  thread_foreach(blocked_thread_check, NULL);
c0024402:	83 ec 08             	sub    $0x8,%esp
c0024405:	6a 00                	push   $0x0
c0024407:	ff b3 f4 ff ff ff    	pushl  -0xc(%ebx)
c002440d:	e8 50 ca ff ff       	call   c0020e62 <thread_foreach>
  intr_set_level (old_level);
c0024412:	89 2c 24             	mov    %ebp,(%esp)
c0024415:	e8 1c da ff ff       	call   c0021e36 <intr_set_level>
}
c002441a:	83 c4 1c             	add    $0x1c,%esp
c002441d:	5b                   	pop    %ebx
c002441e:	5e                   	pop    %esi
c002441f:	5f                   	pop    %edi
c0024420:	5d                   	pop    %ebp
c0024421:	c3                   	ret    
    thread_mlfqs_increase_recent_cpu_by_one();
c0024422:	e8 da d3 ff ff       	call   c0021801 <thread_mlfqs_increase_recent_cpu_by_one>
    if (ticks % TIMER_FREQ == 0)
c0024427:	8b b3 0c 1f 00 00    	mov    0x1f0c(%ebx),%esi
c002442d:	8b bb 10 1f 00 00    	mov    0x1f10(%ebx),%edi
c0024433:	6a 00                	push   $0x0
c0024435:	6a 64                	push   $0x64
c0024437:	57                   	push   %edi
c0024438:	56                   	push   %esi
c0024439:	e8 28 48 00 00       	call   c0028c66 <__moddi3>
c002443e:	83 c4 10             	add    $0x10,%esp
c0024441:	09 c2                	or     %eax,%edx
c0024443:	74 1a                	je     c002445f <timer_interrupt+0x94>
    else if (ticks % 4 == 0)
c0024445:	83 e6 03             	and    $0x3,%esi
c0024448:	85 f6                	test   %esi,%esi
c002444a:	75 b1                	jne    c00243fd <timer_interrupt+0x32>
      thread_mlfqs_update_priority (thread_current());
c002444c:	e8 03 c9 ff ff       	call   c0020d54 <thread_current>
c0024451:	83 ec 0c             	sub    $0xc,%esp
c0024454:	50                   	push   %eax
c0024455:	e8 35 d4 ff ff       	call   c002188f <thread_mlfqs_update_priority>
c002445a:	83 c4 10             	add    $0x10,%esp
c002445d:	eb 9e                	jmp    c00243fd <timer_interrupt+0x32>
      thread_mlfqs_update_load_avg_and_recent_cpu();
c002445f:	e8 df d4 ff ff       	call   c0021943 <thread_mlfqs_update_load_avg_and_recent_cpu>
c0024464:	eb 97                	jmp    c00243fd <timer_interrupt+0x32>

c0024466 <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024466:	55                   	push   %ebp
c0024467:	57                   	push   %edi
c0024468:	56                   	push   %esi
c0024469:	53                   	push   %ebx
c002446a:	83 ec 0c             	sub    $0xc,%esp
c002446d:	e8 1b a6 00 00       	call   c002ea8d <__x86.get_pc_thunk.di>
c0024472:	81 c7 42 6a 01 00    	add    $0x16a42,%edi
c0024478:	89 c5                	mov    %eax,%ebp
c002447a:	89 d3                	mov    %edx,%ebx
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c002447c:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0024481:	89 c8                	mov    %ecx,%eax
c0024483:	f7 ea                	imul   %edx
c0024485:	c1 fa 06             	sar    $0x6,%edx
c0024488:	89 c8                	mov    %ecx,%eax
c002448a:	c1 f8 1f             	sar    $0x1f,%eax
c002448d:	29 c2                	sub    %eax,%edx
c002448f:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c0024495:	39 d1                	cmp    %edx,%ecx
c0024497:	75 61                	jne    c00244fa <real_time_delay+0x94>
c0024499:	89 ce                	mov    %ecx,%esi
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c002449b:	8b 87 04 1f 00 00    	mov    0x1f04(%edi),%eax
c00244a1:	0f af d8             	imul   %eax,%ebx
c00244a4:	f7 e5                	mul    %ebp
c00244a6:	01 da                	add    %ebx,%edx
c00244a8:	6a 00                	push   $0x0
c00244aa:	68 e8 03 00 00       	push   $0x3e8
c00244af:	52                   	push   %edx
c00244b0:	50                   	push   %eax
c00244b1:	89 fb                	mov    %edi,%ebx
c00244b3:	e8 92 47 00 00       	call   c0028c4a <__divdi3>
c00244b8:	83 c4 10             	add    $0x10,%esp
c00244bb:	6b ea 64             	imul   $0x64,%edx,%ebp
c00244be:	b9 64 00 00 00       	mov    $0x64,%ecx
c00244c3:	f7 e1                	mul    %ecx
c00244c5:	89 c1                	mov    %eax,%ecx
c00244c7:	89 d3                	mov    %edx,%ebx
c00244c9:	01 eb                	add    %ebp,%ebx
c00244cb:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00244d0:	89 f0                	mov    %esi,%eax
c00244d2:	f7 ea                	imul   %edx
c00244d4:	c1 fa 06             	sar    $0x6,%edx
c00244d7:	c1 fe 1f             	sar    $0x1f,%esi
c00244da:	29 f2                	sub    %esi,%edx
c00244dc:	89 d0                	mov    %edx,%eax
c00244de:	99                   	cltd   
c00244df:	52                   	push   %edx
c00244e0:	50                   	push   %eax
c00244e1:	53                   	push   %ebx
c00244e2:	51                   	push   %ecx
c00244e3:	89 fb                	mov    %edi,%ebx
c00244e5:	e8 60 47 00 00       	call   c0028c4a <__divdi3>
c00244ea:	83 c4 10             	add    $0x10,%esp
c00244ed:	e8 4d fe ff ff       	call   c002433f <busy_wait>
}
c00244f2:	83 c4 0c             	add    $0xc,%esp
c00244f5:	5b                   	pop    %ebx
c00244f6:	5e                   	pop    %esi
c00244f7:	5f                   	pop    %edi
c00244f8:	5d                   	pop    %ebp
c00244f9:	c3                   	ret    
  ASSERT (denom % 1000 == 0);
c00244fa:	83 ec 0c             	sub    $0xc,%esp
c00244fd:	8d 87 0b 5c ff ff    	lea    -0xa3f5(%edi),%eax
c0024503:	50                   	push   %eax
c0024504:	8d 87 45 4e ff ff    	lea    -0xb1bb(%edi),%eax
c002450a:	50                   	push   %eax
c002450b:	8d 87 98 3f ff ff    	lea    -0xc068(%edi),%eax
c0024511:	50                   	push   %eax
c0024512:	68 04 01 00 00       	push   $0x104
c0024517:	8d 87 1d 5c ff ff    	lea    -0xa3e3(%edi),%eax
c002451d:	50                   	push   %eax
c002451e:	89 fb                	mov    %edi,%ebx
c0024520:	e8 62 4d 00 00       	call   c0029287 <debug_panic>

c0024525 <timer_init>:
{
c0024525:	53                   	push   %ebx
c0024526:	83 ec 0c             	sub    $0xc,%esp
c0024529:	e8 57 a5 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002452e:	81 c3 86 69 01 00    	add    $0x16986,%ebx
  pit_configure_channel (0, 2, TIMER_FREQ);
c0024534:	6a 64                	push   $0x64
c0024536:	6a 02                	push   $0x2
c0024538:	6a 00                	push   $0x0
c002453a:	e8 24 fd ff ff       	call   c0024263 <pit_configure_channel>
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c002453f:	83 c4 0c             	add    $0xc,%esp
c0024542:	8d 83 33 5c ff ff    	lea    -0xa3cd(%ebx),%eax
c0024548:	50                   	push   %eax
c0024549:	8d 83 17 95 fe ff    	lea    -0x16ae9(%ebx),%eax
c002454f:	50                   	push   %eax
c0024550:	6a 20                	push   $0x20
c0024552:	e8 b2 da ff ff       	call   c0022009 <intr_register_ext>
}
c0024557:	83 c4 18             	add    $0x18,%esp
c002455a:	5b                   	pop    %ebx
c002455b:	c3                   	ret    

c002455c <timer_calibrate>:
{
c002455c:	55                   	push   %ebp
c002455d:	57                   	push   %edi
c002455e:	56                   	push   %esi
c002455f:	53                   	push   %ebx
c0024560:	83 ec 0c             	sub    $0xc,%esp
c0024563:	e8 1d a5 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024568:	81 c3 4c 69 01 00    	add    $0x1694c,%ebx
  ASSERT (intr_get_level () == INTR_ON);
c002456e:	e8 6a d8 ff ff       	call   c0021ddd <intr_get_level>
c0024573:	83 f8 01             	cmp    $0x1,%eax
c0024576:	75 60                	jne    c00245d8 <timer_calibrate+0x7c>
  printf ("Calibrating timer...  ");
c0024578:	83 ec 0c             	sub    $0xc,%esp
c002457b:	8d 83 5b 5c ff ff    	lea    -0xa3a5(%ebx),%eax
c0024581:	50                   	push   %eax
c0024582:	e8 69 2f 00 00       	call   c00274f0 <printf>
  loops_per_tick = 1u << 10;
c0024587:	c7 83 04 1f 00 00 00 	movl   $0x400,0x1f04(%ebx)
c002458e:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0024591:	83 c4 10             	add    $0x10,%esp
c0024594:	8b bb 04 1f 00 00    	mov    0x1f04(%ebx),%edi
c002459a:	8d 34 3f             	lea    (%edi,%edi,1),%esi
c002459d:	89 f0                	mov    %esi,%eax
c002459f:	e8 c6 fd ff ff       	call   c002436a <too_many_loops>
c00245a4:	84 c0                	test   %al,%al
c00245a6:	75 56                	jne    c00245fe <timer_calibrate+0xa2>
      loops_per_tick <<= 1;
c00245a8:	89 b3 04 1f 00 00    	mov    %esi,0x1f04(%ebx)
      ASSERT (loops_per_tick != 0);
c00245ae:	85 f6                	test   %esi,%esi
c00245b0:	75 e2                	jne    c0024594 <timer_calibrate+0x38>
c00245b2:	83 ec 0c             	sub    $0xc,%esp
c00245b5:	8d 83 72 5c ff ff    	lea    -0xa38e(%ebx),%eax
c00245bb:	50                   	push   %eax
c00245bc:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00245c2:	50                   	push   %eax
c00245c3:	8d 83 c4 3f ff ff    	lea    -0xc03c(%ebx),%eax
c00245c9:	50                   	push   %eax
c00245ca:	6a 39                	push   $0x39
c00245cc:	8d 83 1d 5c ff ff    	lea    -0xa3e3(%ebx),%eax
c00245d2:	50                   	push   %eax
c00245d3:	e8 af 4c 00 00       	call   c0029287 <debug_panic>
  ASSERT (intr_get_level () == INTR_ON);
c00245d8:	83 ec 0c             	sub    $0xc,%esp
c00245db:	8d 83 3e 5c ff ff    	lea    -0xa3c2(%ebx),%eax
c00245e1:	50                   	push   %eax
c00245e2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00245e8:	50                   	push   %eax
c00245e9:	8d 83 c4 3f ff ff    	lea    -0xc03c(%ebx),%eax
c00245ef:	50                   	push   %eax
c00245f0:	6a 30                	push   $0x30
c00245f2:	8d 83 1d 5c ff ff    	lea    -0xa3e3(%ebx),%eax
c00245f8:	50                   	push   %eax
c00245f9:	e8 89 4c 00 00       	call   c0029287 <debug_panic>
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00245fe:	89 fe                	mov    %edi,%esi
c0024600:	d1 ee                	shr    %esi
c0024602:	89 fd                	mov    %edi,%ebp
c0024604:	c1 ed 0a             	shr    $0xa,%ebp
c0024607:	39 f5                	cmp    %esi,%ebp
c0024609:	75 2a                	jne    c0024635 <timer_calibrate+0xd9>
  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c002460b:	83 ec 04             	sub    $0x4,%esp
c002460e:	b8 64 00 00 00       	mov    $0x64,%eax
c0024613:	f7 a3 04 1f 00 00    	mull   0x1f04(%ebx)
c0024619:	52                   	push   %edx
c002461a:	50                   	push   %eax
c002461b:	8d 83 86 5c ff ff    	lea    -0xa37a(%ebx),%eax
c0024621:	50                   	push   %eax
c0024622:	e8 c9 2e 00 00       	call   c00274f0 <printf>
}
c0024627:	83 c4 1c             	add    $0x1c,%esp
c002462a:	5b                   	pop    %ebx
c002462b:	5e                   	pop    %esi
c002462c:	5f                   	pop    %edi
c002462d:	5d                   	pop    %ebp
c002462e:	c3                   	ret    
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c002462f:	d1 ee                	shr    %esi
c0024631:	39 f5                	cmp    %esi,%ebp
c0024633:	74 d6                	je     c002460b <timer_calibrate+0xaf>
    if (!too_many_loops (high_bit | test_bit))
c0024635:	89 f8                	mov    %edi,%eax
c0024637:	09 f0                	or     %esi,%eax
c0024639:	e8 2c fd ff ff       	call   c002436a <too_many_loops>
c002463e:	84 c0                	test   %al,%al
c0024640:	75 ed                	jne    c002462f <timer_calibrate+0xd3>
      loops_per_tick |= test_bit;
c0024642:	09 b3 04 1f 00 00    	or     %esi,0x1f04(%ebx)
c0024648:	eb e5                	jmp    c002462f <timer_calibrate+0xd3>

c002464a <timer_ticks>:
{
c002464a:	57                   	push   %edi
c002464b:	56                   	push   %esi
c002464c:	53                   	push   %ebx
c002464d:	e8 33 a4 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024652:	81 c3 62 68 01 00    	add    $0x16862,%ebx
  enum intr_level old_level = intr_disable ();
c0024658:	e8 d2 d7 ff ff       	call   c0021e2f <intr_disable>
  int64_t t = ticks;
c002465d:	8b b3 0c 1f 00 00    	mov    0x1f0c(%ebx),%esi
c0024663:	8b bb 10 1f 00 00    	mov    0x1f10(%ebx),%edi
  intr_set_level (old_level);
c0024669:	83 ec 0c             	sub    $0xc,%esp
c002466c:	50                   	push   %eax
c002466d:	e8 c4 d7 ff ff       	call   c0021e36 <intr_set_level>
  return t;
c0024672:	83 c4 10             	add    $0x10,%esp
}
c0024675:	89 f0                	mov    %esi,%eax
c0024677:	89 fa                	mov    %edi,%edx
c0024679:	5b                   	pop    %ebx
c002467a:	5e                   	pop    %esi
c002467b:	5f                   	pop    %edi
c002467c:	c3                   	ret    

c002467d <timer_elapsed>:
{
c002467d:	57                   	push   %edi
c002467e:	56                   	push   %esi
c002467f:	83 ec 04             	sub    $0x4,%esp
c0024682:	8b 74 24 10          	mov    0x10(%esp),%esi
c0024686:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks () - then;
c002468a:	e8 bb ff ff ff       	call   c002464a <timer_ticks>
c002468f:	29 f0                	sub    %esi,%eax
c0024691:	19 fa                	sbb    %edi,%edx
}
c0024693:	83 c4 04             	add    $0x4,%esp
c0024696:	5e                   	pop    %esi
c0024697:	5f                   	pop    %edi
c0024698:	c3                   	ret    

c0024699 <timer_sleep>:
{
c0024699:	57                   	push   %edi
c002469a:	56                   	push   %esi
c002469b:	53                   	push   %ebx
c002469c:	e8 e4 a3 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00246a1:	81 c3 13 68 01 00    	add    $0x16813,%ebx
c00246a7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c00246ab:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (intr_get_level () == INTR_ON);
c00246af:	e8 29 d7 ff ff       	call   c0021ddd <intr_get_level>
c00246b4:	83 f8 01             	cmp    $0x1,%eax
c00246b7:	75 2f                	jne    c00246e8 <timer_sleep+0x4f>
  if (ticks <= 0)
c00246b9:	85 f6                	test   %esi,%esi
c00246bb:	78 27                	js     c00246e4 <timer_sleep+0x4b>
c00246bd:	85 f6                	test   %esi,%esi
c00246bf:	7e 4d                	jle    c002470e <timer_sleep+0x75>
  struct thread *current_thread = thread_current();
c00246c1:	e8 8e c6 ff ff       	call   c0020d54 <thread_current>
  current_thread->ticks_blocked = ticks;
c00246c6:	89 78 34             	mov    %edi,0x34(%eax)
c00246c9:	89 70 38             	mov    %esi,0x38(%eax)
  enum intr_level old_level = intr_disable();
c00246cc:	e8 5e d7 ff ff       	call   c0021e2f <intr_disable>
c00246d1:	89 c6                	mov    %eax,%esi
  thread_block();
c00246d3:	e8 49 ca ff ff       	call   c0021121 <thread_block>
  intr_set_level(old_level);
c00246d8:	83 ec 0c             	sub    $0xc,%esp
c00246db:	56                   	push   %esi
c00246dc:	e8 55 d7 ff ff       	call   c0021e36 <intr_set_level>
c00246e1:	83 c4 10             	add    $0x10,%esp
}
c00246e4:	5b                   	pop    %ebx
c00246e5:	5e                   	pop    %esi
c00246e6:	5f                   	pop    %edi
c00246e7:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c00246e8:	83 ec 0c             	sub    $0xc,%esp
c00246eb:	8d 83 3e 5c ff ff    	lea    -0xa3c2(%ebx),%eax
c00246f1:	50                   	push   %eax
c00246f2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00246f8:	50                   	push   %eax
c00246f9:	8d 83 b8 3f ff ff    	lea    -0xc048(%ebx),%eax
c00246ff:	50                   	push   %eax
c0024700:	6a 5c                	push   $0x5c
c0024702:	8d 83 1d 5c ff ff    	lea    -0xa3e3(%ebx),%eax
c0024708:	50                   	push   %eax
c0024709:	e8 79 4b 00 00       	call   c0029287 <debug_panic>
  if (ticks <= 0)
c002470e:	83 ff 00             	cmp    $0x0,%edi
c0024711:	76 d1                	jbe    c00246e4 <timer_sleep+0x4b>
c0024713:	eb ac                	jmp    c00246c1 <timer_sleep+0x28>

c0024715 <real_time_sleep>:
{
c0024715:	55                   	push   %ebp
c0024716:	57                   	push   %edi
c0024717:	56                   	push   %esi
c0024718:	53                   	push   %ebx
c0024719:	83 ec 1c             	sub    $0x1c,%esp
c002471c:	e8 64 a3 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024721:	81 c3 93 67 01 00    	add    $0x16793,%ebx
c0024727:	89 c6                	mov    %eax,%esi
c0024729:	89 44 24 08          	mov    %eax,0x8(%esp)
c002472d:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0024731:	89 cd                	mov    %ecx,%ebp
  int64_t ticks = num * TIMER_FREQ / denom;
c0024733:	6b ca 64             	imul   $0x64,%edx,%ecx
c0024736:	b8 64 00 00 00       	mov    $0x64,%eax
c002473b:	f7 e6                	mul    %esi
c002473d:	01 ca                	add    %ecx,%edx
c002473f:	89 ef                	mov    %ebp,%edi
c0024741:	c1 ff 1f             	sar    $0x1f,%edi
c0024744:	57                   	push   %edi
c0024745:	55                   	push   %ebp
c0024746:	52                   	push   %edx
c0024747:	50                   	push   %eax
c0024748:	e8 fd 44 00 00       	call   c0028c4a <__divdi3>
c002474d:	83 c4 10             	add    $0x10,%esp
c0024750:	89 c6                	mov    %eax,%esi
c0024752:	89 d7                	mov    %edx,%edi
  ASSERT (intr_get_level () == INTR_ON);
c0024754:	e8 84 d6 ff ff       	call   c0021ddd <intr_get_level>
c0024759:	83 f8 01             	cmp    $0x1,%eax
c002475c:	75 1d                	jne    c002477b <real_time_sleep+0x66>
  if (ticks > 0)
c002475e:	85 ff                	test   %edi,%edi
c0024760:	78 47                	js     c00247a9 <real_time_sleep+0x94>
c0024762:	85 ff                	test   %edi,%edi
c0024764:	7e 3e                	jle    c00247a4 <real_time_sleep+0x8f>
      timer_sleep (ticks); 
c0024766:	83 ec 08             	sub    $0x8,%esp
c0024769:	57                   	push   %edi
c002476a:	56                   	push   %esi
c002476b:	e8 29 ff ff ff       	call   c0024699 <timer_sleep>
c0024770:	83 c4 10             	add    $0x10,%esp
}
c0024773:	83 c4 1c             	add    $0x1c,%esp
c0024776:	5b                   	pop    %ebx
c0024777:	5e                   	pop    %esi
c0024778:	5f                   	pop    %edi
c0024779:	5d                   	pop    %ebp
c002477a:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c002477b:	83 ec 0c             	sub    $0xc,%esp
c002477e:	8d 83 3e 5c ff ff    	lea    -0xa3c2(%ebx),%eax
c0024784:	50                   	push   %eax
c0024785:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002478b:	50                   	push   %eax
c002478c:	8d 83 a8 3f ff ff    	lea    -0xc058(%ebx),%eax
c0024792:	50                   	push   %eax
c0024793:	68 ee 00 00 00       	push   $0xee
c0024798:	8d 83 1d 5c ff ff    	lea    -0xa3e3(%ebx),%eax
c002479e:	50                   	push   %eax
c002479f:	e8 e3 4a 00 00       	call   c0029287 <debug_panic>
  if (ticks > 0)
c00247a4:	83 fe 00             	cmp    $0x0,%esi
c00247a7:	77 bd                	ja     c0024766 <real_time_sleep+0x51>
      real_time_delay (num, denom); 
c00247a9:	89 e9                	mov    %ebp,%ecx
c00247ab:	8b 44 24 08          	mov    0x8(%esp),%eax
c00247af:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00247b3:	e8 ae fc ff ff       	call   c0024466 <real_time_delay>
}
c00247b8:	eb b9                	jmp    c0024773 <real_time_sleep+0x5e>

c00247ba <timer_msleep>:
{
c00247ba:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ms, 1000);
c00247bd:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c00247c2:	8b 44 24 10          	mov    0x10(%esp),%eax
c00247c6:	8b 54 24 14          	mov    0x14(%esp),%edx
c00247ca:	e8 46 ff ff ff       	call   c0024715 <real_time_sleep>
}
c00247cf:	83 c4 0c             	add    $0xc,%esp
c00247d2:	c3                   	ret    

c00247d3 <timer_usleep>:
{
c00247d3:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (us, 1000 * 1000);
c00247d6:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c00247db:	8b 44 24 10          	mov    0x10(%esp),%eax
c00247df:	8b 54 24 14          	mov    0x14(%esp),%edx
c00247e3:	e8 2d ff ff ff       	call   c0024715 <real_time_sleep>
}
c00247e8:	83 c4 0c             	add    $0xc,%esp
c00247eb:	c3                   	ret    

c00247ec <timer_nsleep>:
{
c00247ec:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ns, 1000 * 1000 * 1000);
c00247ef:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c00247f4:	8b 44 24 10          	mov    0x10(%esp),%eax
c00247f8:	8b 54 24 14          	mov    0x14(%esp),%edx
c00247fc:	e8 14 ff ff ff       	call   c0024715 <real_time_sleep>
}
c0024801:	83 c4 0c             	add    $0xc,%esp
c0024804:	c3                   	ret    

c0024805 <timer_mdelay>:
{
c0024805:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ms, 1000);
c0024808:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002480d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024811:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024815:	e8 4c fc ff ff       	call   c0024466 <real_time_delay>
}
c002481a:	83 c4 0c             	add    $0xc,%esp
c002481d:	c3                   	ret    

c002481e <timer_udelay>:
{
c002481e:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (us, 1000 * 1000);
c0024821:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024826:	8b 44 24 10          	mov    0x10(%esp),%eax
c002482a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002482e:	e8 33 fc ff ff       	call   c0024466 <real_time_delay>
}
c0024833:	83 c4 0c             	add    $0xc,%esp
c0024836:	c3                   	ret    

c0024837 <timer_ndelay>:
{
c0024837:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ns, 1000 * 1000 * 1000);
c002483a:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c002483f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024843:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024847:	e8 1a fc ff ff       	call   c0024466 <real_time_delay>
}
c002484c:	83 c4 0c             	add    $0xc,%esp
c002484f:	c3                   	ret    

c0024850 <timer_print_stats>:
{
c0024850:	53                   	push   %ebx
c0024851:	83 ec 08             	sub    $0x8,%esp
c0024854:	e8 2c a2 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024859:	81 c3 5b 66 01 00    	add    $0x1665b,%ebx
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c002485f:	e8 e6 fd ff ff       	call   c002464a <timer_ticks>
c0024864:	83 ec 04             	sub    $0x4,%esp
c0024867:	52                   	push   %edx
c0024868:	50                   	push   %eax
c0024869:	8d 83 96 5c ff ff    	lea    -0xa36a(%ebx),%eax
c002486f:	50                   	push   %eax
c0024870:	e8 7b 2c 00 00       	call   c00274f0 <printf>
}
c0024875:	83 c4 18             	add    $0x18,%esp
c0024878:	5b                   	pop    %ebx
c0024879:	c3                   	ret    

c002487a <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c002487a:	55                   	push   %ebp
c002487b:	57                   	push   %edi
c002487c:	56                   	push   %esi
c002487d:	53                   	push   %ebx
c002487e:	83 ec 04             	sub    $0x4,%esp
c0024881:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c0024884:	0f b6 18             	movzbl (%eax),%ebx
c0024887:	84 db                	test   %bl,%bl
c0024889:	74 50                	je     c00248db <map_key+0x61>
c002488b:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode
        && scancode < k->first_scancode + strlen (k->chars)) 
c002488d:	b8 00 00 00 00       	mov    $0x0,%eax
c0024892:	eb 0a                	jmp    c002489e <map_key+0x24>
  for (; k->first_scancode != 0; k++)
c0024894:	83 c6 08             	add    $0x8,%esi
c0024897:	0f b6 1e             	movzbl (%esi),%ebx
c002489a:	84 db                	test   %bl,%bl
c002489c:	74 30                	je     c00248ce <map_key+0x54>
    if (scancode >= k->first_scancode
c002489e:	0f b6 db             	movzbl %bl,%ebx
c00248a1:	39 d3                	cmp    %edx,%ebx
c00248a3:	77 ef                	ja     c0024894 <map_key+0x1a>
        && scancode < k->first_scancode + strlen (k->chars)) 
c00248a5:	8b 6e 04             	mov    0x4(%esi),%ebp
c00248a8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00248ad:	89 ef                	mov    %ebp,%edi
c00248af:	f2 ae                	repnz scas %es:(%edi),%al
c00248b1:	f7 d1                	not    %ecx
c00248b3:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c00248b7:	39 d1                	cmp    %edx,%ecx
c00248b9:	76 d9                	jbe    c0024894 <map_key+0x1a>
      {
        *c = k->chars[scancode - k->first_scancode];
c00248bb:	29 da                	sub    %ebx,%edx
c00248bd:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c00248c2:	8b 3c 24             	mov    (%esp),%edi
c00248c5:	88 07                	mov    %al,(%edi)
        return true; 
c00248c7:	b8 01 00 00 00       	mov    $0x1,%eax
c00248cc:	eb 05                	jmp    c00248d3 <map_key+0x59>
      }

  return false;
c00248ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00248d3:	83 c4 04             	add    $0x4,%esp
c00248d6:	5b                   	pop    %ebx
c00248d7:	5e                   	pop    %esi
c00248d8:	5f                   	pop    %edi
c00248d9:	5d                   	pop    %ebp
c00248da:	c3                   	ret    
  return false;
c00248db:	b8 00 00 00 00       	mov    $0x0,%eax
c00248e0:	eb f1                	jmp    c00248d3 <map_key+0x59>

c00248e2 <keyboard_interrupt>:
{
c00248e2:	55                   	push   %ebp
c00248e3:	57                   	push   %edi
c00248e4:	56                   	push   %esi
c00248e5:	53                   	push   %ebx
c00248e6:	83 ec 2c             	sub    $0x2c,%esp
c00248e9:	e8 97 a1 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00248ee:	81 c3 c6 65 01 00    	add    $0x165c6,%ebx
  bool shift = left_shift || right_shift;
c00248f4:	ba 01 00 00 00       	mov    $0x1,%edx
c00248f9:	80 bb 22 1f 00 00 00 	cmpb   $0x0,0x1f22(%ebx)
c0024900:	75 07                	jne    c0024909 <keyboard_interrupt+0x27>
c0024902:	0f b6 93 21 1f 00 00 	movzbl 0x1f21(%ebx),%edx
  bool alt = left_alt || right_alt;
c0024909:	bd 01 00 00 00       	mov    $0x1,%ebp
c002490e:	80 bb 20 1f 00 00 00 	cmpb   $0x0,0x1f20(%ebx)
c0024915:	75 07                	jne    c002491e <keyboard_interrupt+0x3c>
c0024917:	0f b6 ab 1f 1f 00 00 	movzbl 0x1f1f(%ebx),%ebp
  bool ctrl = left_ctrl || right_ctrl;
c002491e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0024925:	00 
c0024926:	80 bb 1e 1f 00 00 00 	cmpb   $0x0,0x1f1e(%ebx)
c002492d:	75 0b                	jne    c002493a <keyboard_interrupt+0x58>
c002492f:	0f b6 83 1d 1f 00 00 	movzbl 0x1f1d(%ebx),%eax
c0024936:	89 44 24 08          	mov    %eax,0x8(%esp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002493a:	e4 60                	in     $0x60,%al
  code = inb (DATA_REG);
c002493c:	0f b6 f0             	movzbl %al,%esi
  if (code == 0xe0)
c002493f:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
c0024945:	74 26                	je     c002496d <keyboard_interrupt+0x8b>
  release = (code & 0x80) != 0;
c0024947:	89 f7                	mov    %esi,%edi
c0024949:	81 e7 80 00 00 00    	and    $0x80,%edi
  code &= ~0x80u;
c002494f:	81 e6 7f ff ff ff    	and    $0xffffff7f,%esi
  if (code == 0x3a) 
c0024955:	83 fe 3a             	cmp    $0x3a,%esi
c0024958:	75 20                	jne    c002497a <keyboard_interrupt+0x98>
      if (!release)
c002495a:	85 ff                	test   %edi,%edi
c002495c:	75 07                	jne    c0024965 <keyboard_interrupt+0x83>
        caps_lock = !caps_lock;
c002495e:	80 b3 1c 1f 00 00 01 	xorb   $0x1,0x1f1c(%ebx)
}
c0024965:	83 c4 2c             	add    $0x2c,%esp
c0024968:	5b                   	pop    %ebx
c0024969:	5e                   	pop    %esi
c002496a:	5f                   	pop    %edi
c002496b:	5d                   	pop    %ebp
c002496c:	c3                   	ret    
c002496d:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb (DATA_REG);
c002496f:	0f b6 f0             	movzbl %al,%esi
c0024972:	81 ce 00 e0 00 00    	or     $0xe000,%esi
c0024978:	eb cd                	jmp    c0024947 <keyboard_interrupt+0x65>
  bool shift = left_shift || right_shift;
c002497a:	89 d0                	mov    %edx,%eax
c002497c:	83 e0 01             	and    $0x1,%eax
c002497f:	88 44 24 0f          	mov    %al,0xf(%esp)
  else if (map_key (invariant_keymap, code, &c)
c0024983:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024987:	89 f2                	mov    %esi,%edx
c0024989:	8d 83 2c 01 00 00    	lea    0x12c(%ebx),%eax
c002498f:	e8 e6 fe ff ff       	call   c002487a <map_key>
c0024994:	84 c0                	test   %al,%al
c0024996:	75 57                	jne    c00249ef <keyboard_interrupt+0x10d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c0024998:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002499d:	74 3b                	je     c00249da <keyboard_interrupt+0xf8>
           || (shift && map_key (shifted_keymap, code, &c)))
c002499f:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00249a3:	89 f2                	mov    %esi,%edx
c00249a5:	8d 83 ac 00 00 00    	lea    0xac(%ebx),%eax
c00249ab:	e8 ca fe ff ff       	call   c002487a <map_key>
c00249b0:	84 c0                	test   %al,%al
c00249b2:	75 3b                	jne    c00249ef <keyboard_interrupt+0x10d>
        if (key->scancode == code)
c00249b4:	83 fe 2a             	cmp    $0x2a,%esi
c00249b7:	0f 84 da 00 00 00    	je     c0024a97 <keyboard_interrupt+0x1b5>
      for (key = shift_keys; key->scancode != 0; key++) 
c00249bd:	8d 83 6c 00 00 00    	lea    0x6c(%ebx),%eax
c00249c3:	83 c0 08             	add    $0x8,%eax
c00249c6:	8b 10                	mov    (%eax),%edx
c00249c8:	85 d2                	test   %edx,%edx
c00249ca:	74 99                	je     c0024965 <keyboard_interrupt+0x83>
        if (key->scancode == code)
c00249cc:	39 f2                	cmp    %esi,%edx
c00249ce:	75 f3                	jne    c00249c3 <keyboard_interrupt+0xe1>
            *key->state_var = !release;
c00249d0:	8b 40 04             	mov    0x4(%eax),%eax
c00249d3:	85 ff                	test   %edi,%edi
c00249d5:	0f 94 00             	sete   (%eax)
            break;
c00249d8:	eb 8b                	jmp    c0024965 <keyboard_interrupt+0x83>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00249da:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c00249de:	89 f2                	mov    %esi,%edx
c00249e0:	8d 83 ec 00 00 00    	lea    0xec(%ebx),%eax
c00249e6:	e8 8f fe ff ff       	call   c002487a <map_key>
c00249eb:	84 c0                	test   %al,%al
c00249ed:	74 c5                	je     c00249b4 <keyboard_interrupt+0xd2>
      if (!release) 
c00249ef:	85 ff                	test   %edi,%edi
c00249f1:	0f 85 6e ff ff ff    	jne    c0024965 <keyboard_interrupt+0x83>
          if (c == 0177 && ctrl && alt)
c00249f7:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c00249fc:	3c 7f                	cmp    $0x7f,%al
c00249fe:	74 5a                	je     c0024a5a <keyboard_interrupt+0x178>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024a00:	8d 50 c0             	lea    -0x40(%eax),%edx
c0024a03:	80 fa 1f             	cmp    $0x1f,%dl
c0024a06:	77 07                	ja     c0024a0f <keyboard_interrupt+0x12d>
c0024a08:	f6 44 24 08 01       	testb  $0x1,0x8(%esp)
c0024a0d:	75 6d                	jne    c0024a7c <keyboard_interrupt+0x19a>
          else if (shift == caps_lock)
c0024a0f:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024a14:	38 8b 1c 1f 00 00    	cmp    %cl,0x1f1c(%ebx)
c0024a1a:	74 66                	je     c0024a82 <keyboard_interrupt+0x1a0>
          if (alt)
c0024a1c:	f7 c5 01 00 00 00    	test   $0x1,%ebp
c0024a22:	74 05                	je     c0024a29 <keyboard_interrupt+0x147>
            c += 0x80;
c0024a24:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
          if (!input_full ())
c0024a29:	e8 9e 1c 00 00       	call   c00266cc <input_full>
c0024a2e:	84 c0                	test   %al,%al
c0024a30:	0f 85 2f ff ff ff    	jne    c0024965 <keyboard_interrupt+0x83>
              key_cnt++;
c0024a36:	83 83 14 1f 00 00 01 	addl   $0x1,0x1f14(%ebx)
c0024a3d:	83 93 18 1f 00 00 00 	adcl   $0x0,0x1f18(%ebx)
              input_putc (c);
c0024a44:	83 ec 0c             	sub    $0xc,%esp
c0024a47:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024a4c:	50                   	push   %eax
c0024a4d:	e8 9f 1b 00 00       	call   c00265f1 <input_putc>
c0024a52:	83 c4 10             	add    $0x10,%esp
c0024a55:	e9 0b ff ff ff       	jmp    c0024965 <keyboard_interrupt+0x83>
          if (c == 0177 && ctrl && alt)
c0024a5a:	8b 54 24 08          	mov    0x8(%esp),%edx
c0024a5e:	21 ea                	and    %ebp,%edx
c0024a60:	f6 c2 01             	test   $0x1,%dl
c0024a63:	75 12                	jne    c0024a77 <keyboard_interrupt+0x195>
          else if (shift == caps_lock)
c0024a65:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024a6a:	3a 8b 1c 1f 00 00    	cmp    0x1f1c(%ebx),%cl
c0024a70:	75 aa                	jne    c0024a1c <keyboard_interrupt+0x13a>
            c = tolower (c);
c0024a72:	0f b6 c0             	movzbl %al,%eax
c0024a75:	eb 1a                	jmp    c0024a91 <keyboard_interrupt+0x1af>
            shutdown_reboot ();
c0024a77:	e8 4d 22 00 00       	call   c0026cc9 <shutdown_reboot>
              c -= 0x40; 
c0024a7c:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0024a80:	eb 9a                	jmp    c0024a1c <keyboard_interrupt+0x13a>
            c = tolower (c);
c0024a82:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0024a85:	8d 48 bf             	lea    -0x41(%eax),%ecx
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024a88:	8d 50 20             	lea    0x20(%eax),%edx
c0024a8b:	83 f9 1a             	cmp    $0x1a,%ecx
c0024a8e:	0f 42 c2             	cmovb  %edx,%eax
c0024a91:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0024a95:	eb 85                	jmp    c0024a1c <keyboard_interrupt+0x13a>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024a97:	8d 83 6c 00 00 00    	lea    0x6c(%ebx),%eax
c0024a9d:	e9 2e ff ff ff       	jmp    c00249d0 <keyboard_interrupt+0xee>

c0024aa2 <kbd_init>:
{
c0024aa2:	53                   	push   %ebx
c0024aa3:	83 ec 0c             	sub    $0xc,%esp
c0024aa6:	e8 da 9f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024aab:	81 c3 09 64 01 00    	add    $0x16409,%ebx
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0024ab1:	8d 83 a9 5c ff ff    	lea    -0xa357(%ebx),%eax
c0024ab7:	50                   	push   %eax
c0024ab8:	8d 83 2e 9a fe ff    	lea    -0x165d2(%ebx),%eax
c0024abe:	50                   	push   %eax
c0024abf:	6a 21                	push   $0x21
c0024ac1:	e8 43 d5 ff ff       	call   c0022009 <intr_register_ext>
}
c0024ac6:	83 c4 18             	add    $0x18,%esp
c0024ac9:	5b                   	pop    %ebx
c0024aca:	c3                   	ret    

c0024acb <kbd_print_stats>:
{
c0024acb:	53                   	push   %ebx
c0024acc:	83 ec 0c             	sub    $0xc,%esp
c0024acf:	e8 b1 9f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024ad4:	81 c3 e0 63 01 00    	add    $0x163e0,%ebx
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c0024ada:	ff b3 18 1f 00 00    	pushl  0x1f18(%ebx)
c0024ae0:	ff b3 14 1f 00 00    	pushl  0x1f14(%ebx)
c0024ae6:	8d 83 b7 5c ff ff    	lea    -0xa349(%ebx),%eax
c0024aec:	50                   	push   %eax
c0024aed:	e8 fe 29 00 00       	call   c00274f0 <printf>
}
c0024af2:	83 c4 18             	add    $0x18,%esp
c0024af5:	5b                   	pop    %ebx
c0024af6:	c3                   	ret    

c0024af7 <move_cursor>:
}

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c0024af7:	e8 8d 9f 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0024afc:	05 b8 63 01 00       	add    $0x163b8,%eax
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024b01:	8b 88 2c 1f 00 00    	mov    0x1f2c(%eax),%ecx
c0024b07:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0024b0a:	c1 e1 04             	shl    $0x4,%ecx
c0024b0d:	66 03 88 30 1f 00 00 	add    0x1f30(%eax),%cx
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0024b14:	89 c8                	mov    %ecx,%eax
c0024b16:	b0 00                	mov    $0x0,%al
c0024b18:	83 c8 0e             	or     $0xe,%eax
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024b1b:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0024b20:	66 ef                	out    %ax,(%dx)
  outw (0x3d4, 0x0f | (cp << 8));
c0024b22:	89 c8                	mov    %ecx,%eax
c0024b24:	c1 e0 08             	shl    $0x8,%eax
c0024b27:	83 c8 0f             	or     $0xf,%eax
c0024b2a:	66 ef                	out    %ax,(%dx)
}
c0024b2c:	c3                   	ret    

c0024b2d <newline>:
{
c0024b2d:	56                   	push   %esi
c0024b2e:	53                   	push   %ebx
c0024b2f:	83 ec 04             	sub    $0x4,%esp
c0024b32:	e8 4e 9f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024b37:	81 c3 7d 63 01 00    	add    $0x1637d,%ebx
  cx = 0;
c0024b3d:	c7 83 30 1f 00 00 00 	movl   $0x0,0x1f30(%ebx)
c0024b44:	00 00 00 
  cy++;
c0024b47:	8b 83 2c 1f 00 00    	mov    0x1f2c(%ebx),%eax
c0024b4d:	83 c0 01             	add    $0x1,%eax
  if (cy >= ROW_CNT)
c0024b50:	83 f8 18             	cmp    $0x18,%eax
c0024b53:	77 0c                	ja     c0024b61 <newline+0x34>
  cy++;
c0024b55:	89 83 2c 1f 00 00    	mov    %eax,0x1f2c(%ebx)
}
c0024b5b:	83 c4 04             	add    $0x4,%esp
c0024b5e:	5b                   	pop    %ebx
c0024b5f:	5e                   	pop    %esi
c0024b60:	c3                   	ret    
      cy = ROW_CNT - 1;
c0024b61:	c7 83 2c 1f 00 00 18 	movl   $0x18,0x1f2c(%ebx)
c0024b68:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024b6b:	8b b3 28 1f 00 00    	mov    0x1f28(%ebx),%esi
c0024b71:	83 ec 04             	sub    $0x4,%esp
c0024b74:	68 00 0f 00 00       	push   $0xf00
c0024b79:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0024b7f:	50                   	push   %eax
c0024b80:	56                   	push   %esi
c0024b81:	e8 25 39 00 00       	call   c00284ab <memmove>
c0024b86:	8d 86 00 0f 00 00    	lea    0xf00(%esi),%eax
c0024b8c:	8d 96 a0 0f 00 00    	lea    0xfa0(%esi),%edx
c0024b92:	83 c4 10             	add    $0x10,%esp
      fb[y][x][0] = ' ';
c0024b95:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024b98:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024b9c:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024b9f:	39 d0                	cmp    %edx,%eax
c0024ba1:	75 f2                	jne    c0024b95 <newline+0x68>
c0024ba3:	eb b6                	jmp    c0024b5b <newline+0x2e>

c0024ba5 <vga_putc>:
{
c0024ba5:	55                   	push   %ebp
c0024ba6:	57                   	push   %edi
c0024ba7:	56                   	push   %esi
c0024ba8:	53                   	push   %ebx
c0024ba9:	83 ec 0c             	sub    $0xc,%esp
c0024bac:	e8 d4 9e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024bb1:	81 c3 03 63 01 00    	add    $0x16303,%ebx
  enum intr_level old_level = intr_disable ();
c0024bb7:	e8 73 d2 ff ff       	call   c0021e2f <intr_disable>
c0024bbc:	89 c6                	mov    %eax,%esi
  if (!inited)
c0024bbe:	80 bb 24 1f 00 00 00 	cmpb   $0x0,0x1f24(%ebx)
c0024bc5:	74 1b                	je     c0024be2 <vga_putc+0x3d>
  switch (c) 
c0024bc7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0024bcb:	83 e8 07             	sub    $0x7,%eax
c0024bce:	83 f8 06             	cmp    $0x6,%eax
c0024bd1:	0f 87 1f 01 00 00    	ja     c0024cf6 <.L11>
c0024bd7:	89 df                	mov    %ebx,%edi
c0024bd9:	03 bc 83 d4 3f ff ff 	add    -0xc02c(%ebx,%eax,4),%edi
c0024be0:	ff e7                	jmp    *%edi
      fb = ptov (0xb8000);
c0024be2:	c7 83 28 1f 00 00 00 	movl   $0xc00b8000,0x1f28(%ebx)
c0024be9:	80 0b c0 
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024bec:	bf d4 03 00 00       	mov    $0x3d4,%edi
c0024bf1:	b8 0e 00 00 00       	mov    $0xe,%eax
c0024bf6:	89 fa                	mov    %edi,%edx
c0024bf8:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024bf9:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0024bfe:	89 ca                	mov    %ecx,%edx
c0024c00:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
  cp = inb (0x3d5) << 8;
c0024c01:	89 c5                	mov    %eax,%ebp
c0024c03:	c1 e5 08             	shl    $0x8,%ebp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024c06:	b8 0f 00 00 00       	mov    $0xf,%eax
c0024c0b:	89 fa                	mov    %edi,%edx
c0024c0d:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024c0e:	89 ca                	mov    %ecx,%edx
c0024c10:	ec                   	in     (%dx),%al

  outb (0x3d4, 0x0f);
  cp |= inb (0x3d5);
c0024c11:	0f b6 c0             	movzbl %al,%eax
c0024c14:	09 e8                	or     %ebp,%eax

  *x = cp % COL_CNT;
c0024c16:	0f b7 d0             	movzwl %ax,%edx
c0024c19:	69 d2 cd cc 00 00    	imul   $0xcccd,%edx,%edx
c0024c1f:	c1 ea 16             	shr    $0x16,%edx
c0024c22:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0024c25:	c1 e1 04             	shl    $0x4,%ecx
c0024c28:	29 c8                	sub    %ecx,%eax
c0024c2a:	0f b7 c0             	movzwl %ax,%eax
c0024c2d:	89 83 30 1f 00 00    	mov    %eax,0x1f30(%ebx)
  *y = cp / COL_CNT;
c0024c33:	0f b7 d2             	movzwl %dx,%edx
c0024c36:	89 93 2c 1f 00 00    	mov    %edx,0x1f2c(%ebx)
      inited = true; 
c0024c3c:	c6 83 24 1f 00 00 01 	movb   $0x1,0x1f24(%ebx)
c0024c43:	eb 82                	jmp    c0024bc7 <vga_putc+0x22>

c0024c45 <.L17>:
c0024c45:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c0024c4b:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c0024c51:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
      fb[y][x][0] = ' ';
c0024c57:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024c5a:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0024c5e:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0024c61:	39 c2                	cmp    %eax,%edx
c0024c63:	75 f2                	jne    c0024c57 <.L17+0x12>
  for (y = 0; y < ROW_CNT; y++)
c0024c65:	39 c8                	cmp    %ecx,%eax
c0024c67:	75 e8                	jne    c0024c51 <.L17+0xc>
  cx = cy = 0;
c0024c69:	c7 83 2c 1f 00 00 00 	movl   $0x0,0x1f2c(%ebx)
c0024c70:	00 00 00 
c0024c73:	c7 83 30 1f 00 00 00 	movl   $0x0,0x1f30(%ebx)
c0024c7a:	00 00 00 
  move_cursor ();
c0024c7d:	e8 75 fe ff ff       	call   c0024af7 <move_cursor>
c0024c82:	eb 05                	jmp    c0024c89 <.L16+0x5>

c0024c84 <.L16>:
      newline ();
c0024c84:	e8 a4 fe ff ff       	call   c0024b2d <newline>
  move_cursor ();
c0024c89:	e8 69 fe ff ff       	call   c0024af7 <move_cursor>
  intr_set_level (old_level);
c0024c8e:	83 ec 0c             	sub    $0xc,%esp
c0024c91:	56                   	push   %esi
c0024c92:	e8 9f d1 ff ff       	call   c0021e36 <intr_set_level>
}
c0024c97:	83 c4 1c             	add    $0x1c,%esp
c0024c9a:	5b                   	pop    %ebx
c0024c9b:	5e                   	pop    %esi
c0024c9c:	5f                   	pop    %edi
c0024c9d:	5d                   	pop    %ebp
c0024c9e:	c3                   	ret    

c0024c9f <.L14>:
      if (cx > 0)
c0024c9f:	8b 83 30 1f 00 00    	mov    0x1f30(%ebx),%eax
c0024ca5:	85 c0                	test   %eax,%eax
c0024ca7:	74 e0                	je     c0024c89 <.L16+0x5>
        cx--;
c0024ca9:	83 e8 01             	sub    $0x1,%eax
c0024cac:	89 83 30 1f 00 00    	mov    %eax,0x1f30(%ebx)
c0024cb2:	eb d5                	jmp    c0024c89 <.L16+0x5>

c0024cb4 <.L18>:
      cx = 0;
c0024cb4:	c7 83 30 1f 00 00 00 	movl   $0x0,0x1f30(%ebx)
c0024cbb:	00 00 00 
      break;
c0024cbe:	eb c9                	jmp    c0024c89 <.L16+0x5>

c0024cc0 <.L15>:
      cx = ROUND_UP (cx + 1, 8);
c0024cc0:	8b 83 30 1f 00 00    	mov    0x1f30(%ebx),%eax
c0024cc6:	83 c0 08             	add    $0x8,%eax
c0024cc9:	83 e0 f8             	and    $0xfffffff8,%eax
c0024ccc:	89 83 30 1f 00 00    	mov    %eax,0x1f30(%ebx)
      if (cx >= COL_CNT)
c0024cd2:	83 f8 4f             	cmp    $0x4f,%eax
c0024cd5:	76 b2                	jbe    c0024c89 <.L16+0x5>
        newline ();
c0024cd7:	e8 51 fe ff ff       	call   c0024b2d <newline>
c0024cdc:	eb ab                	jmp    c0024c89 <.L16+0x5>

c0024cde <.L12>:
      intr_set_level (old_level);
c0024cde:	83 ec 0c             	sub    $0xc,%esp
c0024ce1:	56                   	push   %esi
c0024ce2:	e8 4f d1 ff ff       	call   c0021e36 <intr_set_level>
      speaker_beep ();
c0024ce7:	e8 a4 21 00 00       	call   c0026e90 <speaker_beep>
      intr_disable ();
c0024cec:	e8 3e d1 ff ff       	call   c0021e2f <intr_disable>
      break;
c0024cf1:	83 c4 10             	add    $0x10,%esp
c0024cf4:	eb 93                	jmp    c0024c89 <.L16+0x5>

c0024cf6 <.L11>:
      fb[cy][cx][0] = c;
c0024cf6:	8b bb 28 1f 00 00    	mov    0x1f28(%ebx),%edi
c0024cfc:	8b 83 2c 1f 00 00    	mov    0x1f2c(%ebx),%eax
c0024d02:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024d05:	c1 e0 05             	shl    $0x5,%eax
c0024d08:	01 f8                	add    %edi,%eax
c0024d0a:	8b 8b 30 1f 00 00    	mov    0x1f30(%ebx),%ecx
c0024d10:	0f b6 54 24 20       	movzbl 0x20(%esp),%edx
c0024d15:	88 14 48             	mov    %dl,(%eax,%ecx,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024d18:	8b 83 2c 1f 00 00    	mov    0x1f2c(%ebx),%eax
c0024d1e:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0024d21:	c1 e0 05             	shl    $0x5,%eax
c0024d24:	8d 14 07             	lea    (%edi,%eax,1),%edx
c0024d27:	8b 83 30 1f 00 00    	mov    0x1f30(%ebx),%eax
c0024d2d:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c0024d32:	8b 83 30 1f 00 00    	mov    0x1f30(%ebx),%eax
c0024d38:	83 c0 01             	add    $0x1,%eax
c0024d3b:	89 83 30 1f 00 00    	mov    %eax,0x1f30(%ebx)
c0024d41:	83 f8 4f             	cmp    $0x4f,%eax
c0024d44:	0f 86 3f ff ff ff    	jbe    c0024c89 <.L16+0x5>
        newline ();
c0024d4a:	e8 de fd ff ff       	call   c0024b2d <newline>
c0024d4f:	e9 35 ff ff ff       	jmp    c0024c89 <.L16+0x5>

c0024d54 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024d54:	57                   	push   %edi
c0024d55:	56                   	push   %esi
c0024d56:	53                   	push   %ebx
c0024d57:	e8 29 9d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024d5c:	81 c3 58 61 01 00    	add    $0x16158,%ebx
  ASSERT (mode == UNINIT);
c0024d62:	83 bb c0 1f 00 00 00 	cmpl   $0x0,0x1fc0(%ebx)
c0024d69:	75 65                	jne    c0024dd0 <init_poll+0x7c>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024d6b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024d70:	bf f9 03 00 00       	mov    $0x3f9,%edi
c0024d75:	89 c8                	mov    %ecx,%eax
c0024d77:	89 fa                	mov    %edi,%edx
c0024d79:	ee                   	out    %al,(%dx)
c0024d7a:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024d7f:	ee                   	out    %al,(%dx)
c0024d80:	be fb 03 00 00       	mov    $0x3fb,%esi
c0024d85:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c0024d8a:	89 f2                	mov    %esi,%edx
c0024d8c:	ee                   	out    %al,(%dx)
c0024d8d:	b8 0c 00 00 00       	mov    $0xc,%eax
c0024d92:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024d97:	ee                   	out    %al,(%dx)
c0024d98:	89 c8                	mov    %ecx,%eax
c0024d9a:	89 fa                	mov    %edi,%edx
c0024d9c:	ee                   	out    %al,(%dx)
c0024d9d:	b8 03 00 00 00       	mov    $0x3,%eax
c0024da2:	89 f2                	mov    %esi,%edx
c0024da4:	ee                   	out    %al,(%dx)
c0024da5:	b8 08 00 00 00       	mov    $0x8,%eax
c0024daa:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024daf:	ee                   	out    %al,(%dx)
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
  outb (FCR_REG, 0);                    /* Disable FIFO. */
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
  intq_init (&txq);
c0024db0:	83 ec 0c             	sub    $0xc,%esp
c0024db3:	8d 83 4c 1f 00 00    	lea    0x1f4c(%ebx),%eax
c0024db9:	50                   	push   %eax
c0024dba:	e8 5f 19 00 00       	call   c002671e <intq_init>
  mode = POLL;
c0024dbf:	c7 83 c0 1f 00 00 01 	movl   $0x1,0x1fc0(%ebx)
c0024dc6:	00 00 00 
} 
c0024dc9:	83 c4 10             	add    $0x10,%esp
c0024dcc:	5b                   	pop    %ebx
c0024dcd:	5e                   	pop    %esi
c0024dce:	5f                   	pop    %edi
c0024dcf:	c3                   	ret    
  ASSERT (mode == UNINIT);
c0024dd0:	83 ec 0c             	sub    $0xc,%esp
c0024dd3:	8d 83 30 5d ff ff    	lea    -0xa2d0(%ebx),%eax
c0024dd9:	50                   	push   %eax
c0024dda:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0024de0:	50                   	push   %eax
c0024de1:	8d 83 18 40 ff ff    	lea    -0xbfe8(%ebx),%eax
c0024de7:	50                   	push   %eax
c0024de8:	6a 45                	push   $0x45
c0024dea:	8d 83 3f 5d ff ff    	lea    -0xa2c1(%ebx),%eax
c0024df0:	50                   	push   %eax
c0024df1:	e8 91 44 00 00       	call   c0029287 <debug_panic>

c0024df6 <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024df6:	56                   	push   %esi
c0024df7:	53                   	push   %ebx
c0024df8:	83 ec 04             	sub    $0x4,%esp
c0024dfb:	e8 85 9c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024e00:	81 c3 b4 60 01 00    	add    $0x160b4,%ebx
  uint8_t ier = 0;

  ASSERT (intr_get_level () == INTR_OFF);
c0024e06:	e8 d2 cf ff ff       	call   c0021ddd <intr_get_level>
c0024e0b:	85 c0                	test   %eax,%eax
c0024e0d:	75 37                	jne    c0024e46 <write_ier+0x50>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024e0f:	83 ec 0c             	sub    $0xc,%esp
c0024e12:	8d 83 4c 1f 00 00    	lea    0x1f4c(%ebx),%eax
c0024e18:	50                   	push   %eax
c0024e19:	e8 3c 19 00 00       	call   c002675a <intq_empty>
c0024e1e:	83 c4 10             	add    $0x10,%esp
    ier |= IER_XMIT;
c0024e21:	84 c0                	test   %al,%al
c0024e23:	0f 94 c0             	sete   %al
c0024e26:	8d 34 00             	lea    (%eax,%eax,1),%esi

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024e29:	e8 9e 18 00 00       	call   c00266cc <input_full>
    ier |= IER_RECV;
c0024e2e:	89 f2                	mov    %esi,%edx
c0024e30:	83 ca 01             	or     $0x1,%edx
c0024e33:	84 c0                	test   %al,%al
c0024e35:	0f 44 f2             	cmove  %edx,%esi
c0024e38:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0024e3d:	89 f0                	mov    %esi,%eax
c0024e3f:	ee                   	out    %al,(%dx)
  
  outb (IER_REG, ier);
}
c0024e40:	83 c4 04             	add    $0x4,%esp
c0024e43:	5b                   	pop    %ebx
c0024e44:	5e                   	pop    %esi
c0024e45:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024e46:	83 ec 0c             	sub    $0xc,%esp
c0024e49:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0024e4f:	50                   	push   %eax
c0024e50:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0024e56:	50                   	push   %eax
c0024e57:	8d 83 0c 40 ff ff    	lea    -0xbff4(%ebx),%eax
c0024e5d:	50                   	push   %eax
c0024e5e:	68 b5 00 00 00       	push   $0xb5
c0024e63:	8d 83 3f 5d ff ff    	lea    -0xa2c1(%ebx),%eax
c0024e69:	50                   	push   %eax
c0024e6a:	e8 18 44 00 00       	call   c0029287 <debug_panic>

c0024e6f <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024e6f:	57                   	push   %edi
c0024e70:	56                   	push   %esi
c0024e71:	53                   	push   %ebx
c0024e72:	e8 0e 9c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024e77:	81 c3 3d 60 01 00    	add    $0x1603d,%ebx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024e7d:	ba fa 03 00 00       	mov    $0x3fa,%edx
c0024e82:	ec                   	in     (%dx),%al
c0024e83:	be fd 03 00 00       	mov    $0x3fd,%esi
c0024e88:	bf f8 03 00 00       	mov    $0x3f8,%edi
c0024e8d:	eb 12                	jmp    c0024ea1 <serial_interrupt+0x32>
c0024e8f:	89 fa                	mov    %edi,%edx
c0024e91:	ec                   	in     (%dx),%al
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));
c0024e92:	83 ec 0c             	sub    $0xc,%esp
c0024e95:	0f b6 c0             	movzbl %al,%eax
c0024e98:	50                   	push   %eax
c0024e99:	e8 53 17 00 00       	call   c00265f1 <input_putc>
c0024e9e:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024ea1:	e8 26 18 00 00       	call   c00266cc <input_full>
c0024ea6:	84 c0                	test   %al,%al
c0024ea8:	75 07                	jne    c0024eb1 <serial_interrupt+0x42>
c0024eaa:	89 f2                	mov    %esi,%edx
c0024eac:	ec                   	in     (%dx),%al
c0024ead:	a8 01                	test   $0x1,%al
c0024eaf:	75 de                	jne    c0024e8f <serial_interrupt+0x20>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024eb1:	8d b3 4c 1f 00 00    	lea    0x1f4c(%ebx),%esi
c0024eb7:	bf fd 03 00 00       	mov    $0x3fd,%edi
c0024ebc:	eb 12                	jmp    c0024ed0 <serial_interrupt+0x61>
    outb (THR_REG, intq_getc (&txq));
c0024ebe:	83 ec 0c             	sub    $0xc,%esp
c0024ec1:	56                   	push   %esi
c0024ec2:	e8 d6 1a 00 00       	call   c002699d <intq_getc>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024ec7:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024ecc:	ee                   	out    %al,(%dx)
c0024ecd:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024ed0:	83 ec 0c             	sub    $0xc,%esp
c0024ed3:	56                   	push   %esi
c0024ed4:	e8 81 18 00 00       	call   c002675a <intq_empty>
c0024ed9:	83 c4 10             	add    $0x10,%esp
c0024edc:	84 c0                	test   %al,%al
c0024ede:	75 07                	jne    c0024ee7 <serial_interrupt+0x78>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024ee0:	89 fa                	mov    %edi,%edx
c0024ee2:	ec                   	in     (%dx),%al
c0024ee3:	a8 20                	test   $0x20,%al
c0024ee5:	75 d7                	jne    c0024ebe <serial_interrupt+0x4f>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024ee7:	e8 0a ff ff ff       	call   c0024df6 <write_ier>
}
c0024eec:	5b                   	pop    %ebx
c0024eed:	5e                   	pop    %esi
c0024eee:	5f                   	pop    %edi
c0024eef:	c3                   	ret    

c0024ef0 <putc_poll>:
{
c0024ef0:	56                   	push   %esi
c0024ef1:	53                   	push   %ebx
c0024ef2:	83 ec 04             	sub    $0x4,%esp
c0024ef5:	e8 8b 9b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024efa:	81 c3 ba 5f 01 00    	add    $0x15fba,%ebx
c0024f00:	89 c6                	mov    %eax,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0024f02:	e8 d6 ce ff ff       	call   c0021ddd <intr_get_level>
c0024f07:	85 c0                	test   %eax,%eax
c0024f09:	75 18                	jne    c0024f23 <putc_poll+0x33>
c0024f0b:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024f10:	ec                   	in     (%dx),%al
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024f11:	a8 20                	test   $0x20,%al
c0024f13:	74 fb                	je     c0024f10 <putc_poll+0x20>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024f15:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024f1a:	89 f0                	mov    %esi,%eax
c0024f1c:	ee                   	out    %al,(%dx)
}
c0024f1d:	83 c4 04             	add    $0x4,%esp
c0024f20:	5b                   	pop    %ebx
c0024f21:	5e                   	pop    %esi
c0024f22:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0024f23:	83 ec 0c             	sub    $0xc,%esp
c0024f26:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0024f2c:	50                   	push   %eax
c0024f2d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0024f33:	50                   	push   %eax
c0024f34:	8d 83 00 40 ff ff    	lea    -0xc000(%ebx),%eax
c0024f3a:	50                   	push   %eax
c0024f3b:	68 c9 00 00 00       	push   $0xc9
c0024f40:	8d 83 3f 5d ff ff    	lea    -0xa2c1(%ebx),%eax
c0024f46:	50                   	push   %eax
c0024f47:	e8 3b 43 00 00       	call   c0029287 <debug_panic>

c0024f4c <serial_init_queue>:
{
c0024f4c:	56                   	push   %esi
c0024f4d:	53                   	push   %ebx
c0024f4e:	83 ec 04             	sub    $0x4,%esp
c0024f51:	e8 2f 9b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024f56:	81 c3 5e 5f 01 00    	add    $0x15f5e,%ebx
  if (mode == UNINIT)
c0024f5c:	83 bb c0 1f 00 00 00 	cmpl   $0x0,0x1fc0(%ebx)
c0024f63:	74 45                	je     c0024faa <serial_init_queue+0x5e>
  ASSERT (mode == POLL);
c0024f65:	83 bb c0 1f 00 00 01 	cmpl   $0x1,0x1fc0(%ebx)
c0024f6c:	75 43                	jne    c0024fb1 <serial_init_queue+0x65>
  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024f6e:	83 ec 04             	sub    $0x4,%esp
c0024f71:	8d 83 63 5d ff ff    	lea    -0xa29d(%ebx),%eax
c0024f77:	50                   	push   %eax
c0024f78:	8d 83 bb 9f fe ff    	lea    -0x16045(%ebx),%eax
c0024f7e:	50                   	push   %eax
c0024f7f:	6a 24                	push   $0x24
c0024f81:	e8 83 d0 ff ff       	call   c0022009 <intr_register_ext>
  mode = QUEUE;
c0024f86:	c7 83 c0 1f 00 00 02 	movl   $0x2,0x1fc0(%ebx)
c0024f8d:	00 00 00 
  old_level = intr_disable ();
c0024f90:	e8 9a ce ff ff       	call   c0021e2f <intr_disable>
c0024f95:	89 c6                	mov    %eax,%esi
  write_ier ();
c0024f97:	e8 5a fe ff ff       	call   c0024df6 <write_ier>
  intr_set_level (old_level);
c0024f9c:	89 34 24             	mov    %esi,(%esp)
c0024f9f:	e8 92 ce ff ff       	call   c0021e36 <intr_set_level>
}
c0024fa4:	83 c4 14             	add    $0x14,%esp
c0024fa7:	5b                   	pop    %ebx
c0024fa8:	5e                   	pop    %esi
c0024fa9:	c3                   	ret    
    init_poll ();
c0024faa:	e8 a5 fd ff ff       	call   c0024d54 <init_poll>
c0024faf:	eb b4                	jmp    c0024f65 <serial_init_queue+0x19>
  ASSERT (mode == POLL);
c0024fb1:	83 ec 0c             	sub    $0xc,%esp
c0024fb4:	8d 83 56 5d ff ff    	lea    -0xa2aa(%ebx),%eax
c0024fba:	50                   	push   %eax
c0024fbb:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0024fc1:	50                   	push   %eax
c0024fc2:	8d 83 24 40 ff ff    	lea    -0xbfdc(%ebx),%eax
c0024fc8:	50                   	push   %eax
c0024fc9:	6a 58                	push   $0x58
c0024fcb:	8d 83 3f 5d ff ff    	lea    -0xa2c1(%ebx),%eax
c0024fd1:	50                   	push   %eax
c0024fd2:	e8 b0 42 00 00       	call   c0029287 <debug_panic>

c0024fd7 <serial_putc>:
{
c0024fd7:	57                   	push   %edi
c0024fd8:	56                   	push   %esi
c0024fd9:	53                   	push   %ebx
c0024fda:	e8 a6 9a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0024fdf:	81 c3 d5 5e 01 00    	add    $0x15ed5,%ebx
c0024fe5:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable ();
c0024fe9:	e8 41 ce ff ff       	call   c0021e2f <intr_disable>
c0024fee:	89 c7                	mov    %eax,%edi
  if (mode != QUEUE)
c0024ff0:	8b 83 c0 1f 00 00    	mov    0x1fc0(%ebx),%eax
c0024ff6:	83 f8 02             	cmp    $0x2,%eax
c0024ff9:	74 25                	je     c0025020 <serial_putc+0x49>
      if (mode == UNINIT)
c0024ffb:	85 c0                	test   %eax,%eax
c0024ffd:	74 1a                	je     c0025019 <serial_putc+0x42>
      putc_poll (byte); 
c0024fff:	89 f0                	mov    %esi,%eax
c0025001:	0f b6 c0             	movzbl %al,%eax
c0025004:	e8 e7 fe ff ff       	call   c0024ef0 <putc_poll>
  intr_set_level (old_level);
c0025009:	83 ec 0c             	sub    $0xc,%esp
c002500c:	57                   	push   %edi
c002500d:	e8 24 ce ff ff       	call   c0021e36 <intr_set_level>
}
c0025012:	83 c4 10             	add    $0x10,%esp
c0025015:	5b                   	pop    %ebx
c0025016:	5e                   	pop    %esi
c0025017:	5f                   	pop    %edi
c0025018:	c3                   	ret    
        init_poll ();
c0025019:	e8 36 fd ff ff       	call   c0024d54 <init_poll>
c002501e:	eb df                	jmp    c0024fff <serial_putc+0x28>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0025020:	85 ff                	test   %edi,%edi
c0025022:	74 1f                	je     c0025043 <serial_putc+0x6c>
      intq_putc (&txq, byte); 
c0025024:	83 ec 08             	sub    $0x8,%esp
c0025027:	89 f0                	mov    %esi,%eax
c0025029:	0f b6 f0             	movzbl %al,%esi
c002502c:	56                   	push   %esi
c002502d:	8d 83 4c 1f 00 00    	lea    0x1f4c(%ebx),%eax
c0025033:	50                   	push   %eax
c0025034:	e8 2f 1a 00 00       	call   c0026a68 <intq_putc>
      write_ier ();
c0025039:	e8 b8 fd ff ff       	call   c0024df6 <write_ier>
c002503e:	83 c4 10             	add    $0x10,%esp
c0025041:	eb c6                	jmp    c0025009 <serial_putc+0x32>
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0025043:	83 ec 0c             	sub    $0xc,%esp
c0025046:	8d 83 4c 1f 00 00    	lea    0x1f4c(%ebx),%eax
c002504c:	50                   	push   %eax
c002504d:	e8 5a 17 00 00       	call   c00267ac <intq_full>
c0025052:	83 c4 10             	add    $0x10,%esp
c0025055:	84 c0                	test   %al,%al
c0025057:	74 cb                	je     c0025024 <serial_putc+0x4d>
          putc_poll (intq_getc (&txq)); 
c0025059:	83 ec 0c             	sub    $0xc,%esp
c002505c:	8d 83 4c 1f 00 00    	lea    0x1f4c(%ebx),%eax
c0025062:	50                   	push   %eax
c0025063:	e8 35 19 00 00       	call   c002699d <intq_getc>
c0025068:	0f b6 c0             	movzbl %al,%eax
c002506b:	e8 80 fe ff ff       	call   c0024ef0 <putc_poll>
c0025070:	83 c4 10             	add    $0x10,%esp
c0025073:	eb af                	jmp    c0025024 <serial_putc+0x4d>

c0025075 <serial_flush>:
{
c0025075:	57                   	push   %edi
c0025076:	56                   	push   %esi
c0025077:	53                   	push   %ebx
c0025078:	e8 08 9a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002507d:	81 c3 37 5e 01 00    	add    $0x15e37,%ebx
  enum intr_level old_level = intr_disable ();
c0025083:	e8 a7 cd ff ff       	call   c0021e2f <intr_disable>
c0025088:	89 c7                	mov    %eax,%edi
  while (!intq_empty (&txq))
c002508a:	8d b3 4c 1f 00 00    	lea    0x1f4c(%ebx),%esi
c0025090:	eb 14                	jmp    c00250a6 <serial_flush+0x31>
    putc_poll (intq_getc (&txq));
c0025092:	83 ec 0c             	sub    $0xc,%esp
c0025095:	56                   	push   %esi
c0025096:	e8 02 19 00 00       	call   c002699d <intq_getc>
c002509b:	0f b6 c0             	movzbl %al,%eax
c002509e:	e8 4d fe ff ff       	call   c0024ef0 <putc_poll>
c00250a3:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c00250a6:	83 ec 0c             	sub    $0xc,%esp
c00250a9:	56                   	push   %esi
c00250aa:	e8 ab 16 00 00       	call   c002675a <intq_empty>
c00250af:	83 c4 10             	add    $0x10,%esp
c00250b2:	84 c0                	test   %al,%al
c00250b4:	74 dc                	je     c0025092 <serial_flush+0x1d>
  intr_set_level (old_level);
c00250b6:	83 ec 0c             	sub    $0xc,%esp
c00250b9:	57                   	push   %edi
c00250ba:	e8 77 cd ff ff       	call   c0021e36 <intr_set_level>
}
c00250bf:	83 c4 10             	add    $0x10,%esp
c00250c2:	5b                   	pop    %ebx
c00250c3:	5e                   	pop    %esi
c00250c4:	5f                   	pop    %edi
c00250c5:	c3                   	ret    

c00250c6 <serial_notify>:
{
c00250c6:	53                   	push   %ebx
c00250c7:	83 ec 08             	sub    $0x8,%esp
c00250ca:	e8 b6 99 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00250cf:	81 c3 e5 5d 01 00    	add    $0x15de5,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00250d5:	e8 03 cd ff ff       	call   c0021ddd <intr_get_level>
c00250da:	85 c0                	test   %eax,%eax
c00250dc:	75 0e                	jne    c00250ec <serial_notify+0x26>
  if (mode == QUEUE)
c00250de:	83 bb c0 1f 00 00 02 	cmpl   $0x2,0x1fc0(%ebx)
c00250e5:	74 2e                	je     c0025115 <serial_notify+0x4f>
}
c00250e7:	83 c4 08             	add    $0x8,%esp
c00250ea:	5b                   	pop    %ebx
c00250eb:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00250ec:	83 ec 0c             	sub    $0xc,%esp
c00250ef:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c00250f5:	50                   	push   %eax
c00250f6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00250fc:	50                   	push   %eax
c00250fd:	8d 83 f0 3f ff ff    	lea    -0xc010(%ebx),%eax
c0025103:	50                   	push   %eax
c0025104:	68 96 00 00 00       	push   $0x96
c0025109:	8d 83 3f 5d ff ff    	lea    -0xa2c1(%ebx),%eax
c002510f:	50                   	push   %eax
c0025110:	e8 72 41 00 00       	call   c0029287 <debug_panic>
    write_ier ();
c0025115:	e8 dc fc ff ff       	call   c0024df6 <write_ier>
}
c002511a:	eb cb                	jmp    c00250e7 <serial_notify+0x21>

c002511c <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c002511c:	53                   	push   %ebx
c002511d:	83 ec 08             	sub    $0x8,%esp
c0025120:	e8 70 99 00 00       	call   c002ea95 <__x86.get_pc_thunk.cx>
c0025125:	81 c1 8f 5d 01 00    	add    $0x15d8f,%ecx
  if (sector >= block->size)
c002512b:	8b 58 1c             	mov    0x1c(%eax),%ebx
c002512e:	39 d3                	cmp    %edx,%ebx
c0025130:	76 05                	jbe    c0025137 <check_sector+0x1b>
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0025132:	83 c4 08             	add    $0x8,%esp
c0025135:	5b                   	pop    %ebx
c0025136:	c3                   	ret    
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0025137:	83 ec 04             	sub    $0x4,%esp
c002513a:	53                   	push   %ebx
c002513b:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c002513c:	83 c0 08             	add    $0x8,%eax
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c002513f:	50                   	push   %eax
c0025140:	8d 81 6c 5d ff ff    	lea    -0xa294(%ecx),%eax
c0025146:	50                   	push   %eax
c0025147:	8d 81 54 40 ff ff    	lea    -0xbfac(%ecx),%eax
c002514d:	50                   	push   %eax
c002514e:	6a 70                	push   $0x70
c0025150:	8d 81 fa 5d ff ff    	lea    -0xa206(%ecx),%eax
c0025156:	50                   	push   %eax
c0025157:	89 cb                	mov    %ecx,%ebx
c0025159:	e8 29 41 00 00       	call   c0029287 <debug_panic>

c002515e <block_type_name>:
{
c002515e:	53                   	push   %ebx
c002515f:	83 ec 08             	sub    $0x8,%esp
c0025162:	e8 1e 99 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025167:	81 c3 4d 5d 01 00    	add    $0x15d4d,%ebx
c002516d:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (type < BLOCK_CNT);
c0025171:	83 f8 05             	cmp    $0x5,%eax
c0025174:	77 0c                	ja     c0025182 <block_type_name+0x24>
  return block_type_names[type];
c0025176:	8b 84 83 7c 01 00 00 	mov    0x17c(%ebx,%eax,4),%eax
}
c002517d:	83 c4 08             	add    $0x8,%esp
c0025180:	5b                   	pop    %ebx
c0025181:	c3                   	ret    
  ASSERT (type < BLOCK_CNT);
c0025182:	83 ec 0c             	sub    $0xc,%esp
c0025185:	8d 83 10 5e ff ff    	lea    -0xa1f0(%ebx),%eax
c002518b:	50                   	push   %eax
c002518c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0025192:	50                   	push   %eax
c0025193:	8d 83 84 40 ff ff    	lea    -0xbf7c(%ebx),%eax
c0025199:	50                   	push   %eax
c002519a:	6a 2f                	push   $0x2f
c002519c:	8d 83 fa 5d ff ff    	lea    -0xa206(%ebx),%eax
c00251a2:	50                   	push   %eax
c00251a3:	e8 df 40 00 00       	call   c0029287 <debug_panic>

c00251a8 <block_get_role>:
{
c00251a8:	53                   	push   %ebx
c00251a9:	83 ec 08             	sub    $0x8,%esp
c00251ac:	e8 d4 98 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00251b1:	81 c3 03 5d 01 00    	add    $0x15d03,%ebx
c00251b7:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c00251bb:	83 f8 03             	cmp    $0x3,%eax
c00251be:	77 0c                	ja     c00251cc <block_get_role+0x24>
  return block_by_role[role];
c00251c0:	8b 84 83 c4 1f 00 00 	mov    0x1fc4(%ebx,%eax,4),%eax
}
c00251c7:	83 c4 08             	add    $0x8,%esp
c00251ca:	5b                   	pop    %ebx
c00251cb:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c00251cc:	83 ec 0c             	sub    $0xc,%esp
c00251cf:	8d 83 21 5e ff ff    	lea    -0xa1df(%ebx),%eax
c00251d5:	50                   	push   %eax
c00251d6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00251dc:	50                   	push   %eax
c00251dd:	8d 83 74 40 ff ff    	lea    -0xbf8c(%ebx),%eax
c00251e3:	50                   	push   %eax
c00251e4:	6a 38                	push   $0x38
c00251e6:	8d 83 fa 5d ff ff    	lea    -0xa206(%ebx),%eax
c00251ec:	50                   	push   %eax
c00251ed:	e8 95 40 00 00       	call   c0029287 <debug_panic>

c00251f2 <block_set_role>:
{
c00251f2:	53                   	push   %ebx
c00251f3:	83 ec 08             	sub    $0x8,%esp
c00251f6:	e8 8a 98 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00251fb:	81 c3 b9 5c 01 00    	add    $0x15cb9,%ebx
c0025201:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0025205:	83 f8 03             	cmp    $0x3,%eax
c0025208:	77 10                	ja     c002521a <block_set_role+0x28>
  block_by_role[role] = block;
c002520a:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002520e:	89 8c 83 c4 1f 00 00 	mov    %ecx,0x1fc4(%ebx,%eax,4)
}
c0025215:	83 c4 08             	add    $0x8,%esp
c0025218:	5b                   	pop    %ebx
c0025219:	c3                   	ret    
  ASSERT (role < BLOCK_ROLE_CNT);
c002521a:	83 ec 0c             	sub    $0xc,%esp
c002521d:	8d 83 21 5e ff ff    	lea    -0xa1df(%ebx),%eax
c0025223:	50                   	push   %eax
c0025224:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002522a:	50                   	push   %eax
c002522b:	8d 83 64 40 ff ff    	lea    -0xbf9c(%ebx),%eax
c0025231:	50                   	push   %eax
c0025232:	6a 40                	push   $0x40
c0025234:	8d 83 fa 5d ff ff    	lea    -0xa206(%ebx),%eax
c002523a:	50                   	push   %eax
c002523b:	e8 47 40 00 00       	call   c0029287 <debug_panic>

c0025240 <block_first>:
{
c0025240:	57                   	push   %edi
c0025241:	56                   	push   %esi
c0025242:	53                   	push   %ebx
c0025243:	e8 3d 98 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025248:	81 c3 6c 5c 01 00    	add    $0x15c6c,%ebx
  return list_elem_to_block (list_begin (&all_blocks));
c002524e:	83 ec 0c             	sub    $0xc,%esp
c0025251:	8d bb ec 05 00 00    	lea    0x5ec(%ebx),%edi
c0025257:	57                   	push   %edi
c0025258:	e8 4f 41 00 00       	call   c00293ac <list_begin>
c002525d:	89 c6                	mov    %eax,%esi
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c002525f:	89 3c 24             	mov    %edi,(%esp)
c0025262:	e8 e7 41 00 00       	call   c002944e <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025267:	83 c4 10             	add    $0x10,%esp
c002526a:	39 c6                	cmp    %eax,%esi
c002526c:	b8 00 00 00 00       	mov    $0x0,%eax
c0025271:	0f 44 f0             	cmove  %eax,%esi
}
c0025274:	89 f0                	mov    %esi,%eax
c0025276:	5b                   	pop    %ebx
c0025277:	5e                   	pop    %esi
c0025278:	5f                   	pop    %edi
c0025279:	c3                   	ret    

c002527a <block_next>:
{
c002527a:	56                   	push   %esi
c002527b:	53                   	push   %ebx
c002527c:	83 ec 10             	sub    $0x10,%esp
c002527f:	e8 01 98 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025284:	81 c3 30 5c 01 00    	add    $0x15c30,%ebx
  return list_elem_to_block (list_next (&block->list_elem));
c002528a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002528e:	e8 5e 41 00 00       	call   c00293f1 <list_next>
c0025293:	89 c6                	mov    %eax,%esi
  return (list_elem != list_end (&all_blocks)
c0025295:	8d 83 ec 05 00 00    	lea    0x5ec(%ebx),%eax
c002529b:	89 04 24             	mov    %eax,(%esp)
c002529e:	e8 ab 41 00 00       	call   c002944e <list_end>
          : NULL);
c00252a3:	39 c6                	cmp    %eax,%esi
c00252a5:	b8 00 00 00 00       	mov    $0x0,%eax
c00252aa:	0f 44 f0             	cmove  %eax,%esi
}
c00252ad:	89 f0                	mov    %esi,%eax
c00252af:	83 c4 14             	add    $0x14,%esp
c00252b2:	5b                   	pop    %ebx
c00252b3:	5e                   	pop    %esi
c00252b4:	c3                   	ret    

c00252b5 <block_get_by_name>:
{
c00252b5:	55                   	push   %ebp
c00252b6:	57                   	push   %edi
c00252b7:	56                   	push   %esi
c00252b8:	53                   	push   %ebx
c00252b9:	83 ec 18             	sub    $0x18,%esp
c00252bc:	e8 c4 97 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00252c1:	81 c3 f3 5b 01 00    	add    $0x15bf3,%ebx
c00252c7:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c00252cb:	8d 83 ec 05 00 00    	lea    0x5ec(%ebx),%eax
c00252d1:	50                   	push   %eax
c00252d2:	e8 d5 40 00 00       	call   c00293ac <list_begin>
c00252d7:	89 c6                	mov    %eax,%esi
c00252d9:	83 c4 10             	add    $0x10,%esp
c00252dc:	8d bb ec 05 00 00    	lea    0x5ec(%ebx),%edi
c00252e2:	83 ec 0c             	sub    $0xc,%esp
c00252e5:	57                   	push   %edi
c00252e6:	e8 63 41 00 00       	call   c002944e <list_end>
c00252eb:	83 c4 10             	add    $0x10,%esp
c00252ee:	39 f0                	cmp    %esi,%eax
c00252f0:	74 24                	je     c0025316 <block_get_by_name+0x61>
      if (!strcmp (name, block->name))
c00252f2:	8d 46 08             	lea    0x8(%esi),%eax
c00252f5:	83 ec 08             	sub    $0x8,%esp
c00252f8:	50                   	push   %eax
c00252f9:	55                   	push   %ebp
c00252fa:	e8 4d 32 00 00       	call   c002854c <strcmp>
c00252ff:	83 c4 10             	add    $0x10,%esp
c0025302:	85 c0                	test   %eax,%eax
c0025304:	74 15                	je     c002531b <block_get_by_name+0x66>
       e = list_next (e))
c0025306:	83 ec 0c             	sub    $0xc,%esp
c0025309:	56                   	push   %esi
c002530a:	e8 e2 40 00 00       	call   c00293f1 <list_next>
c002530f:	89 c6                	mov    %eax,%esi
c0025311:	83 c4 10             	add    $0x10,%esp
c0025314:	eb cc                	jmp    c00252e2 <block_get_by_name+0x2d>
  return NULL;
c0025316:	be 00 00 00 00       	mov    $0x0,%esi
}
c002531b:	89 f0                	mov    %esi,%eax
c002531d:	83 c4 0c             	add    $0xc,%esp
c0025320:	5b                   	pop    %ebx
c0025321:	5e                   	pop    %esi
c0025322:	5f                   	pop    %edi
c0025323:	5d                   	pop    %ebp
c0025324:	c3                   	ret    

c0025325 <block_read>:
{
c0025325:	56                   	push   %esi
c0025326:	53                   	push   %ebx
c0025327:	83 ec 04             	sub    $0x4,%esp
c002532a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002532e:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0025332:	89 f2                	mov    %esi,%edx
c0025334:	89 d8                	mov    %ebx,%eax
c0025336:	e8 e1 fd ff ff       	call   c002511c <check_sector>
  block->ops->read (block->aux, sector, buffer);
c002533b:	83 ec 04             	sub    $0x4,%esp
c002533e:	8b 43 20             	mov    0x20(%ebx),%eax
c0025341:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025345:	56                   	push   %esi
c0025346:	ff 73 24             	pushl  0x24(%ebx)
c0025349:	ff 10                	call   *(%eax)
  block->read_cnt++;
c002534b:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c002534f:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c0025353:	83 c4 14             	add    $0x14,%esp
c0025356:	5b                   	pop    %ebx
c0025357:	5e                   	pop    %esi
c0025358:	c3                   	ret    

c0025359 <block_write>:
{
c0025359:	57                   	push   %edi
c002535a:	56                   	push   %esi
c002535b:	53                   	push   %ebx
c002535c:	e8 24 97 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025361:	81 c3 53 5b 01 00    	add    $0x15b53,%ebx
c0025367:	8b 74 24 10          	mov    0x10(%esp),%esi
c002536b:	8b 7c 24 14          	mov    0x14(%esp),%edi
  check_sector (block, sector);
c002536f:	89 fa                	mov    %edi,%edx
c0025371:	89 f0                	mov    %esi,%eax
c0025373:	e8 a4 fd ff ff       	call   c002511c <check_sector>
  ASSERT (block->type != BLOCK_FOREIGN);
c0025378:	83 7e 18 05          	cmpl   $0x5,0x18(%esi)
c002537c:	74 20                	je     c002539e <block_write+0x45>
  block->ops->write (block->aux, sector, buffer);
c002537e:	83 ec 04             	sub    $0x4,%esp
c0025381:	8b 46 20             	mov    0x20(%esi),%eax
c0025384:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025388:	57                   	push   %edi
c0025389:	ff 76 24             	pushl  0x24(%esi)
c002538c:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c002538f:	83 46 30 01          	addl   $0x1,0x30(%esi)
c0025393:	83 56 34 00          	adcl   $0x0,0x34(%esi)
}
c0025397:	83 c4 10             	add    $0x10,%esp
c002539a:	5b                   	pop    %ebx
c002539b:	5e                   	pop    %esi
c002539c:	5f                   	pop    %edi
c002539d:	c3                   	ret    
  ASSERT (block->type != BLOCK_FOREIGN);
c002539e:	83 ec 0c             	sub    $0xc,%esp
c00253a1:	8d 83 37 5e ff ff    	lea    -0xa1c9(%ebx),%eax
c00253a7:	50                   	push   %eax
c00253a8:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00253ae:	50                   	push   %eax
c00253af:	8d 83 48 40 ff ff    	lea    -0xbfb8(%ebx),%eax
c00253b5:	50                   	push   %eax
c00253b6:	68 89 00 00 00       	push   $0x89
c00253bb:	8d 83 fa 5d ff ff    	lea    -0xa206(%ebx),%eax
c00253c1:	50                   	push   %eax
c00253c2:	e8 c0 3e 00 00       	call   c0029287 <debug_panic>

c00253c7 <block_size>:
  return block->size;
c00253c7:	8b 44 24 04          	mov    0x4(%esp),%eax
c00253cb:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00253ce:	c3                   	ret    

c00253cf <block_name>:
  return block->name;
c00253cf:	8b 44 24 04          	mov    0x4(%esp),%eax
c00253d3:	83 c0 08             	add    $0x8,%eax
}
c00253d6:	c3                   	ret    

c00253d7 <block_type>:
  return block->type;
c00253d7:	8b 44 24 04          	mov    0x4(%esp),%eax
c00253db:	8b 40 18             	mov    0x18(%eax),%eax
}
c00253de:	c3                   	ret    

c00253df <block_print_stats>:
{
c00253df:	55                   	push   %ebp
c00253e0:	57                   	push   %edi
c00253e1:	56                   	push   %esi
c00253e2:	53                   	push   %ebx
c00253e3:	83 ec 1c             	sub    $0x1c,%esp
c00253e6:	e8 9a 96 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00253eb:	81 c3 c9 5a 01 00    	add    $0x15ac9,%ebx
c00253f1:	8d bb c4 1f 00 00    	lea    0x1fc4(%ebx),%edi
c00253f7:	8d 6f 10             	lea    0x10(%edi),%ebp
          printf ("%s (%s): %llu reads, %llu writes\n",
c00253fa:	8d 83 a0 5d ff ff    	lea    -0xa260(%ebx),%eax
c0025400:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0025404:	eb 07                	jmp    c002540d <block_print_stats+0x2e>
c0025406:	83 c7 04             	add    $0x4,%edi
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025409:	39 ef                	cmp    %ebp,%edi
c002540b:	74 33                	je     c0025440 <block_print_stats+0x61>
      struct block *block = block_by_role[i];
c002540d:	8b 37                	mov    (%edi),%esi
      if (block != NULL)
c002540f:	85 f6                	test   %esi,%esi
c0025411:	74 f3                	je     c0025406 <block_print_stats+0x27>
          printf ("%s (%s): %llu reads, %llu writes\n",
c0025413:	83 ec 0c             	sub    $0xc,%esp
c0025416:	ff 76 18             	pushl  0x18(%esi)
c0025419:	e8 40 fd ff ff       	call   c002515e <block_type_name>
c002541e:	83 c4 0c             	add    $0xc,%esp
c0025421:	ff 76 34             	pushl  0x34(%esi)
c0025424:	ff 76 30             	pushl  0x30(%esi)
c0025427:	ff 76 2c             	pushl  0x2c(%esi)
c002542a:	ff 76 28             	pushl  0x28(%esi)
c002542d:	50                   	push   %eax
c002542e:	83 c6 08             	add    $0x8,%esi
c0025431:	56                   	push   %esi
c0025432:	ff 74 24 28          	pushl  0x28(%esp)
c0025436:	e8 b5 20 00 00       	call   c00274f0 <printf>
c002543b:	83 c4 20             	add    $0x20,%esp
c002543e:	eb c6                	jmp    c0025406 <block_print_stats+0x27>
}
c0025440:	83 c4 1c             	add    $0x1c,%esp
c0025443:	5b                   	pop    %ebx
c0025444:	5e                   	pop    %esi
c0025445:	5f                   	pop    %edi
c0025446:	5d                   	pop    %ebp
c0025447:	c3                   	ret    

c0025448 <block_register>:
{
c0025448:	55                   	push   %ebp
c0025449:	57                   	push   %edi
c002544a:	56                   	push   %esi
c002544b:	53                   	push   %ebx
c002544c:	83 ec 18             	sub    $0x18,%esp
c002544f:	e8 31 96 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025454:	81 c3 60 5a 01 00    	add    $0x15a60,%ebx
c002545a:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc (sizeof *block);
c002545e:	6a 38                	push   $0x38
c0025460:	e8 c2 ea ff ff       	call   c0023f27 <malloc>
  if (block == NULL)
c0025465:	83 c4 10             	add    $0x10,%esp
c0025468:	85 c0                	test   %eax,%eax
c002546a:	0f 84 c6 00 00 00    	je     c0025536 <block_register+0xee>
c0025470:	89 c6                	mov    %eax,%esi
  list_push_back (&all_blocks, &block->list_elem);
c0025472:	83 ec 08             	sub    $0x8,%esp
c0025475:	50                   	push   %eax
c0025476:	8d 83 ec 05 00 00    	lea    0x5ec(%ebx),%eax
c002547c:	50                   	push   %eax
c002547d:	e8 b8 44 00 00       	call   c002993a <list_push_back>
  strlcpy (block->name, name, sizeof block->name);
c0025482:	8d 6e 08             	lea    0x8(%esi),%ebp
c0025485:	83 c4 0c             	add    $0xc,%esp
c0025488:	6a 10                	push   $0x10
c002548a:	ff 74 24 28          	pushl  0x28(%esp)
c002548e:	55                   	push   %ebp
c002548f:	e8 48 34 00 00       	call   c00288dc <strlcpy>
  block->type = type;
c0025494:	8b 44 24 34          	mov    0x34(%esp),%eax
c0025498:	89 46 18             	mov    %eax,0x18(%esi)
  block->size = size;
c002549b:	89 7e 1c             	mov    %edi,0x1c(%esi)
  block->ops = ops;
c002549e:	8b 44 24 40          	mov    0x40(%esp),%eax
c00254a2:	89 46 20             	mov    %eax,0x20(%esi)
  block->aux = aux;
c00254a5:	8b 44 24 44          	mov    0x44(%esp),%eax
c00254a9:	89 46 24             	mov    %eax,0x24(%esi)
  block->read_cnt = 0;
c00254ac:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c00254b3:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  block->write_cnt = 0;
c00254ba:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
c00254c1:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00254c8:	83 c4 0c             	add    $0xc,%esp
c00254cb:	57                   	push   %edi
c00254cc:	55                   	push   %ebp
c00254cd:	8d 83 54 5e ff ff    	lea    -0xa1ac(%ebx),%eax
c00254d3:	50                   	push   %eax
c00254d4:	e8 17 20 00 00       	call   c00274f0 <printf>
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c00254d9:	83 c4 08             	add    $0x8,%esp
c00254dc:	8b 7e 1c             	mov    0x1c(%esi),%edi
c00254df:	bd 00 00 00 00       	mov    $0x0,%ebp
c00254e4:	89 f8                	mov    %edi,%eax
c00254e6:	89 ea                	mov    %ebp,%edx
c00254e8:	0f a4 fa 09          	shld   $0x9,%edi,%edx
c00254ec:	c1 e0 09             	shl    $0x9,%eax
c00254ef:	52                   	push   %edx
c00254f0:	50                   	push   %eax
c00254f1:	e8 2c 2b 00 00       	call   c0028022 <print_human_readable_size>
  printf (")");
c00254f6:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c00254fd:	e8 d0 5d 00 00       	call   c002b2d2 <putchar>
  if (extra_info != NULL)
c0025502:	83 c4 10             	add    $0x10,%esp
c0025505:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c002550a:	74 16                	je     c0025522 <block_register+0xda>
    printf (", %s", extra_info);
c002550c:	83 ec 08             	sub    $0x8,%esp
c002550f:	ff 74 24 30          	pushl  0x30(%esp)
c0025513:	8d 83 66 5e ff ff    	lea    -0xa19a(%ebx),%eax
c0025519:	50                   	push   %eax
c002551a:	e8 d1 1f 00 00       	call   c00274f0 <printf>
c002551f:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025522:	83 ec 0c             	sub    $0xc,%esp
c0025525:	6a 0a                	push   $0xa
c0025527:	e8 a6 5d 00 00       	call   c002b2d2 <putchar>
}
c002552c:	89 f0                	mov    %esi,%eax
c002552e:	83 c4 1c             	add    $0x1c,%esp
c0025531:	5b                   	pop    %ebx
c0025532:	5e                   	pop    %esi
c0025533:	5f                   	pop    %edi
c0025534:	5d                   	pop    %ebp
c0025535:	c3                   	ret    
    PANIC ("Failed to allocate memory for block device descriptor");
c0025536:	8d 83 c4 5d ff ff    	lea    -0xa23c(%ebx),%eax
c002553c:	50                   	push   %eax
c002553d:	8d 83 38 40 ff ff    	lea    -0xbfc8(%ebx),%eax
c0025543:	50                   	push   %eax
c0025544:	68 c1 00 00 00       	push   $0xc1
c0025549:	8d 83 fa 5d ff ff    	lea    -0xa206(%ebx),%eax
c002554f:	50                   	push   %eax
c0025550:	e8 32 3d 00 00       	call   c0029287 <debug_panic>

c0025555 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0025555:	53                   	push   %ebx
c0025556:	83 ec 0c             	sub    $0xc,%esp
c0025559:	e8 27 95 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002555e:	81 c3 56 59 01 00    	add    $0x15956,%ebx
c0025564:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read (p->block, p->start + sector, buffer);
c0025568:	ff 74 24 1c          	pushl  0x1c(%esp)
c002556c:	8b 42 04             	mov    0x4(%edx),%eax
c002556f:	03 44 24 1c          	add    0x1c(%esp),%eax
c0025573:	50                   	push   %eax
c0025574:	ff 32                	pushl  (%edx)
c0025576:	e8 aa fd ff ff       	call   c0025325 <block_read>
}
c002557b:	83 c4 18             	add    $0x18,%esp
c002557e:	5b                   	pop    %ebx
c002557f:	c3                   	ret    

c0025580 <read_partition_table>:
{
c0025580:	55                   	push   %ebp
c0025581:	57                   	push   %edi
c0025582:	56                   	push   %esi
c0025583:	53                   	push   %ebx
c0025584:	81 ec d8 00 00 00    	sub    $0xd8,%esp
c002558a:	e8 f6 94 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002558f:	81 c3 25 59 01 00    	add    $0x15925,%ebx
c0025595:	89 c6                	mov    %eax,%esi
c0025597:	89 d7                	mov    %edx,%edi
c0025599:	89 54 24 14          	mov    %edx,0x14(%esp)
c002559d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  if (sector >= block_size (block))
c00255a1:	50                   	push   %eax
c00255a2:	e8 20 fe ff ff       	call   c00253c7 <block_size>
c00255a7:	83 c4 10             	add    $0x10,%esp
c00255aa:	39 f8                	cmp    %edi,%eax
c00255ac:	76 65                	jbe    c0025613 <read_partition_table+0x93>
  pt = malloc (sizeof *pt);
c00255ae:	83 ec 0c             	sub    $0xc,%esp
c00255b1:	68 00 02 00 00       	push   $0x200
c00255b6:	e8 6c e9 ff ff       	call   c0023f27 <malloc>
c00255bb:	89 c5                	mov    %eax,%ebp
  if (pt == NULL)
c00255bd:	83 c4 10             	add    $0x10,%esp
c00255c0:	85 c0                	test   %eax,%eax
c00255c2:	74 77                	je     c002563b <read_partition_table+0xbb>
  block_read (block, 0, pt);
c00255c4:	83 ec 04             	sub    $0x4,%esp
c00255c7:	50                   	push   %eax
c00255c8:	6a 00                	push   $0x0
c00255ca:	56                   	push   %esi
c00255cb:	e8 55 fd ff ff       	call   c0025325 <block_read>
  if (pt->signature != 0xaa55)
c00255d0:	83 c4 10             	add    $0x10,%esp
c00255d3:	66 81 bd fe 01 00 00 	cmpw   $0xaa55,0x1fe(%ebp)
c00255da:	55 aa 
c00255dc:	0f 84 97 00 00 00    	je     c0025679 <read_partition_table+0xf9>
      if (primary_extended_sector == 0)
c00255e2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c00255e7:	75 6e                	jne    c0025657 <read_partition_table+0xd7>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c00255e9:	83 ec 0c             	sub    $0xc,%esp
c00255ec:	56                   	push   %esi
c00255ed:	e8 dd fd ff ff       	call   c00253cf <block_name>
c00255f2:	83 c4 08             	add    $0x8,%esp
c00255f5:	50                   	push   %eax
c00255f6:	8d 83 78 63 ff ff    	lea    -0x9c88(%ebx),%eax
c00255fc:	50                   	push   %eax
c00255fd:	e8 ee 1e 00 00       	call   c00274f0 <printf>
c0025602:	83 c4 10             	add    $0x10,%esp
      free (pt);
c0025605:	83 ec 0c             	sub    $0xc,%esp
c0025608:	55                   	push   %ebp
c0025609:	e8 cf ea ff ff       	call   c00240dd <free>
      return;
c002560e:	83 c4 10             	add    $0x10,%esp
c0025611:	eb 1d                	jmp    c0025630 <read_partition_table+0xb0>
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025613:	83 ec 0c             	sub    $0xc,%esp
c0025616:	56                   	push   %esi
c0025617:	e8 b3 fd ff ff       	call   c00253cf <block_name>
c002561c:	83 c4 0c             	add    $0xc,%esp
c002561f:	57                   	push   %edi
c0025620:	50                   	push   %eax
c0025621:	8d 83 10 63 ff ff    	lea    -0x9cf0(%ebx),%eax
c0025627:	50                   	push   %eax
c0025628:	e8 c3 1e 00 00       	call   c00274f0 <printf>
      return;
c002562d:	83 c4 10             	add    $0x10,%esp
}
c0025630:	81 c4 cc 00 00 00    	add    $0xcc,%esp
c0025636:	5b                   	pop    %ebx
c0025637:	5e                   	pop    %esi
c0025638:	5f                   	pop    %edi
c0025639:	5d                   	pop    %ebp
c002563a:	c3                   	ret    
    PANIC ("Failed to allocate memory for partition table.");
c002563b:	8d 83 48 63 ff ff    	lea    -0x9cb8(%ebx),%eax
c0025641:	50                   	push   %eax
c0025642:	8d 83 a4 40 ff ff    	lea    -0xbf5c(%ebx),%eax
c0025648:	50                   	push   %eax
c0025649:	6a 5a                	push   $0x5a
c002564b:	8d 83 7f 5e ff ff    	lea    -0xa181(%ebx),%eax
c0025651:	50                   	push   %eax
c0025652:	e8 30 3c 00 00       	call   c0029287 <debug_panic>
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0025657:	83 ec 0c             	sub    $0xc,%esp
c002565a:	56                   	push   %esi
c002565b:	e8 6f fd ff ff       	call   c00253cf <block_name>
c0025660:	83 c4 0c             	add    $0xc,%esp
c0025663:	ff 74 24 0c          	pushl  0xc(%esp)
c0025667:	50                   	push   %eax
c0025668:	8d 83 a0 63 ff ff    	lea    -0x9c60(%ebx),%eax
c002566e:	50                   	push   %eax
c002566f:	e8 7c 1e 00 00       	call   c00274f0 <printf>
c0025674:	83 c4 10             	add    $0x10,%esp
c0025677:	eb 8c                	jmp    c0025605 <read_partition_table+0x85>
c0025679:	8d bd c2 01 00 00    	lea    0x1c2(%ebp),%edi
c002567f:	8d 85 02 02 00 00    	lea    0x202(%ebp),%eax
c0025685:	89 44 24 0c          	mov    %eax,0xc(%esp)
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025689:	8d 83 d4 63 ff ff    	lea    -0x9c2c(%ebx),%eax
c002568f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025693:	8d 83 34 64 ff ff    	lea    -0x9bcc(%ebx),%eax
c0025699:	89 44 24 20          	mov    %eax,0x20(%esp)
c002569d:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c00256a1:	89 74 24 14          	mov    %esi,0x14(%esp)
c00256a5:	eb 30                	jmp    c00256d7 <read_partition_table+0x157>
            read_partition_table (block, e->offset + primary_extended_sector,
c00256a7:	8b 44 24 10          	mov    0x10(%esp),%eax
c00256ab:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00256af:	89 ca                	mov    %ecx,%edx
c00256b1:	03 50 04             	add    0x4(%eax),%edx
c00256b4:	83 ec 0c             	sub    $0xc,%esp
c00256b7:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c00256be:	8b 44 24 24          	mov    0x24(%esp),%eax
c00256c2:	e8 b9 fe ff ff       	call   c0025580 <read_partition_table>
c00256c7:	83 c4 10             	add    $0x10,%esp
c00256ca:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00256cd:	3b 7c 24 0c          	cmp    0xc(%esp),%edi
c00256d1:	0f 84 04 02 00 00    	je     c00258db <read_partition_table+0x35b>
c00256d7:	89 7c 24 10          	mov    %edi,0x10(%esp)
      if (e->size == 0 || e->type == 0)
c00256db:	8b 77 08             	mov    0x8(%edi),%esi
c00256de:	85 f6                	test   %esi,%esi
c00256e0:	74 e8                	je     c00256ca <read_partition_table+0x14a>
c00256e2:	0f b6 2f             	movzbl (%edi),%ebp
c00256e5:	89 e8                	mov    %ebp,%eax
c00256e7:	84 c0                	test   %al,%al
c00256e9:	74 df                	je     c00256ca <read_partition_table+0x14a>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c00256eb:	3c 0f                	cmp    $0xf,%al
c00256ed:	0f 94 c2             	sete   %dl
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c00256f0:	3c c5                	cmp    $0xc5,%al
c00256f2:	0f 94 c0             	sete   %al
c00256f5:	08 c2                	or     %al,%dl
c00256f7:	75 09                	jne    c0025702 <read_partition_table+0x182>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c00256f9:	89 e8                	mov    %ebp,%eax
c00256fb:	83 e0 7f             	and    $0x7f,%eax
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c00256fe:	3c 05                	cmp    $0x5,%al
c0025700:	75 4c                	jne    c002574e <read_partition_table+0x1ce>
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025702:	83 ec 0c             	sub    $0xc,%esp
c0025705:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025709:	55                   	push   %ebp
c002570a:	e8 c0 fc ff ff       	call   c00253cf <block_name>
c002570f:	83 c4 0c             	add    $0xc,%esp
c0025712:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0025716:	56                   	push   %esi
c0025717:	50                   	push   %eax
c0025718:	ff 74 24 28          	pushl  0x28(%esp)
c002571c:	e8 cf 1d 00 00       	call   c00274f0 <printf>
          if (sector == 0)
c0025721:	83 c4 10             	add    $0x10,%esp
c0025724:	85 f6                	test   %esi,%esi
c0025726:	0f 85 7b ff ff ff    	jne    c00256a7 <read_partition_table+0x127>
            read_partition_table (block, e->offset, e->offset, part_nr);
c002572c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025730:	8b 50 04             	mov    0x4(%eax),%edx
c0025733:	83 ec 0c             	sub    $0xc,%esp
c0025736:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c002573d:	89 d1                	mov    %edx,%ecx
c002573f:	89 e8                	mov    %ebp,%eax
c0025741:	e8 3a fe ff ff       	call   c0025580 <read_partition_table>
c0025746:	83 c4 10             	add    $0x10,%esp
c0025749:	e9 7c ff ff ff       	jmp    c00256ca <read_partition_table+0x14a>
          ++*part_nr;
c002574e:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
c0025755:	8b 00                	mov    (%eax),%eax
c0025757:	83 c0 01             	add    $0x1,%eax
c002575a:	89 44 24 24          	mov    %eax,0x24(%esp)
c002575e:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
c0025765:	89 01                	mov    %eax,(%ecx)
          found_partition (block, e->type, e->offset + sector,
c0025767:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002576b:	8b 44 24 08          	mov    0x8(%esp),%eax
c002576f:	03 41 04             	add    0x4(%ecx),%eax
c0025772:	89 44 24 10          	mov    %eax,0x10(%esp)
  if (start >= block_size (block))
c0025776:	83 ec 0c             	sub    $0xc,%esp
c0025779:	ff 74 24 20          	pushl  0x20(%esp)
c002577d:	e8 45 fc ff ff       	call   c00253c7 <block_size>
c0025782:	83 c4 10             	add    $0x10,%esp
c0025785:	39 44 24 10          	cmp    %eax,0x10(%esp)
c0025789:	0f 83 c6 00 00 00    	jae    c0025855 <read_partition_table+0x2d5>
  else if (start + size < start || start + size > block_size (block))
c002578f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025793:	01 f0                	add    %esi,%eax
c0025795:	89 44 24 28          	mov    %eax,0x28(%esp)
c0025799:	0f 82 df 00 00 00    	jb     c002587e <read_partition_table+0x2fe>
c002579f:	83 ec 0c             	sub    $0xc,%esp
c00257a2:	ff 74 24 20          	pushl  0x20(%esp)
c00257a6:	e8 1c fc ff ff       	call   c00253c7 <block_size>
c00257ab:	83 c4 10             	add    $0x10,%esp
c00257ae:	39 44 24 28          	cmp    %eax,0x28(%esp)
c00257b2:	0f 87 c6 00 00 00    	ja     c002587e <read_partition_table+0x2fe>
          found_partition (block, e->type, e->offset + sector,
c00257b8:	89 e8                	mov    %ebp,%eax
c00257ba:	0f b6 c0             	movzbl %al,%eax
c00257bd:	89 44 24 28          	mov    %eax,0x28(%esp)
                              : part_type == 0x21 ? BLOCK_FILESYS
c00257c1:	89 e8                	mov    %ebp,%eax
c00257c3:	3c 20                	cmp    $0x20,%al
c00257c5:	0f 84 25 01 00 00    	je     c00258f0 <read_partition_table+0x370>
c00257cb:	3c 21                	cmp    $0x21,%al
c00257cd:	0f 84 c0 01 00 00    	je     c0025993 <read_partition_table+0x413>
c00257d3:	3c 22                	cmp    $0x22,%al
c00257d5:	0f 84 c5 01 00 00    	je     c00259a0 <read_partition_table+0x420>
c00257db:	3c 23                	cmp    $0x23,%al
c00257dd:	0f 84 ca 01 00 00    	je     c00259ad <read_partition_table+0x42d>
      p = malloc (sizeof *p);
c00257e3:	83 ec 0c             	sub    $0xc,%esp
c00257e6:	6a 08                	push   $0x8
c00257e8:	e8 3a e7 ff ff       	call   c0023f27 <malloc>
c00257ed:	89 c5                	mov    %eax,%ebp
      if (p == NULL)
c00257ef:	83 c4 10             	add    $0x10,%esp
c00257f2:	85 c0                	test   %eax,%eax
c00257f4:	0f 84 b8 00 00 00    	je     c00258b2 <read_partition_table+0x332>
      p->block = block;
c00257fa:	8b 44 24 14          	mov    0x14(%esp),%eax
c00257fe:	89 45 00             	mov    %eax,0x0(%ebp)
      p->start = start;
c0025801:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025805:	89 4d 04             	mov    %ecx,0x4(%ebp)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025808:	83 ec 0c             	sub    $0xc,%esp
c002580b:	50                   	push   %eax
c002580c:	e8 be fb ff ff       	call   c00253cf <block_name>
c0025811:	83 c4 04             	add    $0x4,%esp
c0025814:	ff 74 24 30          	pushl  0x30(%esp)
c0025818:	50                   	push   %eax
c0025819:	8d 83 99 5e ff ff    	lea    -0xa167(%ebx),%eax
c002581f:	50                   	push   %eax
c0025820:	6a 10                	push   $0x10
c0025822:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025826:	50                   	push   %eax
c0025827:	e8 e5 25 00 00       	call   c0027e11 <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c002582c:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025830:	8b 84 83 ac 01 00 00 	mov    0x1ac(%ebx,%eax,4),%eax
c0025837:	83 c4 20             	add    $0x20,%esp
c002583a:	85 c0                	test   %eax,%eax
c002583c:	0f 85 8f 00 00 00    	jne    c00258d1 <read_partition_table+0x351>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025842:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0025849:	00 
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c002584a:	8d 83 77 5e ff ff    	lea    -0xa189(%ebx),%eax
c0025850:	e9 f6 00 00 00       	jmp    c002594b <read_partition_table+0x3cb>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025855:	83 ec 0c             	sub    $0xc,%esp
c0025858:	ff 74 24 20          	pushl  0x20(%esp)
c002585c:	e8 6e fb ff ff       	call   c00253cf <block_name>
c0025861:	ff 74 24 20          	pushl  0x20(%esp)
c0025865:	ff 74 24 38          	pushl  0x38(%esp)
c0025869:	50                   	push   %eax
c002586a:	8d 83 fc 63 ff ff    	lea    -0x9c04(%ebx),%eax
c0025870:	50                   	push   %eax
c0025871:	e8 7a 1c 00 00       	call   c00274f0 <printf>
c0025876:	83 c4 20             	add    $0x20,%esp
c0025879:	e9 4c fe ff ff       	jmp    c00256ca <read_partition_table+0x14a>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c002587e:	83 ec 0c             	sub    $0xc,%esp
c0025881:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025885:	55                   	push   %ebp
c0025886:	e8 3c fb ff ff       	call   c00253c7 <block_size>
c002588b:	89 c6                	mov    %eax,%esi
c002588d:	89 2c 24             	mov    %ebp,(%esp)
c0025890:	e8 3a fb ff ff       	call   c00253cf <block_name>
c0025895:	89 34 24             	mov    %esi,(%esp)
c0025898:	ff 74 24 38          	pushl  0x38(%esp)
c002589c:	ff 74 24 38          	pushl  0x38(%esp)
c00258a0:	50                   	push   %eax
c00258a1:	ff 74 24 3c          	pushl  0x3c(%esp)
c00258a5:	e8 46 1c 00 00       	call   c00274f0 <printf>
c00258aa:	83 c4 20             	add    $0x20,%esp
c00258ad:	e9 18 fe ff ff       	jmp    c00256ca <read_partition_table+0x14a>
        PANIC ("Failed to allocate memory for partition descriptor");
c00258b2:	8d 83 68 64 ff ff    	lea    -0x9b98(%ebx),%eax
c00258b8:	50                   	push   %eax
c00258b9:	8d 83 94 40 ff ff    	lea    -0xbf6c(%ebx),%eax
c00258bf:	50                   	push   %eax
c00258c0:	68 b1 00 00 00       	push   $0xb1
c00258c5:	8d 83 7f 5e ff ff    	lea    -0xa181(%ebx),%eax
c00258cb:	50                   	push   %eax
c00258cc:	e8 b6 39 00 00       	call   c0029287 <debug_panic>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00258d1:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c00258d8:	00 
c00258d9:	eb 70                	jmp    c002594b <read_partition_table+0x3cb>
c00258db:	8b 6c 24 18          	mov    0x18(%esp),%ebp
  free (pt);
c00258df:	83 ec 0c             	sub    $0xc,%esp
c00258e2:	55                   	push   %ebp
c00258e3:	e8 f5 e7 ff ff       	call   c00240dd <free>
c00258e8:	83 c4 10             	add    $0x10,%esp
c00258eb:	e9 40 fd ff ff       	jmp    c0025630 <read_partition_table+0xb0>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00258f0:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c00258f7:	00 
      p = malloc (sizeof *p);
c00258f8:	83 ec 0c             	sub    $0xc,%esp
c00258fb:	6a 08                	push   $0x8
c00258fd:	e8 25 e6 ff ff       	call   c0023f27 <malloc>
c0025902:	89 c5                	mov    %eax,%ebp
      if (p == NULL)
c0025904:	83 c4 10             	add    $0x10,%esp
c0025907:	85 c0                	test   %eax,%eax
c0025909:	74 a7                	je     c00258b2 <read_partition_table+0x332>
      p->block = block;
c002590b:	8b 44 24 14          	mov    0x14(%esp),%eax
c002590f:	89 45 00             	mov    %eax,0x0(%ebp)
      p->start = start;
c0025912:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025916:	89 4d 04             	mov    %ecx,0x4(%ebp)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025919:	83 ec 0c             	sub    $0xc,%esp
c002591c:	50                   	push   %eax
c002591d:	e8 ad fa ff ff       	call   c00253cf <block_name>
c0025922:	83 c4 04             	add    $0x4,%esp
c0025925:	ff 74 24 30          	pushl  0x30(%esp)
c0025929:	50                   	push   %eax
c002592a:	8d 83 99 5e ff ff    	lea    -0xa167(%ebx),%eax
c0025930:	50                   	push   %eax
c0025931:	6a 10                	push   $0x10
c0025933:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025937:	50                   	push   %eax
c0025938:	e8 d4 24 00 00       	call   c0027e11 <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c002593d:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025941:	8b 84 83 ac 01 00 00 	mov    0x1ac(%ebx,%eax,4),%eax
c0025948:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c002594b:	83 ec 0c             	sub    $0xc,%esp
c002594e:	ff 74 24 34          	pushl  0x34(%esp)
c0025952:	50                   	push   %eax
c0025953:	8d 83 9e 5e ff ff    	lea    -0xa162(%ebx),%eax
c0025959:	50                   	push   %eax
c002595a:	68 80 00 00 00       	push   $0x80
c002595f:	8d 44 24 5c          	lea    0x5c(%esp),%eax
c0025963:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0025967:	50                   	push   %eax
c0025968:	e8 a4 24 00 00       	call   c0027e11 <snprintf>
      block_register (name, type, extra_info, size, &partition_operations, p);
c002596d:	83 c4 18             	add    $0x18,%esp
c0025970:	55                   	push   %ebp
c0025971:	8d 83 fc 05 00 00    	lea    0x5fc(%ebx),%eax
c0025977:	50                   	push   %eax
c0025978:	56                   	push   %esi
c0025979:	ff 74 24 24          	pushl  0x24(%esp)
c002597d:	ff 74 24 44          	pushl  0x44(%esp)
c0025981:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025985:	50                   	push   %eax
c0025986:	e8 bd fa ff ff       	call   c0025448 <block_register>
c002598b:	83 c4 20             	add    $0x20,%esp
c002598e:	e9 37 fd ff ff       	jmp    c00256ca <read_partition_table+0x14a>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025993:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c002599a:	00 
c002599b:	e9 58 ff ff ff       	jmp    c00258f8 <read_partition_table+0x378>
c00259a0:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c00259a7:	00 
c00259a8:	e9 4b ff ff ff       	jmp    c00258f8 <read_partition_table+0x378>
c00259ad:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c00259b4:	00 
c00259b5:	e9 3e ff ff ff       	jmp    c00258f8 <read_partition_table+0x378>

c00259ba <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c00259ba:	53                   	push   %ebx
c00259bb:	83 ec 0c             	sub    $0xc,%esp
c00259be:	e8 c2 90 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00259c3:	81 c3 f1 54 01 00    	add    $0x154f1,%ebx
c00259c9:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write (p->block, p->start + sector, buffer);
c00259cd:	ff 74 24 1c          	pushl  0x1c(%esp)
c00259d1:	8b 42 04             	mov    0x4(%edx),%eax
c00259d4:	03 44 24 1c          	add    0x1c(%esp),%eax
c00259d8:	50                   	push   %eax
c00259d9:	ff 32                	pushl  (%edx)
c00259db:	e8 79 f9 ff ff       	call   c0025359 <block_write>
}
c00259e0:	83 c4 18             	add    $0x18,%esp
c00259e3:	5b                   	pop    %ebx
c00259e4:	c3                   	ret    

c00259e5 <partition_scan>:
{
c00259e5:	56                   	push   %esi
c00259e6:	53                   	push   %ebx
c00259e7:	83 ec 20             	sub    $0x20,%esp
c00259ea:	e8 96 90 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00259ef:	81 c3 c5 54 01 00    	add    $0x154c5,%ebx
c00259f5:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  int part_nr = 0;
c00259f9:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0025a00:	00 
  read_partition_table (block, 0, 0, &part_nr);
c0025a01:	8d 44 24 18          	lea    0x18(%esp),%eax
c0025a05:	50                   	push   %eax
c0025a06:	b9 00 00 00 00       	mov    $0x0,%ecx
c0025a0b:	ba 00 00 00 00       	mov    $0x0,%edx
c0025a10:	89 f0                	mov    %esi,%eax
c0025a12:	e8 69 fb ff ff       	call   c0025580 <read_partition_table>
  if (part_nr == 0)
c0025a17:	83 c4 10             	add    $0x10,%esp
c0025a1a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0025a1f:	74 06                	je     c0025a27 <partition_scan+0x42>
}
c0025a21:	83 c4 14             	add    $0x14,%esp
c0025a24:	5b                   	pop    %ebx
c0025a25:	5e                   	pop    %esi
c0025a26:	c3                   	ret    
    printf ("%s: Device contains no partitions\n", block_name (block));
c0025a27:	83 ec 0c             	sub    $0xc,%esp
c0025a2a:	56                   	push   %esi
c0025a2b:	e8 9f f9 ff ff       	call   c00253cf <block_name>
c0025a30:	83 c4 08             	add    $0x8,%esp
c0025a33:	50                   	push   %eax
c0025a34:	8d 83 9c 64 ff ff    	lea    -0x9b64(%ebx),%eax
c0025a3a:	50                   	push   %eax
c0025a3b:	e8 b0 1a 00 00       	call   c00274f0 <printf>
c0025a40:	83 c4 10             	add    $0x10,%esp
}
c0025a43:	eb dc                	jmp    c0025a21 <partition_scan+0x3c>

c0025a45 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0025a45:	57                   	push   %edi
c0025a46:	56                   	push   %esi
c0025a47:	53                   	push   %ebx
c0025a48:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025a4a:	83 fa 01             	cmp    $0x1,%edx
c0025a4d:	7e 1f                	jle    c0025a6e <descramble_ata_string+0x29>
c0025a4f:	89 c1                	mov    %eax,%ecx
c0025a51:	8d 5a fe             	lea    -0x2(%edx),%ebx
c0025a54:	83 e3 fe             	and    $0xfffffffe,%ebx
c0025a57:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
    {
      char tmp = string[i];
c0025a5b:	0f b6 19             	movzbl (%ecx),%ebx
      string[i] = string[i + 1];
c0025a5e:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c0025a62:	88 11                	mov    %dl,(%ecx)
      string[i + 1] = tmp;
c0025a64:	88 59 01             	mov    %bl,0x1(%ecx)
c0025a67:	83 c1 02             	add    $0x2,%ecx
  for (i = 0; i + 1 < size; i += 2)
c0025a6a:	39 f1                	cmp    %esi,%ecx
c0025a6c:	75 ed                	jne    c0025a5b <descramble_ata_string+0x16>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025a6e:	8d 57 ff             	lea    -0x1(%edi),%edx
c0025a71:	85 d2                	test   %edx,%edx
c0025a73:	7f 07                	jg     c0025a7c <descramble_ata_string+0x37>
c0025a75:	eb 17                	jmp    c0025a8e <descramble_ata_string+0x49>
c0025a77:	83 ea 01             	sub    $0x1,%edx
c0025a7a:	74 12                	je     c0025a8e <descramble_ata_string+0x49>
    {
      int c = string[size - 1];
c0025a7c:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
      if (c != '\0' && !isspace (c))
c0025a81:	f6 c1 df             	test   $0xdf,%cl
c0025a84:	74 f1                	je     c0025a77 <descramble_ata_string+0x32>
          || c == '\r' || c == '\t' || c == '\v');
c0025a86:	83 e9 09             	sub    $0x9,%ecx
c0025a89:	80 f9 04             	cmp    $0x4,%cl
c0025a8c:	76 e9                	jbe    c0025a77 <descramble_ata_string+0x32>
        break; 
    }
  string[size] = '\0';
c0025a8e:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c0025a92:	5b                   	pop    %ebx
c0025a93:	5e                   	pop    %esi
c0025a94:	5f                   	pop    %edi
c0025a95:	c3                   	ret    

c0025a96 <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0025a96:	53                   	push   %ebx
c0025a97:	83 ec 08             	sub    $0x8,%esp
c0025a9a:	e8 e6 8f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025a9f:	81 c3 15 54 01 00    	add    $0x15415,%ebx
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c0025aa5:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025aa9:	8b 40 30             	mov    0x30(%eax),%eax
c0025aac:	0f b6 93 f6 1f 00 00 	movzbl 0x1ff6(%ebx),%edx
c0025ab3:	39 d0                	cmp    %edx,%eax
c0025ab5:	74 30                	je     c0025ae7 <interrupt_handler+0x51>
c0025ab7:	0f b6 93 66 20 00 00 	movzbl 0x2066(%ebx),%edx
c0025abe:	8d 8b 5c 20 00 00    	lea    0x205c(%ebx),%ecx
c0025ac4:	39 c2                	cmp    %eax,%edx
c0025ac6:	74 25                	je     c0025aed <interrupt_handler+0x57>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c0025ac8:	8d 83 54 55 ff ff    	lea    -0xaaac(%ebx),%eax
c0025ace:	50                   	push   %eax
c0025acf:	8d 83 0c 41 ff ff    	lea    -0xbef4(%ebx),%eax
c0025ad5:	50                   	push   %eax
c0025ad6:	68 0c 02 00 00       	push   $0x20c
c0025adb:	8d 83 d9 64 ff ff    	lea    -0x9b27(%ebx),%eax
c0025ae1:	50                   	push   %eax
c0025ae2:	e8 a0 37 00 00       	call   c0029287 <debug_panic>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0025ae7:	8d 8b ec 1f 00 00    	lea    0x1fec(%ebx),%ecx
        if (c->expecting_interrupt) 
c0025aed:	80 79 30 00          	cmpb   $0x0,0x30(%ecx)
c0025af1:	74 1c                	je     c0025b0f <interrupt_handler+0x79>
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0025af3:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c0025af7:	8d 50 07             	lea    0x7(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025afa:	ec                   	in     (%dx),%al
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0025afb:	83 ec 0c             	sub    $0xc,%esp
c0025afe:	83 c1 34             	add    $0x34,%ecx
c0025b01:	51                   	push   %ecx
c0025b02:	e8 19 d6 ff ff       	call   c0023120 <sema_up>
c0025b07:	83 c4 10             	add    $0x10,%esp
}
c0025b0a:	83 c4 08             	add    $0x8,%esp
c0025b0d:	5b                   	pop    %ebx
c0025b0e:	c3                   	ret    
          printf ("%s: unexpected interrupt\n", c->name);
c0025b0f:	83 ec 08             	sub    $0x8,%esp
c0025b12:	51                   	push   %ecx
c0025b13:	8d 83 bf 64 ff ff    	lea    -0x9b41(%ebx),%eax
c0025b19:	50                   	push   %eax
c0025b1a:	e8 d1 19 00 00       	call   c00274f0 <printf>
c0025b1f:	83 c4 10             	add    $0x10,%esp
c0025b22:	eb e6                	jmp    c0025b0a <interrupt_handler+0x74>

c0025b24 <wait_until_idle>:
{
c0025b24:	57                   	push   %edi
c0025b25:	56                   	push   %esi
c0025b26:	53                   	push   %ebx
c0025b27:	e8 59 8f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025b2c:	81 c3 88 53 01 00    	add    $0x15388,%ebx
c0025b32:	89 c7                	mov    %eax,%edi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025b34:	8b 40 08             	mov    0x8(%eax),%eax
c0025b37:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b3b:	8d 50 07             	lea    0x7(%eax),%edx
c0025b3e:	ec                   	in     (%dx),%al
c0025b3f:	a8 88                	test   $0x88,%al
c0025b41:	74 4a                	je     c0025b8d <wait_until_idle+0x69>
      timer_usleep (10);
c0025b43:	83 ec 08             	sub    $0x8,%esp
c0025b46:	6a 00                	push   $0x0
c0025b48:	6a 0a                	push   $0xa
c0025b4a:	e8 84 ec ff ff       	call   c00247d3 <timer_usleep>
c0025b4f:	83 c4 10             	add    $0x10,%esp
c0025b52:	be e7 03 00 00       	mov    $0x3e7,%esi
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0025b57:	8b 47 08             	mov    0x8(%edi),%eax
c0025b5a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025b5e:	8d 50 07             	lea    0x7(%eax),%edx
c0025b61:	ec                   	in     (%dx),%al
c0025b62:	a8 88                	test   $0x88,%al
c0025b64:	74 27                	je     c0025b8d <wait_until_idle+0x69>
      timer_usleep (10);
c0025b66:	83 ec 08             	sub    $0x8,%esp
c0025b69:	6a 00                	push   $0x0
c0025b6b:	6a 0a                	push   $0xa
c0025b6d:	e8 61 ec ff ff       	call   c00247d3 <timer_usleep>
  for (i = 0; i < 1000; i++) 
c0025b72:	83 c4 10             	add    $0x10,%esp
c0025b75:	83 ee 01             	sub    $0x1,%esi
c0025b78:	75 dd                	jne    c0025b57 <wait_until_idle+0x33>
  printf ("%s: idle timeout\n", d->name);
c0025b7a:	83 ec 08             	sub    $0x8,%esp
c0025b7d:	57                   	push   %edi
c0025b7e:	8d 83 ed 64 ff ff    	lea    -0x9b13(%ebx),%eax
c0025b84:	50                   	push   %eax
c0025b85:	e8 66 19 00 00       	call   c00274f0 <printf>
c0025b8a:	83 c4 10             	add    $0x10,%esp
}
c0025b8d:	5b                   	pop    %ebx
c0025b8e:	5e                   	pop    %esi
c0025b8f:	5f                   	pop    %edi
c0025b90:	c3                   	ret    

c0025b91 <select_device>:
{
c0025b91:	53                   	push   %ebx
c0025b92:	83 ec 10             	sub    $0x10,%esp
c0025b95:	e8 eb 8e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025b9a:	81 c3 1a 53 01 00    	add    $0x1531a,%ebx
  struct channel *c = d->channel;
c0025ba0:	8b 50 08             	mov    0x8(%eax),%edx
  if (d->dev_no == 1)
c0025ba3:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
    dev |= DEV_DEV;
c0025ba7:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c0025bac:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c0025bb1:	0f 44 c1             	cmove  %ecx,%eax
  outb (reg_device (c), dev);
c0025bb4:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c0025bb8:	8d 51 06             	lea    0x6(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025bbb:	ee                   	out    %al,(%dx)
  inb (reg_alt_status (c));
c0025bbc:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025bc2:	ec                   	in     (%dx),%al
  timer_nsleep (400);
c0025bc3:	6a 00                	push   $0x0
c0025bc5:	68 90 01 00 00       	push   $0x190
c0025bca:	e8 1d ec ff ff       	call   c00247ec <timer_nsleep>
}
c0025bcf:	83 c4 18             	add    $0x18,%esp
c0025bd2:	5b                   	pop    %ebx
c0025bd3:	c3                   	ret    

c0025bd4 <check_device_type>:
{
c0025bd4:	55                   	push   %ebp
c0025bd5:	57                   	push   %edi
c0025bd6:	56                   	push   %esi
c0025bd7:	53                   	push   %ebx
c0025bd8:	83 ec 0c             	sub    $0xc,%esp
c0025bdb:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c0025bdd:	8b 58 08             	mov    0x8(%eax),%ebx
  select_device (d);
c0025be0:	e8 ac ff ff ff       	call   c0025b91 <select_device>
  error = inb (reg_error (c));
c0025be5:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0025be9:	8d 51 01             	lea    0x1(%ecx),%edx
c0025bec:	ec                   	in     (%dx),%al
c0025bed:	89 c3                	mov    %eax,%ebx
  lbam = inb (reg_lbam (c));
c0025bef:	8d 51 04             	lea    0x4(%ecx),%edx
c0025bf2:	ec                   	in     (%dx),%al
c0025bf3:	89 c5                	mov    %eax,%ebp
  lbah = inb (reg_lbah (c));
c0025bf5:	8d 51 05             	lea    0x5(%ecx),%edx
c0025bf8:	ec                   	in     (%dx),%al
c0025bf9:	89 c7                	mov    %eax,%edi
  status = inb (reg_status (c));
c0025bfb:	8d 51 07             	lea    0x7(%ecx),%edx
c0025bfe:	ec                   	in     (%dx),%al
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025bff:	80 fb 01             	cmp    $0x1,%bl
c0025c02:	74 1d                	je     c0025c21 <check_device_type+0x4d>
c0025c04:	80 fb 81             	cmp    $0x81,%bl
c0025c07:	74 12                	je     c0025c1b <check_device_type+0x47>
      d->is_ata = false;
c0025c09:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return error != 0x81;      
c0025c0d:	80 fb 81             	cmp    $0x81,%bl
c0025c10:	0f 95 c0             	setne  %al
}
c0025c13:	83 c4 0c             	add    $0xc,%esp
c0025c16:	5b                   	pop    %ebx
c0025c17:	5e                   	pop    %esi
c0025c18:	5f                   	pop    %edi
c0025c19:	5d                   	pop    %ebp
c0025c1a:	c3                   	ret    
  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025c1b:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0025c1f:	74 e8                	je     c0025c09 <check_device_type+0x35>
      || (status & STA_DRDY) == 0
c0025c21:	a8 40                	test   $0x40,%al
c0025c23:	74 e4                	je     c0025c09 <check_device_type+0x35>
      || (status & STA_BSY) != 0)
c0025c25:	84 c0                	test   %al,%al
c0025c27:	78 e0                	js     c0025c09 <check_device_type+0x35>
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025c29:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c2e:	89 f9                	mov    %edi,%ecx
c0025c30:	89 eb                	mov    %ebp,%ebx
c0025c32:	08 d9                	or     %bl,%cl
c0025c34:	74 12                	je     c0025c48 <check_device_type+0x74>
c0025c36:	80 fb 3c             	cmp    $0x3c,%bl
c0025c39:	0f 94 c2             	sete   %dl
c0025c3c:	89 f8                	mov    %edi,%eax
c0025c3e:	3c c3                	cmp    $0xc3,%al
c0025c40:	0f 94 c0             	sete   %al
c0025c43:	0f b6 c0             	movzbl %al,%eax
c0025c46:	21 d0                	and    %edx,%eax
c0025c48:	88 46 10             	mov    %al,0x10(%esi)
c0025c4b:	80 66 10 01          	andb   $0x1,0x10(%esi)
      return true; 
c0025c4f:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c54:	eb bd                	jmp    c0025c13 <check_device_type+0x3f>

c0025c56 <select_sector>:
{
c0025c56:	55                   	push   %ebp
c0025c57:	57                   	push   %edi
c0025c58:	56                   	push   %esi
c0025c59:	53                   	push   %ebx
c0025c5a:	83 ec 0c             	sub    $0xc,%esp
c0025c5d:	e8 23 8e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025c62:	81 c3 52 52 01 00    	add    $0x15252,%ebx
  struct channel *c = d->channel;
c0025c68:	8b 68 08             	mov    0x8(%eax),%ebp
  ASSERT (sec_no < (1UL << 28));
c0025c6b:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0025c71:	77 5e                	ja     c0025cd1 <select_sector+0x7b>
c0025c73:	89 c7                	mov    %eax,%edi
c0025c75:	89 d6                	mov    %edx,%esi
  wait_until_idle (d);
c0025c77:	e8 a8 fe ff ff       	call   c0025b24 <wait_until_idle>
  select_device (d);
c0025c7c:	89 f8                	mov    %edi,%eax
c0025c7e:	e8 0e ff ff ff       	call   c0025b91 <select_device>
  wait_until_idle (d);
c0025c83:	89 f8                	mov    %edi,%eax
c0025c85:	e8 9a fe ff ff       	call   c0025b24 <wait_until_idle>
  outb (reg_nsect (c), 1);
c0025c8a:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
c0025c8e:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025c91:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c96:	ee                   	out    %al,(%dx)
  outb (reg_lbal (c), sec_no);
c0025c97:	8d 51 03             	lea    0x3(%ecx),%edx
c0025c9a:	89 f0                	mov    %esi,%eax
c0025c9c:	ee                   	out    %al,(%dx)
  outb (reg_lbam (c), sec_no >> 8);
c0025c9d:	89 f0                	mov    %esi,%eax
c0025c9f:	c1 e8 08             	shr    $0x8,%eax
c0025ca2:	8d 51 04             	lea    0x4(%ecx),%edx
c0025ca5:	ee                   	out    %al,(%dx)
  outb (reg_lbah (c), (sec_no >> 16));
c0025ca6:	89 f0                	mov    %esi,%eax
c0025ca8:	c1 e8 10             	shr    $0x10,%eax
c0025cab:	8d 51 05             	lea    0x5(%ecx),%edx
c0025cae:	ee                   	out    %al,(%dx)
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0025caf:	83 7f 0c 01          	cmpl   $0x1,0xc(%edi)
c0025cb3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c0025cb8:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c0025cbd:	0f 45 c2             	cmovne %edx,%eax
c0025cc0:	c1 ee 18             	shr    $0x18,%esi
c0025cc3:	09 f0                	or     %esi,%eax
  outb (reg_device (c),
c0025cc5:	8d 51 06             	lea    0x6(%ecx),%edx
c0025cc8:	ee                   	out    %al,(%dx)
}
c0025cc9:	83 c4 0c             	add    $0xc,%esp
c0025ccc:	5b                   	pop    %ebx
c0025ccd:	5e                   	pop    %esi
c0025cce:	5f                   	pop    %edi
c0025ccf:	5d                   	pop    %ebp
c0025cd0:	c3                   	ret    
  ASSERT (sec_no < (1UL << 28));
c0025cd1:	83 ec 0c             	sub    $0xc,%esp
c0025cd4:	8d 83 ff 64 ff ff    	lea    -0x9b01(%ebx),%eax
c0025cda:	50                   	push   %eax
c0025cdb:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0025ce1:	50                   	push   %eax
c0025ce2:	8d 83 dc 40 ff ff    	lea    -0xbf24(%ebx),%eax
c0025ce8:	50                   	push   %eax
c0025ce9:	68 89 01 00 00       	push   $0x189
c0025cee:	8d 83 d9 64 ff ff    	lea    -0x9b27(%ebx),%eax
c0025cf4:	50                   	push   %eax
c0025cf5:	e8 8d 35 00 00       	call   c0029287 <debug_panic>

c0025cfa <wait_while_busy>:
{
c0025cfa:	55                   	push   %ebp
c0025cfb:	57                   	push   %edi
c0025cfc:	56                   	push   %esi
c0025cfd:	53                   	push   %ebx
c0025cfe:	83 ec 1c             	sub    $0x1c,%esp
c0025d01:	e8 7f 8d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025d06:	81 c3 ae 51 01 00    	add    $0x151ae,%ebx
c0025d0c:	89 c5                	mov    %eax,%ebp
  struct channel *c = d->channel;
c0025d0e:	8b 78 08             	mov    0x8(%eax),%edi
  for (i = 0; i < 3000; i++)
c0025d11:	be 00 00 00 00       	mov    $0x0,%esi
        printf ("%s: busy, waiting...", d->name);
c0025d16:	8d 83 14 65 ff ff    	lea    -0x9aec(%ebx),%eax
c0025d1c:	89 44 24 0c          	mov    %eax,0xc(%esp)
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0025d20:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025d24:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025d2a:	ec                   	in     (%dx),%al
c0025d2b:	84 c0                	test   %al,%al
c0025d2d:	79 34                	jns    c0025d63 <wait_while_busy+0x69>
      timer_msleep (10);
c0025d2f:	83 ec 08             	sub    $0x8,%esp
c0025d32:	6a 00                	push   $0x0
c0025d34:	6a 0a                	push   $0xa
c0025d36:	e8 7f ea ff ff       	call   c00247ba <timer_msleep>
  for (i = 0; i < 3000; i++)
c0025d3b:	83 c6 01             	add    $0x1,%esi
c0025d3e:	83 c4 10             	add    $0x10,%esp
c0025d41:	81 fe b8 0b 00 00    	cmp    $0xbb8,%esi
c0025d47:	74 4f                	je     c0025d98 <wait_while_busy+0x9e>
      if (i == 700)
c0025d49:	81 fe bc 02 00 00    	cmp    $0x2bc,%esi
c0025d4f:	75 cf                	jne    c0025d20 <wait_while_busy+0x26>
        printf ("%s: busy, waiting...", d->name);
c0025d51:	83 ec 08             	sub    $0x8,%esp
c0025d54:	55                   	push   %ebp
c0025d55:	ff 74 24 18          	pushl  0x18(%esp)
c0025d59:	e8 92 17 00 00       	call   c00274f0 <printf>
c0025d5e:	83 c4 10             	add    $0x10,%esp
c0025d61:	eb bd                	jmp    c0025d20 <wait_while_busy+0x26>
          if (i >= 700)
c0025d63:	81 fe bb 02 00 00    	cmp    $0x2bb,%esi
c0025d69:	7f 19                	jg     c0025d84 <wait_while_busy+0x8a>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0025d6b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0025d6f:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025d75:	ec                   	in     (%dx),%al
c0025d76:	c0 e8 03             	shr    $0x3,%al
c0025d79:	83 e0 01             	and    $0x1,%eax
}
c0025d7c:	83 c4 1c             	add    $0x1c,%esp
c0025d7f:	5b                   	pop    %ebx
c0025d80:	5e                   	pop    %esi
c0025d81:	5f                   	pop    %edi
c0025d82:	5d                   	pop    %ebp
c0025d83:	c3                   	ret    
            printf ("ok\n");
c0025d84:	83 ec 0c             	sub    $0xc,%esp
c0025d87:	8d 83 29 65 ff ff    	lea    -0x9ad7(%ebx),%eax
c0025d8d:	50                   	push   %eax
c0025d8e:	e8 cd 54 00 00       	call   c002b260 <puts>
c0025d93:	83 c4 10             	add    $0x10,%esp
c0025d96:	eb d3                	jmp    c0025d6b <wait_while_busy+0x71>
  printf ("failed\n");
c0025d98:	83 ec 0c             	sub    $0xc,%esp
c0025d9b:	8d 83 a4 73 ff ff    	lea    -0x8c5c(%ebx),%eax
c0025da1:	50                   	push   %eax
c0025da2:	e8 b9 54 00 00       	call   c002b260 <puts>
  return false;
c0025da7:	83 c4 10             	add    $0x10,%esp
c0025daa:	b8 00 00 00 00       	mov    $0x0,%eax
c0025daf:	eb cb                	jmp    c0025d7c <wait_while_busy+0x82>

c0025db1 <issue_pio_command>:
{
c0025db1:	57                   	push   %edi
c0025db2:	56                   	push   %esi
c0025db3:	53                   	push   %ebx
c0025db4:	e8 cc 8c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025db9:	81 c3 fb 50 01 00    	add    $0x150fb,%ebx
c0025dbf:	89 c7                	mov    %eax,%edi
c0025dc1:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_ON);
c0025dc3:	e8 15 c0 ff ff       	call   c0021ddd <intr_get_level>
c0025dc8:	83 f8 01             	cmp    $0x1,%eax
c0025dcb:	75 12                	jne    c0025ddf <issue_pio_command+0x2e>
  c->expecting_interrupt = true;
c0025dcd:	c6 47 30 01          	movb   $0x1,0x30(%edi)
  outb (reg_command (c), command);
c0025dd1:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025dd5:	83 c2 07             	add    $0x7,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025dd8:	89 f0                	mov    %esi,%eax
c0025dda:	ee                   	out    %al,(%dx)
}
c0025ddb:	5b                   	pop    %ebx
c0025ddc:	5e                   	pop    %esi
c0025ddd:	5f                   	pop    %edi
c0025dde:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_ON);
c0025ddf:	83 ec 0c             	sub    $0xc,%esp
c0025de2:	8d 83 3e 5c ff ff    	lea    -0xa3c2(%ebx),%eax
c0025de8:	50                   	push   %eax
c0025de9:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0025def:	50                   	push   %eax
c0025df0:	8d 83 bc 40 ff ff    	lea    -0xbf44(%ebx),%eax
c0025df6:	50                   	push   %eax
c0025df7:	68 9b 01 00 00       	push   $0x19b
c0025dfc:	8d 83 d9 64 ff ff    	lea    -0x9b27(%ebx),%eax
c0025e02:	50                   	push   %eax
c0025e03:	e8 7f 34 00 00       	call   c0029287 <debug_panic>

c0025e08 <ide_write>:
{
c0025e08:	55                   	push   %ebp
c0025e09:	57                   	push   %edi
c0025e0a:	56                   	push   %esi
c0025e0b:	53                   	push   %ebx
c0025e0c:	83 ec 18             	sub    $0x18,%esp
c0025e0f:	e8 71 8c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025e14:	81 c3 a0 50 01 00    	add    $0x150a0,%ebx
c0025e1a:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct channel *c = d->channel;
c0025e1e:	8b 7e 08             	mov    0x8(%esi),%edi
  lock_acquire (&c->lock);
c0025e21:	8d 6f 0c             	lea    0xc(%edi),%ebp
c0025e24:	55                   	push   %ebp
c0025e25:	e8 fc d4 ff ff       	call   c0023326 <lock_acquire>
  select_sector (d, sec_no);
c0025e2a:	8b 54 24 34          	mov    0x34(%esp),%edx
c0025e2e:	89 f0                	mov    %esi,%eax
c0025e30:	e8 21 fe ff ff       	call   c0025c56 <select_sector>
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0025e35:	ba 30 00 00 00       	mov    $0x30,%edx
c0025e3a:	89 f8                	mov    %edi,%eax
c0025e3c:	e8 70 ff ff ff       	call   c0025db1 <issue_pio_command>
  if (!wait_while_busy (d))
c0025e41:	89 f0                	mov    %esi,%eax
c0025e43:	e8 b2 fe ff ff       	call   c0025cfa <wait_while_busy>
c0025e48:	83 c4 10             	add    $0x10,%esp
c0025e4b:	84 c0                	test   %al,%al
c0025e4d:	74 2c                	je     c0025e7b <ide_write+0x73>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025e4f:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025e53:	8b 74 24 28          	mov    0x28(%esp),%esi
c0025e57:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025e5c:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  sema_down (&c->completion_wait);
c0025e5f:	83 ec 0c             	sub    $0xc,%esp
c0025e62:	83 c7 34             	add    $0x34,%edi
c0025e65:	57                   	push   %edi
c0025e66:	e8 8d d1 ff ff       	call   c0022ff8 <sema_down>
  lock_release (&c->lock);
c0025e6b:	89 2c 24             	mov    %ebp,(%esp)
c0025e6e:	e8 ab d6 ff ff       	call   c002351e <lock_release>
}
c0025e73:	83 c4 1c             	add    $0x1c,%esp
c0025e76:	5b                   	pop    %ebx
c0025e77:	5e                   	pop    %esi
c0025e78:	5f                   	pop    %edi
c0025e79:	5d                   	pop    %ebp
c0025e7a:	c3                   	ret    
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0025e7b:	83 ec 08             	sub    $0x8,%esp
c0025e7e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025e82:	56                   	push   %esi
c0025e83:	8d 83 78 65 ff ff    	lea    -0x9a88(%ebx),%eax
c0025e89:	50                   	push   %eax
c0025e8a:	8d 83 ec 40 ff ff    	lea    -0xbf14(%ebx),%eax
c0025e90:	50                   	push   %eax
c0025e91:	68 75 01 00 00       	push   $0x175
c0025e96:	8d 83 d9 64 ff ff    	lea    -0x9b27(%ebx),%eax
c0025e9c:	50                   	push   %eax
c0025e9d:	e8 e5 33 00 00       	call   c0029287 <debug_panic>

c0025ea2 <identify_ata_device>:
{
c0025ea2:	55                   	push   %ebp
c0025ea3:	57                   	push   %edi
c0025ea4:	56                   	push   %esi
c0025ea5:	53                   	push   %ebx
c0025ea6:	81 ec 8c 02 00 00    	sub    $0x28c,%esp
c0025eac:	e8 d4 8b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0025eb1:	81 c3 03 50 01 00    	add    $0x15003,%ebx
  struct channel *c = d->channel;
c0025eb7:	8b 78 08             	mov    0x8(%eax),%edi
  ASSERT (d->is_ata);
c0025eba:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c0025ebe:	74 4a                	je     c0025f0a <identify_ata_device+0x68>
c0025ec0:	89 c6                	mov    %eax,%esi
  wait_until_idle (d);
c0025ec2:	e8 5d fc ff ff       	call   c0025b24 <wait_until_idle>
  select_device (d);
c0025ec7:	89 f0                	mov    %esi,%eax
c0025ec9:	e8 c3 fc ff ff       	call   c0025b91 <select_device>
  wait_until_idle (d);
c0025ece:	89 f0                	mov    %esi,%eax
c0025ed0:	e8 4f fc ff ff       	call   c0025b24 <wait_until_idle>
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025ed5:	ba ec 00 00 00       	mov    $0xec,%edx
c0025eda:	89 f8                	mov    %edi,%eax
c0025edc:	e8 d0 fe ff ff       	call   c0025db1 <issue_pio_command>
  sema_down (&c->completion_wait);
c0025ee1:	83 ec 0c             	sub    $0xc,%esp
c0025ee4:	8d 47 34             	lea    0x34(%edi),%eax
c0025ee7:	50                   	push   %eax
c0025ee8:	e8 0b d1 ff ff       	call   c0022ff8 <sema_down>
  if (!wait_while_busy (d))
c0025eed:	89 f0                	mov    %esi,%eax
c0025eef:	e8 06 fe ff ff       	call   c0025cfa <wait_while_busy>
c0025ef4:	83 c4 10             	add    $0x10,%esp
c0025ef7:	84 c0                	test   %al,%al
c0025ef9:	75 38                	jne    c0025f33 <identify_ata_device+0x91>
      d->is_ata = false;
c0025efb:	c6 46 10 00          	movb   $0x0,0x10(%esi)
}
c0025eff:	81 c4 8c 02 00 00    	add    $0x28c,%esp
c0025f05:	5b                   	pop    %ebx
c0025f06:	5e                   	pop    %esi
c0025f07:	5f                   	pop    %edi
c0025f08:	5d                   	pop    %ebp
c0025f09:	c3                   	ret    
  ASSERT (d->is_ata);
c0025f0a:	83 ec 0c             	sub    $0xc,%esp
c0025f0d:	8d 83 2c 65 ff ff    	lea    -0x9ad4(%ebx),%eax
c0025f13:	50                   	push   %eax
c0025f14:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0025f1a:	50                   	push   %eax
c0025f1b:	8d 83 f8 40 ff ff    	lea    -0xbf08(%ebx),%eax
c0025f21:	50                   	push   %eax
c0025f22:	68 0d 01 00 00       	push   $0x10d
c0025f27:	8d 83 d9 64 ff ff    	lea    -0x9b27(%ebx),%eax
c0025f2d:	50                   	push   %eax
c0025f2e:	e8 54 33 00 00       	call   c0029287 <debug_panic>
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025f33:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0025f37:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0025f3e:	b9 00 01 00 00       	mov    $0x100,%ecx
c0025f43:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  capacity = *(uint32_t *) &id[60 * 2];
c0025f46:	8b bc 24 f8 00 00 00 	mov    0xf8(%esp),%edi
  model = descramble_ata_string (&id[10 * 2], 20);
c0025f4d:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0025f54:	ba 14 00 00 00       	mov    $0x14,%edx
c0025f59:	e8 e7 fa ff ff       	call   c0025a45 <descramble_ata_string>
c0025f5e:	89 c5                	mov    %eax,%ebp
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025f60:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0025f67:	ba 28 00 00 00       	mov    $0x28,%edx
c0025f6c:	e8 d4 fa ff ff       	call   c0025a45 <descramble_ata_string>
  snprintf (extra_info, sizeof extra_info,
c0025f71:	83 ec 0c             	sub    $0xc,%esp
c0025f74:	50                   	push   %eax
c0025f75:	55                   	push   %ebp
c0025f76:	8d 83 36 65 ff ff    	lea    -0x9aca(%ebx),%eax
c0025f7c:	50                   	push   %eax
c0025f7d:	68 80 00 00 00       	push   $0x80
c0025f82:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0025f86:	50                   	push   %eax
c0025f87:	e8 85 1e 00 00       	call   c0027e11 <snprintf>
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025f8c:	83 c4 20             	add    $0x20,%esp
c0025f8f:	81 ff ff ff 1f 00    	cmp    $0x1fffff,%edi
c0025f95:	76 3c                	jbe    c0025fd3 <identify_ata_device+0x131>
      printf ("%s: ignoring ", d->name);
c0025f97:	83 ec 08             	sub    $0x8,%esp
c0025f9a:	56                   	push   %esi
c0025f9b:	8d 83 4e 65 ff ff    	lea    -0x9ab2(%ebx),%eax
c0025fa1:	50                   	push   %eax
c0025fa2:	e8 49 15 00 00       	call   c00274f0 <printf>
      print_human_readable_size (capacity * 512);
c0025fa7:	83 c4 08             	add    $0x8,%esp
c0025faa:	c1 e7 09             	shl    $0x9,%edi
c0025fad:	ba 00 00 00 00       	mov    $0x0,%edx
c0025fb2:	52                   	push   %edx
c0025fb3:	57                   	push   %edi
c0025fb4:	e8 69 20 00 00       	call   c0028022 <print_human_readable_size>
      printf ("disk for safety\n");
c0025fb9:	8d 83 5c 65 ff ff    	lea    -0x9aa4(%ebx),%eax
c0025fbf:	89 04 24             	mov    %eax,(%esp)
c0025fc2:	e8 99 52 00 00       	call   c002b260 <puts>
      d->is_ata = false;
c0025fc7:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return;
c0025fcb:	83 c4 10             	add    $0x10,%esp
c0025fce:	e9 2c ff ff ff       	jmp    c0025eff <identify_ata_device+0x5d>
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025fd3:	83 ec 08             	sub    $0x8,%esp
c0025fd6:	56                   	push   %esi
c0025fd7:	8d 83 04 06 00 00    	lea    0x604(%ebx),%eax
c0025fdd:	50                   	push   %eax
c0025fde:	57                   	push   %edi
c0025fdf:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025fe3:	50                   	push   %eax
c0025fe4:	6a 04                	push   $0x4
c0025fe6:	56                   	push   %esi
c0025fe7:	e8 5c f4 ff ff       	call   c0025448 <block_register>
  partition_scan (block);
c0025fec:	83 c4 14             	add    $0x14,%esp
c0025fef:	50                   	push   %eax
c0025ff0:	e8 f0 f9 ff ff       	call   c00259e5 <partition_scan>
c0025ff5:	83 c4 10             	add    $0x10,%esp
c0025ff8:	e9 02 ff ff ff       	jmp    c0025eff <identify_ata_device+0x5d>

c0025ffd <ide_read>:
{
c0025ffd:	55                   	push   %ebp
c0025ffe:	57                   	push   %edi
c0025fff:	56                   	push   %esi
c0026000:	53                   	push   %ebx
c0026001:	83 ec 18             	sub    $0x18,%esp
c0026004:	e8 7c 8a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026009:	81 c3 ab 4e 01 00    	add    $0x14eab,%ebx
c002600f:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  struct channel *c = d->channel;
c0026013:	8b 77 08             	mov    0x8(%edi),%esi
  lock_acquire (&c->lock);
c0026016:	8d 6e 0c             	lea    0xc(%esi),%ebp
c0026019:	55                   	push   %ebp
c002601a:	e8 07 d3 ff ff       	call   c0023326 <lock_acquire>
  select_sector (d, sec_no);
c002601f:	8b 54 24 34          	mov    0x34(%esp),%edx
c0026023:	89 f8                	mov    %edi,%eax
c0026025:	e8 2c fc ff ff       	call   c0025c56 <select_sector>
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c002602a:	ba 20 00 00 00       	mov    $0x20,%edx
c002602f:	89 f0                	mov    %esi,%eax
c0026031:	e8 7b fd ff ff       	call   c0025db1 <issue_pio_command>
  sema_down (&c->completion_wait);
c0026036:	8d 46 34             	lea    0x34(%esi),%eax
c0026039:	89 04 24             	mov    %eax,(%esp)
c002603c:	e8 b7 cf ff ff       	call   c0022ff8 <sema_down>
  if (!wait_while_busy (d))
c0026041:	89 f8                	mov    %edi,%eax
c0026043:	e8 b2 fc ff ff       	call   c0025cfa <wait_while_busy>
c0026048:	83 c4 10             	add    $0x10,%esp
c002604b:	84 c0                	test   %al,%al
c002604d:	74 21                	je     c0026070 <ide_read+0x73>
c002604f:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0026053:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0026057:	b9 00 01 00 00       	mov    $0x100,%ecx
c002605c:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  lock_release (&c->lock);
c002605f:	83 ec 0c             	sub    $0xc,%esp
c0026062:	55                   	push   %ebp
c0026063:	e8 b6 d4 ff ff       	call   c002351e <lock_release>
}
c0026068:	83 c4 1c             	add    $0x1c,%esp
c002606b:	5b                   	pop    %ebx
c002606c:	5e                   	pop    %esi
c002606d:	5f                   	pop    %edi
c002606e:	5d                   	pop    %ebp
c002606f:	c3                   	ret    
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0026070:	83 ec 08             	sub    $0x8,%esp
c0026073:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026077:	57                   	push   %edi
c0026078:	8d 83 9c 65 ff ff    	lea    -0x9a64(%ebx),%eax
c002607e:	50                   	push   %eax
c002607f:	8d 83 d0 40 ff ff    	lea    -0xbf30(%ebx),%eax
c0026085:	50                   	push   %eax
c0026086:	68 62 01 00 00       	push   $0x162
c002608b:	8d 83 d9 64 ff ff    	lea    -0x9b27(%ebx),%eax
c0026091:	50                   	push   %eax
c0026092:	e8 f0 31 00 00       	call   c0029287 <debug_panic>

c0026097 <ide_init>:
{
c0026097:	55                   	push   %ebp
c0026098:	57                   	push   %edi
c0026099:	56                   	push   %esi
c002609a:	53                   	push   %ebx
c002609b:	83 ec 2c             	sub    $0x2c,%esp
c002609e:	e8 e2 89 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00260a3:	81 c3 11 4e 01 00    	add    $0x14e11,%ebx
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c00260a9:	6a 00                	push   $0x0
c00260ab:	8d 83 6c 65 ff ff    	lea    -0x9a94(%ebx),%eax
c00260b1:	50                   	push   %eax
c00260b2:	6a 08                	push   $0x8
c00260b4:	8d b3 ec 1f 00 00    	lea    0x1fec(%ebx),%esi
c00260ba:	56                   	push   %esi
c00260bb:	e8 51 1d 00 00       	call   c0027e11 <snprintf>
          c->reg_base = 0x1f0;
c00260c0:	66 c7 83 f4 1f 00 00 	movw   $0x1f0,0x1ff4(%ebx)
c00260c7:	f0 01 
          c->irq = 14 + 0x20;
c00260c9:	c6 83 f6 1f 00 00 2e 	movb   $0x2e,0x1ff6(%ebx)
      lock_init (&c->lock);
c00260d0:	8d 83 f8 1f 00 00    	lea    0x1ff8(%ebx),%eax
c00260d6:	89 04 24             	mov    %eax,(%esp)
c00260d9:	e8 9c d1 ff ff       	call   c002327a <lock_init>
      c->expecting_interrupt = false;
c00260de:	c6 83 1c 20 00 00 00 	movb   $0x0,0x201c(%ebx)
      sema_init (&c->completion_wait, 0);
c00260e5:	83 c4 08             	add    $0x8,%esp
c00260e8:	6a 00                	push   $0x0
c00260ea:	8d 83 20 20 00 00    	lea    0x2020(%ebx),%eax
c00260f0:	50                   	push   %eax
c00260f1:	e8 ae ce ff ff       	call   c0022fa4 <sema_init>
          snprintf (d->name, sizeof d->name,
c00260f6:	6a 61                	push   $0x61
c00260f8:	8d bb 73 65 ff ff    	lea    -0x9a8d(%ebx),%edi
c00260fe:	57                   	push   %edi
c00260ff:	6a 08                	push   $0x8
c0026101:	8d ab 34 20 00 00    	lea    0x2034(%ebx),%ebp
c0026107:	55                   	push   %ebp
c0026108:	e8 04 1d 00 00       	call   c0027e11 <snprintf>
          d->channel = c;
c002610d:	89 b3 3c 20 00 00    	mov    %esi,0x203c(%ebx)
          d->dev_no = dev_no;
c0026113:	c7 83 40 20 00 00 00 	movl   $0x0,0x2040(%ebx)
c002611a:	00 00 00 
          d->is_ata = false;
c002611d:	c6 83 44 20 00 00 00 	movb   $0x0,0x2044(%ebx)
          snprintf (d->name, sizeof d->name,
c0026124:	83 c4 20             	add    $0x20,%esp
c0026127:	6a 62                	push   $0x62
c0026129:	57                   	push   %edi
c002612a:	6a 08                	push   $0x8
c002612c:	8d 83 48 20 00 00    	lea    0x2048(%ebx),%eax
c0026132:	50                   	push   %eax
c0026133:	e8 d9 1c 00 00       	call   c0027e11 <snprintf>
          d->channel = c;
c0026138:	89 b3 50 20 00 00    	mov    %esi,0x2050(%ebx)
          d->dev_no = dev_no;
c002613e:	c7 83 54 20 00 00 01 	movl   $0x1,0x2054(%ebx)
c0026145:	00 00 00 
          d->is_ata = false;
c0026148:	c6 83 58 20 00 00 00 	movb   $0x0,0x2058(%ebx)
      intr_register_ext (c->irq, interrupt_handler, c->name);
c002614f:	83 c4 0c             	add    $0xc,%esp
c0026152:	56                   	push   %esi
c0026153:	8d 83 e2 ab fe ff    	lea    -0x1541e(%ebx),%eax
c0026159:	50                   	push   %eax
c002615a:	0f b6 83 f6 1f 00 00 	movzbl 0x1ff6(%ebx),%eax
c0026161:	50                   	push   %eax
c0026162:	e8 a2 be ff ff       	call   c0022009 <intr_register_ext>
      select_device (d);
c0026167:	89 e8                	mov    %ebp,%eax
c0026169:	e8 23 fa ff ff       	call   c0025b91 <select_device>
      outb (reg_nsect (c), 0x55);
c002616e:	0f b7 8b f4 1f 00 00 	movzwl 0x1ff4(%ebx),%ecx
c0026175:	8d 71 02             	lea    0x2(%ecx),%esi
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026178:	bd 55 00 00 00       	mov    $0x55,%ebp
c002617d:	89 e8                	mov    %ebp,%eax
c002617f:	89 f2                	mov    %esi,%edx
c0026181:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c0026182:	83 c1 03             	add    $0x3,%ecx
c0026185:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c002618a:	89 f8                	mov    %edi,%eax
c002618c:	89 ca                	mov    %ecx,%edx
c002618e:	ee                   	out    %al,(%dx)
c002618f:	89 f2                	mov    %esi,%edx
c0026191:	ee                   	out    %al,(%dx)
c0026192:	89 e8                	mov    %ebp,%eax
c0026194:	89 ca                	mov    %ecx,%edx
c0026196:	ee                   	out    %al,(%dx)
c0026197:	89 f2                	mov    %esi,%edx
c0026199:	ee                   	out    %al,(%dx)
c002619a:	89 f8                	mov    %edi,%eax
c002619c:	89 ca                	mov    %ecx,%edx
c002619e:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002619f:	89 f2                	mov    %esi,%edx
c00261a1:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c00261a2:	83 c4 10             	add    $0x10,%esp
c00261a5:	ba 00 00 00 00       	mov    $0x0,%edx
c00261aa:	3c 55                	cmp    $0x55,%al
c00261ac:	0f 84 cf 01 00 00    	je     c0026381 <ide_init+0x2ea>
c00261b2:	89 d0                	mov    %edx,%eax
c00261b4:	83 e0 01             	and    $0x1,%eax
c00261b7:	88 44 24 0c          	mov    %al,0xc(%esp)
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00261bb:	88 44 24 1e          	mov    %al,0x1e(%esp)
      select_device (d);
c00261bf:	8d 83 48 20 00 00    	lea    0x2048(%ebx),%eax
c00261c5:	e8 c7 f9 ff ff       	call   c0025b91 <select_device>
      outb (reg_nsect (c), 0x55);
c00261ca:	0f b7 ab f4 1f 00 00 	movzwl 0x1ff4(%ebx),%ebp
c00261d1:	8d 4d 02             	lea    0x2(%ebp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00261d4:	b8 55 00 00 00       	mov    $0x55,%eax
c00261d9:	89 ca                	mov    %ecx,%edx
c00261db:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c00261dc:	8d 75 03             	lea    0x3(%ebp),%esi
c00261df:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c00261e4:	89 f8                	mov    %edi,%eax
c00261e6:	89 f2                	mov    %esi,%edx
c00261e8:	ee                   	out    %al,(%dx)
c00261e9:	89 ca                	mov    %ecx,%edx
c00261eb:	ee                   	out    %al,(%dx)
c00261ec:	b8 55 00 00 00       	mov    $0x55,%eax
c00261f1:	89 f2                	mov    %esi,%edx
c00261f3:	ee                   	out    %al,(%dx)
c00261f4:	89 ca                	mov    %ecx,%edx
c00261f6:	ee                   	out    %al,(%dx)
c00261f7:	89 f8                	mov    %edi,%eax
c00261f9:	89 f2                	mov    %esi,%edx
c00261fb:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00261fc:	89 ca                	mov    %ecx,%edx
c00261fe:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c00261ff:	ba 00 00 00 00       	mov    $0x0,%edx
c0026204:	3c 55                	cmp    $0x55,%al
c0026206:	0f 84 85 01 00 00    	je     c0026391 <ide_init+0x2fa>
c002620c:	89 d6                	mov    %edx,%esi
c002620e:	83 e6 01             	and    $0x1,%esi
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0026211:	89 f0                	mov    %esi,%eax
c0026213:	88 44 24 1f          	mov    %al,0x1f(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026217:	bf 00 00 00 00       	mov    $0x0,%edi
  outb (reg_ctl (c), 0);
c002621c:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c0026222:	89 f8                	mov    %edi,%eax
c0026224:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0026225:	83 ec 08             	sub    $0x8,%esp
c0026228:	6a 00                	push   $0x0
c002622a:	6a 0a                	push   $0xa
c002622c:	e8 a2 e5 ff ff       	call   c00247d3 <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c0026231:	0f b7 93 f4 1f 00 00 	movzwl 0x1ff4(%ebx),%edx
c0026238:	66 81 c2 06 02       	add    $0x206,%dx
c002623d:	b8 04 00 00 00       	mov    $0x4,%eax
c0026242:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c0026243:	83 c4 08             	add    $0x8,%esp
c0026246:	6a 00                	push   $0x0
c0026248:	6a 0a                	push   $0xa
c002624a:	e8 84 e5 ff ff       	call   c00247d3 <timer_usleep>
  outb (reg_ctl (c), 0);
c002624f:	0f b7 93 f4 1f 00 00 	movzwl 0x1ff4(%ebx),%edx
c0026256:	66 81 c2 06 02       	add    $0x206,%dx
c002625b:	89 f8                	mov    %edi,%eax
c002625d:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c002625e:	83 c4 08             	add    $0x8,%esp
c0026261:	6a 00                	push   $0x0
c0026263:	68 96 00 00 00       	push   $0x96
c0026268:	e8 4d e5 ff ff       	call   c00247ba <timer_msleep>
  if (present[0]) 
c002626d:	83 c4 10             	add    $0x10,%esp
c0026270:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%esp)
c0026275:	0f 85 26 01 00 00    	jne    c00263a1 <ide_init+0x30a>
  if (present[1])
c002627b:	89 f0                	mov    %esi,%eax
c002627d:	84 c0                	test   %al,%al
c002627f:	0f 85 37 01 00 00    	jne    c00263bc <ide_init+0x325>
      if (check_device_type (&c->devices[0]))
c0026285:	8d 83 34 20 00 00    	lea    0x2034(%ebx),%eax
c002628b:	e8 44 f9 ff ff       	call   c0025bd4 <check_device_type>
c0026290:	84 c0                	test   %al,%al
c0026292:	0f 85 71 01 00 00    	jne    c0026409 <ide_init+0x372>
        if (c->devices[dev_no].is_ata)
c0026298:	80 bb 44 20 00 00 00 	cmpb   $0x0,0x2044(%ebx)
c002629f:	0f 85 74 01 00 00    	jne    c0026419 <ide_init+0x382>
c00262a5:	80 bb 58 20 00 00 00 	cmpb   $0x0,0x2058(%ebx)
c00262ac:	0f 85 77 01 00 00    	jne    c0026429 <ide_init+0x392>
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c00262b2:	6a 01                	push   $0x1
c00262b4:	8d 83 6c 65 ff ff    	lea    -0x9a94(%ebx),%eax
c00262ba:	50                   	push   %eax
c00262bb:	6a 08                	push   $0x8
c00262bd:	8d b3 5c 20 00 00    	lea    0x205c(%ebx),%esi
c00262c3:	56                   	push   %esi
c00262c4:	e8 48 1b 00 00       	call   c0027e11 <snprintf>
          c->reg_base = 0x170;
c00262c9:	66 c7 83 64 20 00 00 	movw   $0x170,0x2064(%ebx)
c00262d0:	70 01 
          c->irq = 15 + 0x20;
c00262d2:	c6 83 66 20 00 00 2f 	movb   $0x2f,0x2066(%ebx)
      lock_init (&c->lock);
c00262d9:	8d 83 68 20 00 00    	lea    0x2068(%ebx),%eax
c00262df:	89 04 24             	mov    %eax,(%esp)
c00262e2:	e8 93 cf ff ff       	call   c002327a <lock_init>
      c->expecting_interrupt = false;
c00262e7:	c6 83 8c 20 00 00 00 	movb   $0x0,0x208c(%ebx)
      sema_init (&c->completion_wait, 0);
c00262ee:	83 c4 08             	add    $0x8,%esp
c00262f1:	6a 00                	push   $0x0
c00262f3:	8d 83 90 20 00 00    	lea    0x2090(%ebx),%eax
c00262f9:	50                   	push   %eax
c00262fa:	e8 a5 cc ff ff       	call   c0022fa4 <sema_init>
          snprintf (d->name, sizeof d->name,
c00262ff:	6a 63                	push   $0x63
c0026301:	8d bb 73 65 ff ff    	lea    -0x9a8d(%ebx),%edi
c0026307:	57                   	push   %edi
c0026308:	6a 08                	push   $0x8
c002630a:	8d ab a4 20 00 00    	lea    0x20a4(%ebx),%ebp
c0026310:	55                   	push   %ebp
c0026311:	e8 fb 1a 00 00       	call   c0027e11 <snprintf>
          d->channel = c;
c0026316:	89 b3 ac 20 00 00    	mov    %esi,0x20ac(%ebx)
          d->dev_no = dev_no;
c002631c:	c7 83 b0 20 00 00 00 	movl   $0x0,0x20b0(%ebx)
c0026323:	00 00 00 
          d->is_ata = false;
c0026326:	c6 83 b4 20 00 00 00 	movb   $0x0,0x20b4(%ebx)
          snprintf (d->name, sizeof d->name,
c002632d:	83 c4 20             	add    $0x20,%esp
c0026330:	6a 64                	push   $0x64
c0026332:	57                   	push   %edi
c0026333:	6a 08                	push   $0x8
c0026335:	8d 83 b8 20 00 00    	lea    0x20b8(%ebx),%eax
c002633b:	50                   	push   %eax
c002633c:	e8 d0 1a 00 00       	call   c0027e11 <snprintf>
          d->channel = c;
c0026341:	89 b3 c0 20 00 00    	mov    %esi,0x20c0(%ebx)
          d->dev_no = dev_no;
c0026347:	c7 83 c4 20 00 00 01 	movl   $0x1,0x20c4(%ebx)
c002634e:	00 00 00 
          d->is_ata = false;
c0026351:	c6 83 c8 20 00 00 00 	movb   $0x0,0x20c8(%ebx)
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0026358:	83 c4 0c             	add    $0xc,%esp
c002635b:	56                   	push   %esi
c002635c:	8d 83 e2 ab fe ff    	lea    -0x1541e(%ebx),%eax
c0026362:	50                   	push   %eax
c0026363:	0f b6 83 66 20 00 00 	movzbl 0x2066(%ebx),%eax
c002636a:	50                   	push   %eax
c002636b:	e8 99 bc ff ff       	call   c0022009 <intr_register_ext>
c0026370:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0026374:	83 c4 10             	add    $0x10,%esp
  for (dev_no = 0; dev_no < 2; dev_no++)
c0026377:	be 00 00 00 00       	mov    $0x0,%esi
c002637c:	e9 ce 00 00 00       	jmp    c002644f <ide_init+0x3b8>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026381:	89 ca                	mov    %ecx,%edx
c0026383:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c0026384:	3c aa                	cmp    $0xaa,%al
c0026386:	0f 94 c2             	sete   %dl
c0026389:	0f b6 d2             	movzbl %dl,%edx
c002638c:	e9 21 fe ff ff       	jmp    c00261b2 <ide_init+0x11b>
c0026391:	89 f2                	mov    %esi,%edx
c0026393:	ec                   	in     (%dx),%al
c0026394:	3c aa                	cmp    $0xaa,%al
c0026396:	0f 94 c2             	sete   %dl
c0026399:	0f b6 d2             	movzbl %dl,%edx
c002639c:	e9 6b fe ff ff       	jmp    c002620c <ide_init+0x175>
      select_device (&c->devices[0]);
c00263a1:	8d 83 34 20 00 00    	lea    0x2034(%ebx),%eax
c00263a7:	e8 e5 f7 ff ff       	call   c0025b91 <select_device>
      wait_while_busy (&c->devices[0]); 
c00263ac:	8d 83 34 20 00 00    	lea    0x2034(%ebx),%eax
c00263b2:	e8 43 f9 ff ff       	call   c0025cfa <wait_while_busy>
c00263b7:	e9 bf fe ff ff       	jmp    c002627b <ide_init+0x1e4>
      select_device (&c->devices[1]);
c00263bc:	8d 83 48 20 00 00    	lea    0x2048(%ebx),%eax
c00263c2:	e8 ca f7 ff ff       	call   c0025b91 <select_device>
c00263c7:	be b8 0b 00 00       	mov    $0xbb8,%esi
c00263cc:	eb 14                	jmp    c00263e2 <ide_init+0x34b>
          timer_msleep (10);
c00263ce:	83 ec 08             	sub    $0x8,%esp
c00263d1:	6a 00                	push   $0x0
c00263d3:	6a 0a                	push   $0xa
c00263d5:	e8 e0 e3 ff ff       	call   c00247ba <timer_msleep>
      for (i = 0; i < 3000; i++) 
c00263da:	83 c4 10             	add    $0x10,%esp
c00263dd:	83 ee 01             	sub    $0x1,%esi
c00263e0:	74 17                	je     c00263f9 <ide_init+0x362>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c00263e2:	0f b7 8b f4 1f 00 00 	movzwl 0x1ff4(%ebx),%ecx
c00263e9:	8d 51 02             	lea    0x2(%ecx),%edx
c00263ec:	ec                   	in     (%dx),%al
c00263ed:	3c 01                	cmp    $0x1,%al
c00263ef:	75 dd                	jne    c00263ce <ide_init+0x337>
c00263f1:	8d 51 03             	lea    0x3(%ecx),%edx
c00263f4:	ec                   	in     (%dx),%al
c00263f5:	3c 01                	cmp    $0x1,%al
c00263f7:	75 d5                	jne    c00263ce <ide_init+0x337>
      wait_while_busy (&c->devices[1]);
c00263f9:	8d 83 48 20 00 00    	lea    0x2048(%ebx),%eax
c00263ff:	e8 f6 f8 ff ff       	call   c0025cfa <wait_while_busy>
c0026404:	e9 7c fe ff ff       	jmp    c0026285 <ide_init+0x1ee>
        check_device_type (&c->devices[1]);
c0026409:	8d 83 48 20 00 00    	lea    0x2048(%ebx),%eax
c002640f:	e8 c0 f7 ff ff       	call   c0025bd4 <check_device_type>
c0026414:	e9 7f fe ff ff       	jmp    c0026298 <ide_init+0x201>
          identify_ata_device (&c->devices[dev_no]);
c0026419:	8d 83 34 20 00 00    	lea    0x2034(%ebx),%eax
c002641f:	e8 7e fa ff ff       	call   c0025ea2 <identify_ata_device>
c0026424:	e9 7c fe ff ff       	jmp    c00262a5 <ide_init+0x20e>
c0026429:	8d 83 48 20 00 00    	lea    0x2048(%ebx),%eax
c002642f:	e8 6e fa ff ff       	call   c0025ea2 <identify_ata_device>
c0026434:	e9 79 fe ff ff       	jmp    c00262b2 <ide_init+0x21b>
                         && inb (reg_lbal (c)) == 0xaa);
c0026439:	88 54 34 1e          	mov    %dl,0x1e(%esp,%esi,1)
c002643d:	80 64 34 1e 01       	andb   $0x1,0x1e(%esp,%esi,1)
  for (dev_no = 0; dev_no < 2; dev_no++)
c0026442:	83 c6 01             	add    $0x1,%esi
c0026445:	83 44 24 0c 14       	addl   $0x14,0xc(%esp)
c002644a:	83 fe 02             	cmp    $0x2,%esi
c002644d:	74 55                	je     c00264a4 <ide_init+0x40d>
      select_device (d);
c002644f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0026453:	e8 39 f7 ff ff       	call   c0025b91 <select_device>
      outb (reg_nsect (c), 0x55);
c0026458:	0f b7 ab 64 20 00 00 	movzwl 0x2064(%ebx),%ebp
c002645f:	8d 4d 02             	lea    0x2(%ebp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026462:	b8 55 00 00 00       	mov    $0x55,%eax
c0026467:	89 ca                	mov    %ecx,%edx
c0026469:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c002646a:	8d 7d 03             	lea    0x3(%ebp),%edi
c002646d:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c0026472:	89 fa                	mov    %edi,%edx
c0026474:	ee                   	out    %al,(%dx)
c0026475:	89 ca                	mov    %ecx,%edx
c0026477:	ee                   	out    %al,(%dx)
c0026478:	b8 55 00 00 00       	mov    $0x55,%eax
c002647d:	89 fa                	mov    %edi,%edx
c002647f:	ee                   	out    %al,(%dx)
c0026480:	89 ca                	mov    %ecx,%edx
c0026482:	ee                   	out    %al,(%dx)
c0026483:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c0026488:	89 fa                	mov    %edi,%edx
c002648a:	ee                   	out    %al,(%dx)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002648b:	89 ca                	mov    %ecx,%edx
c002648d:	ec                   	in     (%dx),%al
                         && inb (reg_lbal (c)) == 0xaa);
c002648e:	ba 00 00 00 00       	mov    $0x0,%edx
c0026493:	3c 55                	cmp    $0x55,%al
c0026495:	75 a2                	jne    c0026439 <ide_init+0x3a2>
c0026497:	89 fa                	mov    %edi,%edx
c0026499:	ec                   	in     (%dx),%al
c002649a:	3c aa                	cmp    $0xaa,%al
c002649c:	0f 94 c2             	sete   %dl
c002649f:	0f b6 d2             	movzbl %dl,%edx
c00264a2:	eb 95                	jmp    c0026439 <ide_init+0x3a2>
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00264a4:	be 00 00 00 00       	mov    $0x0,%esi
  outb (reg_ctl (c), 0);
c00264a9:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c00264af:	89 f0                	mov    %esi,%eax
c00264b1:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00264b2:	83 ec 08             	sub    $0x8,%esp
c00264b5:	6a 00                	push   $0x0
c00264b7:	6a 0a                	push   $0xa
c00264b9:	e8 15 e3 ff ff       	call   c00247d3 <timer_usleep>
  outb (reg_ctl (c), CTL_SRST);
c00264be:	0f b7 93 64 20 00 00 	movzwl 0x2064(%ebx),%edx
c00264c5:	66 81 c2 06 02       	add    $0x206,%dx
c00264ca:	b8 04 00 00 00       	mov    $0x4,%eax
c00264cf:	ee                   	out    %al,(%dx)
  timer_usleep (10);
c00264d0:	83 c4 08             	add    $0x8,%esp
c00264d3:	6a 00                	push   $0x0
c00264d5:	6a 0a                	push   $0xa
c00264d7:	e8 f7 e2 ff ff       	call   c00247d3 <timer_usleep>
  outb (reg_ctl (c), 0);
c00264dc:	0f b7 93 64 20 00 00 	movzwl 0x2064(%ebx),%edx
c00264e3:	66 81 c2 06 02       	add    $0x206,%dx
c00264e8:	89 f0                	mov    %esi,%eax
c00264ea:	ee                   	out    %al,(%dx)
  timer_msleep (150);
c00264eb:	83 c4 08             	add    $0x8,%esp
c00264ee:	6a 00                	push   $0x0
c00264f0:	68 96 00 00 00       	push   $0x96
c00264f5:	e8 c0 e2 ff ff       	call   c00247ba <timer_msleep>
  if (present[0]) 
c00264fa:	83 c4 10             	add    $0x10,%esp
c00264fd:	80 7c 24 1e 00       	cmpb   $0x0,0x1e(%esp)
c0026502:	75 38                	jne    c002653c <ide_init+0x4a5>
  if (present[1])
c0026504:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026509:	75 49                	jne    c0026554 <ide_init+0x4bd>
      if (check_device_type (&c->devices[0]))
c002650b:	8d 83 a4 20 00 00    	lea    0x20a4(%ebx),%eax
c0026511:	e8 be f6 ff ff       	call   c0025bd4 <check_device_type>
c0026516:	84 c0                	test   %al,%al
c0026518:	0f 85 83 00 00 00    	jne    c00265a1 <ide_init+0x50a>
        if (c->devices[dev_no].is_ata)
c002651e:	80 bb b4 20 00 00 00 	cmpb   $0x0,0x20b4(%ebx)
c0026525:	0f 85 96 00 00 00    	jne    c00265c1 <ide_init+0x52a>
c002652b:	80 bb c8 20 00 00 00 	cmpb   $0x0,0x20c8(%ebx)
c0026532:	75 7d                	jne    c00265b1 <ide_init+0x51a>
}
c0026534:	83 c4 2c             	add    $0x2c,%esp
c0026537:	5b                   	pop    %ebx
c0026538:	5e                   	pop    %esi
c0026539:	5f                   	pop    %edi
c002653a:	5d                   	pop    %ebp
c002653b:	c3                   	ret    
      select_device (&c->devices[0]);
c002653c:	8d 83 a4 20 00 00    	lea    0x20a4(%ebx),%eax
c0026542:	e8 4a f6 ff ff       	call   c0025b91 <select_device>
      wait_while_busy (&c->devices[0]); 
c0026547:	8d 83 a4 20 00 00    	lea    0x20a4(%ebx),%eax
c002654d:	e8 a8 f7 ff ff       	call   c0025cfa <wait_while_busy>
c0026552:	eb b0                	jmp    c0026504 <ide_init+0x46d>
      select_device (&c->devices[1]);
c0026554:	8d 83 b8 20 00 00    	lea    0x20b8(%ebx),%eax
c002655a:	e8 32 f6 ff ff       	call   c0025b91 <select_device>
c002655f:	be b8 0b 00 00       	mov    $0xbb8,%esi
c0026564:	eb 14                	jmp    c002657a <ide_init+0x4e3>
          timer_msleep (10);
c0026566:	83 ec 08             	sub    $0x8,%esp
c0026569:	6a 00                	push   $0x0
c002656b:	6a 0a                	push   $0xa
c002656d:	e8 48 e2 ff ff       	call   c00247ba <timer_msleep>
      for (i = 0; i < 3000; i++) 
c0026572:	83 c4 10             	add    $0x10,%esp
c0026575:	83 ee 01             	sub    $0x1,%esi
c0026578:	74 17                	je     c0026591 <ide_init+0x4fa>
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c002657a:	0f b7 8b 64 20 00 00 	movzwl 0x2064(%ebx),%ecx
c0026581:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026584:	ec                   	in     (%dx),%al
c0026585:	3c 01                	cmp    $0x1,%al
c0026587:	75 dd                	jne    c0026566 <ide_init+0x4cf>
c0026589:	8d 51 03             	lea    0x3(%ecx),%edx
c002658c:	ec                   	in     (%dx),%al
c002658d:	3c 01                	cmp    $0x1,%al
c002658f:	75 d5                	jne    c0026566 <ide_init+0x4cf>
      wait_while_busy (&c->devices[1]);
c0026591:	8d 83 b8 20 00 00    	lea    0x20b8(%ebx),%eax
c0026597:	e8 5e f7 ff ff       	call   c0025cfa <wait_while_busy>
c002659c:	e9 6a ff ff ff       	jmp    c002650b <ide_init+0x474>
        check_device_type (&c->devices[1]);
c00265a1:	8d 83 b8 20 00 00    	lea    0x20b8(%ebx),%eax
c00265a7:	e8 28 f6 ff ff       	call   c0025bd4 <check_device_type>
c00265ac:	e9 6d ff ff ff       	jmp    c002651e <ide_init+0x487>
          identify_ata_device (&c->devices[dev_no]);
c00265b1:	8d 83 b8 20 00 00    	lea    0x20b8(%ebx),%eax
c00265b7:	e8 e6 f8 ff ff       	call   c0025ea2 <identify_ata_device>
}
c00265bc:	e9 73 ff ff ff       	jmp    c0026534 <ide_init+0x49d>
          identify_ata_device (&c->devices[dev_no]);
c00265c1:	8d 83 a4 20 00 00    	lea    0x20a4(%ebx),%eax
c00265c7:	e8 d6 f8 ff ff       	call   c0025ea2 <identify_ata_device>
c00265cc:	e9 5a ff ff ff       	jmp    c002652b <ide_init+0x494>

c00265d1 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c00265d1:	53                   	push   %ebx
c00265d2:	83 ec 14             	sub    $0x14,%esp
c00265d5:	e8 ab 84 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00265da:	81 c3 da 48 01 00    	add    $0x148da,%ebx
  intq_init (&buffer);
c00265e0:	8d 83 cc 20 00 00    	lea    0x20cc(%ebx),%eax
c00265e6:	50                   	push   %eax
c00265e7:	e8 32 01 00 00       	call   c002671e <intq_init>
}
c00265ec:	83 c4 18             	add    $0x18,%esp
c00265ef:	5b                   	pop    %ebx
c00265f0:	c3                   	ret    

c00265f1 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c00265f1:	56                   	push   %esi
c00265f2:	53                   	push   %ebx
c00265f3:	83 ec 04             	sub    $0x4,%esp
c00265f6:	e8 8a 84 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00265fb:	81 c3 b9 48 01 00    	add    $0x148b9,%ebx
c0026601:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c0026605:	e8 d3 b7 ff ff       	call   c0021ddd <intr_get_level>
c002660a:	85 c0                	test   %eax,%eax
c002660c:	75 36                	jne    c0026644 <input_putc+0x53>
  ASSERT (!intq_full (&buffer));
c002660e:	83 ec 0c             	sub    $0xc,%esp
c0026611:	8d 83 cc 20 00 00    	lea    0x20cc(%ebx),%eax
c0026617:	50                   	push   %eax
c0026618:	e8 8f 01 00 00       	call   c00267ac <intq_full>
c002661d:	83 c4 10             	add    $0x10,%esp
c0026620:	84 c0                	test   %al,%al
c0026622:	75 46                	jne    c002666a <input_putc+0x79>

  intq_putc (&buffer, key);
c0026624:	83 ec 08             	sub    $0x8,%esp
c0026627:	89 f0                	mov    %esi,%eax
c0026629:	0f b6 f0             	movzbl %al,%esi
c002662c:	56                   	push   %esi
c002662d:	8d 83 cc 20 00 00    	lea    0x20cc(%ebx),%eax
c0026633:	50                   	push   %eax
c0026634:	e8 2f 04 00 00       	call   c0026a68 <intq_putc>
  serial_notify ();
c0026639:	e8 88 ea ff ff       	call   c00250c6 <serial_notify>
}
c002663e:	83 c4 14             	add    $0x14,%esp
c0026641:	5b                   	pop    %ebx
c0026642:	5e                   	pop    %esi
c0026643:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0026644:	83 ec 0c             	sub    $0xc,%esp
c0026647:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c002664d:	50                   	push   %eax
c002664e:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026654:	50                   	push   %eax
c0026655:	8d 83 2c 41 ff ff    	lea    -0xbed4(%ebx),%eax
c002665b:	50                   	push   %eax
c002665c:	6a 15                	push   $0x15
c002665e:	8d 83 bc 65 ff ff    	lea    -0x9a44(%ebx),%eax
c0026664:	50                   	push   %eax
c0026665:	e8 1d 2c 00 00       	call   c0029287 <debug_panic>
  ASSERT (!intq_full (&buffer));
c002666a:	83 ec 0c             	sub    $0xc,%esp
c002666d:	8d 83 d2 65 ff ff    	lea    -0x9a2e(%ebx),%eax
c0026673:	50                   	push   %eax
c0026674:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002667a:	50                   	push   %eax
c002667b:	8d 83 2c 41 ff ff    	lea    -0xbed4(%ebx),%eax
c0026681:	50                   	push   %eax
c0026682:	6a 16                	push   $0x16
c0026684:	8d 83 bc 65 ff ff    	lea    -0x9a44(%ebx),%eax
c002668a:	50                   	push   %eax
c002668b:	e8 f7 2b 00 00       	call   c0029287 <debug_panic>

c0026690 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0026690:	57                   	push   %edi
c0026691:	56                   	push   %esi
c0026692:	53                   	push   %ebx
c0026693:	e8 ed 83 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026698:	81 c3 1c 48 01 00    	add    $0x1481c,%ebx
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c002669e:	e8 8c b7 ff ff       	call   c0021e2f <intr_disable>
c00266a3:	89 c7                	mov    %eax,%edi
  key = intq_getc (&buffer);
c00266a5:	83 ec 0c             	sub    $0xc,%esp
c00266a8:	8d 83 cc 20 00 00    	lea    0x20cc(%ebx),%eax
c00266ae:	50                   	push   %eax
c00266af:	e8 e9 02 00 00       	call   c002699d <intq_getc>
c00266b4:	89 c6                	mov    %eax,%esi
  serial_notify ();
c00266b6:	e8 0b ea ff ff       	call   c00250c6 <serial_notify>
  intr_set_level (old_level);
c00266bb:	89 3c 24             	mov    %edi,(%esp)
c00266be:	e8 73 b7 ff ff       	call   c0021e36 <intr_set_level>
  
  return key;
c00266c3:	83 c4 10             	add    $0x10,%esp
}
c00266c6:	89 f0                	mov    %esi,%eax
c00266c8:	5b                   	pop    %ebx
c00266c9:	5e                   	pop    %esi
c00266ca:	5f                   	pop    %edi
c00266cb:	c3                   	ret    

c00266cc <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c00266cc:	53                   	push   %ebx
c00266cd:	83 ec 08             	sub    $0x8,%esp
c00266d0:	e8 b0 83 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00266d5:	81 c3 df 47 01 00    	add    $0x147df,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00266db:	e8 fd b6 ff ff       	call   c0021ddd <intr_get_level>
c00266e0:	85 c0                	test   %eax,%eax
c00266e2:	75 14                	jne    c00266f8 <input_full+0x2c>
  return intq_full (&buffer);
c00266e4:	83 ec 0c             	sub    $0xc,%esp
c00266e7:	8d 83 cc 20 00 00    	lea    0x20cc(%ebx),%eax
c00266ed:	50                   	push   %eax
c00266ee:	e8 b9 00 00 00       	call   c00267ac <intq_full>
}
c00266f3:	83 c4 18             	add    $0x18,%esp
c00266f6:	5b                   	pop    %ebx
c00266f7:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00266f8:	83 ec 0c             	sub    $0xc,%esp
c00266fb:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0026701:	50                   	push   %eax
c0026702:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026708:	50                   	push   %eax
c0026709:	8d 83 20 41 ff ff    	lea    -0xbee0(%ebx),%eax
c002670f:	50                   	push   %eax
c0026710:	6a 32                	push   $0x32
c0026712:	8d 83 bc 65 ff ff    	lea    -0x9a44(%ebx),%eax
c0026718:	50                   	push   %eax
c0026719:	e8 69 2b 00 00       	call   c0029287 <debug_panic>

c002671e <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c002671e:	56                   	push   %esi
c002671f:	53                   	push   %ebx
c0026720:	83 ec 10             	sub    $0x10,%esp
c0026723:	e8 5d 83 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026728:	81 c3 8c 47 01 00    	add    $0x1478c,%ebx
c002672e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_init (&q->lock);
c0026732:	56                   	push   %esi
c0026733:	e8 42 cb ff ff       	call   c002327a <lock_init>
  q->not_full = q->not_empty = NULL;
c0026738:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c002673f:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
  q->head = q->tail = 0;
c0026746:	c7 46 70 00 00 00 00 	movl   $0x0,0x70(%esi)
c002674d:	c7 46 6c 00 00 00 00 	movl   $0x0,0x6c(%esi)
}
c0026754:	83 c4 14             	add    $0x14,%esp
c0026757:	5b                   	pop    %ebx
c0026758:	5e                   	pop    %esi
c0026759:	c3                   	ret    

c002675a <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c002675a:	56                   	push   %esi
c002675b:	53                   	push   %ebx
c002675c:	83 ec 04             	sub    $0x4,%esp
c002675f:	e8 21 83 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026764:	81 c3 50 47 01 00    	add    $0x14750,%ebx
c002676a:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c002676e:	e8 6a b6 ff ff       	call   c0021ddd <intr_get_level>
c0026773:	85 c0                	test   %eax,%eax
c0026775:	75 0f                	jne    c0026786 <intq_empty+0x2c>
  return q->head == q->tail;
c0026777:	8b 46 70             	mov    0x70(%esi),%eax
c002677a:	39 46 6c             	cmp    %eax,0x6c(%esi)
c002677d:	0f 94 c0             	sete   %al
}
c0026780:	83 c4 04             	add    $0x4,%esp
c0026783:	5b                   	pop    %ebx
c0026784:	5e                   	pop    %esi
c0026785:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c0026786:	83 ec 0c             	sub    $0xc,%esp
c0026789:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c002678f:	50                   	push   %eax
c0026790:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026796:	50                   	push   %eax
c0026797:	8d 83 6c 41 ff ff    	lea    -0xbe94(%ebx),%eax
c002679d:	50                   	push   %eax
c002679e:	6a 16                	push   $0x16
c00267a0:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c00267a6:	50                   	push   %eax
c00267a7:	e8 db 2a 00 00       	call   c0029287 <debug_panic>

c00267ac <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c00267ac:	56                   	push   %esi
c00267ad:	53                   	push   %ebx
c00267ae:	83 ec 04             	sub    $0x4,%esp
c00267b1:	e8 cf 82 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00267b6:	81 c3 fe 46 01 00    	add    $0x146fe,%ebx
c00267bc:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c00267c0:	e8 18 b6 ff ff       	call   c0021ddd <intr_get_level>
c00267c5:	85 c0                	test   %eax,%eax
c00267c7:	75 1d                	jne    c00267e6 <intq_full+0x3a>

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
  return (pos + 1) % INTQ_BUFSIZE;
c00267c9:	8b 46 6c             	mov    0x6c(%esi),%eax
c00267cc:	83 c0 01             	add    $0x1,%eax
c00267cf:	99                   	cltd   
c00267d0:	c1 ea 1a             	shr    $0x1a,%edx
c00267d3:	01 d0                	add    %edx,%eax
c00267d5:	83 e0 3f             	and    $0x3f,%eax
c00267d8:	29 d0                	sub    %edx,%eax
  return next (q->head) == q->tail;
c00267da:	3b 46 70             	cmp    0x70(%esi),%eax
c00267dd:	0f 94 c0             	sete   %al
}
c00267e0:	83 c4 04             	add    $0x4,%esp
c00267e3:	5b                   	pop    %ebx
c00267e4:	5e                   	pop    %esi
c00267e5:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c00267e6:	83 ec 0c             	sub    $0xc,%esp
c00267e9:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c00267ef:	50                   	push   %eax
c00267f0:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00267f6:	50                   	push   %eax
c00267f7:	8d 83 60 41 ff ff    	lea    -0xbea0(%ebx),%eax
c00267fd:	50                   	push   %eax
c00267fe:	6a 1e                	push   $0x1e
c0026800:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026806:	50                   	push   %eax
c0026807:	e8 7b 2a 00 00       	call   c0029287 <debug_panic>

c002680c <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c002680c:	57                   	push   %edi
c002680d:	56                   	push   %esi
c002680e:	53                   	push   %ebx
c002680f:	e8 71 82 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026814:	81 c3 a0 46 01 00    	add    $0x146a0,%ebx
c002681a:	89 c6                	mov    %eax,%esi
c002681c:	89 d7                	mov    %edx,%edi
  ASSERT (!intr_context ());
c002681e:	e8 b0 b8 ff ff       	call   c00220d3 <intr_context>
c0026823:	84 c0                	test   %al,%al
c0026825:	75 3b                	jne    c0026862 <wait+0x56>
  ASSERT (intr_get_level () == INTR_OFF);
c0026827:	e8 b1 b5 ff ff       	call   c0021ddd <intr_get_level>
c002682c:	85 c0                	test   %eax,%eax
c002682e:	75 58                	jne    c0026888 <wait+0x7c>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0026830:	8d 46 28             	lea    0x28(%esi),%eax
c0026833:	39 c7                	cmp    %eax,%edi
c0026835:	74 77                	je     c00268ae <wait+0xa2>
c0026837:	8d 46 24             	lea    0x24(%esi),%eax
c002683a:	39 c7                	cmp    %eax,%edi
c002683c:	0f 85 82 00 00 00    	jne    c00268c4 <wait+0xb8>
c0026842:	83 ec 0c             	sub    $0xc,%esp
c0026845:	56                   	push   %esi
c0026846:	e8 61 ff ff ff       	call   c00267ac <intq_full>
c002684b:	83 c4 10             	add    $0x10,%esp
c002684e:	84 c0                	test   %al,%al
c0026850:	74 72                	je     c00268c4 <wait+0xb8>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0026852:	e8 fd a4 ff ff       	call   c0020d54 <thread_current>
c0026857:	89 07                	mov    %eax,(%edi)
  thread_block ();
c0026859:	e8 c3 a8 ff ff       	call   c0021121 <thread_block>
}
c002685e:	5b                   	pop    %ebx
c002685f:	5e                   	pop    %esi
c0026860:	5f                   	pop    %edi
c0026861:	c3                   	ret    
  ASSERT (!intr_context ());
c0026862:	83 ec 0c             	sub    $0xc,%esp
c0026865:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c002686b:	50                   	push   %eax
c002686c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026872:	50                   	push   %eax
c0026873:	8d 83 4c 41 ff ff    	lea    -0xbeb4(%ebx),%eax
c0026879:	50                   	push   %eax
c002687a:	6a 59                	push   $0x59
c002687c:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026882:	50                   	push   %eax
c0026883:	e8 ff 29 00 00       	call   c0029287 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0026888:	83 ec 0c             	sub    $0xc,%esp
c002688b:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0026891:	50                   	push   %eax
c0026892:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026898:	50                   	push   %eax
c0026899:	8d 83 4c 41 ff ff    	lea    -0xbeb4(%ebx),%eax
c002689f:	50                   	push   %eax
c00268a0:	6a 5a                	push   $0x5a
c00268a2:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c00268a8:	50                   	push   %eax
c00268a9:	e8 d9 29 00 00       	call   c0029287 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00268ae:	83 ec 0c             	sub    $0xc,%esp
c00268b1:	56                   	push   %esi
c00268b2:	e8 a3 fe ff ff       	call   c002675a <intq_empty>
c00268b7:	83 c4 10             	add    $0x10,%esp
c00268ba:	84 c0                	test   %al,%al
c00268bc:	0f 84 75 ff ff ff    	je     c0026837 <wait+0x2b>
c00268c2:	eb 8e                	jmp    c0026852 <wait+0x46>
c00268c4:	83 ec 0c             	sub    $0xc,%esp
c00268c7:	8d 83 fc 65 ff ff    	lea    -0x9a04(%ebx),%eax
c00268cd:	50                   	push   %eax
c00268ce:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00268d4:	50                   	push   %eax
c00268d5:	8d 83 4c 41 ff ff    	lea    -0xbeb4(%ebx),%eax
c00268db:	50                   	push   %eax
c00268dc:	6a 5c                	push   $0x5c
c00268de:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c00268e4:	50                   	push   %eax
c00268e5:	e8 9d 29 00 00       	call   c0029287 <debug_panic>

c00268ea <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c00268ea:	57                   	push   %edi
c00268eb:	56                   	push   %esi
c00268ec:	53                   	push   %ebx
c00268ed:	e8 93 81 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00268f2:	81 c3 c2 45 01 00    	add    $0x145c2,%ebx
c00268f8:	89 c7                	mov    %eax,%edi
c00268fa:	89 d6                	mov    %edx,%esi
  ASSERT (intr_get_level () == INTR_OFF);
c00268fc:	e8 dc b4 ff ff       	call   c0021ddd <intr_get_level>
c0026901:	85 c0                	test   %eax,%eax
c0026903:	75 3a                	jne    c002693f <signal+0x55>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026905:	8d 47 28             	lea    0x28(%edi),%eax
c0026908:	39 c6                	cmp    %eax,%esi
c002690a:	74 59                	je     c0026965 <signal+0x7b>
c002690c:	8d 47 24             	lea    0x24(%edi),%eax
c002690f:	39 c6                	cmp    %eax,%esi
c0026911:	75 64                	jne    c0026977 <signal+0x8d>
c0026913:	83 ec 0c             	sub    $0xc,%esp
c0026916:	57                   	push   %edi
c0026917:	e8 90 fe ff ff       	call   c00267ac <intq_full>
c002691c:	83 c4 10             	add    $0x10,%esp
c002691f:	84 c0                	test   %al,%al
c0026921:	75 54                	jne    c0026977 <signal+0x8d>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026923:	8b 06                	mov    (%esi),%eax
c0026925:	85 c0                	test   %eax,%eax
c0026927:	74 12                	je     c002693b <signal+0x51>
    {
      thread_unblock (*waiter);
c0026929:	83 ec 0c             	sub    $0xc,%esp
c002692c:	50                   	push   %eax
c002692d:	e8 75 a3 ff ff       	call   c0020ca7 <thread_unblock>
      *waiter = NULL;
c0026932:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0026938:	83 c4 10             	add    $0x10,%esp
    }
}
c002693b:	5b                   	pop    %ebx
c002693c:	5e                   	pop    %esi
c002693d:	5f                   	pop    %edi
c002693e:	c3                   	ret    
  ASSERT (intr_get_level () == INTR_OFF);
c002693f:	83 ec 0c             	sub    $0xc,%esp
c0026942:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0026948:	50                   	push   %eax
c0026949:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002694f:	50                   	push   %eax
c0026950:	8d 83 44 41 ff ff    	lea    -0xbebc(%ebx),%eax
c0026956:	50                   	push   %eax
c0026957:	6a 69                	push   $0x69
c0026959:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c002695f:	50                   	push   %eax
c0026960:	e8 22 29 00 00       	call   c0029287 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026965:	83 ec 0c             	sub    $0xc,%esp
c0026968:	57                   	push   %edi
c0026969:	e8 ec fd ff ff       	call   c002675a <intq_empty>
c002696e:	83 c4 10             	add    $0x10,%esp
c0026971:	84 c0                	test   %al,%al
c0026973:	74 ae                	je     c0026923 <signal+0x39>
c0026975:	eb 95                	jmp    c002690c <signal+0x22>
c0026977:	83 ec 0c             	sub    $0xc,%esp
c002697a:	8d 83 58 66 ff ff    	lea    -0x99a8(%ebx),%eax
c0026980:	50                   	push   %eax
c0026981:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026987:	50                   	push   %eax
c0026988:	8d 83 44 41 ff ff    	lea    -0xbebc(%ebx),%eax
c002698e:	50                   	push   %eax
c002698f:	6a 6b                	push   $0x6b
c0026991:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026997:	50                   	push   %eax
c0026998:	e8 ea 28 00 00       	call   c0029287 <debug_panic>

c002699d <intq_getc>:
{
c002699d:	57                   	push   %edi
c002699e:	56                   	push   %esi
c002699f:	53                   	push   %ebx
c00269a0:	e8 e0 80 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00269a5:	81 c3 0f 45 01 00    	add    $0x1450f,%ebx
c00269ab:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (intr_get_level () == INTR_OFF);
c00269af:	e8 29 b4 ff ff       	call   c0021ddd <intr_get_level>
c00269b4:	85 c0                	test   %eax,%eax
c00269b6:	75 3b                	jne    c00269f3 <intq_getc+0x56>
      wait (q, &q->not_empty);
c00269b8:	8d 7e 28             	lea    0x28(%esi),%edi
  while (intq_empty (q)) 
c00269bb:	83 ec 0c             	sub    $0xc,%esp
c00269be:	56                   	push   %esi
c00269bf:	e8 96 fd ff ff       	call   c002675a <intq_empty>
c00269c4:	83 c4 10             	add    $0x10,%esp
c00269c7:	84 c0                	test   %al,%al
c00269c9:	74 74                	je     c0026a3f <intq_getc+0xa2>
      ASSERT (!intr_context ());
c00269cb:	e8 03 b7 ff ff       	call   c00220d3 <intr_context>
c00269d0:	84 c0                	test   %al,%al
c00269d2:	75 45                	jne    c0026a19 <intq_getc+0x7c>
      lock_acquire (&q->lock);
c00269d4:	83 ec 0c             	sub    $0xc,%esp
c00269d7:	56                   	push   %esi
c00269d8:	e8 49 c9 ff ff       	call   c0023326 <lock_acquire>
      wait (q, &q->not_empty);
c00269dd:	89 fa                	mov    %edi,%edx
c00269df:	89 f0                	mov    %esi,%eax
c00269e1:	e8 26 fe ff ff       	call   c002680c <wait>
      lock_release (&q->lock);
c00269e6:	89 34 24             	mov    %esi,(%esp)
c00269e9:	e8 30 cb ff ff       	call   c002351e <lock_release>
c00269ee:	83 c4 10             	add    $0x10,%esp
c00269f1:	eb c8                	jmp    c00269bb <intq_getc+0x1e>
  ASSERT (intr_get_level () == INTR_OFF);
c00269f3:	83 ec 0c             	sub    $0xc,%esp
c00269f6:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c00269fc:	50                   	push   %eax
c00269fd:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026a03:	50                   	push   %eax
c0026a04:	8d 83 54 41 ff ff    	lea    -0xbeac(%ebx),%eax
c0026a0a:	50                   	push   %eax
c0026a0b:	6a 2a                	push   $0x2a
c0026a0d:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026a13:	50                   	push   %eax
c0026a14:	e8 6e 28 00 00       	call   c0029287 <debug_panic>
      ASSERT (!intr_context ());
c0026a19:	83 ec 0c             	sub    $0xc,%esp
c0026a1c:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0026a22:	50                   	push   %eax
c0026a23:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026a29:	50                   	push   %eax
c0026a2a:	8d 83 54 41 ff ff    	lea    -0xbeac(%ebx),%eax
c0026a30:	50                   	push   %eax
c0026a31:	6a 2d                	push   $0x2d
c0026a33:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026a39:	50                   	push   %eax
c0026a3a:	e8 48 28 00 00       	call   c0029287 <debug_panic>
  byte = q->buf[q->tail];
c0026a3f:	8b 46 70             	mov    0x70(%esi),%eax
c0026a42:	0f b6 5c 06 2c       	movzbl 0x2c(%esi,%eax,1),%ebx
  return (pos + 1) % INTQ_BUFSIZE;
c0026a47:	83 c0 01             	add    $0x1,%eax
c0026a4a:	99                   	cltd   
c0026a4b:	c1 ea 1a             	shr    $0x1a,%edx
c0026a4e:	01 d0                	add    %edx,%eax
c0026a50:	83 e0 3f             	and    $0x3f,%eax
c0026a53:	29 d0                	sub    %edx,%eax
  q->tail = next (q->tail);
c0026a55:	89 46 70             	mov    %eax,0x70(%esi)
  signal (q, &q->not_full);
c0026a58:	8d 56 24             	lea    0x24(%esi),%edx
c0026a5b:	89 f0                	mov    %esi,%eax
c0026a5d:	e8 88 fe ff ff       	call   c00268ea <signal>
}
c0026a62:	89 d8                	mov    %ebx,%eax
c0026a64:	5b                   	pop    %ebx
c0026a65:	5e                   	pop    %esi
c0026a66:	5f                   	pop    %edi
c0026a67:	c3                   	ret    

c0026a68 <intq_putc>:
{
c0026a68:	55                   	push   %ebp
c0026a69:	57                   	push   %edi
c0026a6a:	56                   	push   %esi
c0026a6b:	53                   	push   %ebx
c0026a6c:	83 ec 0c             	sub    $0xc,%esp
c0026a6f:	e8 11 80 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026a74:	81 c3 40 44 01 00    	add    $0x14440,%ebx
c0026a7a:	8b 74 24 20          	mov    0x20(%esp),%esi
c0026a7e:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  ASSERT (intr_get_level () == INTR_OFF);
c0026a82:	e8 56 b3 ff ff       	call   c0021ddd <intr_get_level>
c0026a87:	85 c0                	test   %eax,%eax
c0026a89:	75 3b                	jne    c0026ac6 <intq_putc+0x5e>
      wait (q, &q->not_full);
c0026a8b:	8d 7e 24             	lea    0x24(%esi),%edi
  while (intq_full (q))
c0026a8e:	83 ec 0c             	sub    $0xc,%esp
c0026a91:	56                   	push   %esi
c0026a92:	e8 15 fd ff ff       	call   c00267ac <intq_full>
c0026a97:	83 c4 10             	add    $0x10,%esp
c0026a9a:	84 c0                	test   %al,%al
c0026a9c:	74 74                	je     c0026b12 <intq_putc+0xaa>
      ASSERT (!intr_context ());
c0026a9e:	e8 30 b6 ff ff       	call   c00220d3 <intr_context>
c0026aa3:	84 c0                	test   %al,%al
c0026aa5:	75 45                	jne    c0026aec <intq_putc+0x84>
      lock_acquire (&q->lock);
c0026aa7:	83 ec 0c             	sub    $0xc,%esp
c0026aaa:	56                   	push   %esi
c0026aab:	e8 76 c8 ff ff       	call   c0023326 <lock_acquire>
      wait (q, &q->not_full);
c0026ab0:	89 fa                	mov    %edi,%edx
c0026ab2:	89 f0                	mov    %esi,%eax
c0026ab4:	e8 53 fd ff ff       	call   c002680c <wait>
      lock_release (&q->lock);
c0026ab9:	89 34 24             	mov    %esi,(%esp)
c0026abc:	e8 5d ca ff ff       	call   c002351e <lock_release>
c0026ac1:	83 c4 10             	add    $0x10,%esp
c0026ac4:	eb c8                	jmp    c0026a8e <intq_putc+0x26>
  ASSERT (intr_get_level () == INTR_OFF);
c0026ac6:	83 ec 0c             	sub    $0xc,%esp
c0026ac9:	8d 83 0c 54 ff ff    	lea    -0xabf4(%ebx),%eax
c0026acf:	50                   	push   %eax
c0026ad0:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026ad6:	50                   	push   %eax
c0026ad7:	8d 83 38 41 ff ff    	lea    -0xbec8(%ebx),%eax
c0026add:	50                   	push   %eax
c0026ade:	6a 3f                	push   $0x3f
c0026ae0:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026ae6:	50                   	push   %eax
c0026ae7:	e8 9b 27 00 00       	call   c0029287 <debug_panic>
      ASSERT (!intr_context ());
c0026aec:	83 ec 0c             	sub    $0xc,%esp
c0026aef:	8d 83 a2 54 ff ff    	lea    -0xab5e(%ebx),%eax
c0026af5:	50                   	push   %eax
c0026af6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0026afc:	50                   	push   %eax
c0026afd:	8d 83 38 41 ff ff    	lea    -0xbec8(%ebx),%eax
c0026b03:	50                   	push   %eax
c0026b04:	6a 42                	push   $0x42
c0026b06:	8d 83 e7 65 ff ff    	lea    -0x9a19(%ebx),%eax
c0026b0c:	50                   	push   %eax
c0026b0d:	e8 75 27 00 00       	call   c0029287 <debug_panic>
  q->buf[q->head] = byte;
c0026b12:	8b 46 6c             	mov    0x6c(%esi),%eax
c0026b15:	89 e9                	mov    %ebp,%ecx
c0026b17:	88 4c 06 2c          	mov    %cl,0x2c(%esi,%eax,1)
  return (pos + 1) % INTQ_BUFSIZE;
c0026b1b:	83 c0 01             	add    $0x1,%eax
c0026b1e:	99                   	cltd   
c0026b1f:	c1 ea 1a             	shr    $0x1a,%edx
c0026b22:	01 d0                	add    %edx,%eax
c0026b24:	83 e0 3f             	and    $0x3f,%eax
c0026b27:	29 d0                	sub    %edx,%eax
  q->head = next (q->head);
c0026b29:	89 46 6c             	mov    %eax,0x6c(%esi)
  signal (q, &q->not_empty);
c0026b2c:	8d 56 28             	lea    0x28(%esi),%edx
c0026b2f:	89 f0                	mov    %esi,%eax
c0026b31:	e8 b4 fd ff ff       	call   c00268ea <signal>
}
c0026b36:	83 c4 0c             	add    $0xc,%esp
c0026b39:	5b                   	pop    %ebx
c0026b3a:	5e                   	pop    %esi
c0026b3b:	5f                   	pop    %edi
c0026b3c:	5d                   	pop    %ebp
c0026b3d:	c3                   	ret    

c0026b3e <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026b3e:	55                   	push   %ebp
c0026b3f:	57                   	push   %edi
c0026b40:	56                   	push   %esi
c0026b41:	53                   	push   %ebx
c0026b42:	83 ec 0c             	sub    $0xc,%esp
c0026b45:	e8 3f 7f 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0026b4a:	05 6a 43 01 00       	add    $0x1436a,%eax
c0026b4f:	89 44 24 08          	mov    %eax,0x8(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b53:	bf 00 00 00 00       	mov    $0x0,%edi
c0026b58:	bd 02 00 00 00       	mov    $0x2,%ebp
c0026b5d:	89 f8                	mov    %edi,%eax
c0026b5f:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b61:	e4 71                	in     $0x71,%al
c0026b63:	89 c2                	mov    %eax,%edx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b65:	89 e8                	mov    %ebp,%eax
c0026b67:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b69:	e4 71                	in     $0x71,%al
c0026b6b:	88 04 24             	mov    %al,(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b6e:	b8 04 00 00 00       	mov    $0x4,%eax
c0026b73:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b75:	e4 71                	in     $0x71,%al
c0026b77:	88 44 24 07          	mov    %al,0x7(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b7b:	b8 07 00 00 00       	mov    $0x7,%eax
c0026b80:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b82:	e4 71                	in     $0x71,%al
c0026b84:	88 44 24 06          	mov    %al,0x6(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b88:	b8 08 00 00 00       	mov    $0x8,%eax
c0026b8d:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b8f:	e4 71                	in     $0x71,%al
c0026b91:	88 44 24 05          	mov    %al,0x5(%esp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b95:	b8 09 00 00 00       	mov    $0x9,%eax
c0026b9a:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b9c:	e4 71                	in     $0x71,%al
c0026b9e:	89 c3                	mov    %eax,%ebx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ba0:	89 f8                	mov    %edi,%eax
c0026ba2:	e6 70                	out    %al,$0x70
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026ba4:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c0026ba6:	89 c1                	mov    %eax,%ecx
c0026ba8:	c0 e9 04             	shr    $0x4,%cl
c0026bab:	0f b6 c9             	movzbl %cl,%ecx
c0026bae:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0026bb1:	83 e0 0f             	and    $0xf,%eax
c0026bb4:	8d 34 48             	lea    (%eax,%ecx,2),%esi
c0026bb7:	89 d1                	mov    %edx,%ecx
c0026bb9:	c0 e9 04             	shr    $0x4,%cl
c0026bbc:	0f b6 c9             	movzbl %cl,%ecx
c0026bbf:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
c0026bc2:	83 e2 0f             	and    $0xf,%edx
c0026bc5:	8d 04 42             	lea    (%edx,%eax,2),%eax
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0026bc8:	39 c6                	cmp    %eax,%esi
c0026bca:	75 91                	jne    c0026b5d <rtc_get_time+0x1f>
  return (x & 0x0f) + ((x >> 4) * 10);
c0026bcc:	89 d8                	mov    %ebx,%eax
c0026bce:	c0 e8 04             	shr    $0x4,%al
c0026bd1:	0f b6 c0             	movzbl %al,%eax
c0026bd4:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0026bd7:	83 e3 0f             	and    $0xf,%ebx
c0026bda:	8d 04 43             	lea    (%ebx,%eax,2),%eax
    year += 100;
c0026bdd:	8d 50 64             	lea    0x64(%eax),%edx
c0026be0:	83 f8 46             	cmp    $0x46,%eax
c0026be3:	0f 4c c2             	cmovl  %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c0026be6:	0f b6 5c 24 05       	movzbl 0x5(%esp),%ebx
c0026beb:	89 da                	mov    %ebx,%edx
c0026bed:	c0 ea 04             	shr    $0x4,%dl
c0026bf0:	0f b6 d2             	movzbl %dl,%edx
c0026bf3:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0026bf6:	89 d9                	mov    %ebx,%ecx
c0026bf8:	83 e1 0f             	and    $0xf,%ecx
c0026bfb:	8d 2c 51             	lea    (%ecx,%edx,2),%ebp
  year -= 70;
c0026bfe:	8d 78 ba             	lea    -0x46(%eax),%edi
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026c01:	8d 50 bc             	lea    -0x44(%eax),%edx
c0026c04:	83 e8 47             	sub    $0x47,%eax
c0026c07:	0f 48 c2             	cmovs  %edx,%eax
c0026c0a:	c1 f8 02             	sar    $0x2,%eax
c0026c0d:	69 d7 6d 01 00 00    	imul   $0x16d,%edi,%edx
c0026c13:	01 d0                	add    %edx,%eax
c0026c15:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
  for (i = 1; i <= mon; i++)
c0026c1b:	85 ed                	test   %ebp,%ebp
c0026c1d:	7e 1c                	jle    c0026c3b <rtc_get_time+0xfd>
c0026c1f:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0026c23:	8d 93 8c 41 ff ff    	lea    -0xbe74(%ebx),%edx
c0026c29:	8d 1c aa             	lea    (%edx,%ebp,4),%ebx
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026c2c:	69 0a 80 51 01 00    	imul   $0x15180,(%edx),%ecx
c0026c32:	01 c8                	add    %ecx,%eax
c0026c34:	83 c2 04             	add    $0x4,%edx
  for (i = 1; i <= mon; i++)
c0026c37:	39 da                	cmp    %ebx,%edx
c0026c39:	75 f1                	jne    c0026c2c <rtc_get_time+0xee>
  if (mon > 2 && year % 4 == 0)
c0026c3b:	83 fd 02             	cmp    $0x2,%ebp
c0026c3e:	7e 0e                	jle    c0026c4e <rtc_get_time+0x110>
c0026c40:	83 e7 03             	and    $0x3,%edi
    time += 24 * 60 * 60;
c0026c43:	8d 90 80 51 01 00    	lea    0x15180(%eax),%edx
c0026c49:	85 ff                	test   %edi,%edi
c0026c4b:	0f 44 c2             	cmove  %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c0026c4e:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
c0026c53:	89 da                	mov    %ebx,%edx
c0026c55:	c0 ea 04             	shr    $0x4,%dl
c0026c58:	0f b6 d2             	movzbl %dl,%edx
c0026c5b:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026c5e:	89 da                	mov    %ebx,%edx
c0026c60:	83 e2 0f             	and    $0xf,%edx
c0026c63:	8d 0c 4a             	lea    (%edx,%ecx,2),%ecx
  time += hour * 60 * 60;
c0026c66:	69 c9 10 0e 00 00    	imul   $0xe10,%ecx,%ecx
  return (x & 0x0f) + ((x >> 4) * 10);
c0026c6c:	0f b6 14 24          	movzbl (%esp),%edx
c0026c70:	c0 ea 04             	shr    $0x4,%dl
c0026c73:	0f b6 d2             	movzbl %dl,%edx
c0026c76:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
c0026c79:	8b 14 24             	mov    (%esp),%edx
c0026c7c:	83 e2 0f             	and    $0xf,%edx
c0026c7f:	8d 14 5a             	lea    (%edx,%ebx,2),%edx
  time += min * 60;
c0026c82:	6b d2 3c             	imul   $0x3c,%edx,%edx
  time += sec;
c0026c85:	01 d1                	add    %edx,%ecx
c0026c87:	01 ce                	add    %ecx,%esi
  return (x & 0x0f) + ((x >> 4) * 10);
c0026c89:	0f b6 5c 24 06       	movzbl 0x6(%esp),%ebx
c0026c8e:	89 da                	mov    %ebx,%edx
c0026c90:	c0 ea 04             	shr    $0x4,%dl
c0026c93:	0f b6 d2             	movzbl %dl,%edx
c0026c96:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0026c99:	89 da                	mov    %ebx,%edx
c0026c9b:	83 e2 0f             	and    $0xf,%edx
  time += (mday - 1) * 24 * 60 * 60;
c0026c9e:	8d 54 4a ff          	lea    -0x1(%edx,%ecx,2),%edx
c0026ca2:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
  time += sec;
c0026ca8:	01 d6                	add    %edx,%esi
c0026caa:	01 f0                	add    %esi,%eax
}
c0026cac:	83 c4 0c             	add    $0xc,%esp
c0026caf:	5b                   	pop    %ebx
c0026cb0:	5e                   	pop    %esi
c0026cb1:	5f                   	pop    %edi
c0026cb2:	5d                   	pop    %ebp
c0026cb3:	c3                   	ret    

c0026cb4 <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0026cb4:	e8 d0 7d 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0026cb9:	05 fb 41 01 00       	add    $0x141fb,%eax
  how = type;
c0026cbe:	8b 54 24 04          	mov    0x4(%esp),%edx
c0026cc2:	89 90 40 21 00 00    	mov    %edx,0x2140(%eax)
}
c0026cc8:	c3                   	ret    

c0026cc9 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026cc9:	57                   	push   %edi
c0026cca:	56                   	push   %esi
c0026ccb:	53                   	push   %ebx
c0026ccc:	e8 b4 7d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026cd1:	81 c3 e3 41 01 00    	add    $0x141e3,%ebx
  printf ("Rebooting...\n");
c0026cd7:	83 ec 0c             	sub    $0xc,%esp
c0026cda:	8d 83 b3 66 ff ff    	lea    -0x994d(%ebx),%eax
c0026ce0:	50                   	push   %eax
c0026ce1:	e8 7a 45 00 00       	call   c002b260 <puts>
c0026ce6:	83 c4 10             	add    $0x10,%esp
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ce9:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
c0026cee:	eb 1f                	jmp    c0026d0f <shutdown_reboot+0x46>
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
        }

      timer_udelay (50);
c0026cf0:	83 ec 08             	sub    $0x8,%esp
c0026cf3:	6a 00                	push   $0x0
c0026cf5:	6a 32                	push   $0x32
c0026cf7:	e8 22 db ff ff       	call   c002481e <timer_udelay>
c0026cfc:	89 f8                	mov    %edi,%eax
c0026cfe:	e6 64                	out    %al,$0x64

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
      timer_udelay (50);
c0026d00:	83 c4 08             	add    $0x8,%esp
c0026d03:	6a 00                	push   $0x0
c0026d05:	6a 32                	push   $0x32
c0026d07:	e8 12 db ff ff       	call   c002481e <timer_udelay>
    {
c0026d0c:	83 c4 10             	add    $0x10,%esp
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026d0f:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026d11:	a8 02                	test   $0x2,%al
c0026d13:	74 db                	je     c0026cf0 <shutdown_reboot+0x27>
          timer_udelay (2);
c0026d15:	83 ec 08             	sub    $0x8,%esp
c0026d18:	6a 00                	push   $0x0
c0026d1a:	6a 02                	push   $0x2
c0026d1c:	e8 fd da ff ff       	call   c002481e <timer_udelay>
c0026d21:	83 c4 10             	add    $0x10,%esp
c0026d24:	be ff ff 00 00       	mov    $0xffff,%esi
c0026d29:	e4 64                	in     $0x64,%al
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026d2b:	a8 02                	test   $0x2,%al
c0026d2d:	74 c1                	je     c0026cf0 <shutdown_reboot+0x27>
          timer_udelay (2);
c0026d2f:	83 ec 08             	sub    $0x8,%esp
c0026d32:	6a 00                	push   $0x0
c0026d34:	6a 02                	push   $0x2
c0026d36:	e8 e3 da ff ff       	call   c002481e <timer_udelay>
      for (i = 0; i < 0x10000; i++)
c0026d3b:	83 c4 10             	add    $0x10,%esp
c0026d3e:	83 ee 01             	sub    $0x1,%esi
c0026d41:	75 e6                	jne    c0026d29 <shutdown_reboot+0x60>
c0026d43:	eb ab                	jmp    c0026cf0 <shutdown_reboot+0x27>

c0026d45 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026d45:	53                   	push   %ebx
c0026d46:	83 ec 18             	sub    $0x18,%esp
c0026d49:	e8 37 7d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026d4e:	81 c3 66 41 01 00    	add    $0x14166,%ebx
  const char s[] = "Shutdown";
c0026d54:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0026d5b:	74 
c0026d5c:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c0026d63:	6e 
c0026d64:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
  const char *p;

#ifdef FILESYS
  filesys_done ();
c0026d69:	e8 e8 62 00 00       	call   c002d056 <filesys_done>

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
  timer_print_stats ();
c0026d6e:	e8 dd da ff ff       	call   c0024850 <timer_print_stats>
  thread_print_stats ();
c0026d73:	e8 eb 9e ff ff       	call   c0020c63 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
c0026d78:	e8 62 e6 ff ff       	call   c00253df <block_print_stats>
#endif
  console_print_stats ();
c0026d7d:	e8 6f 44 00 00       	call   c002b1f1 <console_print_stats>
  kbd_print_stats ();
c0026d82:	e8 44 dd ff ff       	call   c0024acb <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
c0026d87:	e8 83 58 00 00       	call   c002c60f <exception_print_stats>
  printf ("Powering off...\n");
c0026d8c:	83 ec 0c             	sub    $0xc,%esp
c0026d8f:	8d 83 c0 66 ff ff    	lea    -0x9940(%ebx),%eax
c0026d95:	50                   	push   %eax
c0026d96:	e8 c5 44 00 00       	call   c002b260 <puts>
  serial_flush ();
c0026d9b:	e8 d5 e2 ff ff       	call   c0025075 <serial_flush>
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026da0:	b8 00 20 00 00       	mov    $0x2000,%eax
c0026da5:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c0026daa:	66 ef                	out    %ax,(%dx)
  for (p = s; *p != '\0'; p++)
c0026dac:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c0026db1:	83 c4 10             	add    $0x10,%esp
c0026db4:	84 c0                	test   %al,%al
c0026db6:	74 14                	je     c0026dcc <shutdown_power_off+0x87>
c0026db8:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026dbc:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c0026dc1:	ee                   	out    %al,(%dx)
c0026dc2:	83 c1 01             	add    $0x1,%ecx
c0026dc5:	0f b6 01             	movzbl (%ecx),%eax
c0026dc8:	84 c0                	test   %al,%al
c0026dca:	75 f5                	jne    c0026dc1 <shutdown_power_off+0x7c>
c0026dcc:	b8 31 00 00 00       	mov    $0x31,%eax
c0026dd1:	ba 01 05 00 00       	mov    $0x501,%edx
c0026dd6:	ee                   	out    %al,(%dx)
  asm volatile ("cli; hlt" : : : "memory");
c0026dd7:	fa                   	cli    
c0026dd8:	f4                   	hlt    
  printf ("still running...\n");
c0026dd9:	83 ec 0c             	sub    $0xc,%esp
c0026ddc:	8d 83 d0 66 ff ff    	lea    -0x9930(%ebx),%eax
c0026de2:	50                   	push   %eax
c0026de3:	e8 78 44 00 00       	call   c002b260 <puts>
c0026de8:	83 c4 10             	add    $0x10,%esp
c0026deb:	eb fe                	jmp    c0026deb <shutdown_power_off+0xa6>

c0026ded <shutdown>:
{
c0026ded:	83 ec 0c             	sub    $0xc,%esp
c0026df0:	e8 94 7c 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0026df5:	05 bf 40 01 00       	add    $0x140bf,%eax
  switch (how)
c0026dfa:	8b 80 40 21 00 00    	mov    0x2140(%eax),%eax
c0026e00:	83 f8 01             	cmp    $0x1,%eax
c0026e03:	74 09                	je     c0026e0e <shutdown+0x21>
c0026e05:	83 f8 02             	cmp    $0x2,%eax
c0026e08:	74 09                	je     c0026e13 <shutdown+0x26>
}
c0026e0a:	83 c4 0c             	add    $0xc,%esp
c0026e0d:	c3                   	ret    
      shutdown_power_off ();
c0026e0e:	e8 32 ff ff ff       	call   c0026d45 <shutdown_power_off>
      shutdown_reboot ();
c0026e13:	e8 b1 fe ff ff       	call   c0026cc9 <shutdown_reboot>

c0026e18 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026e18:	53                   	push   %ebx
c0026e19:	83 ec 08             	sub    $0x8,%esp
c0026e1c:	e8 64 7c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026e21:	81 c3 93 40 01 00    	add    $0x14093,%ebx
  enum intr_level old_level = intr_disable ();
c0026e27:	e8 03 b0 ff ff       	call   c0021e2f <intr_disable>
c0026e2c:	89 c2                	mov    %eax,%edx
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026e2e:	e4 61                	in     $0x61,%al
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026e30:	83 e0 fc             	and    $0xfffffffc,%eax
c0026e33:	e6 61                	out    %al,$0x61
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level (old_level);
c0026e35:	83 ec 0c             	sub    $0xc,%esp
c0026e38:	52                   	push   %edx
c0026e39:	e8 f8 af ff ff       	call   c0021e36 <intr_set_level>
}
c0026e3e:	83 c4 18             	add    $0x18,%esp
c0026e41:	5b                   	pop    %ebx
c0026e42:	c3                   	ret    

c0026e43 <speaker_on>:
{
c0026e43:	57                   	push   %edi
c0026e44:	56                   	push   %esi
c0026e45:	53                   	push   %ebx
c0026e46:	e8 3a 7c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026e4b:	81 c3 69 40 01 00    	add    $0x14069,%ebx
c0026e51:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (frequency >= 20 && frequency <= 20000)
c0026e55:	8d 46 ec             	lea    -0x14(%esi),%eax
c0026e58:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0026e5d:	76 09                	jbe    c0026e68 <speaker_on+0x25>
      speaker_off ();
c0026e5f:	e8 b4 ff ff ff       	call   c0026e18 <speaker_off>
}
c0026e64:	5b                   	pop    %ebx
c0026e65:	5e                   	pop    %esi
c0026e66:	5f                   	pop    %edi
c0026e67:	c3                   	ret    
      enum intr_level old_level = intr_disable ();
c0026e68:	e8 c2 af ff ff       	call   c0021e2f <intr_disable>
c0026e6d:	89 c7                	mov    %eax,%edi
      pit_configure_channel (2, 3, frequency);
c0026e6f:	83 ec 04             	sub    $0x4,%esp
c0026e72:	56                   	push   %esi
c0026e73:	6a 03                	push   $0x3
c0026e75:	6a 02                	push   $0x2
c0026e77:	e8 e7 d3 ff ff       	call   c0024263 <pit_configure_channel>
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026e7c:	e4 61                	in     $0x61,%al
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026e7e:	83 c8 03             	or     $0x3,%eax
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026e81:	e6 61                	out    %al,$0x61
      intr_set_level (old_level);
c0026e83:	89 3c 24             	mov    %edi,(%esp)
c0026e86:	e8 ab af ff ff       	call   c0021e36 <intr_set_level>
c0026e8b:	83 c4 10             	add    $0x10,%esp
c0026e8e:	eb d4                	jmp    c0026e64 <speaker_on+0x21>

c0026e90 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026e90:	53                   	push   %ebx
c0026e91:	83 ec 08             	sub    $0x8,%esp
c0026e94:	e8 ec 7b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026e99:	81 c3 1b 40 01 00    	add    $0x1401b,%ebx

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026e9f:	e8 39 af ff ff       	call   c0021ddd <intr_get_level>
c0026ea4:	83 f8 01             	cmp    $0x1,%eax
c0026ea7:	74 05                	je     c0026eae <speaker_beep+0x1e>
    {
      speaker_on (440);
      timer_msleep (250);
      speaker_off ();
    }
}
c0026ea9:	83 c4 08             	add    $0x8,%esp
c0026eac:	5b                   	pop    %ebx
c0026ead:	c3                   	ret    
      speaker_on (440);
c0026eae:	83 ec 0c             	sub    $0xc,%esp
c0026eb1:	68 b8 01 00 00       	push   $0x1b8
c0026eb6:	e8 88 ff ff ff       	call   c0026e43 <speaker_on>
      timer_msleep (250);
c0026ebb:	83 c4 08             	add    $0x8,%esp
c0026ebe:	6a 00                	push   $0x0
c0026ec0:	68 fa 00 00 00       	push   $0xfa
c0026ec5:	e8 f0 d8 ff ff       	call   c00247ba <timer_msleep>
      speaker_off ();
c0026eca:	e8 49 ff ff ff       	call   c0026e18 <speaker_off>
c0026ecf:	83 c4 10             	add    $0x10,%esp
}
c0026ed2:	eb d5                	jmp    c0026ea9 <speaker_beep+0x19>

c0026ed4 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026ed4:	55                   	push   %ebp
c0026ed5:	89 e5                	mov    %esp,%ebp
c0026ed7:	57                   	push   %edi
c0026ed8:	56                   	push   %esi
c0026ed9:	53                   	push   %ebx
c0026eda:	83 ec 14             	sub    $0x14,%esp
c0026edd:	e8 a3 7b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0026ee2:	81 c3 d2 3f 01 00    	add    $0x13fd2,%ebx
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026ee8:	ff 75 04             	pushl  0x4(%ebp)
c0026eeb:	8d 83 e1 66 ff ff    	lea    -0x991f(%ebx),%eax
c0026ef1:	50                   	push   %eax
c0026ef2:	e8 f9 05 00 00       	call   c00274f0 <printf>
  for (frame = __builtin_frame_address (1);
c0026ef7:	8b 75 00             	mov    0x0(%ebp),%esi
c0026efa:	83 c4 10             	add    $0x10,%esp
c0026efd:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026f03:	76 29                	jbe    c0026f2e <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026f05:	83 3e 00             	cmpl   $0x0,(%esi)
c0026f08:	74 24                	je     c0026f2e <debug_backtrace+0x5a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026f0a:	8d bb ec 66 ff ff    	lea    -0x9914(%ebx),%edi
c0026f10:	83 ec 08             	sub    $0x8,%esp
c0026f13:	ff 76 04             	pushl  0x4(%esi)
c0026f16:	57                   	push   %edi
c0026f17:	e8 d4 05 00 00       	call   c00274f0 <printf>
       frame = frame[0]) 
c0026f1c:	8b 36                	mov    (%esi),%esi
  for (frame = __builtin_frame_address (1);
c0026f1e:	83 c4 10             	add    $0x10,%esp
c0026f21:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0026f27:	76 05                	jbe    c0026f2e <debug_backtrace+0x5a>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026f29:	83 3e 00             	cmpl   $0x0,(%esi)
c0026f2c:	75 e2                	jne    c0026f10 <debug_backtrace+0x3c>
  printf (".\n");
c0026f2e:	83 ec 0c             	sub    $0xc,%esp
c0026f31:	8d 83 83 62 ff ff    	lea    -0x9d7d(%ebx),%eax
c0026f37:	50                   	push   %eax
c0026f38:	e8 23 43 00 00       	call   c002b260 <puts>

  if (!explained) 
c0026f3d:	83 c4 10             	add    $0x10,%esp
c0026f40:	80 bb 44 21 00 00 00 	cmpb   $0x0,0x2144(%ebx)
c0026f47:	74 08                	je     c0026f51 <debug_backtrace+0x7d>
      explained = true;
      printf ("The `backtrace' program can make call stacks useful.\n"
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026f49:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0026f4c:	5b                   	pop    %ebx
c0026f4d:	5e                   	pop    %esi
c0026f4e:	5f                   	pop    %edi
c0026f4f:	5d                   	pop    %ebp
c0026f50:	c3                   	ret    
      explained = true;
c0026f51:	c6 83 44 21 00 00 01 	movb   $0x1,0x2144(%ebx)
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026f58:	83 ec 0c             	sub    $0xc,%esp
c0026f5b:	8d 83 f0 66 ff ff    	lea    -0x9910(%ebx),%eax
c0026f61:	50                   	push   %eax
c0026f62:	e8 f9 42 00 00       	call   c002b260 <puts>
c0026f67:	83 c4 10             	add    $0x10,%esp
}
c0026f6a:	eb dd                	jmp    c0026f49 <debug_backtrace+0x75>

c0026f6c <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026f6c:	55                   	push   %ebp
c0026f6d:	57                   	push   %edi
c0026f6e:	56                   	push   %esi
c0026f6f:	53                   	push   %ebx
c0026f70:	e8 20 7b 00 00       	call   c002ea95 <__x86.get_pc_thunk.cx>
c0026f75:	81 c1 3f 3f 01 00    	add    $0x13f3f,%ecx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026f7b:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0026f80:	88 84 08 6c 21 00 00 	mov    %al,0x216c(%eax,%ecx,1)
  for (i = 0; i < 256; i++) 
c0026f87:	83 c0 01             	add    $0x1,%eax
c0026f8a:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026f8f:	75 ef                	jne    c0026f80 <random_init+0x14>
  for (i = j = 0; i < 256; i++) 
c0026f91:	bd 00 00 00 00       	mov    $0x0,%ebp
c0026f96:	b8 00 00 00 00       	mov    $0x0,%eax
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
c0026f9b:	8d b9 6c 21 00 00    	lea    0x216c(%ecx),%edi
      j += s[i] + seedp[i % sizeof seed];
c0026fa1:	89 c2                	mov    %eax,%edx
c0026fa3:	83 e2 03             	and    $0x3,%edx
c0026fa6:	0f b6 b4 08 6c 21 00 	movzbl 0x216c(%eax,%ecx,1),%esi
c0026fad:	00 
c0026fae:	89 f3                	mov    %esi,%ebx
c0026fb0:	02 5c 14 14          	add    0x14(%esp,%edx,1),%bl
c0026fb4:	89 da                	mov    %ebx,%edx
c0026fb6:	01 d5                	add    %edx,%ebp
      swap_byte (s + i, s + j);
c0026fb8:	89 eb                	mov    %ebp,%ebx
c0026fba:	0f b6 d3             	movzbl %bl,%edx
c0026fbd:	01 fa                	add    %edi,%edx
  *a = *b;
c0026fbf:	0f b6 1a             	movzbl (%edx),%ebx
c0026fc2:	88 9c 08 6c 21 00 00 	mov    %bl,0x216c(%eax,%ecx,1)
  *b = t;
c0026fc9:	89 f3                	mov    %esi,%ebx
c0026fcb:	88 1a                	mov    %bl,(%edx)
  for (i = j = 0; i < 256; i++) 
c0026fcd:	83 c0 01             	add    $0x1,%eax
c0026fd0:	3d 00 01 00 00       	cmp    $0x100,%eax
c0026fd5:	75 ca                	jne    c0026fa1 <random_init+0x35>
    }

  s_i = s_j = 0;
c0026fd7:	c6 81 4d 21 00 00 00 	movb   $0x0,0x214d(%ecx)
c0026fde:	c6 81 4e 21 00 00 00 	movb   $0x0,0x214e(%ecx)
  inited = true;
c0026fe5:	c6 81 4c 21 00 00 01 	movb   $0x1,0x214c(%ecx)
}
c0026fec:	5b                   	pop    %ebx
c0026fed:	5e                   	pop    %esi
c0026fee:	5f                   	pop    %edi
c0026fef:	5d                   	pop    %ebp
c0026ff0:	c3                   	ret    

c0026ff1 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026ff1:	55                   	push   %ebp
c0026ff2:	57                   	push   %edi
c0026ff3:	56                   	push   %esi
c0026ff4:	53                   	push   %ebx
c0026ff5:	83 ec 10             	sub    $0x10,%esp
c0026ff8:	e8 8c 7a 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0026ffd:	05 b7 3e 01 00       	add    $0x13eb7,%eax
c0027002:	89 44 24 0c          	mov    %eax,0xc(%esp)
  uint8_t *buf;

  if (!inited)
c0027006:	80 b8 4c 21 00 00 00 	cmpb   $0x0,0x214c(%eax)
c002700d:	74 31                	je     c0027040 <random_bytes+0x4f>
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c002700f:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0027014:	0f 84 95 00 00 00    	je     c00270af <random_bytes+0xbe>
c002701a:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002701e:	0f b6 87 4d 21 00 00 	movzbl 0x214d(%edi),%eax
c0027025:	88 44 24 03          	mov    %al,0x3(%esp)
c0027029:	bb 00 00 00 00       	mov    $0x0,%ebx
c002702e:	0f b6 87 4e 21 00 00 	movzbl 0x214e(%edi),%eax
c0027035:	8d 68 01             	lea    0x1(%eax),%ebp
    {
      uint8_t s_k;
      
      s_i++;
      s_j += s[s_i];
c0027038:	8d 87 6c 21 00 00    	lea    0x216c(%edi),%eax
c002703e:	eb 0e                	jmp    c002704e <random_bytes+0x5d>
    random_init (0);
c0027040:	6a 00                	push   $0x0
c0027042:	e8 25 ff ff ff       	call   c0026f6c <random_init>
c0027047:	83 c4 04             	add    $0x4,%esp
c002704a:	eb c3                	jmp    c002700f <random_bytes+0x1e>
c002704c:	89 d3                	mov    %edx,%ebx
c002704e:	8d 54 1d 00          	lea    0x0(%ebp,%ebx,1),%edx
      s_j += s[s_i];
c0027052:	0f b6 fa             	movzbl %dl,%edi
c0027055:	0f b6 4c 24 03       	movzbl 0x3(%esp),%ecx
c002705a:	02 0c 38             	add    (%eax,%edi,1),%cl
c002705d:	88 4c 24 03          	mov    %cl,0x3(%esp)
      swap_byte (s + s_i, s + s_j);
c0027061:	0f b6 f1             	movzbl %cl,%esi
c0027064:	89 74 24 08          	mov    %esi,0x8(%esp)
c0027068:	01 c6                	add    %eax,%esi
c002706a:	89 7c 24 04          	mov    %edi,0x4(%esp)
c002706e:	01 c7                	add    %eax,%edi
  uint8_t t = *a;
c0027070:	0f b6 0f             	movzbl (%edi),%ecx
  *a = *b;
c0027073:	0f b6 16             	movzbl (%esi),%edx
c0027076:	88 17                	mov    %dl,(%edi)
  *b = t;
c0027078:	88 0e                	mov    %cl,(%esi)

      s_k = s[s_i] + s[s_j];
c002707a:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002707e:	02 0c 38             	add    (%eax,%edi,1),%cl
      *buf = s[s_k];
c0027081:	0f b6 c9             	movzbl %cl,%ecx
c0027084:	0f b6 14 08          	movzbl (%eax,%ecx,1),%edx
c0027088:	8b 74 24 24          	mov    0x24(%esp),%esi
c002708c:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
c002708f:	8d 53 01             	lea    0x1(%ebx),%edx
  for (buf = buf_; size-- > 0; buf++)
c0027092:	3b 54 24 28          	cmp    0x28(%esp),%edx
c0027096:	75 b4                	jne    c002704c <random_bytes+0x5b>
c0027098:	01 eb                	add    %ebp,%ebx
c002709a:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002709e:	88 9f 4e 21 00 00    	mov    %bl,0x214e(%edi)
c00270a4:	0f b6 44 24 03       	movzbl 0x3(%esp),%eax
c00270a9:	88 87 4d 21 00 00    	mov    %al,0x214d(%edi)
    }
}
c00270af:	83 c4 10             	add    $0x10,%esp
c00270b2:	5b                   	pop    %ebx
c00270b3:	5e                   	pop    %esi
c00270b4:	5f                   	pop    %edi
c00270b5:	5d                   	pop    %ebp
c00270b6:	c3                   	ret    

c00270b7 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c00270b7:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c00270ba:	6a 04                	push   $0x4
c00270bc:	8d 44 24 10          	lea    0x10(%esp),%eax
c00270c0:	50                   	push   %eax
c00270c1:	e8 2b ff ff ff       	call   c0026ff1 <random_bytes>
  return ul;
}
c00270c6:	8b 44 24 14          	mov    0x14(%esp),%eax
c00270ca:	83 c4 18             	add    $0x18,%esp
c00270cd:	c3                   	ret    

c00270ce <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c00270ce:	53                   	push   %ebx
c00270cf:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c00270d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c00270d7:	8b 50 04             	mov    0x4(%eax),%edx
c00270da:	8d 4a 01             	lea    0x1(%edx),%ecx
c00270dd:	89 48 04             	mov    %ecx,0x4(%eax)
c00270e0:	3b 50 08             	cmp    0x8(%eax),%edx
c00270e3:	7d 09                	jge    c00270ee <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c00270e5:	8b 10                	mov    (%eax),%edx
c00270e7:	8d 4a 01             	lea    0x1(%edx),%ecx
c00270ea:	89 08                	mov    %ecx,(%eax)
c00270ec:	88 1a                	mov    %bl,(%edx)
}
c00270ee:	5b                   	pop    %ebx
c00270ef:	c3                   	ret    

c00270f0 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c00270f0:	55                   	push   %ebp
c00270f1:	57                   	push   %edi
c00270f2:	56                   	push   %esi
c00270f3:	53                   	push   %ebx
c00270f4:	83 ec 0c             	sub    $0xc,%esp
c00270f7:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c00270fb:	85 d2                	test   %edx,%edx
c00270fd:	74 1a                	je     c0027119 <output_dup+0x29>
c00270ff:	8d 5a ff             	lea    -0x1(%edx),%ebx
c0027102:	89 cd                	mov    %ecx,%ebp
    output (ch, aux);
c0027104:	0f be f0             	movsbl %al,%esi
c0027107:	83 ec 08             	sub    $0x8,%esp
c002710a:	57                   	push   %edi
c002710b:	56                   	push   %esi
c002710c:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c002710e:	83 eb 01             	sub    $0x1,%ebx
c0027111:	83 c4 10             	add    $0x10,%esp
c0027114:	83 fb ff             	cmp    $0xffffffff,%ebx
c0027117:	75 ee                	jne    c0027107 <output_dup+0x17>
}
c0027119:	83 c4 0c             	add    $0xc,%esp
c002711c:	5b                   	pop    %ebx
c002711d:	5e                   	pop    %esi
c002711e:	5f                   	pop    %edi
c002711f:	5d                   	pop    %ebp
c0027120:	c3                   	ret    

c0027121 <format_integer>:
{
c0027121:	55                   	push   %ebp
c0027122:	57                   	push   %edi
c0027123:	56                   	push   %esi
c0027124:	53                   	push   %ebx
c0027125:	83 ec 7c             	sub    $0x7c,%esp
c0027128:	e8 58 79 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002712d:	81 c3 87 3d 01 00    	add    $0x13d87,%ebx
c0027133:	89 c6                	mov    %eax,%esi
c0027135:	89 d7                	mov    %edx,%edi
c0027137:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  sign = 0;
c002713e:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0027145:	00 
  if (is_signed) 
c0027146:	84 c9                	test   %cl,%cl
c0027148:	74 1c                	je     c0027166 <format_integer+0x45>
      if (c->flags & PLUS)
c002714a:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c0027151:	8b 11                	mov    (%ecx),%edx
c0027153:	f6 c2 02             	test   $0x2,%dl
c0027156:	74 7e                	je     c00271d6 <format_integer+0xb5>
        sign = negative ? '-' : '+';
c0027158:	3c 01                	cmp    $0x1,%al
c002715a:	19 c0                	sbb    %eax,%eax
c002715c:	83 e0 fe             	and    $0xfffffffe,%eax
c002715f:	83 c0 2d             	add    $0x2d,%eax
c0027162:	89 44 24 20          	mov    %eax,0x20(%esp)
  x = (c->flags & POUND) && value ? b->x : 0;
c0027166:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002716d:	8b 00                	mov    (%eax),%eax
c002716f:	89 44 24 28          	mov    %eax,0x28(%esp)
c0027173:	83 e0 08             	and    $0x8,%eax
c0027176:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c002717a:	89 f1                	mov    %esi,%ecx
c002717c:	09 f9                	or     %edi,%ecx
c002717e:	74 04                	je     c0027184 <format_integer+0x63>
c0027180:	85 c0                	test   %eax,%eax
c0027182:	75 7c                	jne    c0027200 <format_integer+0xdf>
c0027184:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c002718b:	00 
  while (value > 0) 
c002718c:	89 fa                	mov    %edi,%edx
c002718e:	09 f2                	or     %esi,%edx
c0027190:	0f 84 32 02 00 00    	je     c00273c8 <format_integer+0x2a7>
      *cp++ = b->digits[value % b->base];
c0027196:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c002719d:	8b 40 04             	mov    0x4(%eax),%eax
c00271a0:	89 44 24 18          	mov    %eax,0x18(%esp)
c00271a4:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00271ab:	8b 00                	mov    (%eax),%eax
c00271ad:	89 44 24 08          	mov    %eax,0x8(%esp)
c00271b1:	89 c1                	mov    %eax,%ecx
c00271b3:	c1 f9 1f             	sar    $0x1f,%ecx
c00271b6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  digit_cnt = 0;
c00271ba:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00271c1:	00 
  cp = buf;
c00271c2:	8d 6c 24 30          	lea    0x30(%esp),%ebp
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c00271c6:	8b 44 24 28          	mov    0x28(%esp),%eax
c00271ca:	c1 e8 05             	shr    $0x5,%eax
c00271cd:	83 e0 01             	and    $0x1,%eax
c00271d0:	88 44 24 1f          	mov    %al,0x1f(%esp)
c00271d4:	eb 41                	jmp    c0027217 <format_integer+0xf6>
      else if (c->flags & SPACE)
c00271d6:	f6 c2 04             	test   $0x4,%dl
c00271d9:	74 13                	je     c00271ee <format_integer+0xcd>
        sign = negative ? '-' : ' ';
c00271db:	3c 01                	cmp    $0x1,%al
c00271dd:	19 c0                	sbb    %eax,%eax
c00271df:	83 e0 f3             	and    $0xfffffff3,%eax
c00271e2:	83 c0 2d             	add    $0x2d,%eax
c00271e5:	89 44 24 20          	mov    %eax,0x20(%esp)
c00271e9:	e9 78 ff ff ff       	jmp    c0027166 <format_integer+0x45>
        sign = '-';
c00271ee:	3c 01                	cmp    $0x1,%al
c00271f0:	19 c0                	sbb    %eax,%eax
c00271f2:	f7 d0                	not    %eax
c00271f4:	83 e0 2d             	and    $0x2d,%eax
c00271f7:	89 44 24 20          	mov    %eax,0x20(%esp)
c00271fb:	e9 66 ff ff ff       	jmp    c0027166 <format_integer+0x45>
  x = (c->flags & POUND) && value ? b->x : 0;
c0027200:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0027207:	8b 40 08             	mov    0x8(%eax),%eax
c002720a:	89 44 24 24          	mov    %eax,0x24(%esp)
c002720e:	e9 79 ff ff ff       	jmp    c002718c <format_integer+0x6b>
c0027213:	8b 6c 24 10          	mov    0x10(%esp),%ebp
      *cp++ = b->digits[value % b->base];
c0027217:	8d 45 01             	lea    0x1(%ebp),%eax
c002721a:	89 44 24 10          	mov    %eax,0x10(%esp)
c002721e:	ff 74 24 0c          	pushl  0xc(%esp)
c0027222:	ff 74 24 0c          	pushl  0xc(%esp)
c0027226:	57                   	push   %edi
c0027227:	56                   	push   %esi
c0027228:	e8 80 1a 00 00       	call   c0028cad <__umoddi3>
c002722d:	83 c4 10             	add    $0x10,%esp
c0027230:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0027234:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
c0027238:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
c002723b:	ff 74 24 0c          	pushl  0xc(%esp)
c002723f:	ff 74 24 0c          	pushl  0xc(%esp)
c0027243:	57                   	push   %edi
c0027244:	56                   	push   %esi
c0027245:	e8 47 1a 00 00       	call   c0028c91 <__udivdi3>
c002724a:	83 c4 10             	add    $0x10,%esp
c002724d:	89 c6                	mov    %eax,%esi
c002724f:	89 d7                	mov    %edx,%edi
      digit_cnt++;
c0027251:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
  while (value > 0) 
c0027256:	09 c2                	or     %eax,%edx
c0027258:	74 2b                	je     c0027285 <format_integer+0x164>
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c002725a:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002725f:	74 b2                	je     c0027213 <format_integer+0xf2>
c0027261:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027265:	85 c0                	test   %eax,%eax
c0027267:	7e aa                	jle    c0027213 <format_integer+0xf2>
c0027269:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0027270:	99                   	cltd   
c0027271:	f7 79 0c             	idivl  0xc(%ecx)
c0027274:	85 d2                	test   %edx,%edx
c0027276:	75 9b                	jne    c0027213 <format_integer+0xf2>
        *cp++ = ',';
c0027278:	8d 45 02             	lea    0x2(%ebp),%eax
c002727b:	89 44 24 10          	mov    %eax,0x10(%esp)
c002727f:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
c0027283:	eb 8e                	jmp    c0027213 <format_integer+0xf2>
c0027285:	8b 6c 24 10          	mov    0x10(%esp),%ebp
  precision = c->precision < 0 ? 1 : c->precision;
c0027289:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027290:	8b 48 08             	mov    0x8(%eax),%ecx
c0027293:	85 c9                	test   %ecx,%ecx
c0027295:	b8 01 00 00 00       	mov    $0x1,%eax
c002729a:	0f 48 c8             	cmovs  %eax,%ecx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c002729d:	8d 44 24 30          	lea    0x30(%esp),%eax
c00272a1:	89 ea                	mov    %ebp,%edx
c00272a3:	29 c2                	sub    %eax,%edx
c00272a5:	39 d1                	cmp    %edx,%ecx
c00272a7:	7e 1f                	jle    c00272c8 <format_integer+0x1a7>
c00272a9:	8d 54 24 6f          	lea    0x6f(%esp),%edx
c00272ad:	39 d5                	cmp    %edx,%ebp
c00272af:	73 17                	jae    c00272c8 <format_integer+0x1a7>
c00272b1:	89 c6                	mov    %eax,%esi
c00272b3:	89 d7                	mov    %edx,%edi
    *cp++ = '0';
c00272b5:	83 c5 01             	add    $0x1,%ebp
c00272b8:	c6 45 ff 30          	movb   $0x30,-0x1(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00272bc:	89 ea                	mov    %ebp,%edx
c00272be:	29 f2                	sub    %esi,%edx
c00272c0:	39 d1                	cmp    %edx,%ecx
c00272c2:	7e 04                	jle    c00272c8 <format_integer+0x1a7>
c00272c4:	39 fd                	cmp    %edi,%ebp
c00272c6:	72 ed                	jb     c00272b5 <format_integer+0x194>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00272c8:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c00272cd:	74 10                	je     c00272df <format_integer+0x1be>
c00272cf:	8b 9c 24 94 00 00 00 	mov    0x94(%esp),%ebx
c00272d6:	83 3b 08             	cmpl   $0x8,(%ebx)
c00272d9:	0f 84 f2 00 00 00    	je     c00273d1 <format_integer+0x2b0>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c00272df:	29 e8                	sub    %ebp,%eax
c00272e1:	8b bc 24 98 00 00 00 	mov    0x98(%esp),%edi
c00272e8:	03 47 04             	add    0x4(%edi),%eax
c00272eb:	89 c6                	mov    %eax,%esi
c00272ed:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00272f1:	85 ff                	test   %edi,%edi
c00272f3:	b8 02 00 00 00       	mov    $0x2,%eax
c00272f8:	0f 44 c7             	cmove  %edi,%eax
c00272fb:	29 c6                	sub    %eax,%esi
c00272fd:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027302:	0f 95 c0             	setne  %al
c0027305:	0f b6 c0             	movzbl %al,%eax
c0027308:	29 c6                	sub    %eax,%esi
c002730a:	b8 00 00 00 00       	mov    $0x0,%eax
c002730f:	0f 48 f0             	cmovs  %eax,%esi
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027312:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c0027317:	0f 84 d2 00 00 00    	je     c00273ef <format_integer+0x2ce>
  if (sign)
c002731d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0027321:	85 c0                	test   %eax,%eax
c0027323:	74 15                	je     c002733a <format_integer+0x219>
    output (sign, aux);
c0027325:	83 ec 08             	sub    $0x8,%esp
c0027328:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002732f:	50                   	push   %eax
c0027330:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0027337:	83 c4 10             	add    $0x10,%esp
  if (x) 
c002733a:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002733e:	85 ff                	test   %edi,%edi
c0027340:	74 2d                	je     c002736f <format_integer+0x24e>
      output ('0', aux);
c0027342:	83 ec 08             	sub    $0x8,%esp
c0027345:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002734c:	6a 30                	push   $0x30
c002734e:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c0027355:	83 c4 08             	add    $0x8,%esp
c0027358:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002735f:	89 f8                	mov    %edi,%eax
c0027361:	0f be c0             	movsbl %al,%eax
c0027364:	50                   	push   %eax
c0027365:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c002736c:	83 c4 10             	add    $0x10,%esp
  if (c->flags & ZERO)
c002736f:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027376:	f6 00 10             	testb  $0x10,(%eax)
c0027379:	0f 85 95 00 00 00    	jne    c0027414 <format_integer+0x2f3>
  while (cp > buf)
c002737f:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027383:	89 c7                	mov    %eax,%edi
c0027385:	39 c5                	cmp    %eax,%ebp
c0027387:	76 2b                	jbe    c00273b4 <format_integer+0x293>
c0027389:	89 74 24 10          	mov    %esi,0x10(%esp)
c002738d:	8b 9c 24 9c 00 00 00 	mov    0x9c(%esp),%ebx
c0027394:	8b b4 24 a0 00 00 00 	mov    0xa0(%esp),%esi
    output (*--cp, aux);
c002739b:	83 ed 01             	sub    $0x1,%ebp
c002739e:	83 ec 08             	sub    $0x8,%esp
c00273a1:	56                   	push   %esi
c00273a2:	0f be 45 00          	movsbl 0x0(%ebp),%eax
c00273a6:	50                   	push   %eax
c00273a7:	ff d3                	call   *%ebx
  while (cp > buf)
c00273a9:	83 c4 10             	add    $0x10,%esp
c00273ac:	39 fd                	cmp    %edi,%ebp
c00273ae:	75 eb                	jne    c002739b <format_integer+0x27a>
c00273b0:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (c->flags & MINUS)
c00273b4:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00273bb:	f6 00 01             	testb  $0x1,(%eax)
c00273be:	75 79                	jne    c0027439 <format_integer+0x318>
}
c00273c0:	83 c4 7c             	add    $0x7c,%esp
c00273c3:	5b                   	pop    %ebx
c00273c4:	5e                   	pop    %esi
c00273c5:	5f                   	pop    %edi
c00273c6:	5d                   	pop    %ebp
c00273c7:	c3                   	ret    
  cp = buf;
c00273c8:	8d 6c 24 30          	lea    0x30(%esp),%ebp
c00273cc:	e9 b8 fe ff ff       	jmp    c0027289 <format_integer+0x168>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00273d1:	8d 54 24 30          	lea    0x30(%esp),%edx
c00273d5:	39 d5                	cmp    %edx,%ebp
c00273d7:	74 0a                	je     c00273e3 <format_integer+0x2c2>
c00273d9:	80 7d ff 30          	cmpb   $0x30,-0x1(%ebp)
c00273dd:	0f 84 fc fe ff ff    	je     c00272df <format_integer+0x1be>
    *cp++ = '0';
c00273e3:	c6 45 00 30          	movb   $0x30,0x0(%ebp)
c00273e7:	8d 6d 01             	lea    0x1(%ebp),%ebp
c00273ea:	e9 f0 fe ff ff       	jmp    c00272df <format_integer+0x1be>
    output_dup (' ', pad_cnt, output, aux);
c00273ef:	83 ec 0c             	sub    $0xc,%esp
c00273f2:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c00273f9:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027400:	89 f2                	mov    %esi,%edx
c0027402:	b8 20 00 00 00       	mov    $0x20,%eax
c0027407:	e8 e4 fc ff ff       	call   c00270f0 <output_dup>
c002740c:	83 c4 10             	add    $0x10,%esp
c002740f:	e9 09 ff ff ff       	jmp    c002731d <format_integer+0x1fc>
    output_dup ('0', pad_cnt, output, aux);
c0027414:	83 ec 0c             	sub    $0xc,%esp
c0027417:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c002741e:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027425:	89 f2                	mov    %esi,%edx
c0027427:	b8 30 00 00 00       	mov    $0x30,%eax
c002742c:	e8 bf fc ff ff       	call   c00270f0 <output_dup>
c0027431:	83 c4 10             	add    $0x10,%esp
c0027434:	e9 46 ff ff ff       	jmp    c002737f <format_integer+0x25e>
    output_dup (' ', pad_cnt, output, aux);
c0027439:	83 ec 0c             	sub    $0xc,%esp
c002743c:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027443:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c002744a:	89 f2                	mov    %esi,%edx
c002744c:	b8 20 00 00 00       	mov    $0x20,%eax
c0027451:	e8 9a fc ff ff       	call   c00270f0 <output_dup>
c0027456:	83 c4 10             	add    $0x10,%esp
}
c0027459:	e9 62 ff ff ff       	jmp    c00273c0 <format_integer+0x29f>

c002745e <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c002745e:	55                   	push   %ebp
c002745f:	57                   	push   %edi
c0027460:	56                   	push   %esi
c0027461:	53                   	push   %ebx
c0027462:	83 ec 1c             	sub    $0x1c,%esp
c0027465:	89 c5                	mov    %eax,%ebp
c0027467:	89 d6                	mov    %edx,%esi
c0027469:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c002746d:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027471:	8b 51 04             	mov    0x4(%ecx),%edx
c0027474:	39 f2                	cmp    %esi,%edx
c0027476:	7e 3f                	jle    c00274b7 <format_string+0x59>
c0027478:	f6 01 01             	testb  $0x1,(%ecx)
c002747b:	74 1d                	je     c002749a <format_string+0x3c>
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c002747d:	85 f6                	test   %esi,%esi
c002747f:	7f 3a                	jg     c00274bb <format_string+0x5d>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
c0027481:	29 f2                	sub    %esi,%edx
c0027483:	83 ec 0c             	sub    $0xc,%esp
c0027486:	57                   	push   %edi
c0027487:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c002748b:	b8 20 00 00 00       	mov    $0x20,%eax
c0027490:	e8 5b fc ff ff       	call   c00270f0 <output_dup>
c0027495:	83 c4 10             	add    $0x10,%esp
}
c0027498:	eb 4e                	jmp    c00274e8 <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
c002749a:	29 f2                	sub    %esi,%edx
c002749c:	83 ec 0c             	sub    $0xc,%esp
c002749f:	57                   	push   %edi
c00274a0:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c00274a4:	b8 20 00 00 00       	mov    $0x20,%eax
c00274a9:	e8 42 fc ff ff       	call   c00270f0 <output_dup>
  for (i = 0; i < length; i++)
c00274ae:	83 c4 10             	add    $0x10,%esp
c00274b1:	85 f6                	test   %esi,%esi
c00274b3:	7f 06                	jg     c00274bb <format_string+0x5d>
c00274b5:	eb 21                	jmp    c00274d8 <format_string+0x7a>
c00274b7:	85 f6                	test   %esi,%esi
c00274b9:	7e 2d                	jle    c00274e8 <format_string+0x8a>
{
c00274bb:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
c00274c0:	83 ec 08             	sub    $0x8,%esp
c00274c3:	57                   	push   %edi
c00274c4:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c00274c9:	50                   	push   %eax
c00274ca:	ff 54 24 40          	call   *0x40(%esp)
  for (i = 0; i < length; i++)
c00274ce:	83 c3 01             	add    $0x1,%ebx
c00274d1:	83 c4 10             	add    $0x10,%esp
c00274d4:	39 de                	cmp    %ebx,%esi
c00274d6:	7f e8                	jg     c00274c0 <format_string+0x62>
  if (c->width > length && (c->flags & MINUS) != 0)
c00274d8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00274dc:	8b 50 04             	mov    0x4(%eax),%edx
c00274df:	39 f2                	cmp    %esi,%edx
c00274e1:	7e 05                	jle    c00274e8 <format_string+0x8a>
c00274e3:	f6 00 01             	testb  $0x1,(%eax)
c00274e6:	75 99                	jne    c0027481 <format_string+0x23>
}
c00274e8:	83 c4 1c             	add    $0x1c,%esp
c00274eb:	5b                   	pop    %ebx
c00274ec:	5e                   	pop    %esi
c00274ed:	5f                   	pop    %edi
c00274ee:	5d                   	pop    %ebp
c00274ef:	c3                   	ret    

c00274f0 <printf>:
{
c00274f0:	53                   	push   %ebx
c00274f1:	83 ec 08             	sub    $0x8,%esp
c00274f4:	e8 8c 75 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00274f9:	81 c3 bb 39 01 00    	add    $0x139bb,%ebx
  va_start (args, format);
c00274ff:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c0027503:	83 ec 08             	sub    $0x8,%esp
c0027506:	50                   	push   %eax
c0027507:	ff 74 24 1c          	pushl  0x1c(%esp)
c002750b:	e8 0d 3d 00 00       	call   c002b21d <vprintf>
}
c0027510:	83 c4 18             	add    $0x18,%esp
c0027513:	5b                   	pop    %ebx
c0027514:	c3                   	ret    

c0027515 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0027515:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c0027518:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c002751c:	ff 74 24 18          	pushl  0x18(%esp)
c0027520:	ff 74 24 18          	pushl  0x18(%esp)
c0027524:	50                   	push   %eax
c0027525:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027529:	e8 04 00 00 00       	call   c0027532 <__vprintf>
  va_end (args);
}
c002752e:	83 c4 1c             	add    $0x1c,%esp
c0027531:	c3                   	ret    

c0027532 <__vprintf>:
{
c0027532:	55                   	push   %ebp
c0027533:	57                   	push   %edi
c0027534:	56                   	push   %esi
c0027535:	53                   	push   %ebx
c0027536:	83 ec 5c             	sub    $0x5c,%esp
c0027539:	e8 4b 75 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c002753e:	05 76 39 01 00       	add    $0x13976,%eax
c0027543:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027547:	8b 74 24 70          	mov    0x70(%esp),%esi
c002754b:	8b 7c 24 78          	mov    0x78(%esp),%edi
c002754f:	8b 6c 24 7c          	mov    0x7c(%esp),%ebp
  for (; *format != '\0'; format++)
c0027553:	0f b6 06             	movzbl (%esi),%eax
c0027556:	84 c0                	test   %al,%al
c0027558:	75 27                	jne    c0027581 <__vprintf+0x4f>
}
c002755a:	83 c4 5c             	add    $0x5c,%esp
c002755d:	5b                   	pop    %ebx
c002755e:	5e                   	pop    %esi
c002755f:	5f                   	pop    %edi
c0027560:	5d                   	pop    %ebp
c0027561:	c3                   	ret    
      format++;
c0027562:	8d 5e 01             	lea    0x1(%esi),%ebx
      if (*format == '%') 
c0027565:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0027569:	75 2b                	jne    c0027596 <__vprintf+0x64>
          output ('%', aux);
c002756b:	83 ec 08             	sub    $0x8,%esp
c002756e:	55                   	push   %ebp
c002756f:	6a 25                	push   $0x25
c0027571:	ff d7                	call   *%edi
          continue;
c0027573:	83 c4 10             	add    $0x10,%esp
  for (; *format != '\0'; format++)
c0027576:	8d 73 01             	lea    0x1(%ebx),%esi
c0027579:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c002757d:	84 c0                	test   %al,%al
c002757f:	74 d9                	je     c002755a <__vprintf+0x28>
      if (*format != '%') 
c0027581:	3c 25                	cmp    $0x25,%al
c0027583:	74 dd                	je     c0027562 <__vprintf+0x30>
          output (*format, aux);
c0027585:	83 ec 08             	sub    $0x8,%esp
c0027588:	55                   	push   %ebp
c0027589:	0f be c0             	movsbl %al,%eax
c002758c:	50                   	push   %eax
c002758d:	ff d7                	call   *%edi
          continue;
c002758f:	83 c4 10             	add    $0x10,%esp
c0027592:	89 f3                	mov    %esi,%ebx
c0027594:	eb e0                	jmp    c0027576 <__vprintf+0x44>
  c->flags = 0;
c0027596:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
c002759d:	00 
c002759e:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
c00275a3:	be 00 00 00 00       	mov    $0x0,%esi
c00275a8:	89 7c 24 78          	mov    %edi,0x78(%esp)
c00275ac:	89 6c 24 7c          	mov    %ebp,0x7c(%esp)
c00275b0:	eb 0a                	jmp    c00275bc <.L79+0xa>

c00275b2 <.L79>:
          c->flags |= MINUS;
c00275b2:	83 ce 01             	or     $0x1,%esi
c00275b5:	c6 44 24 18 01       	movb   $0x1,0x18(%esp)
      switch (*format++) 
c00275ba:	89 cb                	mov    %ecx,%ebx
c00275bc:	8d 4b 01             	lea    0x1(%ebx),%ecx
c00275bf:	0f b6 51 ff          	movzbl -0x1(%ecx),%edx
c00275c3:	8d 42 e0             	lea    -0x20(%edx),%eax
c00275c6:	3c 10                	cmp    $0x10,%al
c00275c8:	77 2b                	ja     c00275f5 <.L73>
c00275ca:	0f b6 c0             	movzbl %al,%eax
c00275cd:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c00275d1:	89 fd                	mov    %edi,%ebp
c00275d3:	03 ac 87 bc 41 ff ff 	add    -0xbe44(%edi,%eax,4),%ebp
c00275da:	ff e5                	jmp    *%ebp

c00275dc <.L78>:
          c->flags |= PLUS;
c00275dc:	83 ce 02             	or     $0x2,%esi
c00275df:	eb d4                	jmp    c00275b5 <.L79+0x3>

c00275e1 <.L74>:
          c->flags |= SPACE;
c00275e1:	83 ce 04             	or     $0x4,%esi
c00275e4:	eb cf                	jmp    c00275b5 <.L79+0x3>

c00275e6 <.L76>:
          c->flags |= POUND;
c00275e6:	83 ce 08             	or     $0x8,%esi
c00275e9:	eb ca                	jmp    c00275b5 <.L79+0x3>

c00275eb <.L80>:
          c->flags |= ZERO;
c00275eb:	83 ce 10             	or     $0x10,%esi
c00275ee:	eb c5                	jmp    c00275b5 <.L79+0x3>

c00275f0 <.L77>:
          c->flags |= GROUP;
c00275f0:	83 ce 20             	or     $0x20,%esi
c00275f3:	eb c0                	jmp    c00275b5 <.L79+0x3>

c00275f5 <.L73>:
c00275f5:	8b 7c 24 78          	mov    0x78(%esp),%edi
c00275f9:	8b 6c 24 7c          	mov    0x7c(%esp),%ebp
c00275fd:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
c0027602:	0f 85 9e 00 00 00    	jne    c00276a6 <.L73+0xb1>
  if (c->flags & PLUS)
c0027608:	8b 44 24 40          	mov    0x40(%esp),%eax
c002760c:	a8 02                	test   $0x2,%al
c002760e:	74 07                	je     c0027617 <.L73+0x22>
    c->flags &= ~SPACE;
c0027610:	83 e0 fb             	and    $0xfffffffb,%eax
c0027613:	89 44 24 40          	mov    %eax,0x40(%esp)
  c->width = 0;
c0027617:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
c002761e:	00 
  if (*format == '*')
c002761f:	80 fa 2a             	cmp    $0x2a,%dl
c0027622:	0f 84 9a 00 00 00    	je     c00276c2 <.L73+0xcd>
      for (; isdigit (*format); format++)
c0027628:	0f be d2             	movsbl %dl,%edx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c002762b:	8d 4a d0             	lea    -0x30(%edx),%ecx
c002762e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027633:	83 f9 09             	cmp    $0x9,%ecx
c0027636:	77 25                	ja     c002765d <.L73+0x68>
        c->width = c->width * 10 + *format - '0';
c0027638:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002763b:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
      for (; isdigit (*format); format++)
c002763f:	83 c3 01             	add    $0x1,%ebx
c0027642:	0f be 13             	movsbl (%ebx),%edx
c0027645:	8d 4a d0             	lea    -0x30(%edx),%ecx
c0027648:	83 f9 09             	cmp    $0x9,%ecx
c002764b:	76 eb                	jbe    c0027638 <.L73+0x43>
c002764d:	89 44 24 44          	mov    %eax,0x44(%esp)
  if (c->width < 0) 
c0027651:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027655:	85 c0                	test   %eax,%eax
c0027657:	0f 88 81 00 00 00    	js     c00276de <.L73+0xe9>
  c->precision = -1;
c002765d:	c7 44 24 48 ff ff ff 	movl   $0xffffffff,0x48(%esp)
c0027664:	ff 
  if (*format == '.') 
c0027665:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c0027668:	0f 84 80 00 00 00    	je     c00276ee <.L73+0xf9>
  if (c->precision >= 0)
c002766e:	8b 44 24 48          	mov    0x48(%esp),%eax
c0027672:	89 44 24 10          	mov    %eax,0x10(%esp)
  c->type = INT;
c0027676:	c7 44 24 4c 03 00 00 	movl   $0x3,0x4c(%esp)
c002767d:	00 
  switch (*format++) 
c002767e:	8d 43 01             	lea    0x1(%ebx),%eax
c0027681:	89 44 24 18          	mov    %eax,0x18(%esp)
c0027685:	0f b6 03             	movzbl (%ebx),%eax
c0027688:	8d 50 98             	lea    -0x68(%eax),%edx
c002768b:	80 fa 12             	cmp    $0x12,%dl
c002768e:	0f 87 44 02 00 00    	ja     c00278d8 <.L93>
c0027694:	0f b6 d2             	movzbl %dl,%edx
c0027697:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c002769b:	89 ce                	mov    %ecx,%esi
c002769d:	03 b4 91 00 42 ff ff 	add    -0xbe00(%ecx,%edx,4),%esi
c00276a4:	ff e6                	jmp    *%esi
c00276a6:	89 74 24 40          	mov    %esi,0x40(%esp)
  if (c->flags & MINUS)
c00276aa:	f7 c6 01 00 00 00    	test   $0x1,%esi
c00276b0:	0f 84 52 ff ff ff    	je     c0027608 <.L73+0x13>
    c->flags &= ~ZERO;
c00276b6:	83 e6 ef             	and    $0xffffffef,%esi
c00276b9:	89 74 24 40          	mov    %esi,0x40(%esp)
c00276bd:	e9 46 ff ff ff       	jmp    c0027608 <.L73+0x13>
      c->width = va_arg (*args, int);
c00276c2:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276c6:	8b 00                	mov    (%eax),%eax
c00276c8:	89 44 24 44          	mov    %eax,0x44(%esp)
c00276cc:	8b 44 24 74          	mov    0x74(%esp),%eax
c00276d0:	8d 40 04             	lea    0x4(%eax),%eax
c00276d3:	89 44 24 74          	mov    %eax,0x74(%esp)
      switch (*format++) 
c00276d7:	89 cb                	mov    %ecx,%ebx
c00276d9:	e9 73 ff ff ff       	jmp    c0027651 <.L73+0x5c>
      c->width = -c->width;
c00276de:	f7 d8                	neg    %eax
c00276e0:	89 44 24 44          	mov    %eax,0x44(%esp)
      c->flags |= MINUS;
c00276e4:	83 4c 24 40 01       	orl    $0x1,0x40(%esp)
c00276e9:	e9 6f ff ff ff       	jmp    c002765d <.L73+0x68>
      if (*format == '*') 
c00276ee:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00276f2:	3c 2a                	cmp    $0x2a,%al
c00276f4:	74 4a                	je     c0027740 <.L73+0x14b>
      format++;
c00276f6:	83 c3 01             	add    $0x1,%ebx
          c->precision = 0;
c00276f9:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
c0027700:	00 
          for (; isdigit (*format); format++)
c0027701:	0f be c0             	movsbl %al,%eax
c0027704:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027707:	83 fa 09             	cmp    $0x9,%edx
c002770a:	77 5b                	ja     c0027767 <.L73+0x172>
c002770c:	ba 00 00 00 00       	mov    $0x0,%edx
            c->precision = c->precision * 10 + *format - '0';
c0027711:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0027714:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
          for (; isdigit (*format); format++)
c0027718:	83 c3 01             	add    $0x1,%ebx
c002771b:	0f be 03             	movsbl (%ebx),%eax
c002771e:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027721:	83 f9 09             	cmp    $0x9,%ecx
c0027724:	76 eb                	jbe    c0027711 <.L73+0x11c>
c0027726:	89 54 24 48          	mov    %edx,0x48(%esp)
      if (c->precision < 0) 
c002772a:	8b 44 24 48          	mov    0x48(%esp),%eax
c002772e:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027732:	85 c0                	test   %eax,%eax
c0027734:	78 24                	js     c002775a <.L73+0x165>
    c->flags &= ~ZERO;
c0027736:	83 64 24 40 ef       	andl   $0xffffffef,0x40(%esp)
c002773b:	e9 36 ff ff ff       	jmp    c0027676 <.L73+0x81>
          format++;
c0027740:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c0027743:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027747:	8b 00                	mov    (%eax),%eax
c0027749:	89 44 24 48          	mov    %eax,0x48(%esp)
c002774d:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027751:	8d 40 04             	lea    0x4(%eax),%eax
c0027754:	89 44 24 74          	mov    %eax,0x74(%esp)
c0027758:	eb d0                	jmp    c002772a <.L73+0x135>
        c->precision = -1;
c002775a:	c7 44 24 48 ff ff ff 	movl   $0xffffffff,0x48(%esp)
c0027761:	ff 
c0027762:	e9 07 ff ff ff       	jmp    c002766e <.L73+0x79>
  if (c->precision >= 0)
c0027767:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c002776e:	00 
c002776f:	eb c5                	jmp    c0027736 <.L73+0x141>

c0027771 <.L94>:
      if (*format == 'h') 
c0027771:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027775:	3c 68                	cmp    $0x68,%al
c0027777:	74 2d                	je     c00277a6 <.L94+0x35>
        c->type = SHORT;
c0027779:	c7 44 24 4c 02 00 00 	movl   $0x2,0x4c(%esp)
c0027780:	00 
      switch (*format) 
c0027781:	0f be d0             	movsbl %al,%edx
c0027784:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0027788:	8d 48 bb             	lea    -0x45(%eax),%ecx
c002778b:	80 f9 33             	cmp    $0x33,%cl
c002778e:	0f 87 dd 05 00 00    	ja     c0027d71 <.L101>
c0027794:	0f b6 c9             	movzbl %cl,%ecx
c0027797:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002779b:	89 d6                	mov    %edx,%esi
c002779d:	03 b4 8a 4c 42 ff ff 	add    -0xbdb4(%edx,%ecx,4),%esi
c00277a4:	ff e6                	jmp    *%esi
          format++;
c00277a6:	8d 43 02             	lea    0x2(%ebx),%eax
c00277a9:	89 44 24 18          	mov    %eax,0x18(%esp)
          c->type = CHAR;
c00277ad:	c7 44 24 4c 01 00 00 	movl   $0x1,0x4c(%esp)
c00277b4:	00 
      switch (*format) 
c00277b5:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c00277b9:	0f be d0             	movsbl %al,%edx
c00277bc:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c00277c0:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00277c3:	80 f9 33             	cmp    $0x33,%cl
c00277c6:	0f 87 a5 05 00 00    	ja     c0027d71 <.L101>
c00277cc:	0f b6 c9             	movzbl %cl,%ecx
c00277cf:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00277d3:	89 d6                	mov    %edx,%esi
c00277d5:	03 b4 8a 1c 43 ff ff 	add    -0xbce4(%edx,%ecx,4),%esi
c00277dc:	ff e6                	jmp    *%esi

c00277de <.L96>:
      c->type = INTMAX;
c00277de:	c7 44 24 4c 04 00 00 	movl   $0x4,0x4c(%esp)
c00277e5:	00 
      switch (*format) 
c00277e6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00277ea:	0f be c8             	movsbl %al,%ecx
c00277ed:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c00277f1:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00277f4:	80 f9 33             	cmp    $0x33,%cl
c00277f7:	0f 87 74 05 00 00    	ja     c0027d71 <.L101>
c00277fd:	0f b6 c9             	movzbl %cl,%ecx
c0027800:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027804:	03 9c 8b ec 43 ff ff 	add    -0xbc14(%ebx,%ecx,4),%ebx
c002780b:	ff e3                	jmp    *%ebx

c002780d <.L97>:
      if (*format == 'l')
c002780d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027811:	3c 6c                	cmp    $0x6c,%al
c0027813:	74 2d                	je     c0027842 <.L97+0x35>
        c->type = LONG;
c0027815:	c7 44 24 4c 05 00 00 	movl   $0x5,0x4c(%esp)
c002781c:	00 
      switch (*format) 
c002781d:	0f be d0             	movsbl %al,%edx
c0027820:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0027824:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027827:	80 f9 33             	cmp    $0x33,%cl
c002782a:	0f 87 41 05 00 00    	ja     c0027d71 <.L101>
c0027830:	0f b6 c9             	movzbl %cl,%ecx
c0027833:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027837:	89 d6                	mov    %edx,%esi
c0027839:	03 b4 8a bc 44 ff ff 	add    -0xbb44(%edx,%ecx,4),%esi
c0027840:	ff e6                	jmp    *%esi
          format++;
c0027842:	8d 43 02             	lea    0x2(%ebx),%eax
c0027845:	89 44 24 18          	mov    %eax,0x18(%esp)
          c->type = LONGLONG;
c0027849:	c7 44 24 4c 06 00 00 	movl   $0x6,0x4c(%esp)
c0027850:	00 
      switch (*format) 
c0027851:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c0027855:	0f be c8             	movsbl %al,%ecx
c0027858:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c002785c:	8d 48 bb             	lea    -0x45(%eax),%ecx
c002785f:	80 f9 33             	cmp    $0x33,%cl
c0027862:	0f 87 09 05 00 00    	ja     c0027d71 <.L101>
c0027868:	0f b6 c9             	movzbl %cl,%ecx
c002786b:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002786f:	89 d6                	mov    %edx,%esi
c0027871:	03 b4 8a 8c 45 ff ff 	add    -0xba74(%edx,%ecx,4),%esi
c0027878:	ff e6                	jmp    *%esi

c002787a <.L98>:
      c->type = PTRDIFFT;
c002787a:	c7 44 24 4c 07 00 00 	movl   $0x7,0x4c(%esp)
c0027881:	00 
      switch (*format) 
c0027882:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027886:	0f be c8             	movsbl %al,%ecx
c0027889:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c002788d:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027890:	80 f9 33             	cmp    $0x33,%cl
c0027893:	0f 87 d8 04 00 00    	ja     c0027d71 <.L101>
c0027899:	0f b6 c9             	movzbl %cl,%ecx
c002789c:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00278a0:	03 9c 8b 5c 46 ff ff 	add    -0xb9a4(%ebx,%ecx,4),%ebx
c00278a7:	ff e3                	jmp    *%ebx

c00278a9 <.L99>:
      c->type = SIZET;
c00278a9:	c7 44 24 4c 08 00 00 	movl   $0x8,0x4c(%esp)
c00278b0:	00 
      switch (*format) 
c00278b1:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00278b5:	0f be c8             	movsbl %al,%ecx
c00278b8:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c00278bc:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00278bf:	80 f9 33             	cmp    $0x33,%cl
c00278c2:	0f 87 a9 04 00 00    	ja     c0027d71 <.L101>
c00278c8:	0f b6 c9             	movzbl %cl,%ecx
c00278cb:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00278cf:	03 9c 8b 2c 47 ff ff 	add    -0xb8d4(%ebx,%ecx,4),%ebx
c00278d6:	ff e3                	jmp    *%ebx

c00278d8 <.L93>:
c00278d8:	0f be c8             	movsbl %al,%ecx
c00278db:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c00278df:	8d 48 bb             	lea    -0x45(%eax),%ecx
c00278e2:	80 f9 33             	cmp    $0x33,%cl
c00278e5:	0f 87 82 04 00 00    	ja     c0027d6d <.L150>
c00278eb:	0f b6 c9             	movzbl %cl,%ecx
c00278ee:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00278f2:	03 94 8a fc 47 ff ff 	add    -0xb804(%edx,%ecx,4),%edx
c00278f9:	ff e2                	jmp    *%edx

c00278fb <.L153>:
c00278fb:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c00278ff <.L106>:
            switch (c.type) 
c00278ff:	83 7c 24 4c 08       	cmpl   $0x8,0x4c(%esp)
c0027904:	0f 87 8b 01 00 00    	ja     c0027a95 <.L124>
c002790a:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002790e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0027912:	03 8c 81 cc 48 ff ff 	add    -0xb734(%ecx,%eax,4),%ecx
c0027919:	ff e1                	jmp    *%ecx

c002791b <.L125>:
                value = (signed char) va_arg (args, int);
c002791b:	8b 44 24 74          	mov    0x74(%esp),%eax
c002791f:	0f be 08             	movsbl (%eax),%ecx
c0027922:	89 c8                	mov    %ecx,%eax
c0027924:	99                   	cltd   
c0027925:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027929:	89 54 24 14          	mov    %edx,0x14(%esp)
c002792d:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027931:	8d 40 04             	lea    0x4(%eax),%eax
c0027934:	89 44 24 74          	mov    %eax,0x74(%esp)
            format_integer (value < 0 ? -value : value,
c0027938:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002793c:	8b 74 24 14          	mov    0x14(%esp),%esi
c0027940:	89 f2                	mov    %esi,%edx
c0027942:	c1 fa 1f             	sar    $0x1f,%edx
c0027945:	89 d1                	mov    %edx,%ecx
c0027947:	31 d9                	xor    %ebx,%ecx
c0027949:	89 4c 24 28          	mov    %ecx,0x28(%esp)
c002794d:	89 d1                	mov    %edx,%ecx
c002794f:	33 4c 24 14          	xor    0x14(%esp),%ecx
c0027953:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
c0027957:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c002795b:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c002795f:	29 d1                	sub    %edx,%ecx
c0027961:	19 d3                	sbb    %edx,%ebx
c0027963:	89 c8                	mov    %ecx,%eax
c0027965:	89 da                	mov    %ebx,%edx
c0027967:	83 ec 0c             	sub    $0xc,%esp
c002796a:	55                   	push   %ebp
c002796b:	57                   	push   %edi
c002796c:	8d 4c 24 54          	lea    0x54(%esp),%ecx
c0027970:	51                   	push   %ecx
c0027971:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0027975:	8d 89 dc 05 00 00    	lea    0x5dc(%ecx),%ecx
c002797b:	51                   	push   %ecx
c002797c:	8b 4c 24 30          	mov    0x30(%esp),%ecx
c0027980:	c1 e9 1f             	shr    $0x1f,%ecx
c0027983:	51                   	push   %ecx
c0027984:	b9 01 00 00 00       	mov    $0x1,%ecx
c0027989:	e8 93 f7 ff ff       	call   c0027121 <format_integer>
          break;
c002798e:	83 c4 20             	add    $0x20,%esp
c0027991:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0027995:	e9 dc fb ff ff       	jmp    c0027576 <__vprintf+0x44>

c002799a <.L127>:
                value = (short) va_arg (args, int);
c002799a:	8b 44 24 74          	mov    0x74(%esp),%eax
c002799e:	0f bf 08             	movswl (%eax),%ecx
c00279a1:	89 c8                	mov    %ecx,%eax
c00279a3:	99                   	cltd   
c00279a4:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00279a8:	89 54 24 14          	mov    %edx,0x14(%esp)
c00279ac:	8b 44 24 74          	mov    0x74(%esp),%eax
c00279b0:	8d 40 04             	lea    0x4(%eax),%eax
c00279b3:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c00279b7:	e9 7c ff ff ff       	jmp    c0027938 <.L125+0x1d>

c00279bc <.L128>:
                value = va_arg (args, int);
c00279bc:	8b 44 24 74          	mov    0x74(%esp),%eax
c00279c0:	8b 08                	mov    (%eax),%ecx
c00279c2:	89 c8                	mov    %ecx,%eax
c00279c4:	99                   	cltd   
c00279c5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c00279c9:	89 54 24 14          	mov    %edx,0x14(%esp)
c00279cd:	8b 44 24 74          	mov    0x74(%esp),%eax
c00279d1:	8d 40 04             	lea    0x4(%eax),%eax
c00279d4:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c00279d8:	e9 5b ff ff ff       	jmp    c0027938 <.L125+0x1d>

c00279dd <.L129>:
                value = va_arg (args, intmax_t);
c00279dd:	8b 44 24 74          	mov    0x74(%esp),%eax
c00279e1:	8b 50 04             	mov    0x4(%eax),%edx
c00279e4:	8b 00                	mov    (%eax),%eax
c00279e6:	89 44 24 10          	mov    %eax,0x10(%esp)
c00279ea:	89 54 24 14          	mov    %edx,0x14(%esp)
c00279ee:	8b 44 24 74          	mov    0x74(%esp),%eax
c00279f2:	8d 40 08             	lea    0x8(%eax),%eax
c00279f5:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c00279f9:	e9 3a ff ff ff       	jmp    c0027938 <.L125+0x1d>

c00279fe <.L130>:
                value = va_arg (args, long);
c00279fe:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a02:	8b 08                	mov    (%eax),%ecx
c0027a04:	89 c8                	mov    %ecx,%eax
c0027a06:	99                   	cltd   
c0027a07:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a0b:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027a0f:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a13:	8d 40 04             	lea    0x4(%eax),%eax
c0027a16:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027a1a:	e9 19 ff ff ff       	jmp    c0027938 <.L125+0x1d>

c0027a1f <.L131>:
                value = va_arg (args, long long);
c0027a1f:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a23:	8b 50 04             	mov    0x4(%eax),%edx
c0027a26:	8b 00                	mov    (%eax),%eax
c0027a28:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027a2c:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027a30:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a34:	8d 40 08             	lea    0x8(%eax),%eax
c0027a37:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027a3b:	e9 f8 fe ff ff       	jmp    c0027938 <.L125+0x1d>

c0027a40 <.L132>:
                value = va_arg (args, ptrdiff_t);
c0027a40:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a44:	8b 08                	mov    (%eax),%ecx
c0027a46:	89 c8                	mov    %ecx,%eax
c0027a48:	99                   	cltd   
c0027a49:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a4d:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027a51:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a55:	8d 40 04             	lea    0x4(%eax),%eax
c0027a58:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
c0027a5c:	e9 d7 fe ff ff       	jmp    c0027938 <.L125+0x1d>

c0027a61 <.L133>:
                value = va_arg (args, size_t);
c0027a61:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027a65:	83 c0 04             	add    $0x4,%eax
c0027a68:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027a6c:	8b 0a                	mov    (%edx),%ecx
c0027a6e:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027a73:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027a77:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c0027a7b:	89 44 24 74          	mov    %eax,0x74(%esp)
                if (value > SIZE_MAX / 2)
c0027a7f:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
c0027a85:	0f 86 ad fe ff ff    	jbe    c0027938 <.L125+0x1d>
                  value = value - SIZE_MAX - 1;
c0027a8b:	83 6c 24 14 01       	subl   $0x1,0x14(%esp)
c0027a90:	e9 a3 fe ff ff       	jmp    c0027938 <.L125+0x1d>

c0027a95 <.L124>:
                NOT_REACHED ();
c0027a95:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027a99:	8d 83 54 55 ff ff    	lea    -0xaaac(%ebx),%eax
c0027a9f:	50                   	push   %eax
c0027aa0:	8d 83 f0 48 ff ff    	lea    -0xb710(%ebx),%eax
c0027aa6:	50                   	push   %eax
c0027aa7:	68 dc 00 00 00       	push   $0xdc
c0027aac:	8d 83 91 67 ff ff    	lea    -0x986f(%ebx),%eax
c0027ab2:	50                   	push   %eax
c0027ab3:	e8 cf 17 00 00       	call   c0029287 <debug_panic>

c0027ab8 <.L123>:
                value = va_arg (args, unsigned);
c0027ab8:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027abc:	8b 12                	mov    (%edx),%edx
c0027abe:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027ac3:	89 54 24 20          	mov    %edx,0x20(%esp)
c0027ac7:	89 4c 24 24          	mov    %ecx,0x24(%esp)
c0027acb:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027acf:	8d 52 04             	lea    0x4(%edx),%edx
c0027ad2:	89 54 24 74          	mov    %edx,0x74(%esp)
            switch (*format) 
c0027ad6:	3c 6f                	cmp    $0x6f,%al
c0027ad8:	0f 84 81 01 00 00    	je     c0027c5f <.L121+0x87>
c0027ade:	3c 6f                	cmp    $0x6f,%al
c0027ae0:	0f 8e 15 01 00 00    	jle    c0027bfb <.L121+0x23>
c0027ae6:	3c 75                	cmp    $0x75,%al
c0027ae8:	0f 84 1d 01 00 00    	je     c0027c0b <.L121+0x33>
c0027aee:	3c 78                	cmp    $0x78,%al
c0027af0:	0f 85 46 01 00 00    	jne    c0027c3c <.L121+0x64>
              case 'x': b = &base_x; break;
c0027af6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027afa:	8d 80 bc 05 00 00    	lea    0x5bc(%eax),%eax
c0027b00:	e9 10 01 00 00       	jmp    c0027c15 <.L121+0x3d>

c0027b05 <.L104>:
                value = (unsigned char) va_arg (args, unsigned);
c0027b05:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027b09:	0f b6 12             	movzbl (%edx),%edx
c0027b0c:	89 54 24 20          	mov    %edx,0x20(%esp)
c0027b10:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027b17:	00 
                break;
c0027b18:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = (unsigned char) va_arg (args, unsigned);
c0027b1c:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027b20:	8d 52 04             	lea    0x4(%edx),%edx
c0027b23:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027b27:	eb ad                	jmp    c0027ad6 <.L123+0x1e>

c0027b29 <.L110>:
                value = (unsigned short) va_arg (args, unsigned);
c0027b29:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027b2d:	0f b7 12             	movzwl (%edx),%edx
c0027b30:	89 54 24 20          	mov    %edx,0x20(%esp)
c0027b34:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027b3b:	00 
                break;
c0027b3c:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = (unsigned short) va_arg (args, unsigned);
c0027b40:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027b44:	8d 52 04             	lea    0x4(%edx),%edx
c0027b47:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027b4b:	eb 89                	jmp    c0027ad6 <.L123+0x1e>

c0027b4d <.L112>:
                value = va_arg (args, uintmax_t);
c0027b4d:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027b51:	8b 0a                	mov    (%edx),%ecx
c0027b53:	8b 5a 04             	mov    0x4(%edx),%ebx
c0027b56:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027b5a:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c0027b5e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, uintmax_t);
c0027b62:	8d 52 08             	lea    0x8(%edx),%edx
c0027b65:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027b69:	e9 68 ff ff ff       	jmp    c0027ad6 <.L123+0x1e>

c0027b6e <.L117>:
                value = va_arg (args, unsigned long);
c0027b6e:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027b72:	8b 0a                	mov    (%edx),%ecx
c0027b74:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027b79:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027b7d:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c0027b81:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, unsigned long);
c0027b85:	8d 52 04             	lea    0x4(%edx),%edx
c0027b88:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027b8c:	e9 45 ff ff ff       	jmp    c0027ad6 <.L123+0x1e>

c0027b91 <.L115>:
                value = va_arg (args, unsigned long long);
c0027b91:	8b 4c 24 74          	mov    0x74(%esp),%ecx
c0027b95:	8b 59 04             	mov    0x4(%ecx),%ebx
c0027b98:	8b 09                	mov    (%ecx),%ecx
c0027b9a:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027b9e:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c0027ba2:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, unsigned long long);
c0027ba6:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027baa:	8d 4a 08             	lea    0x8(%edx),%ecx
c0027bad:	89 4c 24 74          	mov    %ecx,0x74(%esp)
                break;
c0027bb1:	e9 20 ff ff ff       	jmp    c0027ad6 <.L123+0x1e>

c0027bb6 <.L119>:
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027bb6:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027bba:	8b 0a                	mov    (%edx),%ecx
c0027bbc:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027bc0:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027bc7:	00 
                break;
c0027bc8:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, ptrdiff_t);
c0027bcc:	8d 4a 04             	lea    0x4(%edx),%ecx
c0027bcf:	89 4c 24 74          	mov    %ecx,0x74(%esp)
                break;
c0027bd3:	e9 fe fe ff ff       	jmp    c0027ad6 <.L123+0x1e>

c0027bd8 <.L121>:
                value = va_arg (args, size_t);
c0027bd8:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027bdc:	8b 0a                	mov    (%edx),%ecx
c0027bde:	bb 00 00 00 00       	mov    $0x0,%ebx
c0027be3:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0027be7:	89 5c 24 24          	mov    %ebx,0x24(%esp)
                break;
c0027beb:	8b 5c 24 18          	mov    0x18(%esp),%ebx
                value = va_arg (args, size_t);
c0027bef:	8d 52 04             	lea    0x4(%edx),%edx
c0027bf2:	89 54 24 74          	mov    %edx,0x74(%esp)
                break;
c0027bf6:	e9 db fe ff ff       	jmp    c0027ad6 <.L123+0x1e>
            switch (*format) 
c0027bfb:	3c 58                	cmp    $0x58,%al
c0027bfd:	75 3d                	jne    c0027c3c <.L121+0x64>
              case 'X': b = &base_X; break;
c0027bff:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027c03:	8d 80 ac 05 00 00    	lea    0x5ac(%eax),%eax
c0027c09:	eb 0a                	jmp    c0027c15 <.L121+0x3d>
              case 'u': b = &base_d; break;
c0027c0b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027c0f:	8d 80 dc 05 00 00    	lea    0x5dc(%eax),%eax
            format_integer (value, false, false, b, &c, output, aux);
c0027c15:	83 ec 0c             	sub    $0xc,%esp
c0027c18:	55                   	push   %ebp
c0027c19:	57                   	push   %edi
c0027c1a:	8d 54 24 54          	lea    0x54(%esp),%edx
c0027c1e:	52                   	push   %edx
c0027c1f:	50                   	push   %eax
c0027c20:	6a 00                	push   $0x0
c0027c22:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027c27:	8b 44 24 40          	mov    0x40(%esp),%eax
c0027c2b:	8b 54 24 44          	mov    0x44(%esp),%edx
c0027c2f:	e8 ed f4 ff ff       	call   c0027121 <format_integer>
          break;
c0027c34:	83 c4 20             	add    $0x20,%esp
c0027c37:	e9 3a f9 ff ff       	jmp    c0027576 <__vprintf+0x44>
              default: NOT_REACHED ();
c0027c3c:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027c40:	8d 83 54 55 ff ff    	lea    -0xaaac(%ebx),%eax
c0027c46:	50                   	push   %eax
c0027c47:	8d 83 f0 48 ff ff    	lea    -0xb710(%ebx),%eax
c0027c4d:	50                   	push   %eax
c0027c4e:	68 14 01 00 00       	push   $0x114
c0027c53:	8d 83 91 67 ff ff    	lea    -0x986f(%ebx),%eax
c0027c59:	50                   	push   %eax
c0027c5a:	e8 28 16 00 00       	call   c0029287 <debug_panic>
              case 'o': b = &base_o; break;
c0027c5f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027c63:	8d 80 cc 05 00 00    	lea    0x5cc(%eax),%eax
c0027c69:	eb aa                	jmp    c0027c15 <.L121+0x3d>

c0027c6b <.L152>:
      switch (*format) 
c0027c6b:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027c6f <.L105>:
            char ch = va_arg (args, int);
c0027c6f:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027c73:	8d 70 04             	lea    0x4(%eax),%esi
c0027c76:	8b 00                	mov    (%eax),%eax
c0027c78:	88 44 24 3f          	mov    %al,0x3f(%esp)
            format_string (&ch, 1, &c, output, aux);
c0027c7c:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c0027c80:	8d 44 24 3f          	lea    0x3f(%esp),%eax
c0027c84:	83 ec 08             	sub    $0x8,%esp
c0027c87:	55                   	push   %ebp
c0027c88:	57                   	push   %edi
c0027c89:	ba 01 00 00 00       	mov    $0x1,%edx
c0027c8e:	e8 cb f7 ff ff       	call   c002745e <format_string>
          break;
c0027c93:	83 c4 10             	add    $0x10,%esp
c0027c96:	8b 5c 24 18          	mov    0x18(%esp),%ebx
            char ch = va_arg (args, int);
c0027c9a:	89 74 24 74          	mov    %esi,0x74(%esp)
          break;
c0027c9e:	e9 d3 f8 ff ff       	jmp    c0027576 <__vprintf+0x44>

c0027ca3 <.L155>:
      switch (*format) 
c0027ca3:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027ca7 <.L108>:
            const char *s = va_arg (args, char *);
c0027ca7:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027cab:	83 c0 04             	add    $0x4,%eax
c0027cae:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0027cb2:	8b 54 24 74          	mov    0x74(%esp),%edx
c0027cb6:	8b 12                	mov    (%edx),%edx
              s = "(null)";
c0027cb8:	85 d2                	test   %edx,%edx
c0027cba:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027cbe:	8d 83 8a 67 ff ff    	lea    -0x9876(%ebx),%eax
c0027cc4:	0f 45 c2             	cmovne %edx,%eax
c0027cc7:	89 c6                	mov    %eax,%esi
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027cc9:	83 ec 08             	sub    $0x8,%esp
c0027ccc:	ff 74 24 18          	pushl  0x18(%esp)
c0027cd0:	50                   	push   %eax
c0027cd1:	e8 d9 0b 00 00       	call   c00288af <strnlen>
c0027cd6:	8d 4c 24 50          	lea    0x50(%esp),%ecx
c0027cda:	83 c4 08             	add    $0x8,%esp
c0027cdd:	55                   	push   %ebp
c0027cde:	57                   	push   %edi
c0027cdf:	89 c2                	mov    %eax,%edx
c0027ce1:	89 f0                	mov    %esi,%eax
c0027ce3:	e8 76 f7 ff ff       	call   c002745e <format_string>
          break;
c0027ce8:	83 c4 10             	add    $0x10,%esp
c0027ceb:	8b 5c 24 18          	mov    0x18(%esp),%ebx
            const char *s = va_arg (args, char *);
c0027cef:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0027cf3:	89 44 24 74          	mov    %eax,0x74(%esp)
          break;
c0027cf7:	e9 7a f8 ff ff       	jmp    c0027576 <__vprintf+0x44>

c0027cfc <.L154>:
      switch (*format) 
c0027cfc:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027d00 <.L107>:
            void *p = va_arg (args, void *);
c0027d00:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027d04:	8d 70 04             	lea    0x4(%eax),%esi
c0027d07:	8b 00                	mov    (%eax),%eax
            c.flags = POUND;
c0027d09:	c7 44 24 40 08 00 00 	movl   $0x8,0x40(%esp)
c0027d10:	00 
            format_integer ((uintptr_t) p, false, false,
c0027d11:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d16:	83 ec 0c             	sub    $0xc,%esp
c0027d19:	55                   	push   %ebp
c0027d1a:	57                   	push   %edi
c0027d1b:	8d 4c 24 54          	lea    0x54(%esp),%ecx
c0027d1f:	51                   	push   %ecx
c0027d20:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0027d24:	8d 89 bc 05 00 00    	lea    0x5bc(%ecx),%ecx
c0027d2a:	51                   	push   %ecx
c0027d2b:	6a 00                	push   $0x0
c0027d2d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027d32:	e8 ea f3 ff ff       	call   c0027121 <format_integer>
          break;
c0027d37:	83 c4 20             	add    $0x20,%esp
c0027d3a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
            void *p = va_arg (args, void *);
c0027d3e:	89 74 24 74          	mov    %esi,0x74(%esp)
          break;
c0027d42:	e9 2f f8 ff ff       	jmp    c0027576 <__vprintf+0x44>

c0027d47 <.L151>:
      switch (*format) 
c0027d47:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027d4b <.L102>:
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027d4b:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027d4f:	55                   	push   %ebp
c0027d50:	57                   	push   %edi
c0027d51:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027d55:	8d 80 a3 67 ff ff    	lea    -0x985d(%eax),%eax
c0027d5b:	50                   	push   %eax
c0027d5c:	e8 b4 f7 ff ff       	call   c0027515 <__printf>
          break;
c0027d61:	83 c4 10             	add    $0x10,%esp
c0027d64:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0027d68:	e9 09 f8 ff ff       	jmp    c0027576 <__vprintf+0x44>

c0027d6d <.L150>:
      switch (*format) 
c0027d6d:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027d71 <.L101>:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027d71:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027d75:	55                   	push   %ebp
c0027d76:	57                   	push   %edi
c0027d77:	8b 44 24 18          	mov    0x18(%esp),%eax
c0027d7b:	8d 80 b9 67 ff ff    	lea    -0x9847(%eax),%eax
c0027d81:	50                   	push   %eax
c0027d82:	e8 8e f7 ff ff       	call   c0027515 <__printf>
          break;
c0027d87:	83 c4 10             	add    $0x10,%esp
c0027d8a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0027d8e:	e9 e3 f7 ff ff       	jmp    c0027576 <__vprintf+0x44>

c0027d93 <vsnprintf>:
{
c0027d93:	56                   	push   %esi
c0027d94:	53                   	push   %ebx
c0027d95:	83 ec 14             	sub    $0x14,%esp
c0027d98:	e8 e8 6c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0027d9d:	81 c3 17 31 01 00    	add    $0x13117,%ebx
c0027da3:	8b 44 24 24          	mov    0x24(%esp),%eax
c0027da7:	8b 54 24 28          	mov    0x28(%esp),%edx
c0027dab:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c0027daf:	8b 74 24 20          	mov    0x20(%esp),%esi
c0027db3:	89 74 24 04          	mov    %esi,0x4(%esp)
  aux.length = 0;
c0027db7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027dbe:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027dbf:	85 c0                	test   %eax,%eax
c0027dc1:	74 2e                	je     c0027df1 <vsnprintf+0x5e>
c0027dc3:	83 e8 01             	sub    $0x1,%eax
c0027dc6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027dca:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027dce:	50                   	push   %eax
c0027dcf:	8d 83 1a c2 fe ff    	lea    -0x13de6(%ebx),%eax
c0027dd5:	50                   	push   %eax
c0027dd6:	51                   	push   %ecx
c0027dd7:	52                   	push   %edx
c0027dd8:	e8 55 f7 ff ff       	call   c0027532 <__vprintf>
    *aux.p = '\0';
c0027ddd:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027de1:	c6 00 00             	movb   $0x0,(%eax)
c0027de4:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c0027de7:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c0027deb:	83 c4 14             	add    $0x14,%esp
c0027dee:	5b                   	pop    %ebx
c0027def:	5e                   	pop    %esi
c0027df0:	c3                   	ret    
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027df1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027df8:	00 
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027df9:	8d 44 24 04          	lea    0x4(%esp),%eax
c0027dfd:	50                   	push   %eax
c0027dfe:	8d 83 1a c2 fe ff    	lea    -0x13de6(%ebx),%eax
c0027e04:	50                   	push   %eax
c0027e05:	51                   	push   %ecx
c0027e06:	52                   	push   %edx
c0027e07:	e8 26 f7 ff ff       	call   c0027532 <__vprintf>
c0027e0c:	83 c4 10             	add    $0x10,%esp
c0027e0f:	eb d6                	jmp    c0027de7 <vsnprintf+0x54>

c0027e11 <snprintf>:
{
c0027e11:	83 ec 0c             	sub    $0xc,%esp
  va_start (args, format);
c0027e14:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0027e18:	50                   	push   %eax
c0027e19:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027e1d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027e21:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027e25:	e8 69 ff ff ff       	call   c0027d93 <vsnprintf>
}
c0027e2a:	83 c4 1c             	add    $0x1c,%esp
c0027e2d:	c3                   	ret    

c0027e2e <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027e2e:	55                   	push   %ebp
c0027e2f:	57                   	push   %edi
c0027e30:	56                   	push   %esi
c0027e31:	53                   	push   %ebx
c0027e32:	83 ec 1c             	sub    $0x1c,%esp
c0027e35:	e8 53 6c 00 00       	call   c002ea8d <__x86.get_pc_thunk.di>
c0027e3a:	81 c7 7a 30 01 00    	add    $0x1307a,%edi
c0027e40:	0f b6 44 24 3c       	movzbl 0x3c(%esp),%eax
c0027e45:	88 44 24 0b          	mov    %al,0xb(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0027e49:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0027e4e:	0f 84 c6 01 00 00    	je     c002801a <hex_dump+0x1ec>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027e54:	8d 87 d0 67 ff ff    	lea    -0x9830(%edi),%eax
c0027e5a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027e5e:	e9 9b 00 00 00       	jmp    c0027efe <hex_dump+0xd0>
      for (i = 0; i < start; i++)
c0027e63:	89 eb                	mov    %ebp,%ebx
c0027e65:	e9 02 01 00 00       	jmp    c0027f6c <hex_dump+0x13e>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0027e6a:	89 ee                	mov    %ebp,%esi
            printf (" ");
          for (; i < end; i++)
c0027e6c:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0027e71:	0f 84 9a 01 00 00    	je     c0028011 <hex_dump+0x1e3>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027e77:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027e7b:	29 e8                	sub    %ebp,%eax
c0027e7d:	89 c5                	mov    %eax,%ebp
c0027e7f:	0f b6 44 35 00       	movzbl 0x0(%ebp,%esi,1),%eax
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027e84:	0f b6 d0             	movzbl %al,%edx
c0027e87:	83 ea 20             	sub    $0x20,%edx
c0027e8a:	83 fa 5f             	cmp    $0x5f,%edx
c0027e8d:	b9 2e 00 00 00       	mov    $0x2e,%ecx
c0027e92:	0f 43 c1             	cmovae %ecx,%eax
            printf ("%c",
c0027e95:	83 ec 0c             	sub    $0xc,%esp
c0027e98:	0f b6 c0             	movzbl %al,%eax
c0027e9b:	50                   	push   %eax
c0027e9c:	89 fb                	mov    %edi,%ebx
c0027e9e:	e8 2f 34 00 00       	call   c002b2d2 <putchar>
          for (; i < end; i++)
c0027ea3:	83 c6 01             	add    $0x1,%esi
c0027ea6:	83 c4 10             	add    $0x10,%esp
c0027ea9:	39 34 24             	cmp    %esi,(%esp)
c0027eac:	77 d1                	ja     c0027e7f <hex_dump+0x51>
          for (; i < per_line; i++)
c0027eae:	83 fe 0f             	cmp    $0xf,%esi
c0027eb1:	77 17                	ja     c0027eca <hex_dump+0x9c>
            printf (" ");
c0027eb3:	83 ec 0c             	sub    $0xc,%esp
c0027eb6:	6a 20                	push   $0x20
c0027eb8:	89 fb                	mov    %edi,%ebx
c0027eba:	e8 13 34 00 00       	call   c002b2d2 <putchar>
          for (; i < per_line; i++)
c0027ebf:	83 c6 01             	add    $0x1,%esi
c0027ec2:	83 c4 10             	add    $0x10,%esp
c0027ec5:	83 fe 0f             	cmp    $0xf,%esi
c0027ec8:	76 e9                	jbe    c0027eb3 <hex_dump+0x85>
          printf ("|");
c0027eca:	83 ec 0c             	sub    $0xc,%esp
c0027ecd:	6a 7c                	push   $0x7c
c0027ecf:	89 fb                	mov    %edi,%ebx
c0027ed1:	e8 fc 33 00 00       	call   c002b2d2 <putchar>
c0027ed6:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027ed9:	83 ec 0c             	sub    $0xc,%esp
c0027edc:	6a 0a                	push   $0xa
c0027ede:	89 fb                	mov    %edi,%ebx
c0027ee0:	e8 ed 33 00 00       	call   c002b2d2 <putchar>

      ofs += n;
c0027ee5:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027ee9:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
c0027eed:	01 44 24 44          	add    %eax,0x44(%esp)
  while (size > 0)
c0027ef1:	83 c4 10             	add    $0x10,%esp
c0027ef4:	29 44 24 38          	sub    %eax,0x38(%esp)
c0027ef8:	0f 84 1c 01 00 00    	je     c002801a <hex_dump+0x1ec>
      start = ofs % per_line;
c0027efe:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0027f02:	83 e5 0f             	and    $0xf,%ebp
      if (end - start > size)
c0027f05:	ba 10 00 00 00       	mov    $0x10,%edx
c0027f0a:	29 ea                	sub    %ebp,%edx
        end = start + size;
c0027f0c:	89 e8                	mov    %ebp,%eax
c0027f0e:	03 44 24 38          	add    0x38(%esp),%eax
c0027f12:	3b 54 24 38          	cmp    0x38(%esp),%edx
c0027f16:	b9 10 00 00 00       	mov    $0x10,%ecx
c0027f1b:	0f 46 c1             	cmovbe %ecx,%eax
c0027f1e:	89 04 24             	mov    %eax,(%esp)
      n = end - start;
c0027f21:	29 e8                	sub    %ebp,%eax
c0027f23:	89 44 24 04          	mov    %eax,0x4(%esp)
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027f27:	83 ec 04             	sub    $0x4,%esp
c0027f2a:	8b 44 24 34          	mov    0x34(%esp),%eax
c0027f2e:	83 e0 f0             	and    $0xfffffff0,%eax
c0027f31:	ba 00 00 00 00       	mov    $0x0,%edx
c0027f36:	52                   	push   %edx
c0027f37:	50                   	push   %eax
c0027f38:	ff 74 24 18          	pushl  0x18(%esp)
c0027f3c:	e8 af f5 ff ff       	call   c00274f0 <printf>
      for (i = 0; i < start; i++)
c0027f41:	83 c4 10             	add    $0x10,%esp
c0027f44:	85 ed                	test   %ebp,%ebp
c0027f46:	0f 84 17 ff ff ff    	je     c0027e63 <hex_dump+0x35>
c0027f4c:	bb 00 00 00 00       	mov    $0x0,%ebx
        printf ("   ");
c0027f51:	8d b7 d8 67 ff ff    	lea    -0x9828(%edi),%esi
c0027f57:	83 ec 0c             	sub    $0xc,%esp
c0027f5a:	56                   	push   %esi
c0027f5b:	e8 90 f5 ff ff       	call   c00274f0 <printf>
      for (i = 0; i < start; i++)
c0027f60:	83 c3 01             	add    $0x1,%ebx
c0027f63:	83 c4 10             	add    $0x10,%esp
c0027f66:	39 dd                	cmp    %ebx,%ebp
c0027f68:	75 ed                	jne    c0027f57 <hex_dump+0x129>
c0027f6a:	89 eb                	mov    %ebp,%ebx
      for (; i < end; i++) 
c0027f6c:	39 1c 24             	cmp    %ebx,(%esp)
c0027f6f:	76 36                	jbe    c0027fa7 <hex_dump+0x179>
        printf ("%02hhx%c",
c0027f71:	be 20 00 00 00       	mov    $0x20,%esi
c0027f76:	83 fb 07             	cmp    $0x7,%ebx
c0027f79:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027f7e:	0f 45 c6             	cmovne %esi,%eax
c0027f81:	83 ec 04             	sub    $0x4,%esp
c0027f84:	50                   	push   %eax
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027f85:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0027f89:	29 e8                	sub    %ebp,%eax
        printf ("%02hhx%c",
c0027f8b:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
c0027f8f:	50                   	push   %eax
c0027f90:	8d 87 dc 67 ff ff    	lea    -0x9824(%edi),%eax
c0027f96:	50                   	push   %eax
c0027f97:	e8 54 f5 ff ff       	call   c00274f0 <printf>
      for (; i < end; i++) 
c0027f9c:	83 c3 01             	add    $0x1,%ebx
c0027f9f:	83 c4 10             	add    $0x10,%esp
c0027fa2:	39 1c 24             	cmp    %ebx,(%esp)
c0027fa5:	75 cf                	jne    c0027f76 <hex_dump+0x148>
      if (ascii) 
c0027fa7:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
c0027fac:	0f 84 27 ff ff ff    	je     c0027ed9 <hex_dump+0xab>
          for (; i < per_line; i++)
c0027fb2:	83 fb 0f             	cmp    $0xf,%ebx
c0027fb5:	77 1a                	ja     c0027fd1 <hex_dump+0x1a3>
            printf ("   ");
c0027fb7:	8d b7 d8 67 ff ff    	lea    -0x9828(%edi),%esi
c0027fbd:	83 ec 0c             	sub    $0xc,%esp
c0027fc0:	56                   	push   %esi
c0027fc1:	e8 2a f5 ff ff       	call   c00274f0 <printf>
          for (; i < per_line; i++)
c0027fc6:	83 c3 01             	add    $0x1,%ebx
c0027fc9:	83 c4 10             	add    $0x10,%esp
c0027fcc:	83 fb 10             	cmp    $0x10,%ebx
c0027fcf:	75 ec                	jne    c0027fbd <hex_dump+0x18f>
          printf ("|");
c0027fd1:	83 ec 0c             	sub    $0xc,%esp
c0027fd4:	6a 7c                	push   $0x7c
c0027fd6:	89 fb                	mov    %edi,%ebx
c0027fd8:	e8 f5 32 00 00       	call   c002b2d2 <putchar>
          for (i = 0; i < start; i++)
c0027fdd:	83 c4 10             	add    $0x10,%esp
c0027fe0:	85 ed                	test   %ebp,%ebp
c0027fe2:	0f 84 82 fe ff ff    	je     c0027e6a <hex_dump+0x3c>
c0027fe8:	be 00 00 00 00       	mov    $0x0,%esi
            printf (" ");
c0027fed:	83 ec 0c             	sub    $0xc,%esp
c0027ff0:	6a 20                	push   $0x20
c0027ff2:	89 fb                	mov    %edi,%ebx
c0027ff4:	e8 d9 32 00 00       	call   c002b2d2 <putchar>
          for (i = 0; i < start; i++)
c0027ff9:	83 c6 01             	add    $0x1,%esi
c0027ffc:	83 c4 10             	add    $0x10,%esp
c0027fff:	39 f5                	cmp    %esi,%ebp
c0028001:	75 ea                	jne    c0027fed <hex_dump+0x1bf>
          for (; i < end; i++)
c0028003:	39 34 24             	cmp    %esi,(%esp)
c0028006:	0f 87 6b fe ff ff    	ja     c0027e77 <hex_dump+0x49>
c002800c:	e9 9d fe ff ff       	jmp    c0027eae <hex_dump+0x80>
          for (i = 0; i < start; i++)
c0028011:	8b 74 24 04          	mov    0x4(%esp),%esi
c0028015:	e9 99 fe ff ff       	jmp    c0027eb3 <hex_dump+0x85>
      size -= n;
    }
}
c002801a:	83 c4 1c             	add    $0x1c,%esp
c002801d:	5b                   	pop    %ebx
c002801e:	5e                   	pop    %esi
c002801f:	5f                   	pop    %edi
c0028020:	5d                   	pop    %ebp
c0028021:	c3                   	ret    

c0028022 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0028022:	57                   	push   %edi
c0028023:	56                   	push   %esi
c0028024:	53                   	push   %ebx
c0028025:	e8 6f 6a 00 00       	call   c002ea99 <__x86.get_pc_thunk.dx>
c002802a:	81 c2 8a 2e 01 00    	add    $0x12e8a,%edx
c0028030:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028034:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c0028038:	89 f0                	mov    %esi,%eax
c002803a:	83 f0 01             	xor    $0x1,%eax
c002803d:	89 f9                	mov    %edi,%ecx
c002803f:	09 c1                	or     %eax,%ecx
c0028041:	74 24                	je     c0028067 <print_human_readable_size+0x45>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0028043:	83 ff 00             	cmp    $0x0,%edi
c0028046:	77 0e                	ja     c0028056 <print_human_readable_size+0x34>
c0028048:	8d 82 0c 06 00 00    	lea    0x60c(%edx),%eax
c002804e:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0028054:	76 42                	jbe    c0028098 <print_human_readable_size+0x76>
c0028056:	8d 82 0c 06 00 00    	lea    0x60c(%edx),%eax
c002805c:	83 ba 10 06 00 00 00 	cmpl   $0x0,0x610(%edx)
c0028063:	75 1c                	jne    c0028081 <print_human_readable_size+0x5f>
c0028065:	eb 31                	jmp    c0028098 <print_human_readable_size+0x76>
    printf ("1 byte");
c0028067:	83 ec 0c             	sub    $0xc,%esp
c002806a:	8d 82 e5 67 ff ff    	lea    -0x981b(%edx),%eax
c0028070:	50                   	push   %eax
c0028071:	e8 7a f4 ff ff       	call   c00274f0 <printf>
c0028076:	83 c4 10             	add    $0x10,%esp
c0028079:	eb 30                	jmp    c00280ab <print_human_readable_size+0x89>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002807b:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002807f:	74 17                	je     c0028098 <print_human_readable_size+0x76>
        size /= 1024;
c0028081:	0f ac fe 0a          	shrd   $0xa,%edi,%esi
c0028085:	c1 ef 0a             	shr    $0xa,%edi
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0028088:	83 c0 04             	add    $0x4,%eax
c002808b:	83 ff 00             	cmp    $0x0,%edi
c002808e:	77 eb                	ja     c002807b <print_human_readable_size+0x59>
c0028090:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0028096:	77 e3                	ja     c002807b <print_human_readable_size+0x59>
      printf ("%"PRIu64" %s", size, *fp);
c0028098:	ff 30                	pushl  (%eax)
c002809a:	57                   	push   %edi
c002809b:	56                   	push   %esi
c002809c:	8d 82 ec 67 ff ff    	lea    -0x9814(%edx),%eax
c00280a2:	50                   	push   %eax
c00280a3:	e8 48 f4 ff ff       	call   c00274f0 <printf>
c00280a8:	83 c4 10             	add    $0x10,%esp
    }
}
c00280ab:	5b                   	pop    %ebx
c00280ac:	5e                   	pop    %esi
c00280ad:	5f                   	pop    %edi
c00280ae:	c3                   	ret    

c00280af <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c00280af:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c00280b2:	ff 74 24 1c          	pushl  0x1c(%esp)
c00280b6:	ff 74 24 1c          	pushl  0x1c(%esp)
c00280ba:	8b 44 24 28          	mov    0x28(%esp),%eax
c00280be:	ff 10                	call   *(%eax)
}
c00280c0:	83 c4 1c             	add    $0x1c,%esp
c00280c3:	c3                   	ret    

c00280c4 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00280c4:	55                   	push   %ebp
c00280c5:	57                   	push   %edi
c00280c6:	56                   	push   %esi
c00280c7:	53                   	push   %ebx
c00280c8:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c00280cc:	8d 5a ff             	lea    -0x1(%edx),%ebx
c00280cf:	0f af df             	imul   %edi,%ebx
  unsigned char *b = array + (b_idx - 1) * size;
c00280d2:	83 e9 01             	sub    $0x1,%ecx
c00280d5:	0f af cf             	imul   %edi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c00280d8:	85 ff                	test   %edi,%edi
c00280da:	74 23                	je     c00280ff <do_swap+0x3b>
c00280dc:	89 dd                	mov    %ebx,%ebp
c00280de:	8d 14 18             	lea    (%eax,%ebx,1),%edx
c00280e1:	01 f8                	add    %edi,%eax
c00280e3:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
    {
      unsigned char t = a[i];
c00280e6:	0f b6 32             	movzbl (%edx),%esi
c00280e9:	89 d0                	mov    %edx,%eax
c00280eb:	29 e8                	sub    %ebp,%eax
      a[i] = b[i];
c00280ed:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
c00280f1:	88 1a                	mov    %bl,(%edx)
      b[i] = t;
c00280f3:	89 f3                	mov    %esi,%ebx
c00280f5:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
c00280f8:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < size; i++)
c00280fb:	39 fa                	cmp    %edi,%edx
c00280fd:	75 e7                	jne    c00280e6 <do_swap+0x22>
    }
}
c00280ff:	5b                   	pop    %ebx
c0028100:	5e                   	pop    %esi
c0028101:	5f                   	pop    %edi
c0028102:	5d                   	pop    %ebp
c0028103:	c3                   	ret    

c0028104 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0028104:	55                   	push   %ebp
c0028105:	57                   	push   %edi
c0028106:	56                   	push   %esi
c0028107:	53                   	push   %ebx
c0028108:	83 ec 1c             	sub    $0x1c,%esp
c002810b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002810f:	89 d7                	mov    %edx,%edi
c0028111:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0028115:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0028119:	eb 4a                	jmp    c0028165 <heapify+0x61>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c002811b:	83 ec 04             	sub    $0x4,%esp
c002811e:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028122:	8d 47 ff             	lea    -0x1(%edi),%eax
c0028125:	0f af c5             	imul   %ebp,%eax
c0028128:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002812c:	01 c8                	add    %ecx,%eax
c002812e:	50                   	push   %eax
c002812f:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0028132:	0f af c5             	imul   %ebp,%eax
c0028135:	01 c8                	add    %ecx,%eax
c0028137:	50                   	push   %eax
c0028138:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c002813c:	83 c4 10             	add    $0x10,%esp
c002813f:	85 c0                	test   %eax,%eax
c0028141:	7e 2e                	jle    c0028171 <heapify+0x6d>
        max = left;
      if (right <= cnt
c0028143:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0028147:	76 5b                	jbe    c00281a4 <heapify+0xa0>
        max = left;
c0028149:	89 de                	mov    %ebx,%esi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c002814b:	39 f7                	cmp    %esi,%edi
c002814d:	74 4d                	je     c002819c <heapify+0x98>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c002814f:	83 ec 0c             	sub    $0xc,%esp
c0028152:	55                   	push   %ebp
c0028153:	89 f1                	mov    %esi,%ecx
c0028155:	89 fa                	mov    %edi,%edx
c0028157:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002815b:	e8 64 ff ff ff       	call   c00280c4 <do_swap>
c0028160:	89 f7                	mov    %esi,%edi
    {
c0028162:	83 c4 10             	add    $0x10,%esp
      size_t left = 2 * i;
c0028165:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
      size_t right = 2 * i + 1;
c0028168:	8d 73 01             	lea    0x1(%ebx),%esi
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c002816b:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c002816f:	76 aa                	jbe    c002811b <heapify+0x17>
      if (right <= cnt
c0028171:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0028175:	77 25                	ja     c002819c <heapify+0x98>
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028177:	83 ec 04             	sub    $0x4,%esp
c002817a:	ff 74 24 3c          	pushl  0x3c(%esp)
c002817e:	8d 47 ff             	lea    -0x1(%edi),%eax
c0028181:	0f af c5             	imul   %ebp,%eax
c0028184:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028188:	01 d0                	add    %edx,%eax
c002818a:	50                   	push   %eax
c002818b:	0f af dd             	imul   %ebp,%ebx
c002818e:	01 d3                	add    %edx,%ebx
c0028190:	53                   	push   %ebx
c0028191:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028195:	83 c4 10             	add    $0x10,%esp
c0028198:	85 c0                	test   %eax,%eax
c002819a:	7f af                	jg     c002814b <heapify+0x47>
      i = max;
    }
}
c002819c:	83 c4 1c             	add    $0x1c,%esp
c002819f:	5b                   	pop    %ebx
c00281a0:	5e                   	pop    %esi
c00281a1:	5f                   	pop    %edi
c00281a2:	5d                   	pop    %ebp
c00281a3:	c3                   	ret    
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00281a4:	83 ec 04             	sub    $0x4,%esp
c00281a7:	ff 74 24 3c          	pushl  0x3c(%esp)
c00281ab:	8d 43 ff             	lea    -0x1(%ebx),%eax
c00281ae:	0f af c5             	imul   %ebp,%eax
c00281b1:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00281b5:	01 c8                	add    %ecx,%eax
c00281b7:	50                   	push   %eax
c00281b8:	89 d8                	mov    %ebx,%eax
c00281ba:	0f af c5             	imul   %ebp,%eax
c00281bd:	01 c8                	add    %ecx,%eax
c00281bf:	50                   	push   %eax
c00281c0:	ff 54 24 44          	call   *0x44(%esp)
          && do_compare (array, right, max, size, compare, aux) > 0) 
c00281c4:	83 c4 10             	add    $0x10,%esp
c00281c7:	85 c0                	test   %eax,%eax
        max = left;
c00281c9:	0f 4e f3             	cmovle %ebx,%esi
c00281cc:	e9 7a ff ff ff       	jmp    c002814b <heapify+0x47>

c00281d1 <atoi>:
{
c00281d1:	56                   	push   %esi
c00281d2:	53                   	push   %ebx
c00281d3:	83 ec 04             	sub    $0x4,%esp
c00281d6:	e8 aa 68 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00281db:	81 c3 d9 2c 01 00    	add    $0x12cd9,%ebx
c00281e1:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (s != NULL);
c00281e5:	85 d2                	test   %edx,%edx
c00281e7:	75 29                	jne    c0028212 <atoi+0x41>
c00281e9:	83 ec 0c             	sub    $0xc,%esp
c00281ec:	8d 83 8b 68 ff ff    	lea    -0x9775(%ebx),%eax
c00281f2:	50                   	push   %eax
c00281f3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00281f9:	50                   	push   %eax
c00281fa:	8d 83 04 49 ff ff    	lea    -0xb6fc(%ebx),%eax
c0028200:	50                   	push   %eax
c0028201:	6a 0f                	push   $0xf
c0028203:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c0028209:	50                   	push   %eax
c002820a:	e8 78 10 00 00       	call   c0029287 <debug_panic>
    s++;
c002820f:	83 c2 01             	add    $0x1,%edx
  while (isspace ((unsigned char) *s))
c0028212:	0f b6 02             	movzbl (%edx),%eax
          || c == '\r' || c == '\t' || c == '\v');
c0028215:	3c 20                	cmp    $0x20,%al
c0028217:	74 f6                	je     c002820f <atoi+0x3e>
c0028219:	8d 48 f7             	lea    -0x9(%eax),%ecx
c002821c:	80 f9 04             	cmp    $0x4,%cl
c002821f:	76 ee                	jbe    c002820f <atoi+0x3e>
  if (*s == '+')
c0028221:	3c 2b                	cmp    $0x2b,%al
c0028223:	74 40                	je     c0028265 <atoi+0x94>
  negative = false;
c0028225:	bb 00 00 00 00       	mov    $0x0,%ebx
  else if (*s == '-')
c002822a:	3c 2d                	cmp    $0x2d,%al
c002822c:	74 41                	je     c002826f <atoi+0x9e>
  for (value = 0; isdigit (*s); s++)
c002822e:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0028231:	8d 41 d0             	lea    -0x30(%ecx),%eax
c0028234:	83 f8 09             	cmp    $0x9,%eax
c0028237:	77 40                	ja     c0028279 <atoi+0xa8>
c0028239:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c002823e:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0028241:	01 c0                	add    %eax,%eax
c0028243:	83 e9 30             	sub    $0x30,%ecx
c0028246:	29 c8                	sub    %ecx,%eax
  for (value = 0; isdigit (*s); s++)
c0028248:	83 c2 01             	add    $0x1,%edx
c002824b:	0f be 0a             	movsbl (%edx),%ecx
c002824e:	8d 71 d0             	lea    -0x30(%ecx),%esi
c0028251:	83 fe 09             	cmp    $0x9,%esi
c0028254:	76 e8                	jbe    c002823e <atoi+0x6d>
    value = -value;
c0028256:	89 c2                	mov    %eax,%edx
c0028258:	f7 da                	neg    %edx
c002825a:	84 db                	test   %bl,%bl
c002825c:	0f 44 c2             	cmove  %edx,%eax
}
c002825f:	83 c4 04             	add    $0x4,%esp
c0028262:	5b                   	pop    %ebx
c0028263:	5e                   	pop    %esi
c0028264:	c3                   	ret    
    s++;
c0028265:	83 c2 01             	add    $0x1,%edx
  negative = false;
c0028268:	bb 00 00 00 00       	mov    $0x0,%ebx
c002826d:	eb bf                	jmp    c002822e <atoi+0x5d>
      s++;
c002826f:	83 c2 01             	add    $0x1,%edx
      negative = true;
c0028272:	bb 01 00 00 00       	mov    $0x1,%ebx
c0028277:	eb b5                	jmp    c002822e <atoi+0x5d>
  for (value = 0; isdigit (*s); s++)
c0028279:	b8 00 00 00 00       	mov    $0x0,%eax
c002827e:	eb d6                	jmp    c0028256 <atoi+0x85>

c0028280 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0028280:	55                   	push   %ebp
c0028281:	57                   	push   %edi
c0028282:	56                   	push   %esi
c0028283:	53                   	push   %ebx
c0028284:	83 ec 0c             	sub    $0xc,%esp
c0028287:	e8 f9 67 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002828c:	81 c3 28 2c 01 00    	add    $0x12c28,%ebx
c0028292:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0028296:	8b 74 24 24          	mov    0x24(%esp),%esi
c002829a:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c002829e:	85 ff                	test   %edi,%edi
c00282a0:	75 08                	jne    c00282aa <sort+0x2a>
c00282a2:	85 f6                	test   %esi,%esi
c00282a4:	0f 85 93 00 00 00    	jne    c002833d <sort+0xbd>
  ASSERT (compare != NULL);
c00282aa:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c00282af:	0f 84 b1 00 00 00    	je     c0028366 <sort+0xe6>
  ASSERT (size > 0);
c00282b5:	85 ed                	test   %ebp,%ebp
c00282b7:	0f 84 d2 00 00 00    	je     c002838f <sort+0x10f>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00282bd:	89 f3                	mov    %esi,%ebx
c00282bf:	d1 eb                	shr    %ebx
c00282c1:	74 33                	je     c00282f6 <sort+0x76>
c00282c3:	89 74 24 24          	mov    %esi,0x24(%esp)
c00282c7:	89 fe                	mov    %edi,%esi
c00282c9:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify (array, i, cnt, size, compare, aux);
c00282cd:	83 ec 04             	sub    $0x4,%esp
c00282d0:	ff 74 24 34          	pushl  0x34(%esp)
c00282d4:	ff 74 24 34          	pushl  0x34(%esp)
c00282d8:	55                   	push   %ebp
c00282d9:	89 f9                	mov    %edi,%ecx
c00282db:	89 da                	mov    %ebx,%edx
c00282dd:	89 f0                	mov    %esi,%eax
c00282df:	e8 20 fe ff ff       	call   c0028104 <heapify>
  for (i = cnt / 2; i > 0; i--)
c00282e4:	83 c4 10             	add    $0x10,%esp
c00282e7:	83 eb 01             	sub    $0x1,%ebx
c00282ea:	75 e1                	jne    c00282cd <sort+0x4d>
c00282ec:	89 7c 24 24          	mov    %edi,0x24(%esp)
c00282f0:	89 f7                	mov    %esi,%edi
c00282f2:	8b 74 24 24          	mov    0x24(%esp),%esi

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c00282f6:	83 fe 01             	cmp    $0x1,%esi
c00282f9:	76 3a                	jbe    c0028335 <sort+0xb5>
c00282fb:	89 fb                	mov    %edi,%ebx
c00282fd:	8b 7c 24 30          	mov    0x30(%esp),%edi
    {
      do_swap (array, 1, i, size);
c0028301:	83 ec 0c             	sub    $0xc,%esp
c0028304:	55                   	push   %ebp
c0028305:	89 f1                	mov    %esi,%ecx
c0028307:	ba 01 00 00 00       	mov    $0x1,%edx
c002830c:	89 d8                	mov    %ebx,%eax
c002830e:	e8 b1 fd ff ff       	call   c00280c4 <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c0028313:	83 ee 01             	sub    $0x1,%esi
c0028316:	83 c4 0c             	add    $0xc,%esp
c0028319:	57                   	push   %edi
c002831a:	ff 74 24 34          	pushl  0x34(%esp)
c002831e:	55                   	push   %ebp
c002831f:	89 f1                	mov    %esi,%ecx
c0028321:	ba 01 00 00 00       	mov    $0x1,%edx
c0028326:	89 d8                	mov    %ebx,%eax
c0028328:	e8 d7 fd ff ff       	call   c0028104 <heapify>
  for (i = cnt; i > 1; i--) 
c002832d:	83 c4 10             	add    $0x10,%esp
c0028330:	83 fe 01             	cmp    $0x1,%esi
c0028333:	75 cc                	jne    c0028301 <sort+0x81>
    }
}
c0028335:	83 c4 0c             	add    $0xc,%esp
c0028338:	5b                   	pop    %ebx
c0028339:	5e                   	pop    %esi
c002833a:	5f                   	pop    %edi
c002833b:	5d                   	pop    %ebp
c002833c:	c3                   	ret    
  ASSERT (array != NULL || cnt == 0);
c002833d:	83 ec 0c             	sub    $0xc,%esp
c0028340:	8d 83 4f 68 ff ff    	lea    -0x97b1(%ebx),%eax
c0028346:	50                   	push   %eax
c0028347:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002834d:	50                   	push   %eax
c002834e:	8d 83 fc 48 ff ff    	lea    -0xb704(%ebx),%eax
c0028354:	50                   	push   %eax
c0028355:	68 8a 00 00 00       	push   $0x8a
c002835a:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c0028360:	50                   	push   %eax
c0028361:	e8 21 0f 00 00       	call   c0029287 <debug_panic>
  ASSERT (compare != NULL);
c0028366:	83 ec 0c             	sub    $0xc,%esp
c0028369:	8d 83 69 68 ff ff    	lea    -0x9797(%ebx),%eax
c002836f:	50                   	push   %eax
c0028370:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028376:	50                   	push   %eax
c0028377:	8d 83 fc 48 ff ff    	lea    -0xb704(%ebx),%eax
c002837d:	50                   	push   %eax
c002837e:	68 8b 00 00 00       	push   $0x8b
c0028383:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c0028389:	50                   	push   %eax
c002838a:	e8 f8 0e 00 00       	call   c0029287 <debug_panic>
  ASSERT (size > 0);
c002838f:	83 ec 0c             	sub    $0xc,%esp
c0028392:	8d 83 79 68 ff ff    	lea    -0x9787(%ebx),%eax
c0028398:	50                   	push   %eax
c0028399:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002839f:	50                   	push   %eax
c00283a0:	8d 83 fc 48 ff ff    	lea    -0xb704(%ebx),%eax
c00283a6:	50                   	push   %eax
c00283a7:	68 8c 00 00 00       	push   $0x8c
c00283ac:	8d 83 3c 68 ff ff    	lea    -0x97c4(%ebx),%eax
c00283b2:	50                   	push   %eax
c00283b3:	e8 cf 0e 00 00       	call   c0029287 <debug_panic>

c00283b8 <qsort>:
{
c00283b8:	83 ec 18             	sub    $0x18,%esp
c00283bb:	e8 c9 66 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c00283c0:	05 f4 2a 01 00       	add    $0x12af4,%eax
  sort (array, cnt, size, compare_thunk, &compare);
c00283c5:	8d 54 24 28          	lea    0x28(%esp),%edx
c00283c9:	52                   	push   %edx
c00283ca:	8d 80 fb d1 fe ff    	lea    -0x12e05(%eax),%eax
c00283d0:	50                   	push   %eax
c00283d1:	ff 74 24 2c          	pushl  0x2c(%esp)
c00283d5:	ff 74 24 2c          	pushl  0x2c(%esp)
c00283d9:	ff 74 24 2c          	pushl  0x2c(%esp)
c00283dd:	e8 9e fe ff ff       	call   c0028280 <sort>
}
c00283e2:	83 c4 2c             	add    $0x2c,%esp
c00283e5:	c3                   	ret    

c00283e6 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c00283e6:	55                   	push   %ebp
c00283e7:	57                   	push   %edi
c00283e8:	56                   	push   %esi
c00283e9:	53                   	push   %ebx
c00283ea:	83 ec 0c             	sub    $0xc,%esp
c00283ed:	8b 74 24 24          	mov    0x24(%esp),%esi
c00283f1:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c00283f5:	89 fd                	mov    %edi,%ebp
c00283f7:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c00283fc:	01 f5                	add    %esi,%ebp

  while (first < last) 
c00283fe:	39 ee                	cmp    %ebp,%esi
c0028400:	72 0d                	jb     c002840f <binary_search+0x29>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c0028402:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028407:	eb 3e                	jmp    c0028447 <binary_search+0x61>
      const unsigned char *middle = first + (range / 2) * size;
c0028409:	89 dd                	mov    %ebx,%ebp
  while (first < last) 
c002840b:	39 ee                	cmp    %ebp,%esi
c002840d:	73 33                	jae    c0028442 <binary_search+0x5c>
      size_t range = (last - first) / size;
c002840f:	89 e8                	mov    %ebp,%eax
c0028411:	29 f0                	sub    %esi,%eax
c0028413:	ba 00 00 00 00       	mov    $0x0,%edx
c0028418:	f7 f7                	div    %edi
      const unsigned char *middle = first + (range / 2) * size;
c002841a:	d1 e8                	shr    %eax
c002841c:	0f af c7             	imul   %edi,%eax
c002841f:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c0028422:	83 ec 04             	sub    $0x4,%esp
c0028425:	ff 74 24 38          	pushl  0x38(%esp)
c0028429:	53                   	push   %ebx
c002842a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002842e:	ff 54 24 40          	call   *0x40(%esp)
      if (cmp < 0) 
c0028432:	83 c4 10             	add    $0x10,%esp
c0028435:	85 c0                	test   %eax,%eax
c0028437:	78 d0                	js     c0028409 <binary_search+0x23>
      else if (cmp > 0) 
c0028439:	85 c0                	test   %eax,%eax
c002843b:	7e 0a                	jle    c0028447 <binary_search+0x61>
        first = middle + size;
c002843d:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c0028440:	eb c9                	jmp    c002840b <binary_search+0x25>
  return NULL;
c0028442:	bb 00 00 00 00       	mov    $0x0,%ebx
}
c0028447:	89 d8                	mov    %ebx,%eax
c0028449:	83 c4 0c             	add    $0xc,%esp
c002844c:	5b                   	pop    %ebx
c002844d:	5e                   	pop    %esi
c002844e:	5f                   	pop    %edi
c002844f:	5d                   	pop    %ebp
c0028450:	c3                   	ret    

c0028451 <bsearch>:
{
c0028451:	83 ec 14             	sub    $0x14,%esp
c0028454:	e8 30 66 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0028459:	05 5b 2a 01 00       	add    $0x12a5b,%eax
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c002845e:	8d 54 24 28          	lea    0x28(%esp),%edx
c0028462:	52                   	push   %edx
c0028463:	8d 80 fb d1 fe ff    	lea    -0x12e05(%eax),%eax
c0028469:	50                   	push   %eax
c002846a:	ff 74 24 2c          	pushl  0x2c(%esp)
c002846e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028472:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028476:	ff 74 24 2c          	pushl  0x2c(%esp)
c002847a:	e8 67 ff ff ff       	call   c00283e6 <binary_search>
}
c002847f:	83 c4 2c             	add    $0x2c,%esp
c0028482:	c3                   	ret    

c0028483 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0028483:	56                   	push   %esi
c0028484:	53                   	push   %ebx
c0028485:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028489:	8b 74 24 10          	mov    0x10(%esp),%esi
c002848d:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c0028491:	85 db                	test   %ebx,%ebx
c0028493:	74 13                	je     c00284a8 <memcpy+0x25>
c0028495:	ba 00 00 00 00       	mov    $0x0,%edx
    *dst++ = *src++;
c002849a:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c002849e:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c00284a1:	83 c2 01             	add    $0x1,%edx
  while (size-- > 0)
c00284a4:	39 da                	cmp    %ebx,%edx
c00284a6:	75 f2                	jne    c002849a <memcpy+0x17>

  return dst_;
}
c00284a8:	5b                   	pop    %ebx
c00284a9:	5e                   	pop    %esi
c00284aa:	c3                   	ret    

c00284ab <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00284ab:	57                   	push   %edi
c00284ac:	56                   	push   %esi
c00284ad:	53                   	push   %ebx
c00284ae:	8b 44 24 10          	mov    0x10(%esp),%eax
c00284b2:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00284b6:	8b 7c 24 18          	mov    0x18(%esp),%edi
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
c00284ba:	39 c8                	cmp    %ecx,%eax
c00284bc:	73 1d                	jae    c00284db <memmove+0x30>
    {
      while (size-- > 0)
c00284be:	85 ff                	test   %edi,%edi
c00284c0:	74 15                	je     c00284d7 <memmove+0x2c>
c00284c2:	ba 00 00 00 00       	mov    $0x0,%edx
        *dst++ = *src++;
c00284c7:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c00284cb:	88 1c 10             	mov    %bl,(%eax,%edx,1)
c00284ce:	83 c2 01             	add    $0x1,%edx
      while (size-- > 0)
c00284d1:	39 fa                	cmp    %edi,%edx
c00284d3:	75 f2                	jne    c00284c7 <memmove+0x1c>
c00284d5:	01 d0                	add    %edx,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c00284d7:	5b                   	pop    %ebx
c00284d8:	5e                   	pop    %esi
c00284d9:	5f                   	pop    %edi
c00284da:	c3                   	ret    
      dst += size;
c00284db:	8d 34 38             	lea    (%eax,%edi,1),%esi
      while (size-- > 0)
c00284de:	8d 57 ff             	lea    -0x1(%edi),%edx
c00284e1:	85 ff                	test   %edi,%edi
c00284e3:	74 11                	je     c00284f6 <memmove+0x4b>
        *--dst = *--src;
c00284e5:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c00284e9:	88 1c 10             	mov    %bl,(%eax,%edx,1)
      while (size-- > 0)
c00284ec:	83 ea 01             	sub    $0x1,%edx
c00284ef:	83 fa ff             	cmp    $0xffffffff,%edx
c00284f2:	75 f1                	jne    c00284e5 <memmove+0x3a>
c00284f4:	eb e1                	jmp    c00284d7 <memmove+0x2c>
      dst += size;
c00284f6:	89 f0                	mov    %esi,%eax
c00284f8:	eb dd                	jmp    c00284d7 <memmove+0x2c>

c00284fa <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c00284fa:	57                   	push   %edi
c00284fb:	56                   	push   %esi
c00284fc:	53                   	push   %ebx
c00284fd:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028501:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0028505:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0028509:	85 db                	test   %ebx,%ebx
c002850b:	74 38                	je     c0028545 <memcmp+0x4b>
    if (*a != *b)
c002850d:	0f b6 16             	movzbl (%esi),%edx
c0028510:	0f b6 0f             	movzbl (%edi),%ecx
c0028513:	38 ca                	cmp    %cl,%dl
c0028515:	75 19                	jne    c0028530 <memcmp+0x36>
c0028517:	b8 01 00 00 00       	mov    $0x1,%eax
  for (; size-- > 0; a++, b++)
c002851c:	39 d8                	cmp    %ebx,%eax
c002851e:	74 1e                	je     c002853e <memcmp+0x44>
    if (*a != *b)
c0028520:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
c0028524:	83 c0 01             	add    $0x1,%eax
c0028527:	0f b6 4c 07 ff       	movzbl -0x1(%edi,%eax,1),%ecx
c002852c:	38 ca                	cmp    %cl,%dl
c002852e:	74 ec                	je     c002851c <memcmp+0x22>
      return *a > *b ? +1 : -1;
c0028530:	38 d1                	cmp    %dl,%cl
c0028532:	19 c0                	sbb    %eax,%eax
c0028534:	83 e0 02             	and    $0x2,%eax
c0028537:	83 e8 01             	sub    $0x1,%eax
  return 0;
}
c002853a:	5b                   	pop    %ebx
c002853b:	5e                   	pop    %esi
c002853c:	5f                   	pop    %edi
c002853d:	c3                   	ret    
  return 0;
c002853e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028543:	eb f5                	jmp    c002853a <memcmp+0x40>
c0028545:	b8 00 00 00 00       	mov    $0x0,%eax
c002854a:	eb ee                	jmp    c002853a <memcmp+0x40>

c002854c <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c002854c:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028550:	8b 54 24 08          	mov    0x8(%esp),%edx
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c0028554:	0f b6 01             	movzbl (%ecx),%eax
c0028557:	84 c0                	test   %al,%al
c0028559:	74 15                	je     c0028570 <strcmp+0x24>
c002855b:	3a 02                	cmp    (%edx),%al
c002855d:	75 11                	jne    c0028570 <strcmp+0x24>
    {
      a++;
c002855f:	83 c1 01             	add    $0x1,%ecx
      b++;
c0028562:	83 c2 01             	add    $0x1,%edx
  while (*a != '\0' && *a == *b) 
c0028565:	0f b6 01             	movzbl (%ecx),%eax
c0028568:	84 c0                	test   %al,%al
c002856a:	74 04                	je     c0028570 <strcmp+0x24>
c002856c:	3a 02                	cmp    (%edx),%al
c002856e:	74 ef                	je     c002855f <strcmp+0x13>
    }

  return *a < *b ? -1 : *a > *b;
c0028570:	0f b6 12             	movzbl (%edx),%edx
c0028573:	38 c2                	cmp    %al,%dl
c0028575:	77 07                	ja     c002857e <strcmp+0x32>
c0028577:	0f 92 c0             	setb   %al
c002857a:	0f b6 c0             	movzbl %al,%eax
c002857d:	c3                   	ret    
c002857e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028583:	c3                   	ret    

c0028584 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0028584:	53                   	push   %ebx
c0028585:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028589:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002858d:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0028591:	85 d2                	test   %edx,%edx
c0028593:	74 1c                	je     c00285b1 <memchr+0x2d>
c0028595:	89 d9                	mov    %ebx,%ecx
    if (*block == ch)
c0028597:	3a 18                	cmp    (%eax),%bl
c0028599:	74 14                	je     c00285af <memchr+0x2b>
c002859b:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c002859d:	83 c0 01             	add    $0x1,%eax
c00285a0:	39 c2                	cmp    %eax,%edx
c00285a2:	74 06                	je     c00285aa <memchr+0x26>
    if (*block == ch)
c00285a4:	38 08                	cmp    %cl,(%eax)
c00285a6:	75 f5                	jne    c002859d <memchr+0x19>
c00285a8:	eb 05                	jmp    c00285af <memchr+0x2b>
      return (void *) block;

  return NULL;
c00285aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00285af:	5b                   	pop    %ebx
c00285b0:	c3                   	ret    
  return NULL;
c00285b1:	b8 00 00 00 00       	mov    $0x0,%eax
c00285b6:	eb f7                	jmp    c00285af <memchr+0x2b>

c00285b8 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c00285b8:	53                   	push   %ebx
c00285b9:	8b 44 24 08          	mov    0x8(%esp),%eax
c00285bd:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c00285c1:	0f b6 18             	movzbl (%eax),%ebx
c00285c4:	38 da                	cmp    %bl,%dl
c00285c6:	74 19                	je     c00285e1 <strchr+0x29>
c00285c8:	89 d1                	mov    %edx,%ecx
      return (char *) string;
    else if (*string == '\0')
c00285ca:	84 db                	test   %bl,%bl
c00285cc:	74 15                	je     c00285e3 <strchr+0x2b>
      return NULL;
    else
      string++;
c00285ce:	83 c0 01             	add    $0x1,%eax
    if (*string == c)
c00285d1:	0f b6 10             	movzbl (%eax),%edx
c00285d4:	38 ca                	cmp    %cl,%dl
c00285d6:	74 09                	je     c00285e1 <strchr+0x29>
    else if (*string == '\0')
c00285d8:	84 d2                	test   %dl,%dl
c00285da:	75 f2                	jne    c00285ce <strchr+0x16>
      return NULL;
c00285dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00285e1:	5b                   	pop    %ebx
c00285e2:	c3                   	ret    
      return NULL;
c00285e3:	b8 00 00 00 00       	mov    $0x0,%eax
c00285e8:	eb f7                	jmp    c00285e1 <strchr+0x29>

c00285ea <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00285ea:	57                   	push   %edi
c00285eb:	56                   	push   %esi
c00285ec:	53                   	push   %ebx
c00285ed:	8b 74 24 10          	mov    0x10(%esp),%esi
c00285f1:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00285f5:	0f b6 06             	movzbl (%esi),%eax
c00285f8:	84 c0                	test   %al,%al
c00285fa:	74 27                	je     c0028623 <strcspn+0x39>
c00285fc:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c0028601:	0f be c0             	movsbl %al,%eax
c0028604:	50                   	push   %eax
c0028605:	57                   	push   %edi
c0028606:	e8 ad ff ff ff       	call   c00285b8 <strchr>
c002860b:	83 c4 08             	add    $0x8,%esp
c002860e:	85 c0                	test   %eax,%eax
c0028610:	75 0b                	jne    c002861d <strcspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c0028612:	83 c3 01             	add    $0x1,%ebx
c0028615:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028619:	84 c0                	test   %al,%al
c002861b:	75 e4                	jne    c0028601 <strcspn+0x17>
      break;
  return length;
}
c002861d:	89 d8                	mov    %ebx,%eax
c002861f:	5b                   	pop    %ebx
c0028620:	5e                   	pop    %esi
c0028621:	5f                   	pop    %edi
c0028622:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028623:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028628:	eb f3                	jmp    c002861d <strcspn+0x33>

c002862a <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002862a:	56                   	push   %esi
c002862b:	53                   	push   %ebx
c002862c:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028630:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0028634:	0f b6 13             	movzbl (%ebx),%edx
c0028637:	84 d2                	test   %dl,%dl
c0028639:	74 1d                	je     c0028658 <strpbrk+0x2e>
    if (strchr (stop, *string) != NULL)
c002863b:	0f be d2             	movsbl %dl,%edx
c002863e:	52                   	push   %edx
c002863f:	56                   	push   %esi
c0028640:	e8 73 ff ff ff       	call   c00285b8 <strchr>
c0028645:	83 c4 08             	add    $0x8,%esp
c0028648:	85 c0                	test   %eax,%eax
c002864a:	75 13                	jne    c002865f <strpbrk+0x35>
  for (; *string != '\0'; string++)
c002864c:	83 c3 01             	add    $0x1,%ebx
c002864f:	0f b6 13             	movzbl (%ebx),%edx
c0028652:	84 d2                	test   %dl,%dl
c0028654:	75 e5                	jne    c002863b <strpbrk+0x11>
c0028656:	eb 09                	jmp    c0028661 <strpbrk+0x37>
      return (char *) string;
  return NULL;
c0028658:	b8 00 00 00 00       	mov    $0x0,%eax
c002865d:	eb 02                	jmp    c0028661 <strpbrk+0x37>
c002865f:	89 d8                	mov    %ebx,%eax
}
c0028661:	5b                   	pop    %ebx
c0028662:	5e                   	pop    %esi
c0028663:	c3                   	ret    

c0028664 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028664:	53                   	push   %ebx
c0028665:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c0028669:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c002866e:	0f b6 0a             	movzbl (%edx),%ecx
c0028671:	84 c9                	test   %cl,%cl
c0028673:	74 16                	je     c002868b <strrchr+0x27>
  const char *p = NULL;
c0028675:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c002867a:	38 cb                	cmp    %cl,%bl
c002867c:	0f 44 c2             	cmove  %edx,%eax
  for (; *string != '\0'; string++)
c002867f:	83 c2 01             	add    $0x1,%edx
c0028682:	0f b6 0a             	movzbl (%edx),%ecx
c0028685:	84 c9                	test   %cl,%cl
c0028687:	75 f1                	jne    c002867a <strrchr+0x16>
      p = string;
  return (char *) p;
}
c0028689:	5b                   	pop    %ebx
c002868a:	c3                   	ret    
  const char *p = NULL;
c002868b:	b8 00 00 00 00       	mov    $0x0,%eax
  return (char *) p;
c0028690:	eb f7                	jmp    c0028689 <strrchr+0x25>

c0028692 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0028692:	57                   	push   %edi
c0028693:	56                   	push   %esi
c0028694:	53                   	push   %ebx
c0028695:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028699:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002869d:	0f b6 06             	movzbl (%esi),%eax
c00286a0:	84 c0                	test   %al,%al
c00286a2:	74 27                	je     c00286cb <strspn+0x39>
c00286a4:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c00286a9:	0f be c0             	movsbl %al,%eax
c00286ac:	50                   	push   %eax
c00286ad:	57                   	push   %edi
c00286ae:	e8 05 ff ff ff       	call   c00285b8 <strchr>
c00286b3:	83 c4 08             	add    $0x8,%esp
c00286b6:	85 c0                	test   %eax,%eax
c00286b8:	74 0b                	je     c00286c5 <strspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c00286ba:	83 c3 01             	add    $0x1,%ebx
c00286bd:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c00286c1:	84 c0                	test   %al,%al
c00286c3:	75 e4                	jne    c00286a9 <strspn+0x17>
      break;
  return length;
}
c00286c5:	89 d8                	mov    %ebx,%eax
c00286c7:	5b                   	pop    %ebx
c00286c8:	5e                   	pop    %esi
c00286c9:	5f                   	pop    %edi
c00286ca:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c00286cb:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c00286d0:	eb f3                	jmp    c00286c5 <strspn+0x33>

c00286d2 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c00286d2:	55                   	push   %ebp
c00286d3:	57                   	push   %edi
c00286d4:	56                   	push   %esi
c00286d5:	53                   	push   %ebx
c00286d6:	83 ec 1c             	sub    $0x1c,%esp
c00286d9:	e8 a7 63 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00286de:	81 c3 d6 27 01 00    	add    $0x127d6,%ebx
c00286e4:	8b 74 24 30          	mov    0x30(%esp),%esi
c00286e8:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
c00286ec:	85 ff                	test   %edi,%edi
c00286ee:	74 33                	je     c0028723 <strtok_r+0x51>
  ASSERT (save_ptr != NULL);
c00286f0:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00286f5:	74 55                	je     c002874c <strtok_r+0x7a>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c00286f7:	85 f6                	test   %esi,%esi
c00286f9:	74 7a                	je     c0028775 <strtok_r+0xa3>
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c00286fb:	0f b6 1e             	movzbl (%esi),%ebx
c00286fe:	83 ec 08             	sub    $0x8,%esp
c0028701:	0f be c3             	movsbl %bl,%eax
c0028704:	50                   	push   %eax
c0028705:	57                   	push   %edi
c0028706:	e8 ad fe ff ff       	call   c00285b8 <strchr>
c002870b:	83 c4 10             	add    $0x10,%esp
c002870e:	85 c0                	test   %eax,%eax
c0028710:	0f 84 a9 00 00 00    	je     c00287bf <strtok_r+0xed>
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028716:	84 db                	test   %bl,%bl
c0028718:	0f 84 8e 00 00 00    	je     c00287ac <strtok_r+0xda>
        {
          *save_ptr = s;
          return NULL;
        }

      s++;
c002871e:	83 c6 01             	add    $0x1,%esi
c0028721:	eb d8                	jmp    c00286fb <strtok_r+0x29>
  ASSERT (delimiters != NULL);
c0028723:	83 ec 0c             	sub    $0xc,%esp
c0028726:	8d 83 82 68 ff ff    	lea    -0x977e(%ebx),%eax
c002872c:	50                   	push   %eax
c002872d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028733:	50                   	push   %eax
c0028734:	8d 83 1c 49 ff ff    	lea    -0xb6e4(%ebx),%eax
c002873a:	50                   	push   %eax
c002873b:	68 ef 00 00 00       	push   $0xef
c0028740:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c0028746:	50                   	push   %eax
c0028747:	e8 3b 0b 00 00       	call   c0029287 <debug_panic>
  ASSERT (save_ptr != NULL);
c002874c:	83 ec 0c             	sub    $0xc,%esp
c002874f:	8d 83 a8 68 ff ff    	lea    -0x9758(%ebx),%eax
c0028755:	50                   	push   %eax
c0028756:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002875c:	50                   	push   %eax
c002875d:	8d 83 1c 49 ff ff    	lea    -0xb6e4(%ebx),%eax
c0028763:	50                   	push   %eax
c0028764:	68 f0 00 00 00       	push   $0xf0
c0028769:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c002876f:	50                   	push   %eax
c0028770:	e8 12 0b 00 00       	call   c0029287 <debug_panic>
    s = *save_ptr;
c0028775:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028779:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
c002877b:	85 f6                	test   %esi,%esi
c002877d:	0f 85 78 ff ff ff    	jne    c00286fb <strtok_r+0x29>
c0028783:	83 ec 0c             	sub    $0xc,%esp
c0028786:	8d 83 8b 68 ff ff    	lea    -0x9775(%ebx),%eax
c002878c:	50                   	push   %eax
c002878d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028793:	50                   	push   %eax
c0028794:	8d 83 1c 49 ff ff    	lea    -0xb6e4(%ebx),%eax
c002879a:	50                   	push   %eax
c002879b:	68 f6 00 00 00       	push   $0xf6
c00287a0:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c00287a6:	50                   	push   %eax
c00287a7:	e8 db 0a 00 00       	call   c0029287 <debug_panic>
          *save_ptr = s;
c00287ac:	8b 44 24 38          	mov    0x38(%esp),%eax
c00287b0:	89 30                	mov    %esi,(%eax)
          return NULL;
c00287b2:	b8 00 00 00 00       	mov    $0x0,%eax
      *save_ptr = s + 1;
    }
  else 
    *save_ptr = s;
  return token;
}
c00287b7:	83 c4 1c             	add    $0x1c,%esp
c00287ba:	5b                   	pop    %ebx
c00287bb:	5e                   	pop    %esi
c00287bc:	5f                   	pop    %edi
c00287bd:	5d                   	pop    %ebp
c00287be:	c3                   	ret    
c00287bf:	89 f3                	mov    %esi,%ebx
c00287c1:	eb 02                	jmp    c00287c5 <strtok_r+0xf3>
    s++;
c00287c3:	89 eb                	mov    %ebp,%ebx
c00287c5:	8d 6b 01             	lea    0x1(%ebx),%ebp
  while (strchr (delimiters, *s) == NULL)
c00287c8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00287cc:	88 44 24 0f          	mov    %al,0xf(%esp)
c00287d0:	83 ec 08             	sub    $0x8,%esp
c00287d3:	0f be c0             	movsbl %al,%eax
c00287d6:	50                   	push   %eax
c00287d7:	57                   	push   %edi
c00287d8:	e8 db fd ff ff       	call   c00285b8 <strchr>
c00287dd:	83 c4 10             	add    $0x10,%esp
c00287e0:	85 c0                	test   %eax,%eax
c00287e2:	74 df                	je     c00287c3 <strtok_r+0xf1>
  if (*s != '\0') 
c00287e4:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c00287e9:	75 0a                	jne    c00287f5 <strtok_r+0x123>
    *save_ptr = s;
c00287eb:	8b 44 24 38          	mov    0x38(%esp),%eax
c00287ef:	89 28                	mov    %ebp,(%eax)
c00287f1:	89 f0                	mov    %esi,%eax
c00287f3:	eb c2                	jmp    c00287b7 <strtok_r+0xe5>
      *s = '\0';
c00287f5:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
      *save_ptr = s + 1;
c00287f9:	83 c3 02             	add    $0x2,%ebx
c00287fc:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028800:	89 18                	mov    %ebx,(%eax)
c0028802:	89 f0                	mov    %esi,%eax
c0028804:	eb b1                	jmp    c00287b7 <strtok_r+0xe5>

c0028806 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028806:	53                   	push   %ebx
c0028807:	8b 44 24 08          	mov    0x8(%esp),%eax
c002880b:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002880f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0028813:	85 c9                	test   %ecx,%ecx
c0028815:	74 0e                	je     c0028825 <memset+0x1f>
c0028817:	01 c1                	add    %eax,%ecx
  unsigned char *dst = dst_;
c0028819:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c002881b:	83 c2 01             	add    $0x1,%edx
c002881e:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0028821:	39 d1                	cmp    %edx,%ecx
c0028823:	75 f6                	jne    c002881b <memset+0x15>

  return dst_;
}
c0028825:	5b                   	pop    %ebx
c0028826:	c3                   	ret    

c0028827 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0028827:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT (string != NULL);

  for (p = string; *p != '\0'; p++)
c002882b:	89 d0                	mov    %edx,%eax
c002882d:	80 3a 00             	cmpb   $0x0,(%edx)
c0028830:	75 03                	jne    c0028835 <strlen+0xe>
    continue;
  return p - string;
c0028832:	29 d0                	sub    %edx,%eax
}
c0028834:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c0028835:	83 c0 01             	add    $0x1,%eax
c0028838:	80 38 00             	cmpb   $0x0,(%eax)
c002883b:	74 f5                	je     c0028832 <strlen+0xb>
c002883d:	eb f6                	jmp    c0028835 <strlen+0xe>

c002883f <strstr>:
{
c002883f:	55                   	push   %ebp
c0028840:	57                   	push   %edi
c0028841:	56                   	push   %esi
c0028842:	53                   	push   %ebx
c0028843:	83 ec 04             	sub    $0x4,%esp
c0028846:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c002884a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002884f:	b8 00 00 00 00       	mov    $0x0,%eax
c0028854:	89 d9                	mov    %ebx,%ecx
c0028856:	8b 7c 24 18          	mov    0x18(%esp),%edi
c002885a:	f2 ae                	repnz scas %es:(%edi),%al
c002885c:	f7 d1                	not    %ecx
c002885e:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c0028861:	89 d9                	mov    %ebx,%ecx
c0028863:	89 ef                	mov    %ebp,%edi
c0028865:	f2 ae                	repnz scas %es:(%edi),%al
c0028867:	89 c8                	mov    %ecx,%eax
c0028869:	f7 d0                	not    %eax
c002886b:	8d 70 ff             	lea    -0x1(%eax),%esi
  if (haystack_len >= needle_len) 
c002886e:	39 f2                	cmp    %esi,%edx
c0028870:	72 36                	jb     c00288a8 <strstr+0x69>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0028872:	29 f2                	sub    %esi,%edx
c0028874:	89 14 24             	mov    %edx,(%esp)
c0028877:	bb 00 00 00 00       	mov    $0x0,%ebx
c002887c:	89 df                	mov    %ebx,%edi
c002887e:	03 7c 24 18          	add    0x18(%esp),%edi
        if (!memcmp (haystack + i, needle, needle_len))
c0028882:	56                   	push   %esi
c0028883:	55                   	push   %ebp
c0028884:	57                   	push   %edi
c0028885:	e8 70 fc ff ff       	call   c00284fa <memcmp>
c002888a:	83 c4 0c             	add    $0xc,%esp
c002888d:	85 c0                	test   %eax,%eax
c002888f:	74 0d                	je     c002889e <strstr+0x5f>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0028891:	83 c3 01             	add    $0x1,%ebx
c0028894:	3b 1c 24             	cmp    (%esp),%ebx
c0028897:	76 e3                	jbe    c002887c <strstr+0x3d>
  return NULL;
c0028899:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002889e:	89 f8                	mov    %edi,%eax
c00288a0:	83 c4 04             	add    $0x4,%esp
c00288a3:	5b                   	pop    %ebx
c00288a4:	5e                   	pop    %esi
c00288a5:	5f                   	pop    %edi
c00288a6:	5d                   	pop    %ebp
c00288a7:	c3                   	ret    
  return NULL;
c00288a8:	bf 00 00 00 00       	mov    $0x0,%edi
c00288ad:	eb ef                	jmp    c002889e <strstr+0x5f>

c00288af <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00288af:	8b 54 24 04          	mov    0x4(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00288b3:	80 3a 00             	cmpb   $0x0,(%edx)
c00288b6:	74 07                	je     c00288bf <strnlen+0x10>
c00288b8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c00288bd:	75 07                	jne    c00288c6 <strnlen+0x17>
c00288bf:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c00288c4:	f3 c3                	repz ret 
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00288c6:	b8 00 00 00 00       	mov    $0x0,%eax
c00288cb:	83 c0 01             	add    $0x1,%eax
c00288ce:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c00288d2:	74 f0                	je     c00288c4 <strnlen+0x15>
c00288d4:	39 44 24 08          	cmp    %eax,0x8(%esp)
c00288d8:	76 ea                	jbe    c00288c4 <strnlen+0x15>
c00288da:	eb ef                	jmp    c00288cb <strnlen+0x1c>

c00288dc <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c00288dc:	55                   	push   %ebp
c00288dd:	57                   	push   %edi
c00288de:	56                   	push   %esi
c00288df:	53                   	push   %ebx
c00288e0:	83 ec 0c             	sub    $0xc,%esp
c00288e3:	e8 9d 61 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00288e8:	81 c3 cc 25 01 00    	add    $0x125cc,%ebx
c00288ee:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c00288f2:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c00288f6:	85 ed                	test   %ebp,%ebp
c00288f8:	74 49                	je     c0028943 <strlcpy+0x67>
  ASSERT (src != NULL);
c00288fa:	85 d2                	test   %edx,%edx
c00288fc:	74 6e                	je     c002896c <strlcpy+0x90>

  src_len = strlen (src);
c00288fe:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028903:	b8 00 00 00 00       	mov    $0x0,%eax
c0028908:	89 d7                	mov    %edx,%edi
c002890a:	f2 ae                	repnz scas %es:(%edi),%al
c002890c:	89 ce                	mov    %ecx,%esi
c002890e:	f7 d6                	not    %esi
c0028910:	8d 76 ff             	lea    -0x1(%esi),%esi
  if (size > 0) 
c0028913:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0028918:	74 1f                	je     c0028939 <strlcpy+0x5d>
    {
      size_t dst_len = size - 1;
c002891a:	8b 44 24 28          	mov    0x28(%esp),%eax
c002891e:	8d 78 ff             	lea    -0x1(%eax),%edi
c0028921:	39 fe                	cmp    %edi,%esi
c0028923:	0f 46 fe             	cmovbe %esi,%edi
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c0028926:	83 ec 04             	sub    $0x4,%esp
c0028929:	57                   	push   %edi
c002892a:	52                   	push   %edx
c002892b:	55                   	push   %ebp
c002892c:	e8 52 fb ff ff       	call   c0028483 <memcpy>
      dst[dst_len] = '\0';
c0028931:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
c0028936:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
c0028939:	89 f0                	mov    %esi,%eax
c002893b:	83 c4 0c             	add    $0xc,%esp
c002893e:	5b                   	pop    %ebx
c002893f:	5e                   	pop    %esi
c0028940:	5f                   	pop    %edi
c0028941:	5d                   	pop    %ebp
c0028942:	c3                   	ret    
  ASSERT (dst != NULL);
c0028943:	83 ec 0c             	sub    $0xc,%esp
c0028946:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
c002894c:	50                   	push   %eax
c002894d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028953:	50                   	push   %eax
c0028954:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c002895a:	50                   	push   %eax
c002895b:	68 4a 01 00 00       	push   $0x14a
c0028960:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c0028966:	50                   	push   %eax
c0028967:	e8 1b 09 00 00       	call   c0029287 <debug_panic>
  ASSERT (src != NULL);
c002896c:	83 ec 0c             	sub    $0xc,%esp
c002896f:	8d 83 c5 68 ff ff    	lea    -0x973b(%ebx),%eax
c0028975:	50                   	push   %eax
c0028976:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002897c:	50                   	push   %eax
c002897d:	8d 83 14 49 ff ff    	lea    -0xb6ec(%ebx),%eax
c0028983:	50                   	push   %eax
c0028984:	68 4b 01 00 00       	push   $0x14b
c0028989:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c002898f:	50                   	push   %eax
c0028990:	e8 f2 08 00 00       	call   c0029287 <debug_panic>

c0028995 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028995:	55                   	push   %ebp
c0028996:	57                   	push   %edi
c0028997:	56                   	push   %esi
c0028998:	53                   	push   %ebx
c0028999:	83 ec 1c             	sub    $0x1c,%esp
c002899c:	e8 e4 60 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00289a1:	81 c3 13 25 01 00    	add    $0x12513,%ebx
c00289a7:	8b 54 24 34          	mov    0x34(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c00289ab:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00289b0:	74 75                	je     c0028a27 <strlcat+0x92>
  ASSERT (src != NULL);
c00289b2:	85 d2                	test   %edx,%edx
c00289b4:	0f 84 96 00 00 00    	je     c0028a50 <strlcat+0xbb>

  src_len = strlen (src);
c00289ba:	be ff ff ff ff       	mov    $0xffffffff,%esi
c00289bf:	b8 00 00 00 00       	mov    $0x0,%eax
c00289c4:	89 f1                	mov    %esi,%ecx
c00289c6:	89 d7                	mov    %edx,%edi
c00289c8:	f2 ae                	repnz scas %es:(%edi),%al
c00289ca:	f7 d1                	not    %ecx
c00289cc:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
c00289cf:	89 f1                	mov    %esi,%ecx
c00289d1:	8b 7c 24 30          	mov    0x30(%esp),%edi
c00289d5:	f2 ae                	repnz scas %es:(%edi),%al
c00289d7:	89 ce                	mov    %ecx,%esi
c00289d9:	f7 d6                	not    %esi
c00289db:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
c00289de:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00289e3:	74 36                	je     c0028a1b <strlcat+0x86>
c00289e5:	3b 74 24 38          	cmp    0x38(%esp),%esi
c00289e9:	73 30                	jae    c0028a1b <strlcat+0x86>
    {
      size_t copy_cnt = size - dst_len - 1;
c00289eb:	8b 44 24 38          	mov    0x38(%esp),%eax
c00289ef:	83 e8 01             	sub    $0x1,%eax
c00289f2:	29 f0                	sub    %esi,%eax
c00289f4:	39 c5                	cmp    %eax,%ebp
c00289f6:	0f 46 c5             	cmovbe %ebp,%eax
c00289f9:	89 c7                	mov    %eax,%edi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c00289fb:	89 f0                	mov    %esi,%eax
c00289fd:	03 44 24 30          	add    0x30(%esp),%eax
c0028a01:	83 ec 04             	sub    $0x4,%esp
c0028a04:	57                   	push   %edi
c0028a05:	52                   	push   %edx
c0028a06:	89 44 24 18          	mov    %eax,0x18(%esp)
c0028a0a:	50                   	push   %eax
c0028a0b:	e8 73 fa ff ff       	call   c0028483 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
c0028a10:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0028a14:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
c0028a18:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
c0028a1b:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
}
c0028a1f:	83 c4 1c             	add    $0x1c,%esp
c0028a22:	5b                   	pop    %ebx
c0028a23:	5e                   	pop    %esi
c0028a24:	5f                   	pop    %edi
c0028a25:	5d                   	pop    %ebp
c0028a26:	c3                   	ret    
  ASSERT (dst != NULL);
c0028a27:	83 ec 0c             	sub    $0xc,%esp
c0028a2a:	8d 83 b9 68 ff ff    	lea    -0x9747(%ebx),%eax
c0028a30:	50                   	push   %eax
c0028a31:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028a37:	50                   	push   %eax
c0028a38:	8d 83 0c 49 ff ff    	lea    -0xb6f4(%ebx),%eax
c0028a3e:	50                   	push   %eax
c0028a3f:	68 68 01 00 00       	push   $0x168
c0028a44:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c0028a4a:	50                   	push   %eax
c0028a4b:	e8 37 08 00 00       	call   c0029287 <debug_panic>
  ASSERT (src != NULL);
c0028a50:	83 ec 0c             	sub    $0xc,%esp
c0028a53:	8d 83 c5 68 ff ff    	lea    -0x973b(%ebx),%eax
c0028a59:	50                   	push   %eax
c0028a5a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028a60:	50                   	push   %eax
c0028a61:	8d 83 0c 49 ff ff    	lea    -0xb6f4(%ebx),%eax
c0028a67:	50                   	push   %eax
c0028a68:	68 69 01 00 00       	push   $0x169
c0028a6d:	8d 83 95 68 ff ff    	lea    -0x976b(%ebx),%eax
c0028a73:	50                   	push   %eax
c0028a74:	e8 0e 08 00 00       	call   c0029287 <debug_panic>

c0028a79 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028a79:	55                   	push   %ebp
c0028a7a:	57                   	push   %edi
c0028a7b:	56                   	push   %esi
c0028a7c:	53                   	push   %ebx
c0028a7d:	83 ec 1c             	sub    $0x1c,%esp
c0028a80:	89 44 24 08          	mov    %eax,0x8(%esp)
c0028a84:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0028a88:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c0028a8c:	8b 74 24 34          	mov    0x34(%esp),%esi
c0028a90:	89 1c 24             	mov    %ebx,(%esp)
c0028a93:	89 74 24 04          	mov    %esi,0x4(%esp)
  if ((d >> 32) == 0) 
c0028a97:	85 f6                	test   %esi,%esi
c0028a99:	0f 84 fc 00 00 00    	je     c0028b9b <udiv64+0x122>
c0028a9f:	89 f0                	mov    %esi,%eax
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028aa1:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0028aa5:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0028aa9:	8b 14 24             	mov    (%esp),%edx
c0028aac:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028ab0:	39 f1                	cmp    %esi,%ecx
c0028ab2:	0f 87 27 01 00 00    	ja     c0028bdf <udiv64+0x166>
c0028ab8:	72 08                	jb     c0028ac2 <udiv64+0x49>
c0028aba:	39 da                	cmp    %ebx,%edx
c0028abc:	0f 87 1d 01 00 00    	ja     c0028bdf <udiv64+0x166>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
c0028ac2:	89 c2                	mov    %eax,%edx
  int n = 0;
c0028ac4:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x0000FFFF)
c0028ac9:	3d ff ff 00 00       	cmp    $0xffff,%eax
c0028ace:	77 0a                	ja     c0028ada <udiv64+0x61>
      x <<= 16; 
c0028ad0:	c1 e0 10             	shl    $0x10,%eax
c0028ad3:	89 c2                	mov    %eax,%edx
      n += 16;
c0028ad5:	b9 10 00 00 00       	mov    $0x10,%ecx
  if (x <= 0x00FFFFFF)
c0028ada:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
c0028ae0:	77 06                	ja     c0028ae8 <udiv64+0x6f>
      n += 8;
c0028ae2:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
c0028ae5:	c1 e2 08             	shl    $0x8,%edx
  if (x <= 0x0FFFFFFF)
c0028ae8:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0028aee:	77 06                	ja     c0028af6 <udiv64+0x7d>
      n += 4;
c0028af0:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
c0028af3:	c1 e2 04             	shl    $0x4,%edx
  if (x <= 0x3FFFFFFF)
c0028af6:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
c0028afc:	77 06                	ja     c0028b04 <udiv64+0x8b>
      n += 2;
c0028afe:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
c0028b01:	c1 e2 02             	shl    $0x2,%edx
    n++;
c0028b04:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
c0028b0a:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c0028b0d:	8b 74 24 08          	mov    0x8(%esp),%esi
c0028b11:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0028b15:	89 fb                	mov    %edi,%ebx
c0028b17:	d1 eb                	shr    %ebx
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028b19:	89 f0                	mov    %esi,%eax
c0028b1b:	0f ac f8 01          	shrd   $0x1,%edi,%eax
c0028b1f:	8b 3c 24             	mov    (%esp),%edi
c0028b22:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c0028b26:	0f a5 fd             	shld   %cl,%edi,%ebp
c0028b29:	d3 e7                	shl    %cl,%edi
c0028b2b:	f6 c1 20             	test   $0x20,%cl
c0028b2e:	74 02                	je     c0028b32 <udiv64+0xb9>
c0028b30:	89 fd                	mov    %edi,%ebp
  asm ("divl %4"
c0028b32:	89 da                	mov    %ebx,%edx
c0028b34:	f7 f5                	div    %ebp
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028b36:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0028b3b:	29 ca                	sub    %ecx,%edx
c0028b3d:	89 d1                	mov    %edx,%ecx
c0028b3f:	d3 e8                	shr    %cl,%eax
c0028b41:	89 c1                	mov    %eax,%ecx
c0028b43:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028b48:	89 44 24 10          	mov    %eax,0x10(%esp)
c0028b4c:	89 5c 24 14          	mov    %ebx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028b50:	83 c1 ff             	add    $0xffffffff,%ecx
c0028b53:	83 d3 ff             	adc    $0xffffffff,%ebx
c0028b56:	89 dd                	mov    %ebx,%ebp
c0028b58:	8b 34 24             	mov    (%esp),%esi
c0028b5b:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0028b5f:	0f af ee             	imul   %esi,%ebp
c0028b62:	89 f8                	mov    %edi,%eax
c0028b64:	0f af c1             	imul   %ecx,%eax
c0028b67:	01 c5                	add    %eax,%ebp
c0028b69:	89 c8                	mov    %ecx,%eax
c0028b6b:	f7 24 24             	mull   (%esp)
c0028b6e:	01 ea                	add    %ebp,%edx
c0028b70:	8b 74 24 08          	mov    0x8(%esp),%esi
c0028b74:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0028b78:	29 c6                	sub    %eax,%esi
c0028b7a:	19 d7                	sbb    %edx,%edi
c0028b7c:	89 f0                	mov    %esi,%eax
c0028b7e:	89 fa                	mov    %edi,%edx
c0028b80:	8b 34 24             	mov    (%esp),%esi
c0028b83:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0028b87:	39 fa                	cmp    %edi,%edx
c0028b89:	72 48                	jb     c0028bd3 <udiv64+0x15a>
c0028b8b:	77 04                	ja     c0028b91 <udiv64+0x118>
c0028b8d:	39 f0                	cmp    %esi,%eax
c0028b8f:	72 42                	jb     c0028bd3 <udiv64+0x15a>
c0028b91:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0028b95:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0028b99:	eb 38                	jmp    c0028bd3 <udiv64+0x15a>
      uint32_t n1 = n >> 32;
c0028b9b:	89 d0                	mov    %edx,%eax
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028b9d:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ba2:	f7 f3                	div    %ebx
c0028ba4:	89 c7                	mov    %eax,%edi
c0028ba6:	89 d3                	mov    %edx,%ebx
c0028ba8:	89 da                	mov    %ebx,%edx
c0028baa:	b8 00 00 00 00       	mov    $0x0,%eax
c0028baf:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0028bb3:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028bb8:	01 c8                	add    %ecx,%eax
c0028bba:	11 da                	adc    %ebx,%edx
  asm ("divl %4"
c0028bbc:	f7 34 24             	divl   (%esp)
      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028bbf:	89 fd                	mov    %edi,%ebp
c0028bc1:	bf 00 00 00 00       	mov    $0x0,%edi
c0028bc6:	89 f9                	mov    %edi,%ecx
c0028bc8:	89 eb                	mov    %ebp,%ebx
c0028bca:	ba 00 00 00 00       	mov    $0x0,%edx
c0028bcf:	01 c1                	add    %eax,%ecx
c0028bd1:	11 d3                	adc    %edx,%ebx
        }
    }
}
c0028bd3:	89 c8                	mov    %ecx,%eax
c0028bd5:	89 da                	mov    %ebx,%edx
c0028bd7:	83 c4 1c             	add    $0x1c,%esp
c0028bda:	5b                   	pop    %ebx
c0028bdb:	5e                   	pop    %esi
c0028bdc:	5f                   	pop    %edi
c0028bdd:	5d                   	pop    %ebp
c0028bde:	c3                   	ret    
        return 0;
c0028bdf:	b9 00 00 00 00       	mov    $0x0,%ecx
c0028be4:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028be9:	eb e8                	jmp    c0028bd3 <udiv64+0x15a>

c0028beb <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0028beb:	57                   	push   %edi
c0028bec:	56                   	push   %esi
c0028bed:	53                   	push   %ebx
c0028bee:	83 ec 08             	sub    $0x8,%esp
c0028bf1:	89 04 24             	mov    %eax,(%esp)
c0028bf4:	89 54 24 04          	mov    %edx,0x4(%esp)
c0028bf8:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028bfc:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028c00:	85 d2                	test   %edx,%edx
c0028c02:	78 2b                	js     c0028c2f <sdiv64+0x44>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028c04:	89 f1                	mov    %esi,%ecx
c0028c06:	89 fb                	mov    %edi,%ebx
c0028c08:	85 ff                	test   %edi,%edi
c0028c0a:	78 2c                	js     c0028c38 <sdiv64+0x4d>
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028c0c:	53                   	push   %ebx
c0028c0d:	51                   	push   %ecx
c0028c0e:	e8 66 fe ff ff       	call   c0028a79 <udiv64>
c0028c13:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028c16:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028c1a:	f7 d1                	not    %ecx
c0028c1c:	c1 e9 1f             	shr    $0x1f,%ecx
c0028c1f:	89 fb                	mov    %edi,%ebx
c0028c21:	c1 eb 1f             	shr    $0x1f,%ebx
c0028c24:	38 d9                	cmp    %bl,%cl
c0028c26:	74 19                	je     c0028c41 <sdiv64+0x56>
}
c0028c28:	83 c4 08             	add    $0x8,%esp
c0028c2b:	5b                   	pop    %ebx
c0028c2c:	5e                   	pop    %esi
c0028c2d:	5f                   	pop    %edi
c0028c2e:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028c2f:	f7 d8                	neg    %eax
c0028c31:	83 d2 00             	adc    $0x0,%edx
c0028c34:	f7 da                	neg    %edx
c0028c36:	eb cc                	jmp    c0028c04 <sdiv64+0x19>
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028c38:	f7 d9                	neg    %ecx
c0028c3a:	83 d3 00             	adc    $0x0,%ebx
c0028c3d:	f7 db                	neg    %ebx
c0028c3f:	eb cb                	jmp    c0028c0c <sdiv64+0x21>
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028c41:	f7 d8                	neg    %eax
c0028c43:	83 d2 00             	adc    $0x0,%edx
c0028c46:	f7 da                	neg    %edx
c0028c48:	eb de                	jmp    c0028c28 <sdiv64+0x3d>

c0028c4a <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028c4a:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0028c4d:	ff 74 24 14          	pushl  0x14(%esp)
c0028c51:	ff 74 24 14          	pushl  0x14(%esp)
c0028c55:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028c59:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028c5d:	e8 89 ff ff ff       	call   c0028beb <sdiv64>
}
c0028c62:	83 c4 0c             	add    $0xc,%esp
c0028c65:	c3                   	ret    

c0028c66 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0028c66:	57                   	push   %edi
c0028c67:	56                   	push   %esi
c0028c68:	53                   	push   %ebx
c0028c69:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028c6d:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028c71:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64 (n, d);
c0028c75:	57                   	push   %edi
c0028c76:	56                   	push   %esi
c0028c77:	89 d8                	mov    %ebx,%eax
c0028c79:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028c7d:	e8 69 ff ff ff       	call   c0028beb <sdiv64>
c0028c82:	83 c4 08             	add    $0x8,%esp
c0028c85:	0f af c6             	imul   %esi,%eax
c0028c88:	29 c3                	sub    %eax,%ebx
  return smod64 (n, d);
c0028c8a:	89 d8                	mov    %ebx,%eax
c0028c8c:	99                   	cltd   
}
c0028c8d:	5b                   	pop    %ebx
c0028c8e:	5e                   	pop    %esi
c0028c8f:	5f                   	pop    %edi
c0028c90:	c3                   	ret    

c0028c91 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028c91:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c0028c94:	ff 74 24 14          	pushl  0x14(%esp)
c0028c98:	ff 74 24 14          	pushl  0x14(%esp)
c0028c9c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028ca0:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028ca4:	e8 d0 fd ff ff       	call   c0028a79 <udiv64>
}
c0028ca9:	83 c4 0c             	add    $0xc,%esp
c0028cac:	c3                   	ret    

c0028cad <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0028cad:	57                   	push   %edi
c0028cae:	56                   	push   %esi
c0028caf:	53                   	push   %ebx
c0028cb0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028cb4:	8b 74 24 18          	mov    0x18(%esp),%esi
c0028cb8:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64 (n, d);
c0028cbc:	57                   	push   %edi
c0028cbd:	56                   	push   %esi
c0028cbe:	89 d8                	mov    %ebx,%eax
c0028cc0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0028cc4:	e8 b0 fd ff ff       	call   c0028a79 <udiv64>
c0028cc9:	83 c4 08             	add    $0x8,%esp
c0028ccc:	0f af c6             	imul   %esi,%eax
c0028ccf:	29 c3                	sub    %eax,%ebx
  return umod64 (n, d);
c0028cd1:	89 d8                	mov    %ebx,%eax
c0028cd3:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0028cd8:	5b                   	pop    %ebx
c0028cd9:	5e                   	pop    %esi
c0028cda:	5f                   	pop    %edi
c0028cdb:	c3                   	ret    

c0028cdc <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0028cdc:	55                   	push   %ebp
c0028cdd:	57                   	push   %edi
c0028cde:	56                   	push   %esi
c0028cdf:	53                   	push   %ebx
c0028ce0:	83 ec 04             	sub    $0x4,%esp
c0028ce3:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c0028ce6:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0028cec:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ofs = 0; ofs < size; ofs++)
c0028cf1:	85 d2                	test   %edx,%edx
c0028cf3:	74 4d                	je     c0028d42 <parse_octal_field+0x66>
      char c = s[ofs];
c0028cf5:	8b 04 24             	mov    (%esp),%eax
c0028cf8:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
c0028cfb:	8d 6b d0             	lea    -0x30(%ebx),%ebp
  for (ofs = 0; ofs < size; ofs++)
c0028cfe:	be 00 00 00 00       	mov    $0x0,%esi
          if (*value > ULONG_MAX / 8)
c0028d03:	bf 00 00 00 00       	mov    $0x0,%edi
      if (c >= '0' && c <= '7')
c0028d08:	89 e8                	mov    %ebp,%eax
c0028d0a:	3c 07                	cmp    $0x7,%al
c0028d0c:	77 3c                	ja     c0028d4a <parse_octal_field+0x6e>
          *value = c - '0' + *value * 8;
c0028d0e:	0f be db             	movsbl %bl,%ebx
c0028d11:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0028d15:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0028d17:	83 c6 01             	add    $0x1,%esi
c0028d1a:	39 f2                	cmp    %esi,%edx
c0028d1c:	74 1f                	je     c0028d3d <parse_octal_field+0x61>
      char c = s[ofs];
c0028d1e:	8b 04 24             	mov    (%esp),%eax
c0028d21:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
c0028d25:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c0028d28:	89 e8                	mov    %ebp,%eax
c0028d2a:	3c 07                	cmp    $0x7,%al
c0028d2c:	77 1c                	ja     c0028d4a <parse_octal_field+0x6e>
          if (*value > ULONG_MAX / 8)
c0028d2e:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0028d34:	76 d8                	jbe    c0028d0e <parse_octal_field+0x32>
              return false;
c0028d36:	b8 00 00 00 00       	mov    $0x0,%eax
c0028d3b:	eb 05                	jmp    c0028d42 <parse_octal_field+0x66>
  return false;
c0028d3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028d42:	83 c4 04             	add    $0x4,%esp
c0028d45:	5b                   	pop    %ebx
c0028d46:	5e                   	pop    %esi
c0028d47:	5f                   	pop    %edi
c0028d48:	5d                   	pop    %ebp
c0028d49:	c3                   	ret    
          return false;
c0028d4a:	b8 00 00 00 00       	mov    $0x0,%eax
      else if (c == ' ' || c == '\0')
c0028d4f:	f6 c3 df             	test   $0xdf,%bl
c0028d52:	75 ee                	jne    c0028d42 <parse_octal_field+0x66>
          return ofs > 0;
c0028d54:	85 f6                	test   %esi,%esi
c0028d56:	0f 95 c0             	setne  %al
c0028d59:	eb e7                	jmp    c0028d42 <parse_octal_field+0x66>

c0028d5b <strip_antisocial_prefixes>:
{
c0028d5b:	55                   	push   %ebp
c0028d5c:	57                   	push   %edi
c0028d5d:	56                   	push   %esi
c0028d5e:	53                   	push   %ebx
c0028d5f:	83 ec 1c             	sub    $0x1c,%esp
c0028d62:	e8 1e 5d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0028d67:	81 c3 4d 21 01 00    	add    $0x1214d,%ebx
c0028d6d:	89 c5                	mov    %eax,%ebp
         || !memcmp (file_name, "./", 2)
c0028d6f:	8d bb 05 5d ff ff    	lea    -0xa2fb(%ebx),%edi
         || !memcmp (file_name, "../", 3))
c0028d75:	8d 83 d1 68 ff ff    	lea    -0x972f(%ebx),%eax
c0028d7b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (*file_name == '/'
c0028d7f:	eb 11                	jmp    c0028d92 <strip_antisocial_prefixes+0x37>
    file_name = strchr (file_name, '/') + 1;
c0028d81:	83 ec 08             	sub    $0x8,%esp
c0028d84:	6a 2f                	push   $0x2f
c0028d86:	55                   	push   %ebp
c0028d87:	e8 2c f8 ff ff       	call   c00285b8 <strchr>
c0028d8c:	83 c4 10             	add    $0x10,%esp
c0028d8f:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/'
c0028d92:	0f b6 75 00          	movzbl 0x0(%ebp),%esi
c0028d96:	89 f0                	mov    %esi,%eax
c0028d98:	3c 2f                	cmp    $0x2f,%al
c0028d9a:	74 e5                	je     c0028d81 <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "./", 2)
c0028d9c:	83 ec 04             	sub    $0x4,%esp
c0028d9f:	6a 02                	push   $0x2
c0028da1:	57                   	push   %edi
c0028da2:	55                   	push   %ebp
c0028da3:	e8 52 f7 ff ff       	call   c00284fa <memcmp>
c0028da8:	83 c4 10             	add    $0x10,%esp
c0028dab:	85 c0                	test   %eax,%eax
c0028dad:	74 d2                	je     c0028d81 <strip_antisocial_prefixes+0x26>
         || !memcmp (file_name, "../", 3))
c0028daf:	83 ec 04             	sub    $0x4,%esp
c0028db2:	6a 03                	push   $0x3
c0028db4:	ff 74 24 14          	pushl  0x14(%esp)
c0028db8:	55                   	push   %ebp
c0028db9:	e8 3c f7 ff ff       	call   c00284fa <memcmp>
c0028dbe:	83 c4 10             	add    $0x10,%esp
c0028dc1:	85 c0                	test   %eax,%eax
c0028dc3:	74 bc                	je     c0028d81 <strip_antisocial_prefixes+0x26>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0028dc5:	8d 83 83 62 ff ff    	lea    -0x9d7d(%ebx),%eax
c0028dcb:	89 f2                	mov    %esi,%edx
c0028dcd:	84 d2                	test   %dl,%dl
c0028dcf:	74 22                	je     c0028df3 <strip_antisocial_prefixes+0x98>
c0028dd1:	b9 03 00 00 00       	mov    $0x3,%ecx
c0028dd6:	8d bb 82 62 ff ff    	lea    -0x9d7e(%ebx),%edi
c0028ddc:	89 ee                	mov    %ebp,%esi
c0028dde:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0028de0:	0f 97 c0             	seta   %al
c0028de3:	1c 00                	sbb    $0x0,%al
c0028de5:	0f be c0             	movsbl %al,%eax
c0028de8:	85 c0                	test   %eax,%eax
c0028dea:	8d 83 83 62 ff ff    	lea    -0x9d7d(%ebx),%eax
c0028df0:	0f 45 c5             	cmovne %ebp,%eax
}
c0028df3:	83 c4 1c             	add    $0x1c,%esp
c0028df6:	5b                   	pop    %ebx
c0028df7:	5e                   	pop    %esi
c0028df8:	5f                   	pop    %edi
c0028df9:	5d                   	pop    %ebp
c0028dfa:	c3                   	ret    

c0028dfb <ustar_make_header>:
{
c0028dfb:	55                   	push   %ebp
c0028dfc:	57                   	push   %edi
c0028dfd:	56                   	push   %esi
c0028dfe:	53                   	push   %ebx
c0028dff:	83 ec 1c             	sub    $0x1c,%esp
c0028e02:	e8 7e 5c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0028e07:	81 c3 ad 20 01 00    	add    $0x120ad,%ebx
c0028e0d:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028e11:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028e15:	83 fd 30             	cmp    $0x30,%ebp
c0028e18:	0f 94 c2             	sete   %dl
c0028e1b:	83 fd 35             	cmp    $0x35,%ebp
c0028e1e:	0f 94 c0             	sete   %al
c0028e21:	08 c2                	or     %al,%dl
c0028e23:	88 54 24 0f          	mov    %dl,0xf(%esp)
c0028e27:	0f 84 77 01 00 00    	je     c0028fa4 <ustar_make_header+0x1a9>
  file_name = strip_antisocial_prefixes (file_name);
c0028e2d:	8b 44 24 30          	mov    0x30(%esp),%eax
c0028e31:	e8 25 ff ff ff       	call   c0028d5b <strip_antisocial_prefixes>
c0028e36:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c0028e38:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028e3d:	b8 00 00 00 00       	mov    $0x0,%eax
c0028e42:	89 d7                	mov    %edx,%edi
c0028e44:	f2 ae                	repnz scas %es:(%edi),%al
c0028e46:	f7 d1                	not    %ecx
c0028e48:	83 e9 01             	sub    $0x1,%ecx
c0028e4b:	83 f9 63             	cmp    $0x63,%ecx
c0028e4e:	0f 87 76 01 00 00    	ja     c0028fca <ustar_make_header+0x1cf>
  memset (h, 0, sizeof *h);
c0028e54:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0028e5a:	c7 86 fc 01 00 00 00 	movl   $0x0,0x1fc(%esi)
c0028e61:	00 00 00 
c0028e64:	8d 7e 04             	lea    0x4(%esi),%edi
c0028e67:	83 e7 fc             	and    $0xfffffffc,%edi
c0028e6a:	89 f1                	mov    %esi,%ecx
c0028e6c:	29 f9                	sub    %edi,%ecx
c0028e6e:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0028e74:	c1 e9 02             	shr    $0x2,%ecx
c0028e77:	b8 00 00 00 00       	mov    $0x0,%eax
c0028e7c:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c0028e7e:	83 ec 04             	sub    $0x4,%esp
c0028e81:	6a 64                	push   $0x64
c0028e83:	52                   	push   %edx
c0028e84:	56                   	push   %esi
c0028e85:	e8 52 fa ff ff       	call   c00288dc <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
c0028e8a:	83 c4 10             	add    $0x10,%esp
c0028e8d:	83 fd 30             	cmp    $0x30,%ebp
c0028e90:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0028e95:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0028e9a:	0f 45 c2             	cmovne %edx,%eax
c0028e9d:	50                   	push   %eax
c0028e9e:	8d 83 ff 68 ff ff    	lea    -0x9701(%ebx),%eax
c0028ea4:	50                   	push   %eax
c0028ea5:	6a 08                	push   $0x8
c0028ea7:	8d 46 64             	lea    0x64(%esi),%eax
c0028eaa:	50                   	push   %eax
c0028eab:	e8 61 ef ff ff       	call   c0027e11 <snprintf>
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0028eb0:	83 c4 0c             	add    $0xc,%esp
c0028eb3:	6a 08                	push   $0x8
c0028eb5:	8d bb 04 69 ff ff    	lea    -0x96fc(%ebx),%edi
c0028ebb:	57                   	push   %edi
c0028ebc:	8d 46 6c             	lea    0x6c(%esi),%eax
c0028ebf:	50                   	push   %eax
c0028ec0:	e8 17 fa ff ff       	call   c00288dc <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0028ec5:	83 c4 0c             	add    $0xc,%esp
c0028ec8:	6a 08                	push   $0x8
c0028eca:	57                   	push   %edi
c0028ecb:	8d 46 74             	lea    0x74(%esi),%eax
c0028ece:	50                   	push   %eax
c0028ecf:	e8 08 fa ff ff       	call   c00288dc <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0028ed4:	ff 74 24 48          	pushl  0x48(%esp)
c0028ed8:	8d bb 0c 69 ff ff    	lea    -0x96f4(%ebx),%edi
c0028ede:	57                   	push   %edi
c0028edf:	6a 0c                	push   $0xc
c0028ee1:	8d 46 7c             	lea    0x7c(%esi),%eax
c0028ee4:	50                   	push   %eax
c0028ee5:	e8 27 ef ff ff       	call   c0027e11 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0028eea:	83 c4 20             	add    $0x20,%esp
c0028eed:	68 00 8c b7 43       	push   $0x43b78c00
c0028ef2:	57                   	push   %edi
c0028ef3:	6a 0c                	push   $0xc
c0028ef5:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0028efb:	50                   	push   %eax
c0028efc:	e8 10 ef ff ff       	call   c0027e11 <snprintf>
  h->typeflag = type;
c0028f01:	89 e8                	mov    %ebp,%eax
c0028f03:	88 86 9c 00 00 00    	mov    %al,0x9c(%esi)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0028f09:	83 c4 0c             	add    $0xc,%esp
c0028f0c:	6a 06                	push   $0x6
c0028f0e:	8d 83 12 69 ff ff    	lea    -0x96ee(%ebx),%eax
c0028f14:	50                   	push   %eax
c0028f15:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0028f1b:	50                   	push   %eax
c0028f1c:	e8 bb f9 ff ff       	call   c00288dc <strlcpy>
  h->version[0] = h->version[1] = '0';
c0028f21:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0028f28:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy (h->gname, "root", sizeof h->gname);
c0028f2f:	83 c4 0c             	add    $0xc,%esp
c0028f32:	6a 20                	push   $0x20
c0028f34:	8d bb b4 5e ff ff    	lea    -0xa14c(%ebx),%edi
c0028f3a:	57                   	push   %edi
c0028f3b:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c0028f41:	50                   	push   %eax
c0028f42:	e8 95 f9 ff ff       	call   c00288dc <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0028f47:	83 c4 0c             	add    $0xc,%esp
c0028f4a:	6a 20                	push   $0x20
c0028f4c:	57                   	push   %edi
c0028f4d:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0028f53:	50                   	push   %eax
c0028f54:	e8 83 f9 ff ff       	call   c00288dc <strlcpy>
c0028f59:	83 c4 10             	add    $0x10,%esp
c0028f5c:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c0028f61:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c0028f66:	bf 20 00 00 00       	mov    $0x20,%edi
c0028f6b:	83 f8 07             	cmp    $0x7,%eax
c0028f6e:	77 74                	ja     c0028fe4 <ustar_make_header+0x1e9>
c0028f70:	89 f9                	mov    %edi,%ecx
c0028f72:	01 ca                	add    %ecx,%edx
c0028f74:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0028f77:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0028f7c:	75 ed                	jne    c0028f6b <ustar_make_header+0x170>
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0028f7e:	52                   	push   %edx
c0028f7f:	8d 83 ff 68 ff ff    	lea    -0x9701(%ebx),%eax
c0028f85:	50                   	push   %eax
c0028f86:	6a 08                	push   $0x8
c0028f88:	81 c6 94 00 00 00    	add    $0x94,%esi
c0028f8e:	56                   	push   %esi
c0028f8f:	e8 7d ee ff ff       	call   c0027e11 <snprintf>
  return true;
c0028f94:	83 c4 10             	add    $0x10,%esp
}
c0028f97:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0028f9c:	83 c4 1c             	add    $0x1c,%esp
c0028f9f:	5b                   	pop    %ebx
c0028fa0:	5e                   	pop    %esi
c0028fa1:	5f                   	pop    %edi
c0028fa2:	5d                   	pop    %ebp
c0028fa3:	c3                   	ret    
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0028fa4:	83 ec 0c             	sub    $0xc,%esp
c0028fa7:	8d 83 bc 69 ff ff    	lea    -0x9644(%ebx),%eax
c0028fad:	50                   	push   %eax
c0028fae:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0028fb4:	50                   	push   %eax
c0028fb5:	8d 83 28 49 ff ff    	lea    -0xb6d8(%ebx),%eax
c0028fbb:	50                   	push   %eax
c0028fbc:	6a 59                	push   $0x59
c0028fbe:	8d 83 d5 68 ff ff    	lea    -0x972b(%ebx),%eax
c0028fc4:	50                   	push   %eax
c0028fc5:	e8 bd 02 00 00       	call   c0029287 <debug_panic>
      printf ("%s: file name too long\n", file_name);
c0028fca:	83 ec 08             	sub    $0x8,%esp
c0028fcd:	52                   	push   %edx
c0028fce:	8d 83 e7 68 ff ff    	lea    -0x9719(%ebx),%eax
c0028fd4:	50                   	push   %eax
c0028fd5:	e8 16 e5 ff ff       	call   c00274f0 <printf>
      return false;
c0028fda:	83 c4 10             	add    $0x10,%esp
c0028fdd:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
c0028fe2:	eb b3                	jmp    c0028f97 <ustar_make_header+0x19c>
      chksum += in_chksum_field ? ' ' : header[i];
c0028fe4:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0028feb:	00 
c0028fec:	eb 84                	jmp    c0028f72 <ustar_make_header+0x177>

c0028fee <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0028fee:	57                   	push   %edi
c0028fef:	56                   	push   %esi
c0028ff0:	53                   	push   %ebx
c0028ff1:	83 ec 10             	sub    $0x10,%esp
c0028ff4:	e8 8c 5a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0028ff9:	81 c3 bb 1e 01 00    	add    $0x11ebb,%ebx
c0028fff:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029003:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
c0029009:	89 f0                	mov    %esi,%eax
    if (*block++ != 0)
c002900b:	83 c0 01             	add    $0x1,%eax
c002900e:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0029012:	75 70                	jne    c0029084 <ustar_parse_header+0x96>
  while (cnt-- > 0)
c0029014:	39 c2                	cmp    %eax,%edx
c0029016:	75 f3                	jne    c002900b <ustar_parse_header+0x1d>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0029018:	8b 44 24 24          	mov    0x24(%esp),%eax
c002901c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0029022:	8b 44 24 28          	mov    0x28(%esp),%eax
c0029026:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c002902c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0029030:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0029036:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c002903b:	89 c8                	mov    %ecx,%eax
c002903d:	83 c4 10             	add    $0x10,%esp
c0029040:	5b                   	pop    %ebx
c0029041:	5e                   	pop    %esi
c0029042:	5f                   	pop    %edi
c0029043:	c3                   	ret    
      chksum += in_chksum_field ? ' ' : header[i];
c0029044:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c002904b:	00 
c002904c:	e9 b0 00 00 00       	jmp    c0029101 <ustar_parse_header+0x113>
    size_ul = 0;
c0029051:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029058:	00 
  *file_name = strip_antisocial_prefixes (h->name);
c0029059:	89 f0                	mov    %esi,%eax
c002905b:	e8 fb fc ff ff       	call   c0028d5b <strip_antisocial_prefixes>
c0029060:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029064:	89 07                	mov    %eax,(%edi)
  *type = h->typeflag;
c0029066:	0f be 86 9c 00 00 00 	movsbl 0x9c(%esi),%eax
c002906d:	8b 7c 24 28          	mov    0x28(%esp),%edi
c0029071:	89 07                	mov    %eax,(%edi)
  *size = size_ul;
c0029073:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029077:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002907b:	89 07                	mov    %eax,(%edi)
  return NULL;
c002907d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0029082:	eb b7                	jmp    c002903b <ustar_parse_header+0x4d>
  if (memcmp (h->magic, "ustar", 6))
c0029084:	83 ec 04             	sub    $0x4,%esp
c0029087:	6a 06                	push   $0x6
c0029089:	8d 83 12 69 ff ff    	lea    -0x96ee(%ebx),%eax
c002908f:	50                   	push   %eax
c0029090:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0029096:	50                   	push   %eax
c0029097:	e8 5e f4 ff ff       	call   c00284fa <memcmp>
c002909c:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c002909f:	8d 8b 18 69 ff ff    	lea    -0x96e8(%ebx),%ecx
  if (memcmp (h->magic, "ustar", 6))
c00290a5:	85 c0                	test   %eax,%eax
c00290a7:	75 92                	jne    c002903b <ustar_parse_header+0x4d>
    return "invalid ustar version";
c00290a9:	8d 8b 2c 69 ff ff    	lea    -0x96d4(%ebx),%ecx
  else if (h->version[0] != '0' || h->version[1] != '0')
c00290af:	80 be 07 01 00 00 30 	cmpb   $0x30,0x107(%esi)
c00290b6:	75 83                	jne    c002903b <ustar_parse_header+0x4d>
c00290b8:	80 be 08 01 00 00 30 	cmpb   $0x30,0x108(%esi)
c00290bf:	0f 85 76 ff ff ff    	jne    c002903b <ustar_parse_header+0x4d>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c00290c5:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c00290c9:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c00290cf:	ba 08 00 00 00       	mov    $0x8,%edx
c00290d4:	e8 03 fc ff ff       	call   c0028cdc <parse_octal_field>
    return "corrupt chksum field";
c00290d9:	8d 8b 42 69 ff ff    	lea    -0x96be(%ebx),%ecx
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c00290df:	84 c0                	test   %al,%al
c00290e1:	0f 84 54 ff ff ff    	je     c002903b <ustar_parse_header+0x4d>
c00290e7:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c00290ec:	ba 00 00 00 00       	mov    $0x0,%edx
      chksum += in_chksum_field ? ' ' : header[i];
c00290f1:	bf 20 00 00 00       	mov    $0x20,%edi
c00290f6:	83 f8 07             	cmp    $0x7,%eax
c00290f9:	0f 87 45 ff ff ff    	ja     c0029044 <ustar_parse_header+0x56>
c00290ff:	89 f9                	mov    %edi,%ecx
c0029101:	01 ca                	add    %ecx,%edx
c0029103:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029106:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c002910b:	75 e9                	jne    c00290f6 <ustar_parse_header+0x108>
    return "checksum mismatch";
c002910d:	8d 8b 57 69 ff ff    	lea    -0x96a9(%ebx),%ecx
  else if (chksum != calculate_chksum (h))
c0029113:	39 54 24 0c          	cmp    %edx,0xc(%esp)
c0029117:	0f 85 1e ff ff ff    	jne    c002903b <ustar_parse_header+0x4d>
    return "file name too long";
c002911d:	8d 8b 69 69 ff ff    	lea    -0x9697(%ebx),%ecx
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029123:	80 7e 63 00          	cmpb   $0x0,0x63(%esi)
c0029127:	0f 85 0e ff ff ff    	jne    c002903b <ustar_parse_header+0x4d>
c002912d:	80 be 59 01 00 00 00 	cmpb   $0x0,0x159(%esi)
c0029134:	0f 85 01 ff ff ff    	jne    c002903b <ustar_parse_header+0x4d>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c002913a:	0f b6 86 9c 00 00 00 	movzbl 0x9c(%esi),%eax
c0029141:	3c 30                	cmp    $0x30,%al
c0029143:	74 0e                	je     c0029153 <ustar_parse_header+0x165>
    return "unimplemented file type";
c0029145:	8d 8b 7c 69 ff ff    	lea    -0x9684(%ebx),%ecx
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c002914b:	3c 35                	cmp    $0x35,%al
c002914d:	0f 85 e8 fe ff ff    	jne    c002903b <ustar_parse_header+0x4d>
  if (h->typeflag == USTAR_REGULAR)
c0029153:	3c 30                	cmp    $0x30,%al
c0029155:	0f 85 f6 fe ff ff    	jne    c0029051 <ustar_parse_header+0x63>
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c002915b:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c002915f:	8d 46 7c             	lea    0x7c(%esi),%eax
c0029162:	ba 0c 00 00 00       	mov    $0xc,%edx
c0029167:	e8 70 fb ff ff       	call   c0028cdc <parse_octal_field>
        return "corrupt file size field";
c002916c:	8d 8b 94 69 ff ff    	lea    -0x966c(%ebx),%ecx
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0029172:	84 c0                	test   %al,%al
c0029174:	0f 84 c1 fe ff ff    	je     c002903b <ustar_parse_header+0x4d>
        return "file too large";
c002917a:	8d 8b ac 69 ff ff    	lea    -0x9654(%ebx),%ecx
      else if (size_ul > INT_MAX)
c0029180:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0029185:	0f 88 b0 fe ff ff    	js     c002903b <ustar_parse_header+0x4d>
c002918b:	e9 c9 fe ff ff       	jmp    c0029059 <ustar_parse_header+0x6b>

c0029190 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0029190:	55                   	push   %ebp
c0029191:	89 e5                	mov    %esp,%ebp
c0029193:	57                   	push   %edi
c0029194:	56                   	push   %esi
c0029195:	53                   	push   %ebx
c0029196:	83 ec 0c             	sub    $0xc,%esp
c0029199:	e8 e7 58 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002919e:	81 c3 16 1d 01 00    	add    $0x11d16,%ebx
c00291a4:	8b 75 08             	mov    0x8(%ebp),%esi
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c00291a7:	8b 56 04             	mov    0x4(%esi),%edx
    case THREAD_RUNNING:  
      status = "RUNNING";
      break;

    case THREAD_READY:  
      status = "READY";
c00291aa:	8d 83 ed 69 ff ff    	lea    -0x9613(%ebx),%eax
  switch (t->status) {
c00291b0:	83 fa 01             	cmp    $0x1,%edx
c00291b3:	74 1d                	je     c00291d2 <print_stacktrace+0x42>
      status = "RUNNING";
c00291b5:	8d 83 89 54 ff ff    	lea    -0xab77(%ebx),%eax
  switch (t->status) {
c00291bb:	83 fa 01             	cmp    $0x1,%edx
c00291be:	72 12                	jb     c00291d2 <print_stacktrace+0x42>
  const char *status = "UNKNOWN";
c00291c0:	83 fa 02             	cmp    $0x2,%edx
c00291c3:	8d 83 43 54 ff ff    	lea    -0xabbd(%ebx),%eax
c00291c9:	8d 93 f3 69 ff ff    	lea    -0x960d(%ebx),%edx
c00291cf:	0f 45 c2             	cmovne %edx,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c00291d2:	83 ec 04             	sub    $0x4,%esp
c00291d5:	50                   	push   %eax
c00291d6:	8d 46 08             	lea    0x8(%esi),%eax
c00291d9:	50                   	push   %eax
c00291da:	8d 83 18 6a ff ff    	lea    -0x95e8(%ebx),%eax
c00291e0:	50                   	push   %eax
c00291e1:	e8 0a e3 ff ff       	call   c00274f0 <printf>

  if (t == thread_current()) 
c00291e6:	e8 69 7b ff ff       	call   c0020d54 <thread_current>
c00291eb:	83 c4 10             	add    $0x10,%esp
c00291ee:	39 f0                	cmp    %esi,%eax
c00291f0:	74 79                	je     c002926b <print_stacktrace+0xdb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c00291f2:	8b 56 18             	mov    0x18(%esi),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c00291f5:	81 c6 00 10 00 00    	add    $0x1000,%esi
c00291fb:	39 f2                	cmp    %esi,%edx
c00291fd:	74 74                	je     c0029273 <print_stacktrace+0xe3>
c00291ff:	8b 42 10             	mov    0x10(%edx),%eax
c0029202:	81 f8 6d 1c 02 c0    	cmp    $0xc0021c6d,%eax
c0029208:	74 69                	je     c0029273 <print_stacktrace+0xe3>
        {
          printf (" thread was never scheduled.\n");
          return;
        }

      frame = (void **) saved_frame->ebp;
c002920a:	8b 72 08             	mov    0x8(%edx),%esi
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c002920d:	83 ec 08             	sub    $0x8,%esp
c0029210:	50                   	push   %eax
c0029211:	8d 83 ec 66 ff ff    	lea    -0x9914(%ebx),%eax
c0029217:	50                   	push   %eax
c0029218:	e8 d3 e2 ff ff       	call   c00274f0 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002921d:	83 c4 10             	add    $0x10,%esp
c0029220:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0029226:	76 29                	jbe    c0029251 <print_stacktrace+0xc1>
c0029228:	83 3e 00             	cmpl   $0x0,(%esi)
c002922b:	74 24                	je     c0029251 <print_stacktrace+0xc1>
    printf (" %p", frame[1]);
c002922d:	8d bb ec 66 ff ff    	lea    -0x9914(%ebx),%edi
c0029233:	83 ec 08             	sub    $0x8,%esp
c0029236:	ff 76 04             	pushl  0x4(%esi)
c0029239:	57                   	push   %edi
c002923a:	e8 b1 e2 ff ff       	call   c00274f0 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002923f:	8b 36                	mov    (%esi),%esi
c0029241:	83 c4 10             	add    $0x10,%esp
c0029244:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c002924a:	76 05                	jbe    c0029251 <print_stacktrace+0xc1>
c002924c:	83 3e 00             	cmpl   $0x0,(%esi)
c002924f:	75 e2                	jne    c0029233 <print_stacktrace+0xa3>
  printf (".\n");
c0029251:	83 ec 0c             	sub    $0xc,%esp
c0029254:	8d 83 83 62 ff ff    	lea    -0x9d7d(%ebx),%eax
c002925a:	50                   	push   %eax
c002925b:	e8 00 20 00 00       	call   c002b260 <puts>
c0029260:	83 c4 10             	add    $0x10,%esp
}
c0029263:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0029266:	5b                   	pop    %ebx
c0029267:	5e                   	pop    %esi
c0029268:	5f                   	pop    %edi
c0029269:	5d                   	pop    %ebp
c002926a:	c3                   	ret    
      frame = __builtin_frame_address (1);
c002926b:	8b 75 00             	mov    0x0(%ebp),%esi
      retaddr = __builtin_return_address (0);
c002926e:	8b 45 04             	mov    0x4(%ebp),%eax
c0029271:	eb 9a                	jmp    c002920d <print_stacktrace+0x7d>
          printf (" thread was never scheduled.\n");
c0029273:	83 ec 0c             	sub    $0xc,%esp
c0029276:	8d 83 fb 69 ff ff    	lea    -0x9605(%ebx),%eax
c002927c:	50                   	push   %eax
c002927d:	e8 de 1f 00 00       	call   c002b260 <puts>
          return;
c0029282:	83 c4 10             	add    $0x10,%esp
c0029285:	eb dc                	jmp    c0029263 <print_stacktrace+0xd3>

c0029287 <debug_panic>:
{
c0029287:	55                   	push   %ebp
c0029288:	57                   	push   %edi
c0029289:	56                   	push   %esi
c002928a:	53                   	push   %ebx
c002928b:	83 ec 0c             	sub    $0xc,%esp
c002928e:	e8 f2 57 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029293:	81 c3 21 1c 01 00    	add    $0x11c21,%ebx
c0029299:	8b 74 24 20          	mov    0x20(%esp),%esi
c002929d:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00292a1:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  intr_disable ();
c00292a5:	e8 85 8b ff ff       	call   c0021e2f <intr_disable>
  console_panic ();
c00292aa:	e8 30 1f 00 00       	call   c002b1df <console_panic>
  level++;
c00292af:	8b 83 6c 22 00 00    	mov    0x226c(%ebx),%eax
c00292b5:	83 c0 01             	add    $0x1,%eax
c00292b8:	89 83 6c 22 00 00    	mov    %eax,0x226c(%ebx)
  if (level == 1) 
c00292be:	83 f8 01             	cmp    $0x1,%eax
c00292c1:	74 11                	je     c00292d4 <debug_panic+0x4d>
  else if (level == 2)
c00292c3:	83 f8 02             	cmp    $0x2,%eax
c00292c6:	74 42                	je     c002930a <debug_panic+0x83>
  serial_flush ();
c00292c8:	e8 a8 bd ff ff       	call   c0025075 <serial_flush>
  shutdown ();
c00292cd:	e8 1b db ff ff       	call   c0026ded <shutdown>
c00292d2:	eb fe                	jmp    c00292d2 <debug_panic+0x4b>
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c00292d4:	55                   	push   %ebp
c00292d5:	57                   	push   %edi
c00292d6:	56                   	push   %esi
c00292d7:	8d 83 40 6a ff ff    	lea    -0x95c0(%ebx),%eax
c00292dd:	50                   	push   %eax
c00292de:	e8 0d e2 ff ff       	call   c00274f0 <printf>
      va_start (args, message);
c00292e3:	8d 44 24 40          	lea    0x40(%esp),%eax
      vprintf (message, args);
c00292e7:	83 c4 08             	add    $0x8,%esp
c00292ea:	50                   	push   %eax
c00292eb:	ff 74 24 38          	pushl  0x38(%esp)
c00292ef:	e8 29 1f 00 00       	call   c002b21d <vprintf>
      printf ("\n");
c00292f4:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c00292fb:	e8 d2 1f 00 00       	call   c002b2d2 <putchar>
      debug_backtrace ();
c0029300:	e8 cf db ff ff       	call   c0026ed4 <debug_backtrace>
c0029305:	83 c4 10             	add    $0x10,%esp
c0029308:	eb be                	jmp    c00292c8 <debug_panic+0x41>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c002930a:	55                   	push   %ebp
c002930b:	57                   	push   %edi
c002930c:	56                   	push   %esi
c002930d:	8d 83 60 6a ff ff    	lea    -0x95a0(%ebx),%eax
c0029313:	50                   	push   %eax
c0029314:	e8 d7 e1 ff ff       	call   c00274f0 <printf>
c0029319:	83 c4 10             	add    $0x10,%esp
c002931c:	eb aa                	jmp    c00292c8 <debug_panic+0x41>

c002931e <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c002931e:	56                   	push   %esi
c002931f:	53                   	push   %ebx
c0029320:	83 ec 04             	sub    $0x4,%esp
c0029323:	e8 5d 57 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029328:	81 c3 8c 1b 01 00    	add    $0x11b8c,%ebx
  enum intr_level oldlevel = intr_disable ();
c002932e:	e8 fc 8a ff ff       	call   c0021e2f <intr_disable>
c0029333:	89 c6                	mov    %eax,%esi

  thread_foreach (print_stacktrace, 0);
c0029335:	83 ec 08             	sub    $0x8,%esp
c0029338:	6a 00                	push   $0x0
c002933a:	8d 83 dc e2 fe ff    	lea    -0x11d24(%ebx),%eax
c0029340:	50                   	push   %eax
c0029341:	e8 1c 7b ff ff       	call   c0020e62 <thread_foreach>
  intr_set_level (oldlevel);
c0029346:	89 34 24             	mov    %esi,(%esp)
c0029349:	e8 e8 8a ff ff       	call   c0021e36 <intr_set_level>
}
c002934e:	83 c4 14             	add    $0x14,%esp
c0029351:	5b                   	pop    %ebx
c0029352:	5e                   	pop    %esi
c0029353:	c3                   	ret    

c0029354 <list_init>:
}

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0029354:	53                   	push   %ebx
c0029355:	83 ec 08             	sub    $0x8,%esp
c0029358:	e8 28 57 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002935d:	81 c3 57 1b 01 00    	add    $0x11b57,%ebx
c0029363:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0029367:	85 c0                	test   %eax,%eax
c0029369:	74 1b                	je     c0029386 <list_init+0x32>
  list->head.prev = NULL;
c002936b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0029371:	8d 50 08             	lea    0x8(%eax),%edx
c0029374:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0029377:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c002937a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029381:	83 c4 08             	add    $0x8,%esp
c0029384:	5b                   	pop    %ebx
c0029385:	c3                   	ret    
  ASSERT (list != NULL);
c0029386:	83 ec 0c             	sub    $0xc,%esp
c0029389:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c002938f:	50                   	push   %eax
c0029390:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029396:	50                   	push   %eax
c0029397:	8d 83 24 4a ff ff    	lea    -0xb5dc(%ebx),%eax
c002939d:	50                   	push   %eax
c002939e:	6a 3f                	push   $0x3f
c00293a0:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00293a6:	50                   	push   %eax
c00293a7:	e8 db fe ff ff       	call   c0029287 <debug_panic>

c00293ac <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c00293ac:	53                   	push   %ebx
c00293ad:	83 ec 08             	sub    $0x8,%esp
c00293b0:	e8 d0 56 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00293b5:	81 c3 ff 1a 01 00    	add    $0x11aff,%ebx
c00293bb:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00293bf:	85 c0                	test   %eax,%eax
c00293c1:	74 08                	je     c00293cb <list_begin+0x1f>
  return list->head.next;
c00293c3:	8b 40 04             	mov    0x4(%eax),%eax
}
c00293c6:	83 c4 08             	add    $0x8,%esp
c00293c9:	5b                   	pop    %ebx
c00293ca:	c3                   	ret    
  ASSERT (list != NULL);
c00293cb:	83 ec 0c             	sub    $0xc,%esp
c00293ce:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c00293d4:	50                   	push   %eax
c00293d5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00293db:	50                   	push   %eax
c00293dc:	8d 83 18 4a ff ff    	lea    -0xb5e8(%ebx),%eax
c00293e2:	50                   	push   %eax
c00293e3:	6a 4a                	push   $0x4a
c00293e5:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00293eb:	50                   	push   %eax
c00293ec:	e8 96 fe ff ff       	call   c0029287 <debug_panic>

c00293f1 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c00293f1:	53                   	push   %ebx
c00293f2:	83 ec 08             	sub    $0x8,%esp
c00293f5:	e8 8b 56 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00293fa:	81 c3 ba 1a 01 00    	add    $0x11aba,%ebx
c0029400:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029404:	85 c0                	test   %eax,%eax
c0029406:	74 20                	je     c0029428 <list_next+0x37>
c0029408:	83 38 00             	cmpl   $0x0,(%eax)
c002940b:	74 13                	je     c0029420 <list_next+0x2f>
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002940d:	83 38 00             	cmpl   $0x0,(%eax)
c0029410:	74 16                	je     c0029428 <list_next+0x37>
c0029412:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029416:	74 10                	je     c0029428 <list_next+0x37>
  ASSERT (is_head (elem) || is_interior (elem));
  return elem->next;
c0029418:	8b 40 04             	mov    0x4(%eax),%eax
}
c002941b:	83 c4 08             	add    $0x8,%esp
c002941e:	5b                   	pop    %ebx
c002941f:	c3                   	ret    
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029420:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029424:	75 f2                	jne    c0029418 <list_next+0x27>
c0029426:	eb e5                	jmp    c002940d <list_next+0x1c>
  ASSERT (is_head (elem) || is_interior (elem));
c0029428:	83 ec 0c             	sub    $0xc,%esp
c002942b:	8d 83 4c 6b ff ff    	lea    -0x94b4(%ebx),%eax
c0029431:	50                   	push   %eax
c0029432:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029438:	50                   	push   %eax
c0029439:	8d 83 0c 4a ff ff    	lea    -0xb5f4(%ebx),%eax
c002943f:	50                   	push   %eax
c0029440:	6a 54                	push   $0x54
c0029442:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029448:	50                   	push   %eax
c0029449:	e8 39 fe ff ff       	call   c0029287 <debug_panic>

c002944e <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c002944e:	53                   	push   %ebx
c002944f:	83 ec 08             	sub    $0x8,%esp
c0029452:	e8 2e 56 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029457:	81 c3 5d 1a 01 00    	add    $0x11a5d,%ebx
c002945d:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0029461:	85 c0                	test   %eax,%eax
c0029463:	74 08                	je     c002946d <list_end+0x1f>
  return &list->tail;
c0029465:	83 c0 08             	add    $0x8,%eax
}
c0029468:	83 c4 08             	add    $0x8,%esp
c002946b:	5b                   	pop    %ebx
c002946c:	c3                   	ret    
  ASSERT (list != NULL);
c002946d:	83 ec 0c             	sub    $0xc,%esp
c0029470:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c0029476:	50                   	push   %eax
c0029477:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002947d:	50                   	push   %eax
c002947e:	8d 83 00 4a ff ff    	lea    -0xb600(%ebx),%eax
c0029484:	50                   	push   %eax
c0029485:	6a 60                	push   $0x60
c0029487:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c002948d:	50                   	push   %eax
c002948e:	e8 f4 fd ff ff       	call   c0029287 <debug_panic>

c0029493 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0029493:	53                   	push   %ebx
c0029494:	83 ec 08             	sub    $0x8,%esp
c0029497:	e8 e9 55 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002949c:	81 c3 18 1a 01 00    	add    $0x11a18,%ebx
c00294a2:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00294a6:	85 c0                	test   %eax,%eax
c00294a8:	74 08                	je     c00294b2 <list_rbegin+0x1f>
  return list->tail.prev;
c00294aa:	8b 40 08             	mov    0x8(%eax),%eax
}
c00294ad:	83 c4 08             	add    $0x8,%esp
c00294b0:	5b                   	pop    %ebx
c00294b1:	c3                   	ret    
  ASSERT (list != NULL);
c00294b2:	83 ec 0c             	sub    $0xc,%esp
c00294b5:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c00294bb:	50                   	push   %eax
c00294bc:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00294c2:	50                   	push   %eax
c00294c3:	8d 83 f4 49 ff ff    	lea    -0xb60c(%ebx),%eax
c00294c9:	50                   	push   %eax
c00294ca:	6a 69                	push   $0x69
c00294cc:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00294d2:	50                   	push   %eax
c00294d3:	e8 af fd ff ff       	call   c0029287 <debug_panic>

c00294d8 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00294d8:	53                   	push   %ebx
c00294d9:	83 ec 08             	sub    $0x8,%esp
c00294dc:	e8 a4 55 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00294e1:	81 c3 d3 19 01 00    	add    $0x119d3,%ebx
c00294e7:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00294eb:	85 c0                	test   %eax,%eax
c00294ed:	74 1d                	je     c002950c <list_prev+0x34>
c00294ef:	83 38 00             	cmpl   $0x0,(%eax)
c00294f2:	74 0d                	je     c0029501 <list_prev+0x29>
c00294f4:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00294f8:	74 07                	je     c0029501 <list_prev+0x29>
  ASSERT (is_interior (elem) || is_tail (elem));
  return elem->prev;
c00294fa:	8b 00                	mov    (%eax),%eax
}
c00294fc:	83 c4 08             	add    $0x8,%esp
c00294ff:	5b                   	pop    %ebx
c0029500:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029501:	83 38 00             	cmpl   $0x0,(%eax)
c0029504:	74 06                	je     c002950c <list_prev+0x34>
c0029506:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002950a:	74 ee                	je     c00294fa <list_prev+0x22>
  ASSERT (is_interior (elem) || is_tail (elem));
c002950c:	83 ec 0c             	sub    $0xc,%esp
c002950f:	8d 83 74 6b ff ff    	lea    -0x948c(%ebx),%eax
c0029515:	50                   	push   %eax
c0029516:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002951c:	50                   	push   %eax
c002951d:	8d 83 e8 49 ff ff    	lea    -0xb618(%ebx),%eax
c0029523:	50                   	push   %eax
c0029524:	6a 73                	push   $0x73
c0029526:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c002952c:	50                   	push   %eax
c002952d:	e8 55 fd ff ff       	call   c0029287 <debug_panic>

c0029532 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0029532:	55                   	push   %ebp
c0029533:	57                   	push   %edi
c0029534:	56                   	push   %esi
c0029535:	53                   	push   %ebx
c0029536:	83 ec 1c             	sub    $0x1c,%esp
c0029539:	e8 4f 55 00 00       	call   c002ea8d <__x86.get_pc_thunk.di>
c002953e:	81 c7 76 19 01 00    	add    $0x11976,%edi
c0029544:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0029548:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (a != NULL);
c002954c:	85 c0                	test   %eax,%eax
c002954e:	74 50                	je     c00295a0 <find_end_of_run+0x6e>
c0029550:	89 c3                	mov    %eax,%ebx
c0029552:	89 d6                	mov    %edx,%esi
c0029554:	89 cf                	mov    %ecx,%edi
  ASSERT (b != NULL);
c0029556:	85 d2                	test   %edx,%edx
c0029558:	74 73                	je     c00295cd <find_end_of_run+0x9b>
  ASSERT (less != NULL);
c002955a:	85 c9                	test   %ecx,%ecx
c002955c:	0f 84 98 00 00 00    	je     c00295fa <find_end_of_run+0xc8>
  ASSERT (a != b);
c0029562:	39 d0                	cmp    %edx,%eax
c0029564:	0f 84 bd 00 00 00    	je     c0029627 <find_end_of_run+0xf5>
  
  do 
    {
      a = list_next (a);
c002956a:	83 ec 0c             	sub    $0xc,%esp
c002956d:	53                   	push   %ebx
c002956e:	e8 7e fe ff ff       	call   c00293f1 <list_next>
c0029573:	83 c4 10             	add    $0x10,%esp
c0029576:	89 c3                	mov    %eax,%ebx
    }
  while (a != b && !less (a, list_prev (a), aux));
c0029578:	39 c6                	cmp    %eax,%esi
c002957a:	74 1a                	je     c0029596 <find_end_of_run+0x64>
c002957c:	83 ec 0c             	sub    $0xc,%esp
c002957f:	50                   	push   %eax
c0029580:	e8 53 ff ff ff       	call   c00294d8 <list_prev>
c0029585:	83 c4 0c             	add    $0xc,%esp
c0029588:	55                   	push   %ebp
c0029589:	50                   	push   %eax
c002958a:	53                   	push   %ebx
c002958b:	ff d7                	call   *%edi
c002958d:	83 c4 10             	add    $0x10,%esp
c0029590:	84 c0                	test   %al,%al
c0029592:	74 d6                	je     c002956a <find_end_of_run+0x38>
      a = list_next (a);
c0029594:	89 de                	mov    %ebx,%esi
  return a;
}
c0029596:	89 f0                	mov    %esi,%eax
c0029598:	83 c4 1c             	add    $0x1c,%esp
c002959b:	5b                   	pop    %ebx
c002959c:	5e                   	pop    %esi
c002959d:	5f                   	pop    %edi
c002959e:	5d                   	pop    %ebp
c002959f:	c3                   	ret    
  ASSERT (a != NULL);
c00295a0:	83 ec 0c             	sub    $0xc,%esp
c00295a3:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00295a7:	8d 83 21 59 ff ff    	lea    -0xa6df(%ebx),%eax
c00295ad:	50                   	push   %eax
c00295ae:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00295b4:	50                   	push   %eax
c00295b5:	8d 83 6c 49 ff ff    	lea    -0xb694(%ebx),%eax
c00295bb:	50                   	push   %eax
c00295bc:	68 69 01 00 00       	push   $0x169
c00295c1:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00295c7:	50                   	push   %eax
c00295c8:	e8 ba fc ff ff       	call   c0029287 <debug_panic>
  ASSERT (b != NULL);
c00295cd:	83 ec 0c             	sub    $0xc,%esp
c00295d0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c00295d4:	8d 83 af 6a ff ff    	lea    -0x9551(%ebx),%eax
c00295da:	50                   	push   %eax
c00295db:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00295e1:	50                   	push   %eax
c00295e2:	8d 83 6c 49 ff ff    	lea    -0xb694(%ebx),%eax
c00295e8:	50                   	push   %eax
c00295e9:	68 6a 01 00 00       	push   $0x16a
c00295ee:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00295f4:	50                   	push   %eax
c00295f5:	e8 8d fc ff ff       	call   c0029287 <debug_panic>
  ASSERT (less != NULL);
c00295fa:	83 ec 0c             	sub    $0xc,%esp
c00295fd:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029601:	8d 83 b9 6a ff ff    	lea    -0x9547(%ebx),%eax
c0029607:	50                   	push   %eax
c0029608:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002960e:	50                   	push   %eax
c002960f:	8d 83 6c 49 ff ff    	lea    -0xb694(%ebx),%eax
c0029615:	50                   	push   %eax
c0029616:	68 6b 01 00 00       	push   $0x16b
c002961b:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029621:	50                   	push   %eax
c0029622:	e8 60 fc ff ff       	call   c0029287 <debug_panic>
  ASSERT (a != b);
c0029627:	83 ec 0c             	sub    $0xc,%esp
c002962a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002962e:	8d 83 c6 6a ff ff    	lea    -0x953a(%ebx),%eax
c0029634:	50                   	push   %eax
c0029635:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002963b:	50                   	push   %eax
c002963c:	8d 83 6c 49 ff ff    	lea    -0xb694(%ebx),%eax
c0029642:	50                   	push   %eax
c0029643:	68 6c 01 00 00       	push   $0x16c
c0029648:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c002964e:	50                   	push   %eax
c002964f:	e8 33 fc ff ff       	call   c0029287 <debug_panic>

c0029654 <is_sorted>:
{
c0029654:	55                   	push   %ebp
c0029655:	57                   	push   %edi
c0029656:	56                   	push   %esi
c0029657:	53                   	push   %ebx
c0029658:	83 ec 0c             	sub    $0xc,%esp
c002965b:	89 c3                	mov    %eax,%ebx
c002965d:	89 d6                	mov    %edx,%esi
c002965f:	89 cd                	mov    %ecx,%ebp
c0029661:	8b 7c 24 20          	mov    0x20(%esp),%edi
  if (a != b)
c0029665:	39 d0                	cmp    %edx,%eax
c0029667:	74 31                	je     c002969a <is_sorted+0x46>
    while ((a = list_next (a)) != b) 
c0029669:	83 ec 0c             	sub    $0xc,%esp
c002966c:	53                   	push   %ebx
c002966d:	e8 7f fd ff ff       	call   c00293f1 <list_next>
c0029672:	83 c4 10             	add    $0x10,%esp
c0029675:	89 c3                	mov    %eax,%ebx
c0029677:	39 c6                	cmp    %eax,%esi
c0029679:	74 26                	je     c00296a1 <is_sorted+0x4d>
      if (less (a, list_prev (a), aux))
c002967b:	83 ec 0c             	sub    $0xc,%esp
c002967e:	53                   	push   %ebx
c002967f:	e8 54 fe ff ff       	call   c00294d8 <list_prev>
c0029684:	83 c4 0c             	add    $0xc,%esp
c0029687:	57                   	push   %edi
c0029688:	50                   	push   %eax
c0029689:	53                   	push   %ebx
c002968a:	ff d5                	call   *%ebp
c002968c:	83 c4 10             	add    $0x10,%esp
c002968f:	84 c0                	test   %al,%al
c0029691:	74 d6                	je     c0029669 <is_sorted+0x15>
        return false;
c0029693:	b8 00 00 00 00       	mov    $0x0,%eax
c0029698:	eb 0c                	jmp    c00296a6 <is_sorted+0x52>
  return true;
c002969a:	b8 01 00 00 00       	mov    $0x1,%eax
c002969f:	eb 05                	jmp    c00296a6 <is_sorted+0x52>
c00296a1:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00296a6:	83 c4 0c             	add    $0xc,%esp
c00296a9:	5b                   	pop    %ebx
c00296aa:	5e                   	pop    %esi
c00296ab:	5f                   	pop    %edi
c00296ac:	5d                   	pop    %ebp
c00296ad:	c3                   	ret    

c00296ae <list_rend>:
{
c00296ae:	53                   	push   %ebx
c00296af:	83 ec 08             	sub    $0x8,%esp
c00296b2:	e8 ce 53 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00296b7:	81 c3 fd 17 01 00    	add    $0x117fd,%ebx
c00296bd:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c00296c1:	85 c0                	test   %eax,%eax
c00296c3:	74 05                	je     c00296ca <list_rend+0x1c>
}
c00296c5:	83 c4 08             	add    $0x8,%esp
c00296c8:	5b                   	pop    %ebx
c00296c9:	c3                   	ret    
  ASSERT (list != NULL);
c00296ca:	83 ec 0c             	sub    $0xc,%esp
c00296cd:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c00296d3:	50                   	push   %eax
c00296d4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00296da:	50                   	push   %eax
c00296db:	8d 83 dc 49 ff ff    	lea    -0xb624(%ebx),%eax
c00296e1:	50                   	push   %eax
c00296e2:	68 87 00 00 00       	push   $0x87
c00296e7:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00296ed:	50                   	push   %eax
c00296ee:	e8 94 fb ff ff       	call   c0029287 <debug_panic>

c00296f3 <list_head>:
{
c00296f3:	53                   	push   %ebx
c00296f4:	83 ec 08             	sub    $0x8,%esp
c00296f7:	e8 89 53 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c00296fc:	81 c3 b8 17 01 00    	add    $0x117b8,%ebx
c0029702:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0029706:	85 c0                	test   %eax,%eax
c0029708:	74 05                	je     c002970f <list_head+0x1c>
}
c002970a:	83 c4 08             	add    $0x8,%esp
c002970d:	5b                   	pop    %ebx
c002970e:	c3                   	ret    
  ASSERT (list != NULL);
c002970f:	83 ec 0c             	sub    $0xc,%esp
c0029712:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c0029718:	50                   	push   %eax
c0029719:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002971f:	50                   	push   %eax
c0029720:	8d 83 d0 49 ff ff    	lea    -0xb630(%ebx),%eax
c0029726:	50                   	push   %eax
c0029727:	68 99 00 00 00       	push   $0x99
c002972c:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029732:	50                   	push   %eax
c0029733:	e8 4f fb ff ff       	call   c0029287 <debug_panic>

c0029738 <list_tail>:
{
c0029738:	53                   	push   %ebx
c0029739:	83 ec 08             	sub    $0x8,%esp
c002973c:	e8 44 53 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029741:	81 c3 73 17 01 00    	add    $0x11773,%ebx
c0029747:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002974b:	85 c0                	test   %eax,%eax
c002974d:	74 08                	je     c0029757 <list_tail+0x1f>
  return &list->tail;
c002974f:	83 c0 08             	add    $0x8,%eax
}
c0029752:	83 c4 08             	add    $0x8,%esp
c0029755:	5b                   	pop    %ebx
c0029756:	c3                   	ret    
  ASSERT (list != NULL);
c0029757:	83 ec 0c             	sub    $0xc,%esp
c002975a:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c0029760:	50                   	push   %eax
c0029761:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029767:	50                   	push   %eax
c0029768:	8d 83 c4 49 ff ff    	lea    -0xb63c(%ebx),%eax
c002976e:	50                   	push   %eax
c002976f:	68 a1 00 00 00       	push   $0xa1
c0029774:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c002977a:	50                   	push   %eax
c002977b:	e8 07 fb ff ff       	call   c0029287 <debug_panic>

c0029780 <list_insert>:
{
c0029780:	53                   	push   %ebx
c0029781:	83 ec 08             	sub    $0x8,%esp
c0029784:	e8 fc 52 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029789:	81 c3 2b 17 01 00    	add    $0x1172b,%ebx
c002978f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029793:	8b 54 24 14          	mov    0x14(%esp),%edx
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029797:	85 c0                	test   %eax,%eax
c0029799:	74 2d                	je     c00297c8 <list_insert+0x48>
c002979b:	83 38 00             	cmpl   $0x0,(%eax)
c002979e:	74 1d                	je     c00297bd <list_insert+0x3d>
c00297a0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00297a4:	74 17                	je     c00297bd <list_insert+0x3d>
  ASSERT (elem != NULL);
c00297a6:	85 d2                	test   %edx,%edx
c00297a8:	74 47                	je     c00297f1 <list_insert+0x71>
  elem->prev = before->prev;
c00297aa:	8b 08                	mov    (%eax),%ecx
c00297ac:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c00297ae:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c00297b1:	8b 08                	mov    (%eax),%ecx
c00297b3:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c00297b6:	89 10                	mov    %edx,(%eax)
}
c00297b8:	83 c4 08             	add    $0x8,%esp
c00297bb:	5b                   	pop    %ebx
c00297bc:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00297bd:	83 38 00             	cmpl   $0x0,(%eax)
c00297c0:	74 06                	je     c00297c8 <list_insert+0x48>
c00297c2:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00297c6:	74 de                	je     c00297a6 <list_insert+0x26>
  ASSERT (is_interior (before) || is_tail (before));
c00297c8:	83 ec 0c             	sub    $0xc,%esp
c00297cb:	8d 83 9c 6b ff ff    	lea    -0x9464(%ebx),%eax
c00297d1:	50                   	push   %eax
c00297d2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00297d8:	50                   	push   %eax
c00297d9:	8d 83 b8 49 ff ff    	lea    -0xb648(%ebx),%eax
c00297df:	50                   	push   %eax
c00297e0:	68 ab 00 00 00       	push   $0xab
c00297e5:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00297eb:	50                   	push   %eax
c00297ec:	e8 96 fa ff ff       	call   c0029287 <debug_panic>
  ASSERT (elem != NULL);
c00297f1:	83 ec 0c             	sub    $0xc,%esp
c00297f4:	8d 83 cd 6a ff ff    	lea    -0x9533(%ebx),%eax
c00297fa:	50                   	push   %eax
c00297fb:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029801:	50                   	push   %eax
c0029802:	8d 83 b8 49 ff ff    	lea    -0xb648(%ebx),%eax
c0029808:	50                   	push   %eax
c0029809:	68 ac 00 00 00       	push   $0xac
c002980e:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029814:	50                   	push   %eax
c0029815:	e8 6d fa ff ff       	call   c0029287 <debug_panic>

c002981a <list_splice>:
{
c002981a:	57                   	push   %edi
c002981b:	56                   	push   %esi
c002981c:	53                   	push   %ebx
c002981d:	e8 63 52 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029822:	81 c3 92 16 01 00    	add    $0x11692,%ebx
c0029828:	8b 74 24 10          	mov    0x10(%esp),%esi
c002982c:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0029830:	8b 44 24 18          	mov    0x18(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029834:	85 f6                	test   %esi,%esi
c0029836:	74 6a                	je     c00298a2 <list_splice+0x88>
c0029838:	83 3e 00             	cmpl   $0x0,(%esi)
c002983b:	74 5a                	je     c0029897 <list_splice+0x7d>
c002983d:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029841:	74 54                	je     c0029897 <list_splice+0x7d>
  if (first == last)
c0029843:	39 c7                	cmp    %eax,%edi
c0029845:	74 4c                	je     c0029893 <list_splice+0x79>
  last = list_prev (last);
c0029847:	83 ec 0c             	sub    $0xc,%esp
c002984a:	50                   	push   %eax
c002984b:	e8 88 fc ff ff       	call   c00294d8 <list_prev>
c0029850:	83 c4 10             	add    $0x10,%esp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029853:	85 ff                	test   %edi,%edi
c0029855:	74 74                	je     c00298cb <list_splice+0xb1>
c0029857:	8b 17                	mov    (%edi),%edx
c0029859:	85 d2                	test   %edx,%edx
c002985b:	74 6e                	je     c00298cb <list_splice+0xb1>
c002985d:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c0029861:	74 68                	je     c00298cb <list_splice+0xb1>
c0029863:	85 c0                	test   %eax,%eax
c0029865:	0f 84 89 00 00 00    	je     c00298f4 <list_splice+0xda>
c002986b:	83 38 00             	cmpl   $0x0,(%eax)
c002986e:	0f 84 80 00 00 00    	je     c00298f4 <list_splice+0xda>
c0029874:	8b 48 04             	mov    0x4(%eax),%ecx
c0029877:	85 c9                	test   %ecx,%ecx
c0029879:	74 79                	je     c00298f4 <list_splice+0xda>
  first->prev->next = last->next;
c002987b:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c002987e:	8b 50 04             	mov    0x4(%eax),%edx
c0029881:	8b 0f                	mov    (%edi),%ecx
c0029883:	89 0a                	mov    %ecx,(%edx)
  first->prev = before->prev;
c0029885:	8b 16                	mov    (%esi),%edx
c0029887:	89 17                	mov    %edx,(%edi)
  last->next = before;
c0029889:	89 70 04             	mov    %esi,0x4(%eax)
  before->prev->next = first;
c002988c:	8b 16                	mov    (%esi),%edx
c002988e:	89 7a 04             	mov    %edi,0x4(%edx)
  before->prev = last;
c0029891:	89 06                	mov    %eax,(%esi)
}
c0029893:	5b                   	pop    %ebx
c0029894:	5e                   	pop    %esi
c0029895:	5f                   	pop    %edi
c0029896:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029897:	83 3e 00             	cmpl   $0x0,(%esi)
c002989a:	74 06                	je     c00298a2 <list_splice+0x88>
c002989c:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00298a0:	74 a1                	je     c0029843 <list_splice+0x29>
  ASSERT (is_interior (before) || is_tail (before));
c00298a2:	83 ec 0c             	sub    $0xc,%esp
c00298a5:	8d 83 9c 6b ff ff    	lea    -0x9464(%ebx),%eax
c00298ab:	50                   	push   %eax
c00298ac:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00298b2:	50                   	push   %eax
c00298b3:	8d 83 ac 49 ff ff    	lea    -0xb654(%ebx),%eax
c00298b9:	50                   	push   %eax
c00298ba:	68 bb 00 00 00       	push   $0xbb
c00298bf:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00298c5:	50                   	push   %eax
c00298c6:	e8 bc f9 ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_interior (first));
c00298cb:	83 ec 0c             	sub    $0xc,%esp
c00298ce:	8d 83 da 6a ff ff    	lea    -0x9526(%ebx),%eax
c00298d4:	50                   	push   %eax
c00298d5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c00298db:	50                   	push   %eax
c00298dc:	8d 83 ac 49 ff ff    	lea    -0xb654(%ebx),%eax
c00298e2:	50                   	push   %eax
c00298e3:	68 c0 00 00 00       	push   $0xc0
c00298e8:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00298ee:	50                   	push   %eax
c00298ef:	e8 93 f9 ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_interior (last));
c00298f4:	83 ec 0c             	sub    $0xc,%esp
c00298f7:	8d 83 ee 6a ff ff    	lea    -0x9512(%ebx),%eax
c00298fd:	50                   	push   %eax
c00298fe:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029904:	50                   	push   %eax
c0029905:	8d 83 ac 49 ff ff    	lea    -0xb654(%ebx),%eax
c002990b:	50                   	push   %eax
c002990c:	68 c1 00 00 00       	push   $0xc1
c0029911:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029917:	50                   	push   %eax
c0029918:	e8 6a f9 ff ff       	call   c0029287 <debug_panic>

c002991d <list_push_front>:
{
c002991d:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_begin (list), elem);
c0029920:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029924:	e8 83 fa ff ff       	call   c00293ac <list_begin>
c0029929:	83 c4 08             	add    $0x8,%esp
c002992c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029930:	50                   	push   %eax
c0029931:	e8 4a fe ff ff       	call   c0029780 <list_insert>
}
c0029936:	83 c4 1c             	add    $0x1c,%esp
c0029939:	c3                   	ret    

c002993a <list_push_back>:
{
c002993a:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_end (list), elem);
c002993d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029941:	e8 08 fb ff ff       	call   c002944e <list_end>
c0029946:	83 c4 08             	add    $0x8,%esp
c0029949:	ff 74 24 1c          	pushl  0x1c(%esp)
c002994d:	50                   	push   %eax
c002994e:	e8 2d fe ff ff       	call   c0029780 <list_insert>
}
c0029953:	83 c4 1c             	add    $0x1c,%esp
c0029956:	c3                   	ret    

c0029957 <list_remove>:
{
c0029957:	53                   	push   %ebx
c0029958:	83 ec 08             	sub    $0x8,%esp
c002995b:	e8 25 51 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029960:	81 c3 54 15 01 00    	add    $0x11554,%ebx
c0029966:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002996a:	85 c0                	test   %eax,%eax
c002996c:	74 1f                	je     c002998d <list_remove+0x36>
c002996e:	8b 10                	mov    (%eax),%edx
c0029970:	85 d2                	test   %edx,%edx
c0029972:	74 19                	je     c002998d <list_remove+0x36>
c0029974:	8b 48 04             	mov    0x4(%eax),%ecx
c0029977:	85 c9                	test   %ecx,%ecx
c0029979:	74 12                	je     c002998d <list_remove+0x36>
  elem->prev->next = elem->next;
c002997b:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c002997e:	8b 50 04             	mov    0x4(%eax),%edx
c0029981:	8b 08                	mov    (%eax),%ecx
c0029983:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c0029985:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029988:	83 c4 08             	add    $0x8,%esp
c002998b:	5b                   	pop    %ebx
c002998c:	c3                   	ret    
  ASSERT (is_interior (elem));
c002998d:	83 ec 0c             	sub    $0xc,%esp
c0029990:	8d 83 01 6b ff ff    	lea    -0x94ff(%ebx),%eax
c0029996:	50                   	push   %eax
c0029997:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002999d:	50                   	push   %eax
c002999e:	8d 83 a0 49 ff ff    	lea    -0xb660(%ebx),%eax
c00299a4:	50                   	push   %eax
c00299a5:	68 fb 00 00 00       	push   $0xfb
c00299aa:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c00299b0:	50                   	push   %eax
c00299b1:	e8 d1 f8 ff ff       	call   c0029287 <debug_panic>

c00299b6 <list_size>:
{
c00299b6:	57                   	push   %edi
c00299b7:	56                   	push   %esi
c00299b8:	53                   	push   %ebx
c00299b9:	8b 7c 24 10          	mov    0x10(%esp),%edi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00299bd:	83 ec 0c             	sub    $0xc,%esp
c00299c0:	57                   	push   %edi
c00299c1:	e8 e6 f9 ff ff       	call   c00293ac <list_begin>
c00299c6:	83 c4 10             	add    $0x10,%esp
c00299c9:	89 c3                	mov    %eax,%ebx
  size_t cnt = 0;
c00299cb:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00299d0:	eb 11                	jmp    c00299e3 <list_size+0x2d>
    cnt++;
c00299d2:	83 c6 01             	add    $0x1,%esi
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00299d5:	83 ec 0c             	sub    $0xc,%esp
c00299d8:	53                   	push   %ebx
c00299d9:	e8 13 fa ff ff       	call   c00293f1 <list_next>
c00299de:	83 c4 10             	add    $0x10,%esp
c00299e1:	89 c3                	mov    %eax,%ebx
c00299e3:	83 ec 0c             	sub    $0xc,%esp
c00299e6:	57                   	push   %edi
c00299e7:	e8 62 fa ff ff       	call   c002944e <list_end>
c00299ec:	83 c4 10             	add    $0x10,%esp
c00299ef:	39 d8                	cmp    %ebx,%eax
c00299f1:	75 df                	jne    c00299d2 <list_size+0x1c>
}
c00299f3:	89 f0                	mov    %esi,%eax
c00299f5:	5b                   	pop    %ebx
c00299f6:	5e                   	pop    %esi
c00299f7:	5f                   	pop    %edi
c00299f8:	c3                   	ret    

c00299f9 <list_empty>:
{
c00299f9:	56                   	push   %esi
c00299fa:	53                   	push   %ebx
c00299fb:	83 ec 10             	sub    $0x10,%esp
c00299fe:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin (list) == list_end (list);
c0029a02:	53                   	push   %ebx
c0029a03:	e8 a4 f9 ff ff       	call   c00293ac <list_begin>
c0029a08:	89 c6                	mov    %eax,%esi
c0029a0a:	89 1c 24             	mov    %ebx,(%esp)
c0029a0d:	e8 3c fa ff ff       	call   c002944e <list_end>
c0029a12:	39 c6                	cmp    %eax,%esi
c0029a14:	0f 94 c0             	sete   %al
}
c0029a17:	83 c4 14             	add    $0x14,%esp
c0029a1a:	5b                   	pop    %ebx
c0029a1b:	5e                   	pop    %esi
c0029a1c:	c3                   	ret    

c0029a1d <list_front>:
{
c0029a1d:	56                   	push   %esi
c0029a1e:	53                   	push   %ebx
c0029a1f:	83 ec 10             	sub    $0x10,%esp
c0029a22:	e8 5e 50 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029a27:	81 c3 8d 14 01 00    	add    $0x1148d,%ebx
c0029a2d:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (!list_empty (list));
c0029a31:	56                   	push   %esi
c0029a32:	e8 c2 ff ff ff       	call   c00299f9 <list_empty>
c0029a37:	83 c4 10             	add    $0x10,%esp
c0029a3a:	84 c0                	test   %al,%al
c0029a3c:	75 09                	jne    c0029a47 <list_front+0x2a>
  return list->head.next;
c0029a3e:	8b 46 04             	mov    0x4(%esi),%eax
}
c0029a41:	83 c4 04             	add    $0x4,%esp
c0029a44:	5b                   	pop    %ebx
c0029a45:	5e                   	pop    %esi
c0029a46:	c3                   	ret    
  ASSERT (!list_empty (list));
c0029a47:	83 ec 0c             	sub    $0xc,%esp
c0029a4a:	8d 83 14 6b ff ff    	lea    -0x94ec(%ebx),%eax
c0029a50:	50                   	push   %eax
c0029a51:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029a57:	50                   	push   %eax
c0029a58:	8d 83 94 49 ff ff    	lea    -0xb66c(%ebx),%eax
c0029a5e:	50                   	push   %eax
c0029a5f:	68 1a 01 00 00       	push   $0x11a
c0029a64:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029a6a:	50                   	push   %eax
c0029a6b:	e8 17 f8 ff ff       	call   c0029287 <debug_panic>

c0029a70 <list_pop_front>:
{
c0029a70:	53                   	push   %ebx
c0029a71:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front (list);
c0029a74:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029a78:	e8 a0 ff ff ff       	call   c0029a1d <list_front>
c0029a7d:	89 c3                	mov    %eax,%ebx
  list_remove (front);
c0029a7f:	89 04 24             	mov    %eax,(%esp)
c0029a82:	e8 d0 fe ff ff       	call   c0029957 <list_remove>
}
c0029a87:	89 d8                	mov    %ebx,%eax
c0029a89:	83 c4 18             	add    $0x18,%esp
c0029a8c:	5b                   	pop    %ebx
c0029a8d:	c3                   	ret    

c0029a8e <list_back>:
{
c0029a8e:	56                   	push   %esi
c0029a8f:	53                   	push   %ebx
c0029a90:	83 ec 10             	sub    $0x10,%esp
c0029a93:	e8 ed 4f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029a98:	81 c3 1c 14 01 00    	add    $0x1141c,%ebx
c0029a9e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT (!list_empty (list));
c0029aa2:	56                   	push   %esi
c0029aa3:	e8 51 ff ff ff       	call   c00299f9 <list_empty>
c0029aa8:	83 c4 10             	add    $0x10,%esp
c0029aab:	84 c0                	test   %al,%al
c0029aad:	75 09                	jne    c0029ab8 <list_back+0x2a>
  return list->tail.prev;
c0029aaf:	8b 46 08             	mov    0x8(%esi),%eax
}
c0029ab2:	83 c4 04             	add    $0x4,%esp
c0029ab5:	5b                   	pop    %ebx
c0029ab6:	5e                   	pop    %esi
c0029ab7:	c3                   	ret    
  ASSERT (!list_empty (list));
c0029ab8:	83 ec 0c             	sub    $0xc,%esp
c0029abb:	8d 83 14 6b ff ff    	lea    -0x94ec(%ebx),%eax
c0029ac1:	50                   	push   %eax
c0029ac2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029ac8:	50                   	push   %eax
c0029ac9:	8d 83 88 49 ff ff    	lea    -0xb678(%ebx),%eax
c0029acf:	50                   	push   %eax
c0029ad0:	68 23 01 00 00       	push   $0x123
c0029ad5:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029adb:	50                   	push   %eax
c0029adc:	e8 a6 f7 ff ff       	call   c0029287 <debug_panic>

c0029ae1 <list_pop_back>:
{
c0029ae1:	53                   	push   %ebx
c0029ae2:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back (list);
c0029ae5:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029ae9:	e8 a0 ff ff ff       	call   c0029a8e <list_back>
c0029aee:	89 c3                	mov    %eax,%ebx
  list_remove (back);
c0029af0:	89 04 24             	mov    %eax,(%esp)
c0029af3:	e8 5f fe ff ff       	call   c0029957 <list_remove>
}
c0029af8:	89 d8                	mov    %ebx,%eax
c0029afa:	83 c4 18             	add    $0x18,%esp
c0029afd:	5b                   	pop    %ebx
c0029afe:	c3                   	ret    

c0029aff <list_reverse>:
{
c0029aff:	56                   	push   %esi
c0029b00:	53                   	push   %ebx
c0029b01:	83 ec 10             	sub    $0x10,%esp
c0029b04:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty (list)) 
c0029b08:	56                   	push   %esi
c0029b09:	e8 eb fe ff ff       	call   c00299f9 <list_empty>
c0029b0e:	83 c4 10             	add    $0x10,%esp
c0029b11:	84 c0                	test   %al,%al
c0029b13:	74 06                	je     c0029b1b <list_reverse+0x1c>
}
c0029b15:	83 c4 04             	add    $0x4,%esp
c0029b18:	5b                   	pop    %ebx
c0029b19:	5e                   	pop    %esi
c0029b1a:	c3                   	ret    
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029b1b:	83 ec 0c             	sub    $0xc,%esp
c0029b1e:	56                   	push   %esi
c0029b1f:	e8 88 f8 ff ff       	call   c00293ac <list_begin>
c0029b24:	83 c4 10             	add    $0x10,%esp
c0029b27:	89 c3                	mov    %eax,%ebx
c0029b29:	eb 0c                	jmp    c0029b37 <list_reverse+0x38>
  struct list_elem *t = *a;
c0029b2b:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c0029b2d:	8b 43 04             	mov    0x4(%ebx),%eax
c0029b30:	89 03                	mov    %eax,(%ebx)
  *b = t;
c0029b32:	89 53 04             	mov    %edx,0x4(%ebx)
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029b35:	89 c3                	mov    %eax,%ebx
c0029b37:	83 ec 0c             	sub    $0xc,%esp
c0029b3a:	56                   	push   %esi
c0029b3b:	e8 0e f9 ff ff       	call   c002944e <list_end>
c0029b40:	83 c4 10             	add    $0x10,%esp
c0029b43:	39 d8                	cmp    %ebx,%eax
c0029b45:	75 e4                	jne    c0029b2b <list_reverse+0x2c>
  struct list_elem *t = *a;
c0029b47:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c0029b4a:	8b 56 08             	mov    0x8(%esi),%edx
c0029b4d:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c0029b50:	89 46 08             	mov    %eax,0x8(%esi)
  struct list_elem *t = *a;
c0029b53:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c0029b55:	8b 58 04             	mov    0x4(%eax),%ebx
c0029b58:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c0029b5a:	89 48 04             	mov    %ecx,0x4(%eax)
}
c0029b5d:	eb b6                	jmp    c0029b15 <list_reverse+0x16>

c0029b5f <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c0029b5f:	55                   	push   %ebp
c0029b60:	57                   	push   %edi
c0029b61:	56                   	push   %esi
c0029b62:	53                   	push   %ebx
c0029b63:	83 ec 1c             	sub    $0x1c,%esp
c0029b66:	e8 1e 4f 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c0029b6b:	05 49 13 01 00       	add    $0x11349,%eax
c0029b70:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0029b74:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0029b78:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c0029b7c:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0029b81:	74 35                	je     c0029bb8 <list_sort+0x59>
  ASSERT (less != NULL);
c0029b83:	85 ed                	test   %ebp,%ebp
c0029b85:	0f 85 41 02 00 00    	jne    c0029dcc <list_sort+0x26d>
c0029b8b:	83 ec 0c             	sub    $0xc,%esp
c0029b8e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029b92:	8d 83 b9 6a ff ff    	lea    -0x9547(%ebx),%eax
c0029b98:	50                   	push   %eax
c0029b99:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029b9f:	50                   	push   %eax
c0029ba0:	8d 83 7c 49 ff ff    	lea    -0xb684(%ebx),%eax
c0029ba6:	50                   	push   %eax
c0029ba7:	68 9a 01 00 00       	push   $0x19a
c0029bac:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029bb2:	50                   	push   %eax
c0029bb3:	e8 cf f6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (list != NULL);
c0029bb8:	83 ec 0c             	sub    $0xc,%esp
c0029bbb:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029bbf:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c0029bc5:	50                   	push   %eax
c0029bc6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029bcc:	50                   	push   %eax
c0029bcd:	8d 83 7c 49 ff ff    	lea    -0xb684(%ebx),%eax
c0029bd3:	50                   	push   %eax
c0029bd4:	68 99 01 00 00       	push   $0x199
c0029bd9:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029bdf:	50                   	push   %eax
c0029be0:	e8 a2 f6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (a0 != NULL);
c0029be5:	83 ec 0c             	sub    $0xc,%esp
c0029be8:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029bec:	8d 83 27 6b ff ff    	lea    -0x94d9(%ebx),%eax
c0029bf2:	50                   	push   %eax
c0029bf3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029bf9:	50                   	push   %eax
c0029bfa:	8d 83 5c 49 ff ff    	lea    -0xb6a4(%ebx),%eax
c0029c00:	50                   	push   %eax
c0029c01:	68 80 01 00 00       	push   $0x180
c0029c06:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029c0c:	50                   	push   %eax
c0029c0d:	e8 75 f6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (a1b0 != NULL);
c0029c12:	83 ec 0c             	sub    $0xc,%esp
c0029c15:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c19:	8d 83 32 6b ff ff    	lea    -0x94ce(%ebx),%eax
c0029c1f:	50                   	push   %eax
c0029c20:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029c26:	50                   	push   %eax
c0029c27:	8d 83 5c 49 ff ff    	lea    -0xb6a4(%ebx),%eax
c0029c2d:	50                   	push   %eax
c0029c2e:	68 81 01 00 00       	push   $0x181
c0029c33:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029c39:	50                   	push   %eax
c0029c3a:	e8 48 f6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (b1 != NULL);
c0029c3f:	83 ec 0c             	sub    $0xc,%esp
c0029c42:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c46:	8d 83 3f 6b ff ff    	lea    -0x94c1(%ebx),%eax
c0029c4c:	50                   	push   %eax
c0029c4d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029c53:	50                   	push   %eax
c0029c54:	8d 83 5c 49 ff ff    	lea    -0xb6a4(%ebx),%eax
c0029c5a:	50                   	push   %eax
c0029c5b:	68 82 01 00 00       	push   $0x182
c0029c60:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029c66:	50                   	push   %eax
c0029c67:	e8 1b f6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0029c6c:	83 ec 0c             	sub    $0xc,%esp
c0029c6f:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c73:	8d 83 c8 6b ff ff    	lea    -0x9438(%ebx),%eax
c0029c79:	50                   	push   %eax
c0029c7a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029c80:	50                   	push   %eax
c0029c81:	8d 83 5c 49 ff ff    	lea    -0xb6a4(%ebx),%eax
c0029c87:	50                   	push   %eax
c0029c88:	68 84 01 00 00       	push   $0x184
c0029c8d:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029c93:	50                   	push   %eax
c0029c94:	e8 ee f5 ff ff       	call   c0029287 <debug_panic>
        a1b0 = list_next (a1b0);
c0029c99:	83 ec 0c             	sub    $0xc,%esp
c0029c9c:	53                   	push   %ebx
c0029c9d:	e8 4f f7 ff ff       	call   c00293f1 <list_next>
c0029ca2:	89 c3                	mov    %eax,%ebx
        list_splice (a0, list_prev (a1b0), a1b0);
c0029ca4:	89 04 24             	mov    %eax,(%esp)
c0029ca7:	e8 2c f8 ff ff       	call   c00294d8 <list_prev>
c0029cac:	83 c4 0c             	add    $0xc,%esp
c0029caf:	53                   	push   %ebx
c0029cb0:	50                   	push   %eax
c0029cb1:	56                   	push   %esi
c0029cb2:	e8 63 fb ff ff       	call   c002981a <list_splice>
c0029cb7:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c0029cba:	39 f3                	cmp    %esi,%ebx
c0029cbc:	0f 95 c2             	setne  %dl
c0029cbf:	39 5c 24 04          	cmp    %ebx,0x4(%esp)
c0029cc3:	0f 95 c0             	setne  %al
c0029cc6:	84 c2                	test   %al,%dl
c0029cc8:	74 1f                	je     c0029ce9 <list_sort+0x18a>
    if (!less (a1b0, a0, aux)) 
c0029cca:	83 ec 04             	sub    $0x4,%esp
c0029ccd:	57                   	push   %edi
c0029cce:	56                   	push   %esi
c0029ccf:	53                   	push   %ebx
c0029cd0:	ff d5                	call   *%ebp
c0029cd2:	83 c4 10             	add    $0x10,%esp
c0029cd5:	84 c0                	test   %al,%al
c0029cd7:	75 c0                	jne    c0029c99 <list_sort+0x13a>
      a0 = list_next (a0);
c0029cd9:	83 ec 0c             	sub    $0xc,%esp
c0029cdc:	56                   	push   %esi
c0029cdd:	e8 0f f7 ff ff       	call   c00293f1 <list_next>
c0029ce2:	83 c4 10             	add    $0x10,%esp
c0029ce5:	89 c6                	mov    %eax,%esi
c0029ce7:	eb d1                	jmp    c0029cba <list_sort+0x15b>
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0029ce9:	8b 74 24 04          	mov    0x4(%esp),%esi
c0029ced:	83 ec 0c             	sub    $0xc,%esp
c0029cf0:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029cf4:	e8 55 f7 ff ff       	call   c002944e <list_end>
c0029cf9:	83 c4 10             	add    $0x10,%esp
c0029cfc:	39 f0                	cmp    %esi,%eax
c0029cfe:	0f 84 c1 00 00 00    	je     c0029dc5 <list_sort+0x266>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c0029d04:	83 44 24 08 01       	addl   $0x1,0x8(%esp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c0029d09:	83 ec 0c             	sub    $0xc,%esp
c0029d0c:	57                   	push   %edi
c0029d0d:	89 e9                	mov    %ebp,%ecx
c0029d0f:	89 c2                	mov    %eax,%edx
c0029d11:	89 f0                	mov    %esi,%eax
c0029d13:	e8 1a f8 ff ff       	call   c0029532 <find_end_of_run>
c0029d18:	89 c3                	mov    %eax,%ebx
          if (a1b0 == list_end (list))
c0029d1a:	83 c4 04             	add    $0x4,%esp
c0029d1d:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029d21:	e8 28 f7 ff ff       	call   c002944e <list_end>
c0029d26:	83 c4 10             	add    $0x10,%esp
c0029d29:	39 d8                	cmp    %ebx,%eax
c0029d2b:	0f 84 94 00 00 00    	je     c0029dc5 <list_sort+0x266>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c0029d31:	83 ec 0c             	sub    $0xc,%esp
c0029d34:	57                   	push   %edi
c0029d35:	89 e9                	mov    %ebp,%ecx
c0029d37:	89 c2                	mov    %eax,%edx
c0029d39:	89 d8                	mov    %ebx,%eax
c0029d3b:	e8 f2 f7 ff ff       	call   c0029532 <find_end_of_run>
c0029d40:	89 44 24 14          	mov    %eax,0x14(%esp)
  ASSERT (a0 != NULL);
c0029d44:	83 c4 10             	add    $0x10,%esp
c0029d47:	85 f6                	test   %esi,%esi
c0029d49:	0f 84 96 fe ff ff    	je     c0029be5 <list_sort+0x86>
  ASSERT (a1b0 != NULL);
c0029d4f:	85 db                	test   %ebx,%ebx
c0029d51:	0f 84 bb fe ff ff    	je     c0029c12 <list_sort+0xb3>
  ASSERT (b1 != NULL);
c0029d57:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0029d5c:	0f 84 dd fe ff ff    	je     c0029c3f <list_sort+0xe0>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0029d62:	83 ec 0c             	sub    $0xc,%esp
c0029d65:	57                   	push   %edi
c0029d66:	89 e9                	mov    %ebp,%ecx
c0029d68:	89 da                	mov    %ebx,%edx
c0029d6a:	89 f0                	mov    %esi,%eax
c0029d6c:	e8 e3 f8 ff ff       	call   c0029654 <is_sorted>
c0029d71:	83 c4 10             	add    $0x10,%esp
c0029d74:	84 c0                	test   %al,%al
c0029d76:	0f 84 f0 fe ff ff    	je     c0029c6c <list_sort+0x10d>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0029d7c:	83 ec 0c             	sub    $0xc,%esp
c0029d7f:	57                   	push   %edi
c0029d80:	89 e9                	mov    %ebp,%ecx
c0029d82:	8b 54 24 14          	mov    0x14(%esp),%edx
c0029d86:	89 d8                	mov    %ebx,%eax
c0029d88:	e8 c7 f8 ff ff       	call   c0029654 <is_sorted>
c0029d8d:	83 c4 10             	add    $0x10,%esp
c0029d90:	84 c0                	test   %al,%al
c0029d92:	0f 85 22 ff ff ff    	jne    c0029cba <list_sort+0x15b>
c0029d98:	83 ec 0c             	sub    $0xc,%esp
c0029d9b:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029d9f:	8d 83 e8 6b ff ff    	lea    -0x9418(%ebx),%eax
c0029da5:	50                   	push   %eax
c0029da6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029dac:	50                   	push   %eax
c0029dad:	8d 83 5c 49 ff ff    	lea    -0xb6a4(%ebx),%eax
c0029db3:	50                   	push   %eax
c0029db4:	68 85 01 00 00       	push   $0x185
c0029db9:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029dbf:	50                   	push   %eax
c0029dc0:	e8 c2 f4 ff ff       	call   c0029287 <debug_panic>

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c0029dc5:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
c0029dca:	76 1e                	jbe    c0029dea <list_sort+0x28b>
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0029dcc:	83 ec 0c             	sub    $0xc,%esp
c0029dcf:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029dd3:	e8 d4 f5 ff ff       	call   c00293ac <list_begin>
c0029dd8:	83 c4 10             	add    $0x10,%esp
c0029ddb:	89 c6                	mov    %eax,%esi
      output_run_cnt = 0;
c0029ddd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029de4:	00 
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0029de5:	e9 03 ff ff ff       	jmp    c0029ced <list_sort+0x18e>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0029dea:	83 ec 0c             	sub    $0xc,%esp
c0029ded:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029df1:	e8 58 f6 ff ff       	call   c002944e <list_end>
c0029df6:	83 c4 04             	add    $0x4,%esp
c0029df9:	89 c3                	mov    %eax,%ebx
c0029dfb:	ff 74 24 3c          	pushl  0x3c(%esp)
c0029dff:	e8 a8 f5 ff ff       	call   c00293ac <list_begin>
c0029e04:	89 3c 24             	mov    %edi,(%esp)
c0029e07:	89 e9                	mov    %ebp,%ecx
c0029e09:	89 da                	mov    %ebx,%edx
c0029e0b:	e8 44 f8 ff ff       	call   c0029654 <is_sorted>
c0029e10:	83 c4 10             	add    $0x10,%esp
c0029e13:	84 c0                	test   %al,%al
c0029e15:	74 08                	je     c0029e1f <list_sort+0x2c0>
}
c0029e17:	83 c4 1c             	add    $0x1c,%esp
c0029e1a:	5b                   	pop    %ebx
c0029e1b:	5e                   	pop    %esi
c0029e1c:	5f                   	pop    %edi
c0029e1d:	5d                   	pop    %ebp
c0029e1e:	c3                   	ret    
  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c0029e1f:	83 ec 0c             	sub    $0xc,%esp
c0029e22:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029e26:	8d 83 08 6c ff ff    	lea    -0x93f8(%ebx),%eax
c0029e2c:	50                   	push   %eax
c0029e2d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029e33:	50                   	push   %eax
c0029e34:	8d 83 7c 49 ff ff    	lea    -0xb684(%ebx),%eax
c0029e3a:	50                   	push   %eax
c0029e3b:	68 b7 01 00 00       	push   $0x1b7
c0029e40:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029e46:	50                   	push   %eax
c0029e47:	e8 3b f4 ff ff       	call   c0029287 <debug_panic>

c0029e4c <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c0029e4c:	55                   	push   %ebp
c0029e4d:	57                   	push   %edi
c0029e4e:	56                   	push   %esi
c0029e4f:	53                   	push   %ebx
c0029e50:	83 ec 0c             	sub    $0xc,%esp
c0029e53:	e8 2d 4c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029e58:	81 c3 5c 10 01 00    	add    $0x1105c,%ebx
c0029e5e:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029e62:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029e66:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT (list != NULL);
c0029e6a:	85 f6                	test   %esi,%esi
c0029e6c:	74 54                	je     c0029ec2 <list_insert_ordered+0x76>
  ASSERT (elem != NULL);
c0029e6e:	85 ff                	test   %edi,%edi
c0029e70:	74 79                	je     c0029eeb <list_insert_ordered+0x9f>
  ASSERT (less != NULL);
c0029e72:	85 ed                	test   %ebp,%ebp
c0029e74:	0f 84 9a 00 00 00    	je     c0029f14 <list_insert_ordered+0xc8>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029e7a:	83 ec 0c             	sub    $0xc,%esp
c0029e7d:	56                   	push   %esi
c0029e7e:	e8 29 f5 ff ff       	call   c00293ac <list_begin>
c0029e83:	83 c4 10             	add    $0x10,%esp
c0029e86:	89 c3                	mov    %eax,%ebx
c0029e88:	83 ec 0c             	sub    $0xc,%esp
c0029e8b:	56                   	push   %esi
c0029e8c:	e8 bd f5 ff ff       	call   c002944e <list_end>
c0029e91:	83 c4 10             	add    $0x10,%esp
c0029e94:	39 d8                	cmp    %ebx,%eax
c0029e96:	0f 84 a3 00 00 00    	je     c0029f3f <list_insert_ordered+0xf3>
    if (less (elem, e, aux))
c0029e9c:	83 ec 04             	sub    $0x4,%esp
c0029e9f:	ff 74 24 30          	pushl  0x30(%esp)
c0029ea3:	53                   	push   %ebx
c0029ea4:	57                   	push   %edi
c0029ea5:	ff d5                	call   *%ebp
c0029ea7:	83 c4 10             	add    $0x10,%esp
c0029eaa:	84 c0                	test   %al,%al
c0029eac:	0f 85 8b 00 00 00    	jne    c0029f3d <list_insert_ordered+0xf1>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029eb2:	83 ec 0c             	sub    $0xc,%esp
c0029eb5:	53                   	push   %ebx
c0029eb6:	e8 36 f5 ff ff       	call   c00293f1 <list_next>
c0029ebb:	83 c4 10             	add    $0x10,%esp
c0029ebe:	89 c3                	mov    %eax,%ebx
c0029ec0:	eb c6                	jmp    c0029e88 <list_insert_ordered+0x3c>
  ASSERT (list != NULL);
c0029ec2:	83 ec 0c             	sub    $0xc,%esp
c0029ec5:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c0029ecb:	50                   	push   %eax
c0029ecc:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029ed2:	50                   	push   %eax
c0029ed3:	8d 83 48 49 ff ff    	lea    -0xb6b8(%ebx),%eax
c0029ed9:	50                   	push   %eax
c0029eda:	68 c3 01 00 00       	push   $0x1c3
c0029edf:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029ee5:	50                   	push   %eax
c0029ee6:	e8 9c f3 ff ff       	call   c0029287 <debug_panic>
  ASSERT (elem != NULL);
c0029eeb:	83 ec 0c             	sub    $0xc,%esp
c0029eee:	8d 83 cd 6a ff ff    	lea    -0x9533(%ebx),%eax
c0029ef4:	50                   	push   %eax
c0029ef5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029efb:	50                   	push   %eax
c0029efc:	8d 83 48 49 ff ff    	lea    -0xb6b8(%ebx),%eax
c0029f02:	50                   	push   %eax
c0029f03:	68 c4 01 00 00       	push   $0x1c4
c0029f08:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029f0e:	50                   	push   %eax
c0029f0f:	e8 73 f3 ff ff       	call   c0029287 <debug_panic>
  ASSERT (less != NULL);
c0029f14:	83 ec 0c             	sub    $0xc,%esp
c0029f17:	8d 83 b9 6a ff ff    	lea    -0x9547(%ebx),%eax
c0029f1d:	50                   	push   %eax
c0029f1e:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029f24:	50                   	push   %eax
c0029f25:	8d 83 48 49 ff ff    	lea    -0xb6b8(%ebx),%eax
c0029f2b:	50                   	push   %eax
c0029f2c:	68 c5 01 00 00       	push   $0x1c5
c0029f31:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029f37:	50                   	push   %eax
c0029f38:	e8 4a f3 ff ff       	call   c0029287 <debug_panic>
c0029f3d:	89 d8                	mov    %ebx,%eax
      break;
  return list_insert (e, elem);
c0029f3f:	83 ec 08             	sub    $0x8,%esp
c0029f42:	57                   	push   %edi
c0029f43:	50                   	push   %eax
c0029f44:	e8 37 f8 ff ff       	call   c0029780 <list_insert>
}
c0029f49:	83 c4 1c             	add    $0x1c,%esp
c0029f4c:	5b                   	pop    %ebx
c0029f4d:	5e                   	pop    %esi
c0029f4e:	5f                   	pop    %edi
c0029f4f:	5d                   	pop    %ebp
c0029f50:	c3                   	ret    

c0029f51 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c0029f51:	55                   	push   %ebp
c0029f52:	57                   	push   %edi
c0029f53:	56                   	push   %esi
c0029f54:	53                   	push   %ebx
c0029f55:	83 ec 0c             	sub    $0xc,%esp
c0029f58:	e8 28 4b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c0029f5d:	81 c3 57 0f 01 00    	add    $0x10f57,%ebx
c0029f63:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0029f67:	8b 7c 24 28          	mov    0x28(%esp),%edi
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c0029f6b:	85 ed                	test   %ebp,%ebp
c0029f6d:	74 1c                	je     c0029f8b <list_unique+0x3a>
  ASSERT (less != NULL);
c0029f6f:	85 ff                	test   %edi,%edi
c0029f71:	74 41                	je     c0029fb4 <list_unique+0x63>
  if (list_empty (list))
c0029f73:	83 ec 0c             	sub    $0xc,%esp
c0029f76:	55                   	push   %ebp
c0029f77:	e8 7d fa ff ff       	call   c00299f9 <list_empty>
c0029f7c:	83 c4 10             	add    $0x10,%esp
c0029f7f:	84 c0                	test   %al,%al
c0029f81:	74 5a                	je     c0029fdd <list_unique+0x8c>
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c0029f83:	83 c4 0c             	add    $0xc,%esp
c0029f86:	5b                   	pop    %ebx
c0029f87:	5e                   	pop    %esi
c0029f88:	5f                   	pop    %edi
c0029f89:	5d                   	pop    %ebp
c0029f8a:	c3                   	ret    
  ASSERT (list != NULL);
c0029f8b:	83 ec 0c             	sub    $0xc,%esp
c0029f8e:	8d 83 8a 6a ff ff    	lea    -0x9576(%ebx),%eax
c0029f94:	50                   	push   %eax
c0029f95:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029f9b:	50                   	push   %eax
c0029f9c:	8d 83 3c 49 ff ff    	lea    -0xb6c4(%ebx),%eax
c0029fa2:	50                   	push   %eax
c0029fa3:	68 d7 01 00 00       	push   $0x1d7
c0029fa8:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029fae:	50                   	push   %eax
c0029faf:	e8 d3 f2 ff ff       	call   c0029287 <debug_panic>
  ASSERT (less != NULL);
c0029fb4:	83 ec 0c             	sub    $0xc,%esp
c0029fb7:	8d 83 b9 6a ff ff    	lea    -0x9547(%ebx),%eax
c0029fbd:	50                   	push   %eax
c0029fbe:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c0029fc4:	50                   	push   %eax
c0029fc5:	8d 83 3c 49 ff ff    	lea    -0xb6c4(%ebx),%eax
c0029fcb:	50                   	push   %eax
c0029fcc:	68 d8 01 00 00       	push   $0x1d8
c0029fd1:	8d 83 97 6a ff ff    	lea    -0x9569(%ebx),%eax
c0029fd7:	50                   	push   %eax
c0029fd8:	e8 aa f2 ff ff       	call   c0029287 <debug_panic>
  elem = list_begin (list);
c0029fdd:	83 ec 0c             	sub    $0xc,%esp
c0029fe0:	55                   	push   %ebp
c0029fe1:	e8 c6 f3 ff ff       	call   c00293ac <list_begin>
c0029fe6:	83 c4 10             	add    $0x10,%esp
c0029fe9:	89 c6                	mov    %eax,%esi
  while ((next = list_next (elem)) != list_end (list))
c0029feb:	eb 04                	jmp    c0029ff1 <list_unique+0xa0>
c0029fed:	89 f3                	mov    %esi,%ebx
c0029fef:	89 de                	mov    %ebx,%esi
c0029ff1:	83 ec 0c             	sub    $0xc,%esp
c0029ff4:	56                   	push   %esi
c0029ff5:	e8 f7 f3 ff ff       	call   c00293f1 <list_next>
c0029ffa:	89 c3                	mov    %eax,%ebx
c0029ffc:	89 2c 24             	mov    %ebp,(%esp)
c0029fff:	e8 4a f4 ff ff       	call   c002944e <list_end>
c002a004:	83 c4 10             	add    $0x10,%esp
c002a007:	39 d8                	cmp    %ebx,%eax
c002a009:	0f 84 74 ff ff ff    	je     c0029f83 <list_unique+0x32>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002a00f:	83 ec 04             	sub    $0x4,%esp
c002a012:	ff 74 24 30          	pushl  0x30(%esp)
c002a016:	53                   	push   %ebx
c002a017:	56                   	push   %esi
c002a018:	ff d7                	call   *%edi
c002a01a:	83 c4 10             	add    $0x10,%esp
c002a01d:	84 c0                	test   %al,%al
c002a01f:	75 ce                	jne    c0029fef <list_unique+0x9e>
c002a021:	83 ec 04             	sub    $0x4,%esp
c002a024:	ff 74 24 30          	pushl  0x30(%esp)
c002a028:	56                   	push   %esi
c002a029:	53                   	push   %ebx
c002a02a:	ff d7                	call   *%edi
c002a02c:	83 c4 10             	add    $0x10,%esp
c002a02f:	84 c0                	test   %al,%al
c002a031:	75 bc                	jne    c0029fef <list_unique+0x9e>
        list_remove (next);
c002a033:	83 ec 0c             	sub    $0xc,%esp
c002a036:	53                   	push   %ebx
c002a037:	e8 1b f9 ff ff       	call   c0029957 <list_remove>
        if (duplicates != NULL)
c002a03c:	83 c4 10             	add    $0x10,%esp
c002a03f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c002a044:	74 a7                	je     c0029fed <list_unique+0x9c>
          list_push_back (duplicates, next);
c002a046:	83 ec 08             	sub    $0x8,%esp
c002a049:	53                   	push   %ebx
c002a04a:	ff 74 24 30          	pushl  0x30(%esp)
c002a04e:	e8 e7 f8 ff ff       	call   c002993a <list_push_back>
c002a053:	83 c4 10             	add    $0x10,%esp
c002a056:	89 f3                	mov    %esi,%ebx
c002a058:	eb 95                	jmp    c0029fef <list_unique+0x9e>

c002a05a <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002a05a:	55                   	push   %ebp
c002a05b:	57                   	push   %edi
c002a05c:	56                   	push   %esi
c002a05d:	53                   	push   %ebx
c002a05e:	83 ec 18             	sub    $0x18,%esp
c002a061:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002a065:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin (list);
c002a069:	57                   	push   %edi
c002a06a:	e8 3d f3 ff ff       	call   c00293ac <list_begin>
c002a06f:	89 c6                	mov    %eax,%esi
  if (max != list_end (list)) 
c002a071:	89 3c 24             	mov    %edi,(%esp)
c002a074:	e8 d5 f3 ff ff       	call   c002944e <list_end>
c002a079:	83 c4 10             	add    $0x10,%esp
c002a07c:	39 f0                	cmp    %esi,%eax
c002a07e:	74 3c                	je     c002a0bc <list_max+0x62>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a080:	83 ec 0c             	sub    $0xc,%esp
c002a083:	56                   	push   %esi
c002a084:	e8 68 f3 ff ff       	call   c00293f1 <list_next>
c002a089:	83 c4 10             	add    $0x10,%esp
c002a08c:	89 c3                	mov    %eax,%ebx
c002a08e:	eb 1c                	jmp    c002a0ac <list_max+0x52>
        if (less (max, e, aux))
c002a090:	83 ec 04             	sub    $0x4,%esp
c002a093:	55                   	push   %ebp
c002a094:	53                   	push   %ebx
c002a095:	56                   	push   %esi
c002a096:	ff 54 24 34          	call   *0x34(%esp)
c002a09a:	84 c0                	test   %al,%al
          max = e; 
c002a09c:	0f 45 f3             	cmovne %ebx,%esi
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a09f:	89 1c 24             	mov    %ebx,(%esp)
c002a0a2:	e8 4a f3 ff ff       	call   c00293f1 <list_next>
c002a0a7:	83 c4 10             	add    $0x10,%esp
c002a0aa:	89 c3                	mov    %eax,%ebx
c002a0ac:	83 ec 0c             	sub    $0xc,%esp
c002a0af:	57                   	push   %edi
c002a0b0:	e8 99 f3 ff ff       	call   c002944e <list_end>
c002a0b5:	83 c4 10             	add    $0x10,%esp
c002a0b8:	39 d8                	cmp    %ebx,%eax
c002a0ba:	75 d4                	jne    c002a090 <list_max+0x36>
    }
  return max;
}
c002a0bc:	89 f0                	mov    %esi,%eax
c002a0be:	83 c4 0c             	add    $0xc,%esp
c002a0c1:	5b                   	pop    %ebx
c002a0c2:	5e                   	pop    %esi
c002a0c3:	5f                   	pop    %edi
c002a0c4:	5d                   	pop    %ebp
c002a0c5:	c3                   	ret    

c002a0c6 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002a0c6:	55                   	push   %ebp
c002a0c7:	57                   	push   %edi
c002a0c8:	56                   	push   %esi
c002a0c9:	53                   	push   %ebx
c002a0ca:	83 ec 18             	sub    $0x18,%esp
c002a0cd:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002a0d1:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin (list);
c002a0d5:	57                   	push   %edi
c002a0d6:	e8 d1 f2 ff ff       	call   c00293ac <list_begin>
c002a0db:	89 c6                	mov    %eax,%esi
  if (min != list_end (list)) 
c002a0dd:	89 3c 24             	mov    %edi,(%esp)
c002a0e0:	e8 69 f3 ff ff       	call   c002944e <list_end>
c002a0e5:	83 c4 10             	add    $0x10,%esp
c002a0e8:	39 f0                	cmp    %esi,%eax
c002a0ea:	74 3c                	je     c002a128 <list_min+0x62>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a0ec:	83 ec 0c             	sub    $0xc,%esp
c002a0ef:	56                   	push   %esi
c002a0f0:	e8 fc f2 ff ff       	call   c00293f1 <list_next>
c002a0f5:	83 c4 10             	add    $0x10,%esp
c002a0f8:	89 c3                	mov    %eax,%ebx
c002a0fa:	eb 1c                	jmp    c002a118 <list_min+0x52>
        if (less (e, min, aux))
c002a0fc:	83 ec 04             	sub    $0x4,%esp
c002a0ff:	55                   	push   %ebp
c002a100:	56                   	push   %esi
c002a101:	53                   	push   %ebx
c002a102:	ff 54 24 34          	call   *0x34(%esp)
c002a106:	84 c0                	test   %al,%al
          min = e; 
c002a108:	0f 45 f3             	cmovne %ebx,%esi
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a10b:	89 1c 24             	mov    %ebx,(%esp)
c002a10e:	e8 de f2 ff ff       	call   c00293f1 <list_next>
c002a113:	83 c4 10             	add    $0x10,%esp
c002a116:	89 c3                	mov    %eax,%ebx
c002a118:	83 ec 0c             	sub    $0xc,%esp
c002a11b:	57                   	push   %edi
c002a11c:	e8 2d f3 ff ff       	call   c002944e <list_end>
c002a121:	83 c4 10             	add    $0x10,%esp
c002a124:	39 d8                	cmp    %ebx,%eax
c002a126:	75 d4                	jne    c002a0fc <list_min+0x36>
    }
  return min;
}
c002a128:	89 f0                	mov    %esi,%eax
c002a12a:	83 c4 0c             	add    $0xc,%esp
c002a12d:	5b                   	pop    %ebx
c002a12e:	5e                   	pop    %esi
c002a12f:	5f                   	pop    %edi
c002a130:	5d                   	pop    %ebp
c002a131:	c3                   	ret    

c002a132 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a132:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a136:	83 c0 1f             	add    $0x1f,%eax
c002a139:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002a13c:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c002a143:	c3                   	ret    

c002a144 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002a144:	56                   	push   %esi
c002a145:	53                   	push   %ebx
c002a146:	83 ec 04             	sub    $0x4,%esp
c002a149:	e8 37 49 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a14e:	81 c3 66 0d 01 00    	add    $0x10d66,%ebx
c002a154:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (b != NULL) 
c002a158:	85 f6                	test   %esi,%esi
c002a15a:	74 16                	je     c002a172 <bitmap_destroy+0x2e>
    {
      free (b->bits);
c002a15c:	83 ec 0c             	sub    $0xc,%esp
c002a15f:	ff 76 04             	pushl  0x4(%esi)
c002a162:	e8 76 9f ff ff       	call   c00240dd <free>
      free (b);
c002a167:	89 34 24             	mov    %esi,(%esp)
c002a16a:	e8 6e 9f ff ff       	call   c00240dd <free>
c002a16f:	83 c4 10             	add    $0x10,%esp
    }
}
c002a172:	83 c4 04             	add    $0x4,%esp
c002a175:	5b                   	pop    %ebx
c002a176:	5e                   	pop    %esi
c002a177:	c3                   	ret    

c002a178 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c002a178:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a17c:	8b 00                	mov    (%eax),%eax
}
c002a17e:	c3                   	ret    

c002a17f <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a17f:	53                   	push   %ebx
c002a180:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a184:	89 cb                	mov    %ecx,%ebx
c002a186:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a189:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a18d:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a190:	b8 01 00 00 00       	mov    $0x1,%eax
c002a195:	d3 e0                	shl    %cl,%eax
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a197:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c002a19a:	5b                   	pop    %ebx
c002a19b:	c3                   	ret    

c002a19c <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a19c:	53                   	push   %ebx
c002a19d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a1a1:	89 cb                	mov    %ecx,%ebx
c002a1a3:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a1a6:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a1aa:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a1ad:	b8 01 00 00 00       	mov    $0x1,%eax
c002a1b2:	d3 e0                	shl    %cl,%eax
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a1b4:	f7 d0                	not    %eax
c002a1b6:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c002a1b9:	5b                   	pop    %ebx
c002a1ba:	c3                   	ret    

c002a1bb <bitmap_set>:
{
c002a1bb:	53                   	push   %ebx
c002a1bc:	83 ec 08             	sub    $0x8,%esp
c002a1bf:	e8 c1 48 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a1c4:	81 c3 f0 0c 01 00    	add    $0x10cf0,%ebx
c002a1ca:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a1ce:	8b 54 24 14          	mov    0x14(%esp),%edx
c002a1d2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c002a1d6:	85 c0                	test   %eax,%eax
c002a1d8:	74 1a                	je     c002a1f4 <bitmap_set+0x39>
  ASSERT (idx < b->bit_cnt);
c002a1da:	39 10                	cmp    %edx,(%eax)
c002a1dc:	76 3f                	jbe    c002a21d <bitmap_set+0x62>
  if (value)
c002a1de:	84 c9                	test   %cl,%cl
c002a1e0:	75 64                	jne    c002a246 <bitmap_set+0x8b>
    bitmap_reset (b, idx);
c002a1e2:	83 ec 08             	sub    $0x8,%esp
c002a1e5:	52                   	push   %edx
c002a1e6:	50                   	push   %eax
c002a1e7:	e8 b0 ff ff ff       	call   c002a19c <bitmap_reset>
c002a1ec:	83 c4 10             	add    $0x10,%esp
}
c002a1ef:	83 c4 08             	add    $0x8,%esp
c002a1f2:	5b                   	pop    %ebx
c002a1f3:	c3                   	ret    
  ASSERT (b != NULL);
c002a1f4:	83 ec 0c             	sub    $0xc,%esp
c002a1f7:	8d 83 af 6a ff ff    	lea    -0x9551(%ebx),%eax
c002a1fd:	50                   	push   %eax
c002a1fe:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a204:	50                   	push   %eax
c002a205:	8d 83 8c 4a ff ff    	lea    -0xb574(%ebx),%eax
c002a20b:	50                   	push   %eax
c002a20c:	68 93 00 00 00       	push   $0x93
c002a211:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a217:	50                   	push   %eax
c002a218:	e8 6a f0 ff ff       	call   c0029287 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a21d:	83 ec 0c             	sub    $0xc,%esp
c002a220:	8d 83 5c 6c ff ff    	lea    -0x93a4(%ebx),%eax
c002a226:	50                   	push   %eax
c002a227:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a22d:	50                   	push   %eax
c002a22e:	8d 83 8c 4a ff ff    	lea    -0xb574(%ebx),%eax
c002a234:	50                   	push   %eax
c002a235:	68 94 00 00 00       	push   $0x94
c002a23a:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a240:	50                   	push   %eax
c002a241:	e8 41 f0 ff ff       	call   c0029287 <debug_panic>
    bitmap_mark (b, idx);
c002a246:	83 ec 08             	sub    $0x8,%esp
c002a249:	52                   	push   %edx
c002a24a:	50                   	push   %eax
c002a24b:	e8 2f ff ff ff       	call   c002a17f <bitmap_mark>
c002a250:	83 c4 10             	add    $0x10,%esp
c002a253:	eb 9a                	jmp    c002a1ef <bitmap_set+0x34>

c002a255 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a255:	53                   	push   %ebx
c002a256:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a25a:	89 cb                	mov    %ecx,%ebx
c002a25c:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a25f:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a263:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a266:	b8 01 00 00 00       	mov    $0x1,%eax
c002a26b:	d3 e0                	shl    %cl,%eax
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a26d:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c002a270:	5b                   	pop    %ebx
c002a271:	c3                   	ret    

c002a272 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002a272:	53                   	push   %ebx
c002a273:	83 ec 08             	sub    $0x8,%esp
c002a276:	e8 0a 48 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a27b:	81 c3 39 0c 01 00    	add    $0x10c39,%ebx
c002a281:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a285:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c002a289:	85 c0                	test   %eax,%eax
c002a28b:	74 1e                	je     c002a2ab <bitmap_test+0x39>
  ASSERT (idx < b->bit_cnt);
c002a28d:	39 08                	cmp    %ecx,(%eax)
c002a28f:	76 43                	jbe    c002a2d4 <bitmap_test+0x62>
  return bit_idx / ELEM_BITS;
c002a291:	89 cb                	mov    %ecx,%ebx
c002a293:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a296:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a299:	b8 01 00 00 00       	mov    $0x1,%eax
c002a29e:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a2a0:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c002a2a3:	0f 95 c0             	setne  %al
}
c002a2a6:	83 c4 08             	add    $0x8,%esp
c002a2a9:	5b                   	pop    %ebx
c002a2aa:	c3                   	ret    
  ASSERT (b != NULL);
c002a2ab:	83 ec 0c             	sub    $0xc,%esp
c002a2ae:	8d 83 af 6a ff ff    	lea    -0x9551(%ebx),%eax
c002a2b4:	50                   	push   %eax
c002a2b5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a2bb:	50                   	push   %eax
c002a2bc:	8d 83 80 4a ff ff    	lea    -0xb580(%ebx),%eax
c002a2c2:	50                   	push   %eax
c002a2c3:	68 c8 00 00 00       	push   $0xc8
c002a2c8:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a2ce:	50                   	push   %eax
c002a2cf:	e8 b3 ef ff ff       	call   c0029287 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a2d4:	83 ec 0c             	sub    $0xc,%esp
c002a2d7:	8d 83 5c 6c ff ff    	lea    -0x93a4(%ebx),%eax
c002a2dd:	50                   	push   %eax
c002a2de:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a2e4:	50                   	push   %eax
c002a2e5:	8d 83 80 4a ff ff    	lea    -0xb580(%ebx),%eax
c002a2eb:	50                   	push   %eax
c002a2ec:	68 c9 00 00 00       	push   $0xc9
c002a2f1:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a2f7:	50                   	push   %eax
c002a2f8:	e8 8a ef ff ff       	call   c0029287 <debug_panic>

c002a2fd <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a2fd:	55                   	push   %ebp
c002a2fe:	57                   	push   %edi
c002a2ff:	56                   	push   %esi
c002a300:	53                   	push   %ebx
c002a301:	83 ec 0c             	sub    $0xc,%esp
c002a304:	e8 8c 47 00 00       	call   c002ea95 <__x86.get_pc_thunk.cx>
c002a309:	81 c1 ab 0b 01 00    	add    $0x10bab,%ecx
c002a30f:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a313:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a317:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a31b:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a320:	85 ff                	test   %edi,%edi
c002a322:	74 31                	je     c002a355 <bitmap_set_multiple+0x58>
  ASSERT (start <= b->bit_cnt);
c002a324:	8b 17                	mov    (%edi),%edx
c002a326:	39 f2                	cmp    %esi,%edx
c002a328:	72 56                	jb     c002a380 <bitmap_set_multiple+0x83>
  ASSERT (start + cnt <= b->bit_cnt);
c002a32a:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a32d:	39 ea                	cmp    %ebp,%edx
c002a32f:	72 7a                	jb     c002a3ab <bitmap_set_multiple+0xae>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c002a331:	0f b6 db             	movzbl %bl,%ebx
  for (i = 0; i < cnt; i++)
c002a334:	85 c0                	test   %eax,%eax
c002a336:	74 15                	je     c002a34d <bitmap_set_multiple+0x50>
    bitmap_set (b, start + i, value);
c002a338:	83 ec 04             	sub    $0x4,%esp
c002a33b:	53                   	push   %ebx
c002a33c:	56                   	push   %esi
c002a33d:	57                   	push   %edi
c002a33e:	e8 78 fe ff ff       	call   c002a1bb <bitmap_set>
c002a343:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a346:	83 c4 10             	add    $0x10,%esp
c002a349:	39 f5                	cmp    %esi,%ebp
c002a34b:	75 eb                	jne    c002a338 <bitmap_set_multiple+0x3b>
}
c002a34d:	83 c4 0c             	add    $0xc,%esp
c002a350:	5b                   	pop    %ebx
c002a351:	5e                   	pop    %esi
c002a352:	5f                   	pop    %edi
c002a353:	5d                   	pop    %ebp
c002a354:	c3                   	ret    
  ASSERT (b != NULL);
c002a355:	83 ec 0c             	sub    $0xc,%esp
c002a358:	8d 81 af 6a ff ff    	lea    -0x9551(%ecx),%eax
c002a35e:	50                   	push   %eax
c002a35f:	8d 81 45 4e ff ff    	lea    -0xb1bb(%ecx),%eax
c002a365:	50                   	push   %eax
c002a366:	8d 81 5c 4a ff ff    	lea    -0xb5a4(%ecx),%eax
c002a36c:	50                   	push   %eax
c002a36d:	68 de 00 00 00       	push   $0xde
c002a372:	8d 81 42 6c ff ff    	lea    -0x93be(%ecx),%eax
c002a378:	50                   	push   %eax
c002a379:	89 cb                	mov    %ecx,%ebx
c002a37b:	e8 07 ef ff ff       	call   c0029287 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a380:	83 ec 0c             	sub    $0xc,%esp
c002a383:	8d 81 6d 6c ff ff    	lea    -0x9393(%ecx),%eax
c002a389:	50                   	push   %eax
c002a38a:	8d 81 45 4e ff ff    	lea    -0xb1bb(%ecx),%eax
c002a390:	50                   	push   %eax
c002a391:	8d 81 5c 4a ff ff    	lea    -0xb5a4(%ecx),%eax
c002a397:	50                   	push   %eax
c002a398:	68 df 00 00 00       	push   $0xdf
c002a39d:	8d 81 42 6c ff ff    	lea    -0x93be(%ecx),%eax
c002a3a3:	50                   	push   %eax
c002a3a4:	89 cb                	mov    %ecx,%ebx
c002a3a6:	e8 dc ee ff ff       	call   c0029287 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a3ab:	83 ec 0c             	sub    $0xc,%esp
c002a3ae:	8d 81 81 6c ff ff    	lea    -0x937f(%ecx),%eax
c002a3b4:	50                   	push   %eax
c002a3b5:	8d 81 45 4e ff ff    	lea    -0xb1bb(%ecx),%eax
c002a3bb:	50                   	push   %eax
c002a3bc:	8d 81 5c 4a ff ff    	lea    -0xb5a4(%ecx),%eax
c002a3c2:	50                   	push   %eax
c002a3c3:	68 e0 00 00 00       	push   $0xe0
c002a3c8:	8d 81 42 6c ff ff    	lea    -0x93be(%ecx),%eax
c002a3ce:	50                   	push   %eax
c002a3cf:	89 cb                	mov    %ecx,%ebx
c002a3d1:	e8 b1 ee ff ff       	call   c0029287 <debug_panic>

c002a3d6 <bitmap_set_all>:
{
c002a3d6:	53                   	push   %ebx
c002a3d7:	83 ec 08             	sub    $0x8,%esp
c002a3da:	e8 a6 46 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a3df:	81 c3 d5 0a 01 00    	add    $0x10ad5,%ebx
c002a3e5:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a3e9:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c002a3ed:	85 c0                	test   %eax,%eax
c002a3ef:	74 13                	je     c002a404 <bitmap_set_all+0x2e>
  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a3f1:	0f b6 d2             	movzbl %dl,%edx
c002a3f4:	52                   	push   %edx
c002a3f5:	ff 30                	pushl  (%eax)
c002a3f7:	6a 00                	push   $0x0
c002a3f9:	50                   	push   %eax
c002a3fa:	e8 fe fe ff ff       	call   c002a2fd <bitmap_set_multiple>
}
c002a3ff:	83 c4 18             	add    $0x18,%esp
c002a402:	5b                   	pop    %ebx
c002a403:	c3                   	ret    
  ASSERT (b != NULL);
c002a404:	83 ec 0c             	sub    $0xc,%esp
c002a407:	8d 83 af 6a ff ff    	lea    -0x9551(%ebx),%eax
c002a40d:	50                   	push   %eax
c002a40e:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a414:	50                   	push   %eax
c002a415:	8d 83 70 4a ff ff    	lea    -0xb590(%ebx),%eax
c002a41b:	50                   	push   %eax
c002a41c:	68 d3 00 00 00       	push   $0xd3
c002a421:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a427:	50                   	push   %eax
c002a428:	e8 5a ee ff ff       	call   c0029287 <debug_panic>

c002a42d <bitmap_create>:
{
c002a42d:	57                   	push   %edi
c002a42e:	56                   	push   %esi
c002a42f:	53                   	push   %ebx
c002a430:	e8 50 46 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a435:	81 c3 7f 0a 01 00    	add    $0x10a7f,%ebx
c002a43b:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct bitmap *b = malloc (sizeof *b);
c002a43f:	83 ec 0c             	sub    $0xc,%esp
c002a442:	6a 08                	push   $0x8
c002a444:	e8 de 9a ff ff       	call   c0023f27 <malloc>
c002a449:	89 c6                	mov    %eax,%esi
  if (b != NULL)
c002a44b:	83 c4 10             	add    $0x10,%esp
c002a44e:	85 c0                	test   %eax,%eax
c002a450:	74 30                	je     c002a482 <bitmap_create+0x55>
      b->bit_cnt = bit_cnt;
c002a452:	89 38                	mov    %edi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a454:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a457:	8d 47 1f             	lea    0x1f(%edi),%eax
c002a45a:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a45d:	c1 e0 02             	shl    $0x2,%eax
      b->bits = malloc (byte_cnt (bit_cnt));
c002a460:	50                   	push   %eax
c002a461:	e8 c1 9a ff ff       	call   c0023f27 <malloc>
c002a466:	89 46 04             	mov    %eax,0x4(%esi)
      if (b->bits != NULL || bit_cnt == 0)
c002a469:	83 c4 10             	add    $0x10,%esp
c002a46c:	85 ff                	test   %edi,%edi
c002a46e:	74 04                	je     c002a474 <bitmap_create+0x47>
c002a470:	85 c0                	test   %eax,%eax
c002a472:	74 14                	je     c002a488 <bitmap_create+0x5b>
          bitmap_set_all (b, false);
c002a474:	83 ec 08             	sub    $0x8,%esp
c002a477:	6a 00                	push   $0x0
c002a479:	56                   	push   %esi
c002a47a:	e8 57 ff ff ff       	call   c002a3d6 <bitmap_set_all>
          return b;
c002a47f:	83 c4 10             	add    $0x10,%esp
}
c002a482:	89 f0                	mov    %esi,%eax
c002a484:	5b                   	pop    %ebx
c002a485:	5e                   	pop    %esi
c002a486:	5f                   	pop    %edi
c002a487:	c3                   	ret    
      free (b);
c002a488:	83 ec 0c             	sub    $0xc,%esp
c002a48b:	56                   	push   %esi
c002a48c:	e8 4c 9c ff ff       	call   c00240dd <free>
c002a491:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002a494:	be 00 00 00 00       	mov    $0x0,%esi
c002a499:	eb e7                	jmp    c002a482 <bitmap_create+0x55>

c002a49b <bitmap_create_in_buf>:
{
c002a49b:	57                   	push   %edi
c002a49c:	56                   	push   %esi
c002a49d:	53                   	push   %ebx
c002a49e:	e8 e2 45 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a4a3:	81 c3 11 0a 01 00    	add    $0x10a11,%ebx
c002a4a9:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002a4ad:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a4b1:	57                   	push   %edi
c002a4b2:	e8 7b fc ff ff       	call   c002a132 <bitmap_buf_size>
c002a4b7:	83 c4 04             	add    $0x4,%esp
c002a4ba:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002a4be:	77 1c                	ja     c002a4dc <bitmap_create_in_buf+0x41>
  b->bit_cnt = bit_cnt;
c002a4c0:	89 3e                	mov    %edi,(%esi)
  b->bits = (elem_type *) (b + 1);
c002a4c2:	8d 46 08             	lea    0x8(%esi),%eax
c002a4c5:	89 46 04             	mov    %eax,0x4(%esi)
  bitmap_set_all (b, false);
c002a4c8:	83 ec 08             	sub    $0x8,%esp
c002a4cb:	6a 00                	push   $0x0
c002a4cd:	56                   	push   %esi
c002a4ce:	e8 03 ff ff ff       	call   c002a3d6 <bitmap_set_all>
  return b;
c002a4d3:	83 c4 10             	add    $0x10,%esp
}
c002a4d6:	89 f0                	mov    %esi,%eax
c002a4d8:	5b                   	pop    %ebx
c002a4d9:	5e                   	pop    %esi
c002a4da:	5f                   	pop    %edi
c002a4db:	c3                   	ret    
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a4dc:	83 ec 0c             	sub    $0xc,%esp
c002a4df:	8d 83 9c 6c ff ff    	lea    -0x9364(%ebx),%eax
c002a4e5:	50                   	push   %eax
c002a4e6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a4ec:	50                   	push   %eax
c002a4ed:	8d 83 98 4a ff ff    	lea    -0xb568(%ebx),%eax
c002a4f3:	50                   	push   %eax
c002a4f4:	6a 68                	push   $0x68
c002a4f6:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a4fc:	50                   	push   %eax
c002a4fd:	e8 85 ed ff ff       	call   c0029287 <debug_panic>

c002a502 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a502:	55                   	push   %ebp
c002a503:	57                   	push   %edi
c002a504:	56                   	push   %esi
c002a505:	53                   	push   %ebx
c002a506:	83 ec 1c             	sub    $0x1c,%esp
c002a509:	e8 77 45 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a50e:	81 c3 a6 09 01 00    	add    $0x109a6,%ebx
c002a514:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a518:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a51c:	8b 44 24 38          	mov    0x38(%esp),%eax
c002a520:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c002a525:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a529:	85 ff                	test   %edi,%edi
c002a52b:	74 44                	je     c002a571 <bitmap_count+0x6f>
  ASSERT (start <= b->bit_cnt);
c002a52d:	8b 17                	mov    (%edi),%edx
c002a52f:	39 f2                	cmp    %esi,%edx
c002a531:	72 67                	jb     c002a59a <bitmap_count+0x98>
  ASSERT (start + cnt <= b->bit_cnt);
c002a533:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a536:	39 ea                	cmp    %ebp,%edx
c002a538:	0f 82 89 00 00 00    	jb     c002a5c7 <bitmap_count+0xc5>

  value_cnt = 0;
c002a53e:	bb 00 00 00 00       	mov    $0x0,%ebx
  for (i = 0; i < cnt; i++)
c002a543:	85 c0                	test   %eax,%eax
c002a545:	74 7c                	je     c002a5c3 <bitmap_count+0xc1>
    if (bitmap_test (b, start + i) == value)
c002a547:	83 ec 08             	sub    $0x8,%esp
c002a54a:	56                   	push   %esi
c002a54b:	57                   	push   %edi
c002a54c:	e8 21 fd ff ff       	call   c002a272 <bitmap_test>
c002a551:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c002a554:	3a 44 24 0f          	cmp    0xf(%esp),%al
c002a558:	0f 94 c0             	sete   %al
c002a55b:	0f b6 c0             	movzbl %al,%eax
c002a55e:	01 c3                	add    %eax,%ebx
c002a560:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a563:	39 f5                	cmp    %esi,%ebp
c002a565:	75 e0                	jne    c002a547 <bitmap_count+0x45>
  return value_cnt;
}
c002a567:	89 d8                	mov    %ebx,%eax
c002a569:	83 c4 1c             	add    $0x1c,%esp
c002a56c:	5b                   	pop    %ebx
c002a56d:	5e                   	pop    %esi
c002a56e:	5f                   	pop    %edi
c002a56f:	5d                   	pop    %ebp
c002a570:	c3                   	ret    
  ASSERT (b != NULL);
c002a571:	83 ec 0c             	sub    $0xc,%esp
c002a574:	8d 83 af 6a ff ff    	lea    -0x9551(%ebx),%eax
c002a57a:	50                   	push   %eax
c002a57b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a581:	50                   	push   %eax
c002a582:	8d 83 4c 4a ff ff    	lea    -0xb5b4(%ebx),%eax
c002a588:	50                   	push   %eax
c002a589:	68 ed 00 00 00       	push   $0xed
c002a58e:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a594:	50                   	push   %eax
c002a595:	e8 ed ec ff ff       	call   c0029287 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a59a:	83 ec 0c             	sub    $0xc,%esp
c002a59d:	8d 83 6d 6c ff ff    	lea    -0x9393(%ebx),%eax
c002a5a3:	50                   	push   %eax
c002a5a4:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a5aa:	50                   	push   %eax
c002a5ab:	8d 83 4c 4a ff ff    	lea    -0xb5b4(%ebx),%eax
c002a5b1:	50                   	push   %eax
c002a5b2:	68 ee 00 00 00       	push   $0xee
c002a5b7:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a5bd:	50                   	push   %eax
c002a5be:	e8 c4 ec ff ff       	call   c0029287 <debug_panic>
  value_cnt = 0;
c002a5c3:	89 c3                	mov    %eax,%ebx
c002a5c5:	eb a0                	jmp    c002a567 <bitmap_count+0x65>
  ASSERT (start + cnt <= b->bit_cnt);
c002a5c7:	83 ec 0c             	sub    $0xc,%esp
c002a5ca:	8d 83 81 6c ff ff    	lea    -0x937f(%ebx),%eax
c002a5d0:	50                   	push   %eax
c002a5d1:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002a5d7:	50                   	push   %eax
c002a5d8:	8d 83 4c 4a ff ff    	lea    -0xb5b4(%ebx),%eax
c002a5de:	50                   	push   %eax
c002a5df:	68 ef 00 00 00       	push   $0xef
c002a5e4:	8d 83 42 6c ff ff    	lea    -0x93be(%ebx),%eax
c002a5ea:	50                   	push   %eax
c002a5eb:	e8 97 ec ff ff       	call   c0029287 <debug_panic>

c002a5f0 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a5f0:	55                   	push   %ebp
c002a5f1:	57                   	push   %edi
c002a5f2:	56                   	push   %esi
c002a5f3:	53                   	push   %ebx
c002a5f4:	83 ec 0c             	sub    $0xc,%esp
c002a5f7:	e8 99 44 00 00       	call   c002ea95 <__x86.get_pc_thunk.cx>
c002a5fc:	81 c1 b8 08 01 00    	add    $0x108b8,%ecx
c002a602:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a606:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a60a:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a60e:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;
  
  ASSERT (b != NULL);
c002a613:	85 ff                	test   %edi,%edi
c002a615:	74 3f                	je     c002a656 <bitmap_contains+0x66>
  ASSERT (start <= b->bit_cnt);
c002a617:	8b 17                	mov    (%edi),%edx
c002a619:	39 f2                	cmp    %esi,%edx
c002a61b:	72 64                	jb     c002a681 <bitmap_contains+0x91>
  ASSERT (start + cnt <= b->bit_cnt);
c002a61d:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a620:	39 ea                	cmp    %ebp,%edx
c002a622:	0f 82 84 00 00 00    	jb     c002a6ac <bitmap_contains+0xbc>

  for (i = 0; i < cnt; i++)
c002a628:	85 c0                	test   %eax,%eax
c002a62a:	0f 84 ac 00 00 00    	je     c002a6dc <bitmap_contains+0xec>
    if (bitmap_test (b, start + i) == value)
c002a630:	83 ec 08             	sub    $0x8,%esp
c002a633:	56                   	push   %esi
c002a634:	57                   	push   %edi
c002a635:	e8 38 fc ff ff       	call   c002a272 <bitmap_test>
c002a63a:	83 c4 10             	add    $0x10,%esp
c002a63d:	38 d8                	cmp    %bl,%al
c002a63f:	0f 84 92 00 00 00    	je     c002a6d7 <bitmap_contains+0xe7>
c002a645:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a648:	39 f5                	cmp    %esi,%ebp
c002a64a:	75 e4                	jne    c002a630 <bitmap_contains+0x40>
      return true;
  return false;
c002a64c:	b8 00 00 00 00       	mov    $0x0,%eax
c002a651:	e9 86 00 00 00       	jmp    c002a6dc <bitmap_contains+0xec>
  ASSERT (b != NULL);
c002a656:	83 ec 0c             	sub    $0xc,%esp
c002a659:	8d 81 af 6a ff ff    	lea    -0x9551(%ecx),%eax
c002a65f:	50                   	push   %eax
c002a660:	8d 81 45 4e ff ff    	lea    -0xb1bb(%ecx),%eax
c002a666:	50                   	push   %eax
c002a667:	8d 81 3c 4a ff ff    	lea    -0xb5c4(%ecx),%eax
c002a66d:	50                   	push   %eax
c002a66e:	68 ff 00 00 00       	push   $0xff
c002a673:	8d 81 42 6c ff ff    	lea    -0x93be(%ecx),%eax
c002a679:	50                   	push   %eax
c002a67a:	89 cb                	mov    %ecx,%ebx
c002a67c:	e8 06 ec ff ff       	call   c0029287 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a681:	83 ec 0c             	sub    $0xc,%esp
c002a684:	8d 81 6d 6c ff ff    	lea    -0x9393(%ecx),%eax
c002a68a:	50                   	push   %eax
c002a68b:	8d 81 45 4e ff ff    	lea    -0xb1bb(%ecx),%eax
c002a691:	50                   	push   %eax
c002a692:	8d 81 3c 4a ff ff    	lea    -0xb5c4(%ecx),%eax
c002a698:	50                   	push   %eax
c002a699:	68 00 01 00 00       	push   $0x100
c002a69e:	8d 81 42 6c ff ff    	lea    -0x93be(%ecx),%eax
c002a6a4:	50                   	push   %eax
c002a6a5:	89 cb                	mov    %ecx,%ebx
c002a6a7:	e8 db eb ff ff       	call   c0029287 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a6ac:	83 ec 0c             	sub    $0xc,%esp
c002a6af:	8d 81 81 6c ff ff    	lea    -0x937f(%ecx),%eax
c002a6b5:	50                   	push   %eax
c002a6b6:	8d 81 45 4e ff ff    	lea    -0xb1bb(%ecx),%eax
c002a6bc:	50                   	push   %eax
c002a6bd:	8d 81 3c 4a ff ff    	lea    -0xb5c4(%ecx),%eax
c002a6c3:	50                   	push   %eax
c002a6c4:	68 01 01 00 00       	push   $0x101
c002a6c9:	8d 81 42 6c ff ff    	lea    -0x93be(%ecx),%eax
c002a6cf:	50                   	push   %eax
c002a6d0:	89 cb                	mov    %ecx,%ebx
c002a6d2:	e8 b0 eb ff ff       	call   c0029287 <debug_panic>
      return true;
c002a6d7:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a6dc:	83 c4 0c             	add    $0xc,%esp
c002a6df:	5b                   	pop    %ebx
c002a6e0:	5e                   	pop    %esi
c002a6e1:	5f                   	pop    %edi
c002a6e2:	5d                   	pop    %ebp
c002a6e3:	c3                   	ret    

c002a6e4 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a6e4:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c002a6e7:	6a 01                	push   $0x1
c002a6e9:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a6ed:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a6f1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a6f5:	e8 f6 fe ff ff       	call   c002a5f0 <bitmap_contains>
}
c002a6fa:	83 c4 1c             	add    $0x1c,%esp
c002a6fd:	c3                   	ret    

c002a6fe <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a6fe:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c002a701:	6a 01                	push   $0x1
c002a703:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a707:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a70b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a70f:	e8 dc fe ff ff       	call   c002a5f0 <bitmap_contains>
c002a714:	83 f0 01             	xor    $0x1,%eax
}
c002a717:	83 c4 1c             	add    $0x1c,%esp
c002a71a:	c3                   	ret    

c002a71b <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002a71b:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c002a71e:	6a 00                	push   $0x0
c002a720:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a724:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a728:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a72c:	e8 bf fe ff ff       	call   c002a5f0 <bitmap_contains>
c002a731:	83 f0 01             	xor    $0x1,%eax
}
c002a734:	83 c4 1c             	add    $0x1c,%esp
c002a737:	c3                   	ret    

c002a738 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a738:	55                   	push   %ebp
c002a739:	57                   	push   %edi
c002a73a:	56                   	push   %esi
c002a73b:	53                   	push   %ebx
c002a73c:	83 ec 1c             	sub    $0x1c,%esp
c002a73f:	e8 45 43 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c002a744:	05 70 07 01 00       	add    $0x10770,%eax
c002a749:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002a74d:	8b 74 24 34          	mov    0x34(%esp),%esi
c002a751:	8b 6c 24 38          	mov    0x38(%esp),%ebp
c002a755:	0f b6 5c 24 3c       	movzbl 0x3c(%esp),%ebx
  ASSERT (b != NULL);
c002a75a:	85 ff                	test   %edi,%edi
c002a75c:	74 43                	je     c002a7a1 <bitmap_scan+0x69>
  ASSERT (start <= b->bit_cnt);
c002a75e:	8b 17                	mov    (%edi),%edx
c002a760:	39 f2                	cmp    %esi,%edx
c002a762:	72 68                	jb     c002a7cc <bitmap_scan+0x94>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002a764:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  if (cnt <= b->bit_cnt) 
c002a769:	39 ea                	cmp    %ebp,%edx
c002a76b:	0f 82 8f 00 00 00    	jb     c002a800 <bitmap_scan+0xc8>
      size_t last = b->bit_cnt - cnt;
c002a771:	29 ea                	sub    %ebp,%edx
c002a773:	89 54 24 0c          	mov    %edx,0xc(%esp)
      for (i = start; i <= last; i++)
c002a777:	39 d6                	cmp    %edx,%esi
c002a779:	77 7c                	ja     c002a7f7 <bitmap_scan+0xbf>
        if (!bitmap_contains (b, i, cnt, !value))
c002a77b:	83 f3 01             	xor    $0x1,%ebx
c002a77e:	0f b6 db             	movzbl %bl,%ebx
c002a781:	53                   	push   %ebx
c002a782:	55                   	push   %ebp
c002a783:	56                   	push   %esi
c002a784:	57                   	push   %edi
c002a785:	e8 66 fe ff ff       	call   c002a5f0 <bitmap_contains>
c002a78a:	83 c4 10             	add    $0x10,%esp
c002a78d:	84 c0                	test   %al,%al
c002a78f:	74 6d                	je     c002a7fe <bitmap_scan+0xc6>
      for (i = start; i <= last; i++)
c002a791:	83 c6 01             	add    $0x1,%esi
c002a794:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c002a798:	73 e7                	jae    c002a781 <bitmap_scan+0x49>
  return BITMAP_ERROR;
c002a79a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a79f:	eb 5f                	jmp    c002a800 <bitmap_scan+0xc8>
  ASSERT (b != NULL);
c002a7a1:	83 ec 0c             	sub    $0xc,%esp
c002a7a4:	8d 90 af 6a ff ff    	lea    -0x9551(%eax),%edx
c002a7aa:	52                   	push   %edx
c002a7ab:	8d 90 45 4e ff ff    	lea    -0xb1bb(%eax),%edx
c002a7b1:	52                   	push   %edx
c002a7b2:	8d 90 30 4a ff ff    	lea    -0xb5d0(%eax),%edx
c002a7b8:	52                   	push   %edx
c002a7b9:	68 2a 01 00 00       	push   $0x12a
c002a7be:	8d 90 42 6c ff ff    	lea    -0x93be(%eax),%edx
c002a7c4:	52                   	push   %edx
c002a7c5:	89 c3                	mov    %eax,%ebx
c002a7c7:	e8 bb ea ff ff       	call   c0029287 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a7cc:	83 ec 0c             	sub    $0xc,%esp
c002a7cf:	8d 90 6d 6c ff ff    	lea    -0x9393(%eax),%edx
c002a7d5:	52                   	push   %edx
c002a7d6:	8d 90 45 4e ff ff    	lea    -0xb1bb(%eax),%edx
c002a7dc:	52                   	push   %edx
c002a7dd:	8d 90 30 4a ff ff    	lea    -0xb5d0(%eax),%edx
c002a7e3:	52                   	push   %edx
c002a7e4:	68 2b 01 00 00       	push   $0x12b
c002a7e9:	8d 90 42 6c ff ff    	lea    -0x93be(%eax),%edx
c002a7ef:	52                   	push   %edx
c002a7f0:	89 c3                	mov    %eax,%ebx
c002a7f2:	e8 90 ea ff ff       	call   c0029287 <debug_panic>
  return BITMAP_ERROR;
c002a7f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a7fc:	eb 02                	jmp    c002a800 <bitmap_scan+0xc8>
c002a7fe:	89 f0                	mov    %esi,%eax
}
c002a800:	83 c4 1c             	add    $0x1c,%esp
c002a803:	5b                   	pop    %ebx
c002a804:	5e                   	pop    %esi
c002a805:	5f                   	pop    %edi
c002a806:	5d                   	pop    %ebp
c002a807:	c3                   	ret    

c002a808 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002a808:	55                   	push   %ebp
c002a809:	57                   	push   %edi
c002a80a:	56                   	push   %esi
c002a80b:	53                   	push   %ebx
c002a80c:	83 ec 0c             	sub    $0xc,%esp
c002a80f:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a813:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002a817:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c002a81b:	0f b6 c3             	movzbl %bl,%eax
c002a81e:	50                   	push   %eax
c002a81f:	55                   	push   %ebp
c002a820:	ff 74 24 2c          	pushl  0x2c(%esp)
c002a824:	57                   	push   %edi
c002a825:	e8 0e ff ff ff       	call   c002a738 <bitmap_scan>
c002a82a:	83 c4 10             	add    $0x10,%esp
c002a82d:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c002a82f:	83 f8 ff             	cmp    $0xffffffff,%eax
c002a832:	74 12                	je     c002a846 <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple (b, idx, cnt, !value);
c002a834:	83 f3 01             	xor    $0x1,%ebx
c002a837:	0f b6 db             	movzbl %bl,%ebx
c002a83a:	53                   	push   %ebx
c002a83b:	55                   	push   %ebp
c002a83c:	50                   	push   %eax
c002a83d:	57                   	push   %edi
c002a83e:	e8 ba fa ff ff       	call   c002a2fd <bitmap_set_multiple>
c002a843:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c002a846:	89 f0                	mov    %esi,%eax
c002a848:	83 c4 0c             	add    $0xc,%esp
c002a84b:	5b                   	pop    %ebx
c002a84c:	5e                   	pop    %esi
c002a84d:	5f                   	pop    %edi
c002a84e:	5d                   	pop    %ebp
c002a84f:	c3                   	ret    

c002a850 <bitmap_file_size>:
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a850:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a854:	8b 00                	mov    (%eax),%eax
c002a856:	83 c0 1f             	add    $0x1f,%eax
c002a859:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a85c:	c1 e0 02             	shl    $0x2,%eax
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
  return byte_cnt (b->bit_cnt);
}
c002a85f:	c3                   	ret    

c002a860 <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c002a860:	57                   	push   %edi
c002a861:	56                   	push   %esi
c002a862:	53                   	push   %ebx
c002a863:	e8 1d 42 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a868:	81 c3 4c 06 01 00    	add    $0x1064c,%ebx
c002a86e:	8b 7c 24 10          	mov    0x10(%esp),%edi
  bool success = true;
  if (b->bit_cnt > 0) 
c002a872:	8b 17                	mov    (%edi),%edx
  bool success = true;
c002a874:	b8 01 00 00 00       	mov    $0x1,%eax
  if (b->bit_cnt > 0) 
c002a879:	85 d2                	test   %edx,%edx
c002a87b:	75 04                	jne    c002a881 <bitmap_read+0x21>
      off_t size = byte_cnt (b->bit_cnt);
      success = file_read_at (file, b->bits, size, 0) == size;
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
    }
  return success;
}
c002a87d:	5b                   	pop    %ebx
c002a87e:	5e                   	pop    %esi
c002a87f:	5f                   	pop    %edi
c002a880:	c3                   	ret    
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a881:	83 c2 1f             	add    $0x1f,%edx
c002a884:	c1 ea 05             	shr    $0x5,%edx
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a887:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
      success = file_read_at (file, b->bits, size, 0) == size;
c002a88e:	6a 00                	push   $0x0
c002a890:	56                   	push   %esi
c002a891:	ff 77 04             	pushl  0x4(%edi)
c002a894:	ff 74 24 20          	pushl  0x20(%esp)
c002a898:	e8 73 2c 00 00       	call   c002d510 <file_read_at>
c002a89d:	83 c4 10             	add    $0x10,%esp
c002a8a0:	39 f0                	cmp    %esi,%eax
c002a8a2:	0f 94 c0             	sete   %al
  int last_bits = b->bit_cnt % ELEM_BITS;
c002a8a5:	8b 17                	mov    (%edi),%edx
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c002a8a7:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002a8ac:	89 d1                	mov    %edx,%ecx
c002a8ae:	83 e1 1f             	and    $0x1f,%ecx
c002a8b1:	74 0a                	je     c002a8bd <bitmap_read+0x5d>
c002a8b3:	be 01 00 00 00       	mov    $0x1,%esi
c002a8b8:	d3 e6                	shl    %cl,%esi
c002a8ba:	83 ee 01             	sub    $0x1,%esi
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a8bd:	83 c2 1f             	add    $0x1f,%edx
c002a8c0:	c1 ea 05             	shr    $0x5,%edx
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c002a8c3:	8b 4f 04             	mov    0x4(%edi),%ecx
c002a8c6:	21 74 91 fc          	and    %esi,-0x4(%ecx,%edx,4)
c002a8ca:	eb b1                	jmp    c002a87d <bitmap_read+0x1d>

c002a8cc <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c002a8cc:	56                   	push   %esi
c002a8cd:	53                   	push   %ebx
c002a8ce:	83 ec 04             	sub    $0x4,%esp
c002a8d1:	e8 af 41 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a8d6:	81 c3 de 05 01 00    	add    $0x105de,%ebx
c002a8dc:	8b 44 24 10          	mov    0x10(%esp),%eax
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a8e0:	8b 10                	mov    (%eax),%edx
c002a8e2:	8d 72 1f             	lea    0x1f(%edx),%esi
c002a8e5:	c1 ee 05             	shr    $0x5,%esi
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a8e8:	c1 e6 02             	shl    $0x2,%esi
  off_t size = byte_cnt (b->bit_cnt);
  return file_write_at (file, b->bits, size, 0) == size;
c002a8eb:	6a 00                	push   $0x0
c002a8ed:	56                   	push   %esi
c002a8ee:	ff 70 04             	pushl  0x4(%eax)
c002a8f1:	ff 74 24 20          	pushl  0x20(%esp)
c002a8f5:	e8 70 2c 00 00       	call   c002d56a <file_write_at>
c002a8fa:	39 f0                	cmp    %esi,%eax
c002a8fc:	0f 94 c0             	sete   %al
}
c002a8ff:	83 c4 14             	add    $0x14,%esp
c002a902:	5b                   	pop    %ebx
c002a903:	5e                   	pop    %esi
c002a904:	c3                   	ret    

c002a905 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002a905:	53                   	push   %ebx
c002a906:	83 ec 08             	sub    $0x8,%esp
c002a909:	e8 77 41 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a90e:	81 c3 a6 05 01 00    	add    $0x105a6,%ebx
c002a914:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a918:	6a 00                	push   $0x0
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a91a:	8b 02                	mov    (%edx),%eax
c002a91c:	83 c0 1f             	add    $0x1f,%eax
c002a91f:	c1 e8 05             	shr    $0x5,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a922:	c1 e0 02             	shl    $0x2,%eax
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002a925:	50                   	push   %eax
c002a926:	ff 72 04             	pushl  0x4(%edx)
c002a929:	6a 00                	push   $0x0
c002a92b:	e8 fe d4 ff ff       	call   c0027e2e <hex_dump>
}
c002a930:	83 c4 18             	add    $0x18,%esp
c002a933:	5b                   	pop    %ebx
c002a934:	c3                   	ret    

c002a935 <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002a935:	53                   	push   %ebx
c002a936:	83 ec 10             	sub    $0x10,%esp
c002a939:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002a93b:	ff 70 14             	pushl  0x14(%eax)
c002a93e:	52                   	push   %edx
c002a93f:	ff 50 0c             	call   *0xc(%eax)
c002a942:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002a945:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002a948:	21 d0                	and    %edx,%eax
  return &h->buckets[bucket_idx];
c002a94a:	c1 e0 04             	shl    $0x4,%eax
c002a94d:	03 43 08             	add    0x8(%ebx),%eax
}
c002a950:	83 c4 18             	add    $0x18,%esp
c002a953:	5b                   	pop    %ebx
c002a954:	c3                   	ret    

c002a955 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002a955:	55                   	push   %ebp
c002a956:	57                   	push   %edi
c002a957:	56                   	push   %esi
c002a958:	53                   	push   %ebx
c002a959:	83 ec 28             	sub    $0x28,%esp
c002a95c:	e8 24 41 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a961:	81 c3 53 05 01 00    	add    $0x10553,%ebx
c002a967:	89 c7                	mov    %eax,%edi
c002a969:	89 54 24 18          	mov    %edx,0x18(%esp)
c002a96d:	89 cd                	mov    %ecx,%ebp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002a96f:	52                   	push   %edx
c002a970:	e8 37 ea ff ff       	call   c00293ac <list_begin>
c002a975:	89 c6                	mov    %eax,%esi
c002a977:	83 c4 10             	add    $0x10,%esp
c002a97a:	eb 0e                	jmp    c002a98a <find_elem+0x35>
c002a97c:	83 ec 0c             	sub    $0xc,%esp
c002a97f:	56                   	push   %esi
c002a980:	e8 6c ea ff ff       	call   c00293f1 <list_next>
c002a985:	89 c6                	mov    %eax,%esi
c002a987:	83 c4 10             	add    $0x10,%esp
c002a98a:	83 ec 0c             	sub    $0xc,%esp
c002a98d:	ff 74 24 18          	pushl  0x18(%esp)
c002a991:	e8 b8 ea ff ff       	call   c002944e <list_end>
c002a996:	83 c4 10             	add    $0x10,%esp
c002a999:	39 f0                	cmp    %esi,%eax
c002a99b:	74 26                	je     c002a9c3 <find_elem+0x6e>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002a99d:	83 ec 04             	sub    $0x4,%esp
c002a9a0:	ff 77 14             	pushl  0x14(%edi)
c002a9a3:	55                   	push   %ebp
c002a9a4:	56                   	push   %esi
c002a9a5:	ff 57 10             	call   *0x10(%edi)
c002a9a8:	83 c4 10             	add    $0x10,%esp
c002a9ab:	84 c0                	test   %al,%al
c002a9ad:	75 cd                	jne    c002a97c <find_elem+0x27>
c002a9af:	83 ec 04             	sub    $0x4,%esp
c002a9b2:	ff 77 14             	pushl  0x14(%edi)
c002a9b5:	56                   	push   %esi
c002a9b6:	55                   	push   %ebp
c002a9b7:	ff 57 10             	call   *0x10(%edi)
c002a9ba:	83 c4 10             	add    $0x10,%esp
c002a9bd:	84 c0                	test   %al,%al
c002a9bf:	75 bb                	jne    c002a97c <find_elem+0x27>
c002a9c1:	eb 05                	jmp    c002a9c8 <find_elem+0x73>
        return hi; 
    }
  return NULL;
c002a9c3:	be 00 00 00 00       	mov    $0x0,%esi
}
c002a9c8:	89 f0                	mov    %esi,%eax
c002a9ca:	83 c4 1c             	add    $0x1c,%esp
c002a9cd:	5b                   	pop    %ebx
c002a9ce:	5e                   	pop    %esi
c002a9cf:	5f                   	pop    %edi
c002a9d0:	5d                   	pop    %ebp
c002a9d1:	c3                   	ret    

c002a9d2 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002a9d2:	55                   	push   %ebp
c002a9d3:	57                   	push   %edi
c002a9d4:	56                   	push   %esi
c002a9d5:	53                   	push   %ebx
c002a9d6:	83 ec 2c             	sub    $0x2c,%esp
c002a9d9:	e8 a7 40 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002a9de:	81 c3 d6 04 01 00    	add    $0x104d6,%ebx
c002a9e4:	89 44 24 10          	mov    %eax,0x10(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002a9e8:	85 c0                	test   %eax,%eax
c002a9ea:	74 22                	je     c002aa0e <rehash+0x3c>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c002a9ec:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a9f0:	8b 48 04             	mov    0x4(%eax),%ecx
c002a9f3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002a9f7:	8b 00                	mov    (%eax),%eax
c002a9f9:	89 44 24 14          	mov    %eax,0x14(%esp)
c002a9fd:	89 c6                	mov    %eax,%esi
c002a9ff:	d1 ee                	shr    %esi
c002aa01:	83 fe 04             	cmp    $0x4,%esi
c002aa04:	b8 04 00 00 00       	mov    $0x4,%eax
c002aa09:	0f 42 f0             	cmovb  %eax,%esi
c002aa0c:	eb 2e                	jmp    c002aa3c <rehash+0x6a>
  ASSERT (h != NULL);
c002aa0e:	83 ec 0c             	sub    $0xc,%esp
c002aa11:	8d 83 c4 6c ff ff    	lea    -0x933c(%ebx),%eax
c002aa17:	50                   	push   %eax
c002aa18:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002aa1e:	50                   	push   %eax
c002aa1f:	8d 83 ec 4a ff ff    	lea    -0xb514(%ebx),%eax
c002aa25:	50                   	push   %eax
c002aa26:	68 66 01 00 00       	push   $0x166
c002aa2b:	8d 83 ce 6c ff ff    	lea    -0x9332(%ebx),%eax
c002aa31:	50                   	push   %eax
c002aa32:	e8 50 e8 ff ff       	call   c0029287 <debug_panic>
  return x & (x - 1);
c002aa37:	8d 46 ff             	lea    -0x1(%esi),%eax
c002aa3a:	21 c6                	and    %eax,%esi
  return x != 0 && turn_off_least_1bit (x) == 0;
c002aa3c:	85 f6                	test   %esi,%esi
c002aa3e:	74 f7                	je     c002aa37 <rehash+0x65>
  return x & (x - 1);
c002aa40:	8d 46 ff             	lea    -0x1(%esi),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002aa43:	85 f0                	test   %esi,%eax
c002aa45:	75 f0                	jne    c002aa37 <rehash+0x65>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002aa47:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002aa4b:	0f 84 df 00 00 00    	je     c002ab30 <rehash+0x15e>
  old_buckets = h->buckets;
c002aa51:	8b 44 24 10          	mov    0x10(%esp),%eax
c002aa55:	8b 40 08             	mov    0x8(%eax),%eax
c002aa58:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002aa5c:	89 f5                	mov    %esi,%ebp
c002aa5e:	c1 e5 04             	shl    $0x4,%ebp
c002aa61:	83 ec 0c             	sub    $0xc,%esp
c002aa64:	55                   	push   %ebp
c002aa65:	e8 bd 94 ff ff       	call   c0023f27 <malloc>
c002aa6a:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (new_buckets == NULL) 
c002aa6e:	83 c4 10             	add    $0x10,%esp
c002aa71:	85 c0                	test   %eax,%eax
c002aa73:	0f 84 b7 00 00 00    	je     c002ab30 <rehash+0x15e>
c002aa79:	89 c7                	mov    %eax,%edi
c002aa7b:	01 c5                	add    %eax,%ebp
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c002aa7d:	83 ec 0c             	sub    $0xc,%esp
c002aa80:	57                   	push   %edi
c002aa81:	e8 ce e8 ff ff       	call   c0029354 <list_init>
c002aa86:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < new_bucket_cnt; i++) 
c002aa89:	83 c4 10             	add    $0x10,%esp
c002aa8c:	39 ef                	cmp    %ebp,%edi
c002aa8e:	75 ed                	jne    c002aa7d <rehash+0xab>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002aa90:	8b 44 24 10          	mov    0x10(%esp),%eax
c002aa94:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002aa98:	89 48 08             	mov    %ecx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002aa9b:	89 70 04             	mov    %esi,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002aa9e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002aaa2:	85 c0                	test   %eax,%eax
c002aaa4:	74 7b                	je     c002ab21 <rehash+0x14f>
c002aaa6:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002aaaa:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002aaae:	c1 e0 04             	shl    $0x4,%eax
c002aab1:	01 c8                	add    %ecx,%eax
c002aab3:	89 44 24 18          	mov    %eax,0x18(%esp)
c002aab7:	eb 52                	jmp    c002ab0b <rehash+0x139>

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c002aab9:	89 f2                	mov    %esi,%edx
c002aabb:	8b 44 24 10          	mov    0x10(%esp),%eax
c002aabf:	e8 71 fe ff ff       	call   c002a935 <find_bucket>
c002aac4:	89 c5                	mov    %eax,%ebp
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c002aac6:	83 ec 0c             	sub    $0xc,%esp
c002aac9:	56                   	push   %esi
c002aaca:	e8 22 e9 ff ff       	call   c00293f1 <list_next>
c002aacf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          list_remove (elem);
c002aad3:	89 34 24             	mov    %esi,(%esp)
c002aad6:	e8 7c ee ff ff       	call   c0029957 <list_remove>
          list_push_front (new_bucket, elem);
c002aadb:	83 c4 08             	add    $0x8,%esp
c002aade:	56                   	push   %esi
c002aadf:	55                   	push   %ebp
c002aae0:	e8 38 ee ff ff       	call   c002991d <list_push_front>
           elem != list_end (old_bucket); elem = next) 
c002aae5:	83 c4 10             	add    $0x10,%esp
c002aae8:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002aaec:	83 ec 0c             	sub    $0xc,%esp
c002aaef:	57                   	push   %edi
c002aaf0:	e8 59 e9 ff ff       	call   c002944e <list_end>
      for (elem = list_begin (old_bucket);
c002aaf5:	83 c4 10             	add    $0x10,%esp
c002aaf8:	39 f0                	cmp    %esi,%eax
c002aafa:	75 bd                	jne    c002aab9 <rehash+0xe7>
c002aafc:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002ab01:	8b 44 24 14          	mov    0x14(%esp),%eax
  for (i = 0; i < old_bucket_cnt; i++) 
c002ab05:	39 44 24 18          	cmp    %eax,0x18(%esp)
c002ab09:	74 16                	je     c002ab21 <rehash+0x14f>
      old_bucket = &old_buckets[i];
c002ab0b:	8b 44 24 14          	mov    0x14(%esp),%eax
c002ab0f:	89 c7                	mov    %eax,%edi
      for (elem = list_begin (old_bucket);
c002ab11:	83 ec 0c             	sub    $0xc,%esp
c002ab14:	50                   	push   %eax
c002ab15:	e8 92 e8 ff ff       	call   c00293ac <list_begin>
c002ab1a:	89 c6                	mov    %eax,%esi
c002ab1c:	83 c4 10             	add    $0x10,%esp
c002ab1f:	eb cb                	jmp    c002aaec <rehash+0x11a>
        }
    }

  free (old_buckets);
c002ab21:	83 ec 0c             	sub    $0xc,%esp
c002ab24:	ff 74 24 28          	pushl  0x28(%esp)
c002ab28:	e8 b0 95 ff ff       	call   c00240dd <free>
c002ab2d:	83 c4 10             	add    $0x10,%esp
}
c002ab30:	83 c4 2c             	add    $0x2c,%esp
c002ab33:	5b                   	pop    %ebx
c002ab34:	5e                   	pop    %esi
c002ab35:	5f                   	pop    %edi
c002ab36:	5d                   	pop    %ebp
c002ab37:	c3                   	ret    

c002ab38 <hash_clear>:
{
c002ab38:	55                   	push   %ebp
c002ab39:	57                   	push   %edi
c002ab3a:	56                   	push   %esi
c002ab3b:	53                   	push   %ebx
c002ab3c:	83 ec 1c             	sub    $0x1c,%esp
c002ab3f:	e8 41 3f 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ab44:	81 c3 70 03 01 00    	add    $0x10370,%ebx
c002ab4a:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002ab4e:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  for (i = 0; i < h->bucket_cnt; i++) 
c002ab52:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002ab56:	74 59                	je     c002abb1 <hash_clear+0x79>
c002ab58:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002ab5f:	00 
c002ab60:	eb 3f                	jmp    c002aba1 <hash_clear+0x69>
            struct list_elem *list_elem = list_pop_front (bucket);
c002ab62:	83 ec 0c             	sub    $0xc,%esp
c002ab65:	56                   	push   %esi
c002ab66:	e8 05 ef ff ff       	call   c0029a70 <list_pop_front>
            destructor (hash_elem, h->aux);
c002ab6b:	83 c4 08             	add    $0x8,%esp
c002ab6e:	ff 77 14             	pushl  0x14(%edi)
c002ab71:	50                   	push   %eax
c002ab72:	ff d5                	call   *%ebp
c002ab74:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002ab77:	83 ec 0c             	sub    $0xc,%esp
c002ab7a:	56                   	push   %esi
c002ab7b:	e8 79 ee ff ff       	call   c00299f9 <list_empty>
c002ab80:	83 c4 10             	add    $0x10,%esp
c002ab83:	84 c0                	test   %al,%al
c002ab85:	74 db                	je     c002ab62 <hash_clear+0x2a>
      list_init (bucket); 
c002ab87:	83 ec 0c             	sub    $0xc,%esp
c002ab8a:	56                   	push   %esi
c002ab8b:	e8 c4 e7 ff ff       	call   c0029354 <list_init>
  for (i = 0; i < h->bucket_cnt; i++) 
c002ab90:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
c002ab95:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ab99:	83 c4 10             	add    $0x10,%esp
c002ab9c:	39 47 04             	cmp    %eax,0x4(%edi)
c002ab9f:	76 10                	jbe    c002abb1 <hash_clear+0x79>
      struct list *bucket = &h->buckets[i];
c002aba1:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002aba5:	c1 e6 04             	shl    $0x4,%esi
c002aba8:	03 77 08             	add    0x8(%edi),%esi
      if (destructor != NULL) 
c002abab:	85 ed                	test   %ebp,%ebp
c002abad:	75 c8                	jne    c002ab77 <hash_clear+0x3f>
c002abaf:	eb d6                	jmp    c002ab87 <hash_clear+0x4f>
  h->elem_cnt = 0;
c002abb1:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
c002abb7:	83 c4 1c             	add    $0x1c,%esp
c002abba:	5b                   	pop    %ebx
c002abbb:	5e                   	pop    %esi
c002abbc:	5f                   	pop    %edi
c002abbd:	5d                   	pop    %ebp
c002abbe:	c3                   	ret    

c002abbf <hash_init>:
{
c002abbf:	56                   	push   %esi
c002abc0:	53                   	push   %ebx
c002abc1:	83 ec 10             	sub    $0x10,%esp
c002abc4:	e8 bc 3e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002abc9:	81 c3 eb 02 01 00    	add    $0x102eb,%ebx
c002abcf:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  h->elem_cnt = 0;
c002abd3:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  h->bucket_cnt = 4;
c002abd9:	c7 46 04 04 00 00 00 	movl   $0x4,0x4(%esi)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002abe0:	6a 40                	push   $0x40
c002abe2:	e8 40 93 ff ff       	call   c0023f27 <malloc>
c002abe7:	89 c2                	mov    %eax,%edx
c002abe9:	89 46 08             	mov    %eax,0x8(%esi)
  h->hash = hash;
c002abec:	8b 44 24 24          	mov    0x24(%esp),%eax
c002abf0:	89 46 0c             	mov    %eax,0xc(%esi)
  h->less = less;
c002abf3:	8b 44 24 28          	mov    0x28(%esp),%eax
c002abf7:	89 46 10             	mov    %eax,0x10(%esi)
  h->aux = aux;
c002abfa:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002abfe:	89 46 14             	mov    %eax,0x14(%esi)
  if (h->buckets != NULL) 
c002ac01:	83 c4 10             	add    $0x10,%esp
    return false;
c002ac04:	b8 00 00 00 00       	mov    $0x0,%eax
  if (h->buckets != NULL) 
c002ac09:	85 d2                	test   %edx,%edx
c002ac0b:	74 13                	je     c002ac20 <hash_init+0x61>
      hash_clear (h, NULL);
c002ac0d:	83 ec 08             	sub    $0x8,%esp
c002ac10:	6a 00                	push   $0x0
c002ac12:	56                   	push   %esi
c002ac13:	e8 20 ff ff ff       	call   c002ab38 <hash_clear>
      return true;
c002ac18:	83 c4 10             	add    $0x10,%esp
c002ac1b:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002ac20:	83 c4 04             	add    $0x4,%esp
c002ac23:	5b                   	pop    %ebx
c002ac24:	5e                   	pop    %esi
c002ac25:	c3                   	ret    

c002ac26 <hash_destroy>:
{
c002ac26:	56                   	push   %esi
c002ac27:	53                   	push   %ebx
c002ac28:	83 ec 04             	sub    $0x4,%esp
c002ac2b:	e8 55 3e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ac30:	81 c3 84 02 01 00    	add    $0x10284,%ebx
c002ac36:	8b 74 24 10          	mov    0x10(%esp),%esi
c002ac3a:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002ac3e:	85 c0                	test   %eax,%eax
c002ac40:	74 0d                	je     c002ac4f <hash_destroy+0x29>
    hash_clear (h, destructor);
c002ac42:	83 ec 08             	sub    $0x8,%esp
c002ac45:	50                   	push   %eax
c002ac46:	56                   	push   %esi
c002ac47:	e8 ec fe ff ff       	call   c002ab38 <hash_clear>
c002ac4c:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002ac4f:	83 ec 0c             	sub    $0xc,%esp
c002ac52:	ff 76 08             	pushl  0x8(%esi)
c002ac55:	e8 83 94 ff ff       	call   c00240dd <free>
}
c002ac5a:	83 c4 14             	add    $0x14,%esp
c002ac5d:	5b                   	pop    %ebx
c002ac5e:	5e                   	pop    %esi
c002ac5f:	c3                   	ret    

c002ac60 <hash_insert>:
{
c002ac60:	55                   	push   %ebp
c002ac61:	57                   	push   %edi
c002ac62:	56                   	push   %esi
c002ac63:	53                   	push   %ebx
c002ac64:	83 ec 0c             	sub    $0xc,%esp
c002ac67:	e8 19 3e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ac6c:	81 c3 48 02 01 00    	add    $0x10248,%ebx
c002ac72:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002ac76:	8b 54 24 24          	mov    0x24(%esp),%edx
c002ac7a:	89 f0                	mov    %esi,%eax
c002ac7c:	e8 b4 fc ff ff       	call   c002a935 <find_bucket>
c002ac81:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002ac83:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002ac87:	89 c2                	mov    %eax,%edx
c002ac89:	89 f0                	mov    %esi,%eax
c002ac8b:	e8 c5 fc ff ff       	call   c002a955 <find_elem>
c002ac90:	89 c7                	mov    %eax,%edi
  if (old == NULL) 
c002ac92:	85 c0                	test   %eax,%eax
c002ac94:	74 11                	je     c002aca7 <hash_insert+0x47>
  rehash (h);
c002ac96:	89 f0                	mov    %esi,%eax
c002ac98:	e8 35 fd ff ff       	call   c002a9d2 <rehash>
}
c002ac9d:	89 f8                	mov    %edi,%eax
c002ac9f:	83 c4 0c             	add    $0xc,%esp
c002aca2:	5b                   	pop    %ebx
c002aca3:	5e                   	pop    %esi
c002aca4:	5f                   	pop    %edi
c002aca5:	5d                   	pop    %ebp
c002aca6:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002aca7:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002acaa:	83 ec 08             	sub    $0x8,%esp
c002acad:	ff 74 24 2c          	pushl  0x2c(%esp)
c002acb1:	55                   	push   %ebp
c002acb2:	e8 66 ec ff ff       	call   c002991d <list_push_front>
c002acb7:	83 c4 10             	add    $0x10,%esp
c002acba:	eb da                	jmp    c002ac96 <hash_insert+0x36>

c002acbc <hash_replace>:
{
c002acbc:	55                   	push   %ebp
c002acbd:	57                   	push   %edi
c002acbe:	56                   	push   %esi
c002acbf:	53                   	push   %ebx
c002acc0:	83 ec 0c             	sub    $0xc,%esp
c002acc3:	e8 bd 3d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002acc8:	81 c3 ec 01 01 00    	add    $0x101ec,%ebx
c002acce:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002acd2:	8b 54 24 24          	mov    0x24(%esp),%edx
c002acd6:	89 f0                	mov    %esi,%eax
c002acd8:	e8 58 fc ff ff       	call   c002a935 <find_bucket>
c002acdd:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002acdf:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002ace3:	89 c2                	mov    %eax,%edx
c002ace5:	89 f0                	mov    %esi,%eax
c002ace7:	e8 69 fc ff ff       	call   c002a955 <find_elem>
c002acec:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c002acee:	85 c0                	test   %eax,%eax
c002acf0:	74 0f                	je     c002ad01 <hash_replace+0x45>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c002acf2:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002acf5:	83 ec 0c             	sub    $0xc,%esp
c002acf8:	50                   	push   %eax
c002acf9:	e8 59 ec ff ff       	call   c0029957 <list_remove>
c002acfe:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c002ad01:	83 06 01             	addl   $0x1,(%esi)
  list_push_front (bucket, &e->list_elem);
c002ad04:	83 ec 08             	sub    $0x8,%esp
c002ad07:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ad0b:	55                   	push   %ebp
c002ad0c:	e8 0c ec ff ff       	call   c002991d <list_push_front>
  rehash (h);
c002ad11:	89 f0                	mov    %esi,%eax
c002ad13:	e8 ba fc ff ff       	call   c002a9d2 <rehash>
}
c002ad18:	89 f8                	mov    %edi,%eax
c002ad1a:	83 c4 1c             	add    $0x1c,%esp
c002ad1d:	5b                   	pop    %ebx
c002ad1e:	5e                   	pop    %esi
c002ad1f:	5f                   	pop    %edi
c002ad20:	5d                   	pop    %ebp
c002ad21:	c3                   	ret    

c002ad22 <hash_find>:
{
c002ad22:	56                   	push   %esi
c002ad23:	53                   	push   %ebx
c002ad24:	83 ec 04             	sub    $0x4,%esp
c002ad27:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002ad2b:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem (h, find_bucket (h, e), e);
c002ad2f:	89 f2                	mov    %esi,%edx
c002ad31:	89 d8                	mov    %ebx,%eax
c002ad33:	e8 fd fb ff ff       	call   c002a935 <find_bucket>
c002ad38:	89 f1                	mov    %esi,%ecx
c002ad3a:	89 c2                	mov    %eax,%edx
c002ad3c:	89 d8                	mov    %ebx,%eax
c002ad3e:	e8 12 fc ff ff       	call   c002a955 <find_elem>
}
c002ad43:	83 c4 04             	add    $0x4,%esp
c002ad46:	5b                   	pop    %ebx
c002ad47:	5e                   	pop    %esi
c002ad48:	c3                   	ret    

c002ad49 <hash_delete>:
{
c002ad49:	57                   	push   %edi
c002ad4a:	56                   	push   %esi
c002ad4b:	53                   	push   %ebx
c002ad4c:	e8 34 3d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ad51:	81 c3 63 01 01 00    	add    $0x10163,%ebx
c002ad57:	8b 74 24 10          	mov    0x10(%esp),%esi
c002ad5b:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002ad5f:	89 fa                	mov    %edi,%edx
c002ad61:	89 f0                	mov    %esi,%eax
c002ad63:	e8 cd fb ff ff       	call   c002a935 <find_bucket>
c002ad68:	89 f9                	mov    %edi,%ecx
c002ad6a:	89 c2                	mov    %eax,%edx
c002ad6c:	89 f0                	mov    %esi,%eax
c002ad6e:	e8 e2 fb ff ff       	call   c002a955 <find_elem>
c002ad73:	89 c7                	mov    %eax,%edi
  if (found != NULL) 
c002ad75:	85 c0                	test   %eax,%eax
c002ad77:	74 16                	je     c002ad8f <hash_delete+0x46>
  h->elem_cnt--;
c002ad79:	83 2e 01             	subl   $0x1,(%esi)
  list_remove (&e->list_elem);
c002ad7c:	83 ec 0c             	sub    $0xc,%esp
c002ad7f:	50                   	push   %eax
c002ad80:	e8 d2 eb ff ff       	call   c0029957 <list_remove>
      rehash (h); 
c002ad85:	89 f0                	mov    %esi,%eax
c002ad87:	e8 46 fc ff ff       	call   c002a9d2 <rehash>
c002ad8c:	83 c4 10             	add    $0x10,%esp
}
c002ad8f:	89 f8                	mov    %edi,%eax
c002ad91:	5b                   	pop    %ebx
c002ad92:	5e                   	pop    %esi
c002ad93:	5f                   	pop    %edi
c002ad94:	c3                   	ret    

c002ad95 <hash_apply>:
{
c002ad95:	55                   	push   %ebp
c002ad96:	57                   	push   %edi
c002ad97:	56                   	push   %esi
c002ad98:	53                   	push   %ebx
c002ad99:	83 ec 1c             	sub    $0x1c,%esp
c002ad9c:	e8 e4 3c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ada1:	81 c3 13 01 01 00    	add    $0x10113,%ebx
c002ada7:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT (action != NULL);
c002adab:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002adb0:	74 16                	je     c002adc8 <hash_apply+0x33>
  for (i = 0; i < h->bucket_cnt; i++) 
c002adb2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002adb9:	00 
c002adba:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002adbe:	75 6e                	jne    c002ae2e <hash_apply+0x99>
}
c002adc0:	83 c4 1c             	add    $0x1c,%esp
c002adc3:	5b                   	pop    %ebx
c002adc4:	5e                   	pop    %esi
c002adc5:	5f                   	pop    %edi
c002adc6:	5d                   	pop    %ebp
c002adc7:	c3                   	ret    
  ASSERT (action != NULL);
c002adc8:	83 ec 0c             	sub    $0xc,%esp
c002adcb:	8d 83 e6 6c ff ff    	lea    -0x931a(%ebx),%eax
c002add1:	50                   	push   %eax
c002add2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002add8:	50                   	push   %eax
c002add9:	8d 83 e0 4a ff ff    	lea    -0xb520(%ebx),%eax
c002addf:	50                   	push   %eax
c002ade0:	68 a7 00 00 00       	push   $0xa7
c002ade5:	8d 83 ce 6c ff ff    	lea    -0x9332(%ebx),%eax
c002adeb:	50                   	push   %eax
c002adec:	e8 96 e4 ff ff       	call   c0029287 <debug_panic>
          next = list_next (elem);
c002adf1:	83 ec 0c             	sub    $0xc,%esp
c002adf4:	56                   	push   %esi
c002adf5:	e8 f7 e5 ff ff       	call   c00293f1 <list_next>
c002adfa:	89 44 24 18          	mov    %eax,0x18(%esp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002adfe:	83 c4 08             	add    $0x8,%esp
c002ae01:	ff 75 14             	pushl  0x14(%ebp)
c002ae04:	56                   	push   %esi
c002ae05:	ff 54 24 44          	call   *0x44(%esp)
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002ae09:	83 c4 10             	add    $0x10,%esp
c002ae0c:	8b 74 24 08          	mov    0x8(%esp),%esi
c002ae10:	83 ec 0c             	sub    $0xc,%esp
c002ae13:	57                   	push   %edi
c002ae14:	e8 35 e6 ff ff       	call   c002944e <list_end>
c002ae19:	83 c4 10             	add    $0x10,%esp
c002ae1c:	39 f0                	cmp    %esi,%eax
c002ae1e:	75 d1                	jne    c002adf1 <hash_apply+0x5c>
  for (i = 0; i < h->bucket_cnt; i++) 
c002ae20:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002ae25:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002ae29:	39 45 04             	cmp    %eax,0x4(%ebp)
c002ae2c:	76 92                	jbe    c002adc0 <hash_apply+0x2b>
      struct list *bucket = &h->buckets[i];
c002ae2e:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002ae32:	c1 e7 04             	shl    $0x4,%edi
c002ae35:	03 7d 08             	add    0x8(%ebp),%edi
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002ae38:	83 ec 0c             	sub    $0xc,%esp
c002ae3b:	57                   	push   %edi
c002ae3c:	e8 6b e5 ff ff       	call   c00293ac <list_begin>
c002ae41:	89 c6                	mov    %eax,%esi
c002ae43:	83 c4 10             	add    $0x10,%esp
c002ae46:	eb c8                	jmp    c002ae10 <hash_apply+0x7b>

c002ae48 <hash_first>:
{
c002ae48:	56                   	push   %esi
c002ae49:	53                   	push   %ebx
c002ae4a:	83 ec 04             	sub    $0x4,%esp
c002ae4d:	e8 33 3c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ae52:	81 c3 62 00 01 00    	add    $0x10062,%ebx
c002ae58:	8b 74 24 10          	mov    0x10(%esp),%esi
c002ae5c:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c002ae60:	85 f6                	test   %esi,%esi
c002ae62:	74 1e                	je     c002ae82 <hash_first+0x3a>
  ASSERT (h != NULL);
c002ae64:	85 c0                	test   %eax,%eax
c002ae66:	74 43                	je     c002aeab <hash_first+0x63>
  i->hash = h;
c002ae68:	89 06                	mov    %eax,(%esi)
  i->bucket = i->hash->buckets;
c002ae6a:	8b 40 08             	mov    0x8(%eax),%eax
c002ae6d:	89 46 04             	mov    %eax,0x4(%esi)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002ae70:	83 ec 0c             	sub    $0xc,%esp
c002ae73:	50                   	push   %eax
c002ae74:	e8 7a e8 ff ff       	call   c00296f3 <list_head>
c002ae79:	89 46 08             	mov    %eax,0x8(%esi)
}
c002ae7c:	83 c4 14             	add    $0x14,%esp
c002ae7f:	5b                   	pop    %ebx
c002ae80:	5e                   	pop    %esi
c002ae81:	c3                   	ret    
  ASSERT (i != NULL);
c002ae82:	83 ec 0c             	sub    $0xc,%esp
c002ae85:	8d 83 f5 6c ff ff    	lea    -0x930b(%ebx),%eax
c002ae8b:	50                   	push   %eax
c002ae8c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002ae92:	50                   	push   %eax
c002ae93:	8d 83 d4 4a ff ff    	lea    -0xb52c(%ebx),%eax
c002ae99:	50                   	push   %eax
c002ae9a:	68 ca 00 00 00       	push   $0xca
c002ae9f:	8d 83 ce 6c ff ff    	lea    -0x9332(%ebx),%eax
c002aea5:	50                   	push   %eax
c002aea6:	e8 dc e3 ff ff       	call   c0029287 <debug_panic>
  ASSERT (h != NULL);
c002aeab:	83 ec 0c             	sub    $0xc,%esp
c002aeae:	8d 83 c4 6c ff ff    	lea    -0x933c(%ebx),%eax
c002aeb4:	50                   	push   %eax
c002aeb5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002aebb:	50                   	push   %eax
c002aebc:	8d 83 d4 4a ff ff    	lea    -0xb52c(%ebx),%eax
c002aec2:	50                   	push   %eax
c002aec3:	68 cb 00 00 00       	push   $0xcb
c002aec8:	8d 83 ce 6c ff ff    	lea    -0x9332(%ebx),%eax
c002aece:	50                   	push   %eax
c002aecf:	e8 b3 e3 ff ff       	call   c0029287 <debug_panic>

c002aed4 <hash_next>:
{
c002aed4:	57                   	push   %edi
c002aed5:	56                   	push   %esi
c002aed6:	53                   	push   %ebx
c002aed7:	e8 a9 3b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002aedc:	81 c3 d8 ff 00 00    	add    $0xffd8,%ebx
c002aee2:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (i != NULL);
c002aee6:	85 f6                	test   %esi,%esi
c002aee8:	74 4f                	je     c002af39 <hash_next+0x65>
  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002aeea:	83 ec 0c             	sub    $0xc,%esp
c002aeed:	ff 76 08             	pushl  0x8(%esi)
c002aef0:	e8 fc e4 ff ff       	call   c00293f1 <list_next>
c002aef5:	89 46 08             	mov    %eax,0x8(%esi)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002aef8:	83 c4 10             	add    $0x10,%esp
c002aefb:	8b 7e 08             	mov    0x8(%esi),%edi
c002aefe:	83 ec 0c             	sub    $0xc,%esp
c002af01:	ff 76 04             	pushl  0x4(%esi)
c002af04:	e8 45 e5 ff ff       	call   c002944e <list_end>
c002af09:	83 c4 10             	add    $0x10,%esp
c002af0c:	39 c7                	cmp    %eax,%edi
c002af0e:	75 59                	jne    c002af69 <hash_next+0x95>
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002af10:	8b 46 04             	mov    0x4(%esi),%eax
c002af13:	8d 50 10             	lea    0x10(%eax),%edx
c002af16:	89 56 04             	mov    %edx,0x4(%esi)
c002af19:	8b 0e                	mov    (%esi),%ecx
c002af1b:	8b 41 04             	mov    0x4(%ecx),%eax
c002af1e:	c1 e0 04             	shl    $0x4,%eax
c002af21:	03 41 08             	add    0x8(%ecx),%eax
c002af24:	39 c2                	cmp    %eax,%edx
c002af26:	73 3a                	jae    c002af62 <hash_next+0x8e>
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002af28:	83 ec 0c             	sub    $0xc,%esp
c002af2b:	52                   	push   %edx
c002af2c:	e8 7b e4 ff ff       	call   c00293ac <list_begin>
c002af31:	89 46 08             	mov    %eax,0x8(%esi)
c002af34:	83 c4 10             	add    $0x10,%esp
c002af37:	eb c2                	jmp    c002aefb <hash_next+0x27>
  ASSERT (i != NULL);
c002af39:	83 ec 0c             	sub    $0xc,%esp
c002af3c:	8d 83 f5 6c ff ff    	lea    -0x930b(%ebx),%eax
c002af42:	50                   	push   %eax
c002af43:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002af49:	50                   	push   %eax
c002af4a:	8d 83 c8 4a ff ff    	lea    -0xb538(%ebx),%eax
c002af50:	50                   	push   %eax
c002af51:	68 dd 00 00 00       	push   $0xdd
c002af56:	8d 83 ce 6c ff ff    	lea    -0x9332(%ebx),%eax
c002af5c:	50                   	push   %eax
c002af5d:	e8 25 e3 ff ff       	call   c0029287 <debug_panic>
          i->elem = NULL;
c002af62:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  return i->elem;
c002af69:	8b 46 08             	mov    0x8(%esi),%eax
}
c002af6c:	5b                   	pop    %ebx
c002af6d:	5e                   	pop    %esi
c002af6e:	5f                   	pop    %edi
c002af6f:	c3                   	ret    

c002af70 <hash_cur>:
  return i->elem;
c002af70:	8b 44 24 04          	mov    0x4(%esp),%eax
c002af74:	8b 40 08             	mov    0x8(%eax),%eax
}
c002af77:	c3                   	ret    

c002af78 <hash_size>:
  return h->elem_cnt;
c002af78:	8b 44 24 04          	mov    0x4(%esp),%eax
c002af7c:	8b 00                	mov    (%eax),%eax
}
c002af7e:	c3                   	ret    

c002af7f <hash_empty>:
  return h->elem_cnt == 0;
c002af7f:	8b 44 24 04          	mov    0x4(%esp),%eax
c002af83:	83 38 00             	cmpl   $0x0,(%eax)
c002af86:	0f 94 c0             	sete   %al
}
c002af89:	c3                   	ret    

c002af8a <hash_bytes>:
{
c002af8a:	53                   	push   %ebx
c002af8b:	83 ec 08             	sub    $0x8,%esp
c002af8e:	e8 f2 3a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002af93:	81 c3 21 ff 00 00    	add    $0xff21,%ebx
c002af99:	8b 54 24 10          	mov    0x10(%esp),%edx
c002af9d:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (buf != NULL);
c002afa1:	85 d2                	test   %edx,%edx
c002afa3:	74 24                	je     c002afc9 <hash_bytes+0x3f>
c002afa5:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx
  hash = FNV_32_BASIS;
c002afa8:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (size-- > 0)
c002afad:	85 c9                	test   %ecx,%ecx
c002afaf:	74 13                	je     c002afc4 <hash_bytes+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002afb1:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002afb7:	83 c2 01             	add    $0x1,%edx
c002afba:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c002afbe:	31 c8                	xor    %ecx,%eax
  while (size-- > 0)
c002afc0:	39 da                	cmp    %ebx,%edx
c002afc2:	75 ed                	jne    c002afb1 <hash_bytes+0x27>
} 
c002afc4:	83 c4 08             	add    $0x8,%esp
c002afc7:	5b                   	pop    %ebx
c002afc8:	c3                   	ret    
  ASSERT (buf != NULL);
c002afc9:	83 ec 0c             	sub    $0xc,%esp
c002afcc:	8d 83 ff 6c ff ff    	lea    -0x9301(%ebx),%eax
c002afd2:	50                   	push   %eax
c002afd3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002afd9:	50                   	push   %eax
c002afda:	8d 83 bc 4a ff ff    	lea    -0xb544(%ebx),%eax
c002afe0:	50                   	push   %eax
c002afe1:	68 10 01 00 00       	push   $0x110
c002afe6:	8d 83 ce 6c ff ff    	lea    -0x9332(%ebx),%eax
c002afec:	50                   	push   %eax
c002afed:	e8 95 e2 ff ff       	call   c0029287 <debug_panic>

c002aff2 <hash_string>:
{
c002aff2:	56                   	push   %esi
c002aff3:	53                   	push   %ebx
c002aff4:	83 ec 04             	sub    $0x4,%esp
c002aff7:	e8 89 3a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002affc:	81 c3 b8 fe 00 00    	add    $0xfeb8,%ebx
c002b002:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT (s != NULL);
c002b006:	85 f6                	test   %esi,%esi
c002b008:	74 27                	je     c002b031 <hash_string+0x3f>
  while (*s != '\0')
c002b00a:	0f b6 16             	movzbl (%esi),%edx
  hash = FNV_32_BASIS;
c002b00d:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (*s != '\0')
c002b012:	84 d2                	test   %dl,%dl
c002b014:	74 15                	je     c002b02b <hash_string+0x39>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b016:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b01c:	83 c6 01             	add    $0x1,%esi
c002b01f:	0f b6 c2             	movzbl %dl,%eax
c002b022:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c002b024:	0f b6 16             	movzbl (%esi),%edx
c002b027:	84 d2                	test   %dl,%dl
c002b029:	75 eb                	jne    c002b016 <hash_string+0x24>
}
c002b02b:	83 c4 04             	add    $0x4,%esp
c002b02e:	5b                   	pop    %ebx
c002b02f:	5e                   	pop    %esi
c002b030:	c3                   	ret    
  ASSERT (s != NULL);
c002b031:	83 ec 0c             	sub    $0xc,%esp
c002b034:	8d 93 8b 68 ff ff    	lea    -0x9775(%ebx),%edx
c002b03a:	52                   	push   %edx
c002b03b:	8d 93 45 4e ff ff    	lea    -0xb1bb(%ebx),%edx
c002b041:	52                   	push   %edx
c002b042:	8d 93 b0 4a ff ff    	lea    -0xb550(%ebx),%edx
c002b048:	52                   	push   %edx
c002b049:	68 20 01 00 00       	push   $0x120
c002b04e:	8d 93 ce 6c ff ff    	lea    -0x9332(%ebx),%edx
c002b054:	52                   	push   %edx
c002b055:	e8 2d e2 ff ff       	call   c0029287 <debug_panic>

c002b05a <hash_int>:
{
c002b05a:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c002b05d:	6a 04                	push   $0x4
c002b05f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002b063:	50                   	push   %eax
c002b064:	e8 21 ff ff ff       	call   c002af8a <hash_bytes>
}
c002b069:	83 c4 1c             	add    $0x1c,%esp
c002b06c:	c3                   	ret    

c002b06d <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002b06d:	56                   	push   %esi
c002b06e:	53                   	push   %ebx
c002b06f:	83 ec 04             	sub    $0x4,%esp
c002b072:	e8 0e 3a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b077:	81 c3 3d fe 00 00    	add    $0xfe3d,%ebx
c002b07d:	89 c6                	mov    %eax,%esi
  return (intr_context ()
c002b07f:	e8 4f 70 ff ff       	call   c00220d3 <intr_context>
          || lock_held_by_current_thread (&console_lock));
c002b084:	84 c0                	test   %al,%al
c002b086:	75 09                	jne    c002b091 <putchar_have_lock+0x24>
          || !use_console_lock
c002b088:	80 bb 98 22 00 00 00 	cmpb   $0x0,0x2298(%ebx)
c002b08f:	75 2a                	jne    c002b0bb <putchar_have_lock+0x4e>
  ASSERT (console_locked_by_current_thread ());
  write_cnt++;
c002b091:	83 83 8c 22 00 00 01 	addl   $0x1,0x228c(%ebx)
c002b098:	83 93 90 22 00 00 00 	adcl   $0x0,0x2290(%ebx)
  serial_putc (c);
c002b09f:	89 f0                	mov    %esi,%eax
c002b0a1:	0f b6 f0             	movzbl %al,%esi
c002b0a4:	83 ec 0c             	sub    $0xc,%esp
c002b0a7:	56                   	push   %esi
c002b0a8:	e8 2a 9f ff ff       	call   c0024fd7 <serial_putc>
  vga_putc (c);
c002b0ad:	89 34 24             	mov    %esi,(%esp)
c002b0b0:	e8 f0 9a ff ff       	call   c0024ba5 <vga_putc>
}
c002b0b5:	83 c4 14             	add    $0x14,%esp
c002b0b8:	5b                   	pop    %ebx
c002b0b9:	5e                   	pop    %esi
c002b0ba:	c3                   	ret    
          || lock_held_by_current_thread (&console_lock));
c002b0bb:	83 ec 0c             	sub    $0xc,%esp
c002b0be:	8d 83 ac 22 00 00    	lea    0x22ac(%ebx),%eax
c002b0c4:	50                   	push   %eax
c002b0c5:	e8 09 82 ff ff       	call   c00232d3 <lock_held_by_current_thread>
  ASSERT (console_locked_by_current_thread ());
c002b0ca:	83 c4 10             	add    $0x10,%esp
c002b0cd:	84 c0                	test   %al,%al
c002b0cf:	75 c0                	jne    c002b091 <putchar_have_lock+0x24>
c002b0d1:	83 ec 0c             	sub    $0xc,%esp
c002b0d4:	8d 83 0c 6d ff ff    	lea    -0x92f4(%ebx),%eax
c002b0da:	50                   	push   %eax
c002b0db:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002b0e1:	50                   	push   %eax
c002b0e2:	8d 83 f4 4a ff ff    	lea    -0xb50c(%ebx),%eax
c002b0e8:	50                   	push   %eax
c002b0e9:	68 bb 00 00 00       	push   $0xbb
c002b0ee:	8d 83 51 6d ff ff    	lea    -0x92af(%ebx),%eax
c002b0f4:	50                   	push   %eax
c002b0f5:	e8 8d e1 ff ff       	call   c0029287 <debug_panic>

c002b0fa <vprintf_helper>:
{
c002b0fa:	83 ec 0c             	sub    $0xc,%esp
c002b0fd:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002b101:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock (c);
c002b104:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002b109:	e8 5f ff ff ff       	call   c002b06d <putchar_have_lock>
}
c002b10e:	83 c4 0c             	add    $0xc,%esp
c002b111:	c3                   	ret    

c002b112 <acquire_console>:
{
c002b112:	53                   	push   %ebx
c002b113:	83 ec 08             	sub    $0x8,%esp
c002b116:	e8 6a 39 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b11b:	81 c3 99 fd 00 00    	add    $0xfd99,%ebx
  if (!intr_context () && use_console_lock) 
c002b121:	e8 ad 6f ff ff       	call   c00220d3 <intr_context>
c002b126:	84 c0                	test   %al,%al
c002b128:	75 09                	jne    c002b133 <acquire_console+0x21>
c002b12a:	80 bb 98 22 00 00 00 	cmpb   $0x0,0x2298(%ebx)
c002b131:	75 05                	jne    c002b138 <acquire_console+0x26>
}
c002b133:	83 c4 08             	add    $0x8,%esp
c002b136:	5b                   	pop    %ebx
c002b137:	c3                   	ret    
      if (lock_held_by_current_thread (&console_lock)) 
c002b138:	83 ec 0c             	sub    $0xc,%esp
c002b13b:	8d 83 ac 22 00 00    	lea    0x22ac(%ebx),%eax
c002b141:	50                   	push   %eax
c002b142:	e8 8c 81 ff ff       	call   c00232d3 <lock_held_by_current_thread>
c002b147:	83 c4 10             	add    $0x10,%esp
c002b14a:	84 c0                	test   %al,%al
c002b14c:	74 09                	je     c002b157 <acquire_console+0x45>
        console_lock_depth++; 
c002b14e:	83 83 94 22 00 00 01 	addl   $0x1,0x2294(%ebx)
c002b155:	eb dc                	jmp    c002b133 <acquire_console+0x21>
        lock_acquire (&console_lock); 
c002b157:	83 ec 0c             	sub    $0xc,%esp
c002b15a:	8d 83 ac 22 00 00    	lea    0x22ac(%ebx),%eax
c002b160:	50                   	push   %eax
c002b161:	e8 c0 81 ff ff       	call   c0023326 <lock_acquire>
c002b166:	83 c4 10             	add    $0x10,%esp
}
c002b169:	eb c8                	jmp    c002b133 <acquire_console+0x21>

c002b16b <release_console>:
{
c002b16b:	53                   	push   %ebx
c002b16c:	83 ec 08             	sub    $0x8,%esp
c002b16f:	e8 11 39 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b174:	81 c3 40 fd 00 00    	add    $0xfd40,%ebx
  if (!intr_context () && use_console_lock) 
c002b17a:	e8 54 6f ff ff       	call   c00220d3 <intr_context>
c002b17f:	84 c0                	test   %al,%al
c002b181:	75 1c                	jne    c002b19f <release_console+0x34>
c002b183:	80 bb 98 22 00 00 00 	cmpb   $0x0,0x2298(%ebx)
c002b18a:	74 13                	je     c002b19f <release_console+0x34>
      if (console_lock_depth > 0)
c002b18c:	8b 83 94 22 00 00    	mov    0x2294(%ebx),%eax
c002b192:	85 c0                	test   %eax,%eax
c002b194:	7e 0e                	jle    c002b1a4 <release_console+0x39>
        console_lock_depth--;
c002b196:	83 e8 01             	sub    $0x1,%eax
c002b199:	89 83 94 22 00 00    	mov    %eax,0x2294(%ebx)
}
c002b19f:	83 c4 08             	add    $0x8,%esp
c002b1a2:	5b                   	pop    %ebx
c002b1a3:	c3                   	ret    
        lock_release (&console_lock); 
c002b1a4:	83 ec 0c             	sub    $0xc,%esp
c002b1a7:	8d 83 ac 22 00 00    	lea    0x22ac(%ebx),%eax
c002b1ad:	50                   	push   %eax
c002b1ae:	e8 6b 83 ff ff       	call   c002351e <lock_release>
c002b1b3:	83 c4 10             	add    $0x10,%esp
}
c002b1b6:	eb e7                	jmp    c002b19f <release_console+0x34>

c002b1b8 <console_init>:
{
c002b1b8:	53                   	push   %ebx
c002b1b9:	83 ec 14             	sub    $0x14,%esp
c002b1bc:	e8 c4 38 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b1c1:	81 c3 f3 fc 00 00    	add    $0xfcf3,%ebx
  lock_init (&console_lock);
c002b1c7:	8d 83 ac 22 00 00    	lea    0x22ac(%ebx),%eax
c002b1cd:	50                   	push   %eax
c002b1ce:	e8 a7 80 ff ff       	call   c002327a <lock_init>
  use_console_lock = true;
c002b1d3:	c6 83 98 22 00 00 01 	movb   $0x1,0x2298(%ebx)
}
c002b1da:	83 c4 18             	add    $0x18,%esp
c002b1dd:	5b                   	pop    %ebx
c002b1de:	c3                   	ret    

c002b1df <console_panic>:
{
c002b1df:	e8 a5 38 00 00       	call   c002ea89 <__x86.get_pc_thunk.ax>
c002b1e4:	05 d0 fc 00 00       	add    $0xfcd0,%eax
  use_console_lock = false;
c002b1e9:	c6 80 98 22 00 00 00 	movb   $0x0,0x2298(%eax)
}
c002b1f0:	c3                   	ret    

c002b1f1 <console_print_stats>:
{
c002b1f1:	53                   	push   %ebx
c002b1f2:	83 ec 0c             	sub    $0xc,%esp
c002b1f5:	e8 8b 38 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b1fa:	81 c3 ba fc 00 00    	add    $0xfcba,%ebx
  printf ("Console: %lld characters output\n", write_cnt);
c002b200:	ff b3 90 22 00 00    	pushl  0x2290(%ebx)
c002b206:	ff b3 8c 22 00 00    	pushl  0x228c(%ebx)
c002b20c:	8d 83 30 6d ff ff    	lea    -0x92d0(%ebx),%eax
c002b212:	50                   	push   %eax
c002b213:	e8 d8 c2 ff ff       	call   c00274f0 <printf>
}
c002b218:	83 c4 18             	add    $0x18,%esp
c002b21b:	5b                   	pop    %ebx
c002b21c:	c3                   	ret    

c002b21d <vprintf>:
{
c002b21d:	53                   	push   %ebx
c002b21e:	83 ec 18             	sub    $0x18,%esp
c002b221:	e8 5f 38 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b226:	81 c3 8e fc 00 00    	add    $0xfc8e,%ebx
  int char_cnt = 0;
c002b22c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b233:	00 
  acquire_console ();
c002b234:	e8 d9 fe ff ff       	call   c002b112 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b239:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002b23d:	50                   	push   %eax
c002b23e:	8d 83 46 02 ff ff    	lea    -0xfdba(%ebx),%eax
c002b244:	50                   	push   %eax
c002b245:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b249:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b24d:	e8 e0 c2 ff ff       	call   c0027532 <__vprintf>
  release_console ();
c002b252:	e8 14 ff ff ff       	call   c002b16b <release_console>
}
c002b257:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b25b:	83 c4 28             	add    $0x28,%esp
c002b25e:	5b                   	pop    %ebx
c002b25f:	c3                   	ret    

c002b260 <puts>:
{
c002b260:	53                   	push   %ebx
c002b261:	83 ec 08             	sub    $0x8,%esp
c002b264:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002b268:	e8 a5 fe ff ff       	call   c002b112 <acquire_console>
  while (*s != '\0')
c002b26d:	0f b6 03             	movzbl (%ebx),%eax
c002b270:	84 c0                	test   %al,%al
c002b272:	74 12                	je     c002b286 <puts+0x26>
    putchar_have_lock (*s++);
c002b274:	83 c3 01             	add    $0x1,%ebx
c002b277:	0f b6 c0             	movzbl %al,%eax
c002b27a:	e8 ee fd ff ff       	call   c002b06d <putchar_have_lock>
  while (*s != '\0')
c002b27f:	0f b6 03             	movzbl (%ebx),%eax
c002b282:	84 c0                	test   %al,%al
c002b284:	75 ee                	jne    c002b274 <puts+0x14>
  putchar_have_lock ('\n');
c002b286:	b8 0a 00 00 00       	mov    $0xa,%eax
c002b28b:	e8 dd fd ff ff       	call   c002b06d <putchar_have_lock>
  release_console ();
c002b290:	e8 d6 fe ff ff       	call   c002b16b <release_console>
}
c002b295:	b8 00 00 00 00       	mov    $0x0,%eax
c002b29a:	83 c4 08             	add    $0x8,%esp
c002b29d:	5b                   	pop    %ebx
c002b29e:	c3                   	ret    

c002b29f <putbuf>:
{
c002b29f:	56                   	push   %esi
c002b2a0:	53                   	push   %ebx
c002b2a1:	83 ec 04             	sub    $0x4,%esp
c002b2a4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002b2a8:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console ();
c002b2ac:	e8 61 fe ff ff       	call   c002b112 <acquire_console>
  while (n-- > 0)
c002b2b1:	85 f6                	test   %esi,%esi
c002b2b3:	74 12                	je     c002b2c7 <putbuf+0x28>
c002b2b5:	01 de                	add    %ebx,%esi
    putchar_have_lock (*buffer++);
c002b2b7:	83 c3 01             	add    $0x1,%ebx
c002b2ba:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002b2be:	e8 aa fd ff ff       	call   c002b06d <putchar_have_lock>
  while (n-- > 0)
c002b2c3:	39 de                	cmp    %ebx,%esi
c002b2c5:	75 f0                	jne    c002b2b7 <putbuf+0x18>
  release_console ();
c002b2c7:	e8 9f fe ff ff       	call   c002b16b <release_console>
}
c002b2cc:	83 c4 04             	add    $0x4,%esp
c002b2cf:	5b                   	pop    %ebx
c002b2d0:	5e                   	pop    %esi
c002b2d1:	c3                   	ret    

c002b2d2 <putchar>:
{
c002b2d2:	53                   	push   %ebx
c002b2d3:	83 ec 08             	sub    $0x8,%esp
c002b2d6:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002b2da:	e8 33 fe ff ff       	call   c002b112 <acquire_console>
  putchar_have_lock (c);
c002b2df:	0f b6 c3             	movzbl %bl,%eax
c002b2e2:	e8 86 fd ff ff       	call   c002b06d <putchar_have_lock>
  release_console ();
c002b2e7:	e8 7f fe ff ff       	call   c002b16b <release_console>
}
c002b2ec:	89 d8                	mov    %ebx,%eax
c002b2ee:	83 c4 08             	add    $0x8,%esp
c002b2f1:	5b                   	pop    %ebx
c002b2f2:	c3                   	ret    

c002b2f3 <install_page>:
   with palloc_get_page().
   Returns true on success, false if UPAGE is already mapped or
   if memory allocation fails. */
static bool
install_page (void *upage, void *kpage, bool writable)
{
c002b2f3:	55                   	push   %ebp
c002b2f4:	57                   	push   %edi
c002b2f5:	56                   	push   %esi
c002b2f6:	53                   	push   %ebx
c002b2f7:	83 ec 1c             	sub    $0x1c,%esp
c002b2fa:	e8 86 37 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b2ff:	81 c3 b5 fb 00 00    	add    $0xfbb5,%ebx
c002b305:	89 c7                	mov    %eax,%edi
c002b307:	89 d5                	mov    %edx,%ebp
c002b309:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
#ifdef VM
  return page_set_frame(upage, kpage, writable);
#endif

  struct thread *t = thread_current ();
c002b30d:	e8 42 5a ff ff       	call   c0020d54 <thread_current>
c002b312:	89 c6                	mov    %eax,%esi

  /* Verify that there's not already a page at that virtual
     address, then map our page there. */
  return (pagedir_get_page (t->pagedir, upage) == NULL
c002b314:	83 ec 08             	sub    $0x8,%esp
c002b317:	57                   	push   %edi
c002b318:	ff b0 a0 00 00 00    	pushl  0xa0(%eax)
c002b31e:	e8 4c 0d 00 00       	call   c002c06f <pagedir_get_page>
          && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002b323:	83 c4 10             	add    $0x10,%esp
c002b326:	85 c0                	test   %eax,%eax
c002b328:	74 10                	je     c002b33a <install_page+0x47>
c002b32a:	b8 00 00 00 00       	mov    $0x0,%eax
c002b32f:	83 e0 01             	and    $0x1,%eax
}
c002b332:	83 c4 1c             	add    $0x1c,%esp
c002b335:	5b                   	pop    %ebx
c002b336:	5e                   	pop    %esi
c002b337:	5f                   	pop    %edi
c002b338:	5d                   	pop    %ebp
c002b339:	c3                   	ret    
          && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002b33a:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c002b33f:	50                   	push   %eax
c002b340:	55                   	push   %ebp
c002b341:	57                   	push   %edi
c002b342:	ff b6 a0 00 00 00    	pushl  0xa0(%esi)
c002b348:	e8 5a 0b 00 00       	call   c002bea7 <pagedir_set_page>
c002b34d:	0f b6 c0             	movzbl %al,%eax
c002b350:	83 c4 10             	add    $0x10,%esp
c002b353:	eb da                	jmp    c002b32f <install_page+0x3c>

c002b355 <process_execute>:
{
c002b355:	55                   	push   %ebp
c002b356:	57                   	push   %edi
c002b357:	56                   	push   %esi
c002b358:	53                   	push   %ebx
c002b359:	83 ec 28             	sub    $0x28,%esp
c002b35c:	e8 24 37 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b361:	81 c3 53 fb 00 00    	add    $0xfb53,%ebx
  file_name = palloc_get_page(0);
c002b367:	6a 00                	push   $0x0
c002b369:	e8 a4 87 ff ff       	call   c0023b12 <palloc_get_page>
c002b36e:	89 c6                	mov    %eax,%esi
  strlcpy (file_name, file_name_, PGSIZE);
c002b370:	83 c4 0c             	add    $0xc,%esp
c002b373:	68 00 10 00 00       	push   $0x1000
c002b378:	ff 74 24 38          	pushl  0x38(%esp)
c002b37c:	50                   	push   %eax
c002b37d:	e8 5a d5 ff ff       	call   c00288dc <strlcpy>
  fn_copy = palloc_get_page (0);
c002b382:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b389:	e8 84 87 ff ff       	call   c0023b12 <palloc_get_page>
  if (fn_copy == NULL)
c002b38e:	83 c4 10             	add    $0x10,%esp
c002b391:	85 c0                	test   %eax,%eax
c002b393:	0f 84 83 00 00 00    	je     c002b41c <process_execute+0xc7>
c002b399:	89 c7                	mov    %eax,%edi
  strlcpy (fn_copy, file_name, PGSIZE);
c002b39b:	83 ec 04             	sub    $0x4,%esp
c002b39e:	68 00 10 00 00       	push   $0x1000
c002b3a3:	56                   	push   %esi
c002b3a4:	50                   	push   %eax
c002b3a5:	e8 32 d5 ff ff       	call   c00288dc <strlcpy>
  thread_name = strtok_r (file_name, " ", &saveptr);
c002b3aa:	83 c4 0c             	add    $0xc,%esp
c002b3ad:	8d 44 24 10          	lea    0x10(%esp),%eax
c002b3b1:	50                   	push   %eax
c002b3b2:	8d 83 da 67 ff ff    	lea    -0x9826(%ebx),%eax
c002b3b8:	50                   	push   %eax
c002b3b9:	56                   	push   %esi
c002b3ba:	e8 13 d3 ff ff       	call   c00286d2 <strtok_r>
  tid = thread_create (thread_name, PRI_DEFAULT, start_process, fn_copy);
c002b3bf:	57                   	push   %edi
c002b3c0:	8d 93 05 07 ff ff    	lea    -0xf8fb(%ebx),%edx
c002b3c6:	52                   	push   %edx
c002b3c7:	6a 1f                	push   $0x1f
c002b3c9:	50                   	push   %eax
c002b3ca:	e8 44 60 ff ff       	call   c0021413 <thread_create>
c002b3cf:	89 c5                	mov    %eax,%ebp
  if (tid == TID_ERROR)
c002b3d1:	83 c4 20             	add    $0x20,%esp
c002b3d4:	83 f8 ff             	cmp    $0xffffffff,%eax
c002b3d7:	74 35                	je     c002b40e <process_execute+0xb9>
  palloc_free_page(file_name);
c002b3d9:	83 ec 0c             	sub    $0xc,%esp
c002b3dc:	56                   	push   %esi
c002b3dd:	e8 9e 88 ff ff       	call   c0023c80 <palloc_free_page>
                  &thread_get_child_message (tid)->elem);
c002b3e2:	89 2c 24             	mov    %ebp,(%esp)
c002b3e5:	e8 17 67 ff ff       	call   c0021b01 <thread_get_child_message>
c002b3ea:	89 c6                	mov    %eax,%esi
  list_push_back (&thread_current ()->child_list,
c002b3ec:	e8 63 59 ff ff       	call   c0020d54 <thread_current>
c002b3f1:	83 c4 08             	add    $0x8,%esp
c002b3f4:	83 c6 18             	add    $0x18,%esi
c002b3f7:	56                   	push   %esi
c002b3f8:	83 c0 60             	add    $0x60,%eax
c002b3fb:	50                   	push   %eax
c002b3fc:	e8 39 e5 ff ff       	call   c002993a <list_push_back>
  return tid;
c002b401:	83 c4 10             	add    $0x10,%esp
}
c002b404:	89 e8                	mov    %ebp,%eax
c002b406:	83 c4 1c             	add    $0x1c,%esp
c002b409:	5b                   	pop    %ebx
c002b40a:	5e                   	pop    %esi
c002b40b:	5f                   	pop    %edi
c002b40c:	5d                   	pop    %ebp
c002b40d:	c3                   	ret    
    palloc_free_page (fn_copy);
c002b40e:	83 ec 0c             	sub    $0xc,%esp
c002b411:	57                   	push   %edi
c002b412:	e8 69 88 ff ff       	call   c0023c80 <palloc_free_page>
c002b417:	83 c4 10             	add    $0x10,%esp
c002b41a:	eb bd                	jmp    c002b3d9 <process_execute+0x84>
    return TID_ERROR;
c002b41c:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b421:	eb e1                	jmp    c002b404 <process_execute+0xaf>

c002b423 <process_wait>:
{
c002b423:	55                   	push   %ebp
c002b424:	57                   	push   %edi
c002b425:	56                   	push   %esi
c002b426:	53                   	push   %ebx
c002b427:	83 ec 0c             	sub    $0xc,%esp
c002b42a:	e8 56 36 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b42f:	81 c3 85 fa 00 00    	add    $0xfa85,%ebx
c002b435:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  struct thread *cur = thread_current ();
c002b439:	e8 16 59 ff ff       	call   c0020d54 <thread_current>
  for (e = list_begin (&cur->child_list); e != list_end (&cur->child_list); e = list_next (e))
c002b43e:	8d 78 60             	lea    0x60(%eax),%edi
c002b441:	83 ec 0c             	sub    $0xc,%esp
c002b444:	57                   	push   %edi
c002b445:	e8 62 df ff ff       	call   c00293ac <list_begin>
c002b44a:	89 c6                	mov    %eax,%esi
c002b44c:	83 c4 10             	add    $0x10,%esp
c002b44f:	83 ec 0c             	sub    $0xc,%esp
c002b452:	57                   	push   %edi
c002b453:	e8 f6 df ff ff       	call   c002944e <list_end>
c002b458:	83 c4 10             	add    $0x10,%esp
c002b45b:	39 f0                	cmp    %esi,%eax
c002b45d:	74 5d                	je     c002b4bc <process_wait+0x99>
    if (l->tid == child_tid)
c002b45f:	39 6e ec             	cmp    %ebp,-0x14(%esi)
c002b462:	74 10                	je     c002b474 <process_wait+0x51>
  for (e = list_begin (&cur->child_list); e != list_end (&cur->child_list); e = list_next (e))
c002b464:	83 ec 0c             	sub    $0xc,%esp
c002b467:	56                   	push   %esi
c002b468:	e8 84 df ff ff       	call   c00293f1 <list_next>
c002b46d:	89 c6                	mov    %eax,%esi
c002b46f:	83 c4 10             	add    $0x10,%esp
c002b472:	eb db                	jmp    c002b44f <process_wait+0x2c>
      if (!l->terminated) sema_down (l->sema_finished);
c002b474:	80 7e f1 00          	cmpb   $0x0,-0xf(%esi)
c002b478:	74 32                	je     c002b4ac <process_wait+0x89>
      int ret = l->exited ? l->return_value : -1;
c002b47a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002b47f:	80 7e f0 00          	cmpb   $0x0,-0x10(%esi)
c002b483:	74 03                	je     c002b488 <process_wait+0x65>
c002b485:	8b 7e f4             	mov    -0xc(%esi),%edi
      list_remove (e);
c002b488:	83 ec 0c             	sub    $0xc,%esp
c002b48b:	56                   	push   %esi
c002b48c:	e8 c6 e4 ff ff       	call   c0029957 <list_remove>
      list_remove (&l->allelem);
c002b491:	8d 6e e8             	lea    -0x18(%esi),%ebp
c002b494:	83 c6 08             	add    $0x8,%esi
c002b497:	89 34 24             	mov    %esi,(%esp)
c002b49a:	e8 b8 e4 ff ff       	call   c0029957 <list_remove>
      palloc_free_page (l);
c002b49f:	89 2c 24             	mov    %ebp,(%esp)
c002b4a2:	e8 d9 87 ff ff       	call   c0023c80 <palloc_free_page>
      return ret;
c002b4a7:	83 c4 10             	add    $0x10,%esp
c002b4aa:	eb 15                	jmp    c002b4c1 <process_wait+0x9e>
      if (!l->terminated) sema_down (l->sema_finished);
c002b4ac:	83 ec 0c             	sub    $0xc,%esp
c002b4af:	ff 76 f8             	pushl  -0x8(%esi)
c002b4b2:	e8 41 7b ff ff       	call   c0022ff8 <sema_down>
c002b4b7:	83 c4 10             	add    $0x10,%esp
c002b4ba:	eb be                	jmp    c002b47a <process_wait+0x57>
  return -1;
c002b4bc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
c002b4c1:	89 f8                	mov    %edi,%eax
c002b4c3:	83 c4 0c             	add    $0xc,%esp
c002b4c6:	5b                   	pop    %ebx
c002b4c7:	5e                   	pop    %esi
c002b4c8:	5f                   	pop    %edi
c002b4c9:	5d                   	pop    %ebp
c002b4ca:	c3                   	ret    

c002b4cb <process_exit>:
{
c002b4cb:	55                   	push   %ebp
c002b4cc:	57                   	push   %edi
c002b4cd:	56                   	push   %esi
c002b4ce:	53                   	push   %ebx
c002b4cf:	83 ec 1c             	sub    $0x1c,%esp
c002b4d2:	e8 ae 35 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b4d7:	81 c3 dd f9 00 00    	add    $0xf9dd,%ebx
  struct thread *cur = thread_current ();
c002b4dd:	e8 72 58 ff ff       	call   c0020d54 <thread_current>
c002b4e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  while (!list_empty (&cur->child_list))
c002b4e6:	8d 78 60             	lea    0x60(%eax),%edi
c002b4e9:	eb 2e                	jmp    c002b519 <process_exit+0x4e>
    l = list_entry (list_pop_front (&cur->child_list), struct child_message, elem);
c002b4eb:	83 ec 0c             	sub    $0xc,%esp
c002b4ee:	57                   	push   %edi
c002b4ef:	e8 7c e5 ff ff       	call   c0029a70 <list_pop_front>
c002b4f4:	89 c6                	mov    %eax,%esi
    list_remove (&l->allelem);
c002b4f6:	8d 68 e8             	lea    -0x18(%eax),%ebp
c002b4f9:	8d 40 08             	lea    0x8(%eax),%eax
c002b4fc:	89 04 24             	mov    %eax,(%esp)
c002b4ff:	e8 53 e4 ff ff       	call   c0029957 <list_remove>
    l->tchild->grandpa_died = true;
c002b504:	8b 46 e8             	mov    -0x18(%esi),%eax
c002b507:	c6 80 98 00 00 00 01 	movb   $0x1,0x98(%eax)
    palloc_free_page (l);
c002b50e:	89 2c 24             	mov    %ebp,(%esp)
c002b511:	e8 6a 87 ff ff       	call   c0023c80 <palloc_free_page>
c002b516:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cur->child_list))
c002b519:	83 ec 0c             	sub    $0xc,%esp
c002b51c:	57                   	push   %edi
c002b51d:	e8 d7 e4 ff ff       	call   c00299f9 <list_empty>
c002b522:	83 c4 10             	add    $0x10,%esp
c002b525:	84 c0                	test   %al,%al
c002b527:	74 c2                	je     c002b4eb <process_exit+0x20>
  pd = cur->pagedir;
c002b529:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002b52d:	8b b7 a0 00 00 00    	mov    0xa0(%edi),%esi
  if (pd != NULL)
c002b533:	85 f6                	test   %esi,%esi
c002b535:	74 37                	je     c002b56e <process_exit+0xa3>
    cur->pagedir = NULL;
c002b537:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
c002b53e:	00 00 00 
    pagedir_activate (NULL);
c002b541:	83 ec 0c             	sub    $0xc,%esp
c002b544:	6a 00                	push   $0x0
c002b546:	e8 70 0c 00 00       	call   c002c1bb <pagedir_activate>
    pagedir_destroy (pd);
c002b54b:	89 34 24             	mov    %esi,(%esp)
c002b54e:	e8 0b 08 00 00       	call   c002bd5e <pagedir_destroy>
    printf ("%s: exit(%d)\n", cur->name, cur->return_value);
c002b553:	83 c4 0c             	add    $0xc,%esp
c002b556:	89 f8                	mov    %edi,%eax
c002b558:	ff 77 5c             	pushl  0x5c(%edi)
c002b55b:	83 c0 08             	add    $0x8,%eax
c002b55e:	50                   	push   %eax
c002b55f:	8d 83 6c 6d ff ff    	lea    -0x9294(%ebx),%eax
c002b565:	50                   	push   %eax
c002b566:	e8 85 bf ff ff       	call   c00274f0 <printf>
c002b56b:	83 c4 10             	add    $0x10,%esp
  if (!cur->grandpa_died)
c002b56e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b572:	80 b8 98 00 00 00 00 	cmpb   $0x0,0x98(%eax)
c002b579:	75 0a                	jne    c002b585 <process_exit+0xba>
    cur->message_to_grandpa->terminated = true;
c002b57b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
c002b581:	c6 40 09 01          	movb   $0x1,0x9(%eax)
}
c002b585:	83 c4 1c             	add    $0x1c,%esp
c002b588:	5b                   	pop    %ebx
c002b589:	5e                   	pop    %esi
c002b58a:	5f                   	pop    %edi
c002b58b:	5d                   	pop    %ebp
c002b58c:	c3                   	ret    

c002b58d <process_activate>:
{
c002b58d:	53                   	push   %ebx
c002b58e:	83 ec 08             	sub    $0x8,%esp
c002b591:	e8 ef 34 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b596:	81 c3 1e f9 00 00    	add    $0xf91e,%ebx
  struct thread *t = thread_current ();
c002b59c:	e8 b3 57 ff ff       	call   c0020d54 <thread_current>
  pagedir_activate (t->pagedir);
c002b5a1:	83 ec 0c             	sub    $0xc,%esp
c002b5a4:	ff b0 a0 00 00 00    	pushl  0xa0(%eax)
c002b5aa:	e8 0c 0c 00 00       	call   c002c1bb <pagedir_activate>
  tss_update ();
c002b5af:	e8 5d 19 00 00       	call   c002cf11 <tss_update>
}
c002b5b4:	83 c4 18             	add    $0x18,%esp
c002b5b7:	5b                   	pop    %ebx
c002b5b8:	c3                   	ret    

c002b5b9 <start_process>:
{
c002b5b9:	55                   	push   %ebp
c002b5ba:	57                   	push   %edi
c002b5bb:	56                   	push   %esi
c002b5bc:	53                   	push   %ebx
c002b5bd:	81 ec 40 01 00 00    	sub    $0x140,%esp
c002b5c3:	e8 bd 34 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002b5c8:	81 c3 ec f8 00 00    	add    $0xf8ec,%ebx
  name_tmp = strtok_r (file_name, " ", &saveptr);
c002b5ce:	8d 84 24 e0 00 00 00 	lea    0xe0(%esp),%eax
c002b5d5:	50                   	push   %eax
c002b5d6:	8d 83 da 67 ff ff    	lea    -0x9826(%ebx),%eax
c002b5dc:	50                   	push   %eax
c002b5dd:	ff b4 24 5c 01 00 00 	pushl  0x15c(%esp)
c002b5e4:	e8 e9 d0 ff ff       	call   c00286d2 <strtok_r>
c002b5e9:	89 c5                	mov    %eax,%ebp
  memset (&if_, 0, sizeof if_);
c002b5eb:	8d 94 24 f0 00 00 00 	lea    0xf0(%esp),%edx
c002b5f2:	b9 14 00 00 00       	mov    $0x14,%ecx
c002b5f7:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5fc:	89 d7                	mov    %edx,%edi
c002b5fe:	f3 ab                	rep stos %eax,%es:(%edi)
  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002b600:	66 c7 84 24 3c 01 00 	movw   $0x23,0x13c(%esp)
c002b607:	00 23 00 
c002b60a:	66 c7 84 24 1c 01 00 	movw   $0x23,0x11c(%esp)
c002b611:	00 23 00 
c002b614:	66 c7 84 24 18 01 00 	movw   $0x23,0x118(%esp)
c002b61b:	00 23 00 
c002b61e:	66 c7 84 24 14 01 00 	movw   $0x23,0x114(%esp)
c002b625:	00 23 00 
c002b628:	66 c7 84 24 10 01 00 	movw   $0x23,0x110(%esp)
c002b62f:	00 23 00 
  if_.cs = SEL_UCSEG;
c002b632:	66 c7 84 24 30 01 00 	movw   $0x1b,0x130(%esp)
c002b639:	00 1b 00 
  if_.eflags = FLAG_IF | FLAG_MBS;
c002b63c:	c7 84 24 34 01 00 00 	movl   $0x202,0x134(%esp)
c002b643:	02 02 00 00 
  struct thread *t = thread_current ();
c002b647:	e8 08 57 ff ff       	call   c0020d54 <thread_current>
c002b64c:	89 c6                	mov    %eax,%esi
  t->pagedir = pagedir_create ();
c002b64e:	e8 b9 06 00 00       	call   c002bd0c <pagedir_create>
c002b653:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
  if (t->pagedir == NULL)
c002b659:	83 c4 10             	add    $0x10,%esp
c002b65c:	85 c0                	test   %eax,%eax
c002b65e:	74 71                	je     c002b6d1 <start_process+0x118>
  process_activate ();
c002b660:	e8 28 ff ff ff       	call   c002b58d <process_activate>
  file = filesys_open (file_name);
c002b665:	83 ec 0c             	sub    $0xc,%esp
c002b668:	55                   	push   %ebp
c002b669:	e8 9d 1a 00 00       	call   c002d10b <filesys_open>
c002b66e:	89 c7                	mov    %eax,%edi
  if (file == NULL)
c002b670:	83 c4 10             	add    $0x10,%esp
c002b673:	85 c0                	test   %eax,%eax
c002b675:	0f 84 ad 00 00 00    	je     c002b728 <start_process+0x16f>
  if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
c002b67b:	83 ec 04             	sub    $0x4,%esp
c002b67e:	6a 34                	push   $0x34
c002b680:	8d 44 24 64          	lea    0x64(%esp),%eax
c002b684:	50                   	push   %eax
c002b685:	57                   	push   %edi
c002b686:	e8 56 1e 00 00       	call   c002d4e1 <file_read>
c002b68b:	83 c4 10             	add    $0x10,%esp
c002b68e:	83 f8 34             	cmp    $0x34,%eax
c002b691:	75 2b                	jne    c002b6be <start_process+0x105>
      || memcmp (ehdr.e_ident, "\177ELF\1\1\1", 7)
c002b693:	83 ec 04             	sub    $0x4,%esp
c002b696:	6a 07                	push   $0x7
c002b698:	8d 83 91 6d ff ff    	lea    -0x926f(%ebx),%eax
c002b69e:	50                   	push   %eax
c002b69f:	8d 44 24 68          	lea    0x68(%esp),%eax
c002b6a3:	50                   	push   %eax
c002b6a4:	e8 51 ce ff ff       	call   c00284fa <memcmp>
c002b6a9:	83 c4 10             	add    $0x10,%esp
c002b6ac:	89 44 24 08          	mov    %eax,0x8(%esp)
c002b6b0:	85 c0                	test   %eax,%eax
c002b6b2:	75 0a                	jne    c002b6be <start_process+0x105>
      || ehdr.e_machine != 3
c002b6b4:	81 7c 24 6c 02 00 03 	cmpl   $0x30002,0x6c(%esp)
c002b6bb:	00 
c002b6bc:	74 7f                	je     c002b73d <start_process+0x184>
    printf ("load: %s: error loading executable\n", file_name);
c002b6be:	83 ec 08             	sub    $0x8,%esp
c002b6c1:	55                   	push   %ebp
c002b6c2:	8d 83 b4 6d ff ff    	lea    -0x924c(%ebx),%eax
c002b6c8:	50                   	push   %eax
c002b6c9:	e8 22 be ff ff       	call   c00274f0 <printf>
c002b6ce:	83 c4 10             	add    $0x10,%esp
    thread_current ()->message_to_grandpa->load_failed = true;
c002b6d1:	e8 7e 56 ff ff       	call   c0020d54 <thread_current>
c002b6d6:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
c002b6dc:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
    thread_current ()->message_to_grandpa->return_value = -1;
c002b6e0:	e8 6f 56 ff ff       	call   c0020d54 <thread_current>
c002b6e5:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
c002b6eb:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
    thread_current ()->return_value = -1;
c002b6f2:	e8 5d 56 ff ff       	call   c0020d54 <thread_current>
c002b6f7:	c7 40 5c ff ff ff ff 	movl   $0xffffffff,0x5c(%eax)
  palloc_free_page (file_name);
c002b6fe:	83 ec 0c             	sub    $0xc,%esp
c002b701:	ff b4 24 5c 01 00 00 	pushl  0x15c(%esp)
c002b708:	e8 73 85 ff ff       	call   c0023c80 <palloc_free_page>
  sema_up (thread_current ()->message_to_grandpa->sema_started);
c002b70d:	e8 42 56 ff ff       	call   c0020d54 <thread_current>
c002b712:	83 c4 04             	add    $0x4,%esp
c002b715:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
c002b71b:	ff 70 14             	pushl  0x14(%eax)
c002b71e:	e8 fd 79 ff ff       	call   c0023120 <sema_up>
    thread_exit ();
c002b723:	e8 b9 5a ff ff       	call   c00211e1 <thread_exit>
    printf ("load: %s: open failed\n", file_name);
c002b728:	83 ec 08             	sub    $0x8,%esp
c002b72b:	55                   	push   %ebp
c002b72c:	8d 83 7a 6d ff ff    	lea    -0x9286(%ebx),%eax
c002b732:	50                   	push   %eax
c002b733:	e8 b8 bd ff ff       	call   c00274f0 <printf>
c002b738:	83 c4 10             	add    $0x10,%esp
c002b73b:	eb 94                	jmp    c002b6d1 <start_process+0x118>
      || ehdr.e_version != 1
c002b73d:	83 7c 24 70 01       	cmpl   $0x1,0x70(%esp)
c002b742:	0f 85 76 ff ff ff    	jne    c002b6be <start_process+0x105>
      || ehdr.e_phentsize != sizeof (struct Elf32_Phdr)
c002b748:	66 83 bc 24 86 00 00 	cmpw   $0x20,0x86(%esp)
c002b74f:	00 20 
c002b751:	0f 85 67 ff ff ff    	jne    c002b6be <start_process+0x105>
      || ehdr.e_phnum > 1024)
c002b757:	66 81 bc 24 88 00 00 	cmpw   $0x400,0x88(%esp)
c002b75e:	00 00 04 
c002b761:	0f 87 57 ff ff ff    	ja     c002b6be <start_process+0x105>
  file_ofs = ehdr.e_phoff;
c002b767:	8b 4c 24 78          	mov    0x78(%esp),%ecx
c002b76b:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  for (i = 0; i < ehdr.e_phnum; i++)
c002b76f:	89 44 24 20          	mov    %eax,0x20(%esp)
c002b773:	89 6c 24 28          	mov    %ebp,0x28(%esp)
c002b777:	89 74 24 2c          	mov    %esi,0x2c(%esp)
c002b77b:	89 7c 24 14          	mov    %edi,0x14(%esp)
c002b77f:	eb 13                	jmp    c002b794 <start_process+0x1db>
    switch (phdr.p_type)
c002b781:	83 f8 05             	cmp    $0x5,%eax
c002b784:	0f 84 47 ff ff ff    	je     c002b6d1 <start_process+0x118>
c002b78a:	83 44 24 24 20       	addl   $0x20,0x24(%esp)
  for (i = 0; i < ehdr.e_phnum; i++)
c002b78f:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
c002b794:	0f b7 84 24 88 00 00 	movzwl 0x88(%esp),%eax
c002b79b:	00 
c002b79c:	39 44 24 20          	cmp    %eax,0x20(%esp)
c002b7a0:	0f 8d 4c 02 00 00    	jge    c002b9f2 <start_process+0x439>
    if (file_ofs < 0 || file_ofs > file_length (file))
c002b7a6:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002b7aa:	85 ff                	test   %edi,%edi
c002b7ac:	0f 88 1f ff ff ff    	js     c002b6d1 <start_process+0x118>
c002b7b2:	83 ec 0c             	sub    $0xc,%esp
c002b7b5:	8b 74 24 20          	mov    0x20(%esp),%esi
c002b7b9:	56                   	push   %esi
c002b7ba:	e8 cb 1e 00 00       	call   c002d68a <file_length>
c002b7bf:	83 c4 10             	add    $0x10,%esp
c002b7c2:	39 c7                	cmp    %eax,%edi
c002b7c4:	0f 8f 07 ff ff ff    	jg     c002b6d1 <start_process+0x118>
    file_seek (file, file_ofs);
c002b7ca:	83 ec 08             	sub    $0x8,%esp
c002b7cd:	57                   	push   %edi
c002b7ce:	56                   	push   %esi
c002b7cf:	e8 05 1f 00 00       	call   c002d6d9 <file_seek>
    if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
c002b7d4:	83 c4 0c             	add    $0xc,%esp
c002b7d7:	6a 20                	push   $0x20
c002b7d9:	8d 44 24 44          	lea    0x44(%esp),%eax
c002b7dd:	50                   	push   %eax
c002b7de:	56                   	push   %esi
c002b7df:	e8 fd 1c 00 00       	call   c002d4e1 <file_read>
c002b7e4:	83 c4 10             	add    $0x10,%esp
c002b7e7:	83 f8 20             	cmp    $0x20,%eax
c002b7ea:	0f 85 e1 fe ff ff    	jne    c002b6d1 <start_process+0x118>
    switch (phdr.p_type)
c002b7f0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002b7f4:	83 f8 03             	cmp    $0x3,%eax
c002b7f7:	77 88                	ja     c002b781 <start_process+0x1c8>
c002b7f9:	83 f8 02             	cmp    $0x2,%eax
c002b7fc:	0f 83 cf fe ff ff    	jae    c002b6d1 <start_process+0x118>
c002b802:	83 f8 01             	cmp    $0x1,%eax
c002b805:	75 83                	jne    c002b78a <start_process+0x1d1>
  if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK))
c002b807:	8b 74 24 40          	mov    0x40(%esp),%esi
c002b80b:	89 f0                	mov    %esi,%eax
c002b80d:	33 44 24 44          	xor    0x44(%esp),%eax
c002b811:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002b816:	0f 85 b5 fe ff ff    	jne    c002b6d1 <start_process+0x118>
  if (phdr->p_offset > (Elf32_Off) file_length (file))
c002b81c:	83 ec 0c             	sub    $0xc,%esp
c002b81f:	ff 74 24 20          	pushl  0x20(%esp)
c002b823:	e8 62 1e 00 00       	call   c002d68a <file_length>
c002b828:	83 c4 10             	add    $0x10,%esp
c002b82b:	39 c6                	cmp    %eax,%esi
c002b82d:	0f 87 9e fe ff ff    	ja     c002b6d1 <start_process+0x118>
  if (phdr->p_memsz < phdr->p_filesz)
c002b833:	8b 54 24 50          	mov    0x50(%esp),%edx
c002b837:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
  if (phdr->p_memsz == 0)
c002b83b:	85 d2                	test   %edx,%edx
c002b83d:	0f 84 8e fe ff ff    	je     c002b6d1 <start_process+0x118>
c002b843:	39 fa                	cmp    %edi,%edx
c002b845:	0f 82 86 fe ff ff    	jb     c002b6d1 <start_process+0x118>
  if (!is_user_vaddr ((void *) phdr->p_vaddr))
c002b84b:	8b 44 24 44          	mov    0x44(%esp),%eax
c002b84f:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002b854:	0f 87 77 fe ff ff    	ja     c002b6d1 <start_process+0x118>
  if (phdr->p_vaddr < PGSIZE)
c002b85a:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002b85f:	0f 96 c1             	setbe  %cl
c002b862:	89 ce                	mov    %ecx,%esi
  if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002b864:	89 d5                	mov    %edx,%ebp
c002b866:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002b86a:	01 c5                	add    %eax,%ebp
c002b86c:	0f 92 c1             	setb   %cl
        if (validate_segment (&phdr, file))
c002b86f:	89 f0                	mov    %esi,%eax
c002b871:	08 c8                	or     %cl,%al
c002b873:	0f 85 58 fe ff ff    	jne    c002b6d1 <start_process+0x118>
c002b879:	81 fd ff ff ff bf    	cmp    $0xbfffffff,%ebp
c002b87f:	0f 87 4c fe ff ff    	ja     c002b6d1 <start_process+0x118>
          bool writable = (phdr.p_flags & PF_W) != 0;
c002b885:	8b 4c 24 54          	mov    0x54(%esp),%ecx
c002b889:	d1 e9                	shr    %ecx
c002b88b:	83 e1 01             	and    $0x1,%ecx
          uint32_t file_page = phdr.p_offset & ~PGMASK;
c002b88e:	8b 44 24 40          	mov    0x40(%esp),%eax
c002b892:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002b897:	89 44 24 10          	mov    %eax,0x10(%esp)
          uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002b89b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b89f:	89 c5                	mov    %eax,%ebp
c002b8a1:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
          uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002b8a7:	25 ff 0f 00 00       	and    $0xfff,%eax
          if (phdr.p_filesz > 0)
c002b8ac:	85 ff                	test   %edi,%edi
c002b8ae:	0f 84 d9 00 00 00    	je     c002b98d <start_process+0x3d4>
            read_bytes = page_offset + phdr.p_filesz;
c002b8b4:	8d 34 38             	lea    (%eax,%edi,1),%esi
            zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
c002b8b7:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax
c002b8be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002b8c3:	29 f0                	sub    %esi,%eax
c002b8c5:	89 44 24 0c          	mov    %eax,0xc(%esp)
          if (!load_segment (file, file_page, (void *) mem_page,
c002b8c9:	0f b6 c1             	movzbl %cl,%eax
c002b8cc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002b8d0:	89 6c 24 18          	mov    %ebp,0x18(%esp)
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002b8d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b8d8:	01 f0                	add    %esi,%eax
c002b8da:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002b8df:	0f 85 c2 00 00 00    	jne    c002b9a7 <start_process+0x3ee>
  file_seek (file, ofs);
c002b8e5:	83 ec 08             	sub    $0x8,%esp
c002b8e8:	ff 74 24 18          	pushl  0x18(%esp)
c002b8ec:	ff 74 24 20          	pushl  0x20(%esp)
c002b8f0:	e8 e4 1d 00 00       	call   c002d6d9 <file_seek>
c002b8f5:	83 c4 10             	add    $0x10,%esp
  while (read_bytes > 0 || zero_bytes > 0)
c002b8f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b8fc:	09 f0                	or     %esi,%eax
c002b8fe:	0f 84 86 fe ff ff    	je     c002b78a <start_process+0x1d1>
    size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002b904:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
c002b90a:	bf 00 10 00 00       	mov    $0x1000,%edi
c002b90f:	0f 46 fe             	cmovbe %esi,%edi
    size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002b912:	b8 00 10 00 00       	mov    $0x1000,%eax
c002b917:	29 f8                	sub    %edi,%eax
c002b919:	89 44 24 10          	mov    %eax,0x10(%esp)
    uint8_t *kpage = palloc_get_page (PAL_USER);
c002b91d:	83 ec 0c             	sub    $0xc,%esp
c002b920:	6a 04                	push   $0x4
c002b922:	e8 eb 81 ff ff       	call   c0023b12 <palloc_get_page>
c002b927:	89 c5                	mov    %eax,%ebp
    if (kpage == NULL)
c002b929:	83 c4 10             	add    $0x10,%esp
c002b92c:	85 c0                	test   %eax,%eax
c002b92e:	0f 84 9d fd ff ff    	je     c002b6d1 <start_process+0x118>
    if (file_read (file, kpage, page_read_bytes) != (int) page_read_bytes)
c002b934:	83 ec 04             	sub    $0x4,%esp
c002b937:	57                   	push   %edi
c002b938:	50                   	push   %eax
c002b939:	ff 74 24 20          	pushl  0x20(%esp)
c002b93d:	e8 9f 1b 00 00       	call   c002d4e1 <file_read>
c002b942:	83 c4 10             	add    $0x10,%esp
c002b945:	39 c7                	cmp    %eax,%edi
c002b947:	0f 85 83 00 00 00    	jne    c002b9d0 <start_process+0x417>
    memset (kpage + page_read_bytes, 0, page_zero_bytes);
c002b94d:	8d 44 3d 00          	lea    0x0(%ebp,%edi,1),%eax
c002b951:	83 ec 04             	sub    $0x4,%esp
c002b954:	ff 74 24 14          	pushl  0x14(%esp)
c002b958:	6a 00                	push   $0x0
c002b95a:	50                   	push   %eax
c002b95b:	e8 a6 ce ff ff       	call   c0028806 <memset>
    if (!install_page (upage, kpage, writable))
c002b960:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
c002b964:	89 ea                	mov    %ebp,%edx
c002b966:	8b 44 24 28          	mov    0x28(%esp),%eax
c002b96a:	e8 84 f9 ff ff       	call   c002b2f3 <install_page>
c002b96f:	83 c4 10             	add    $0x10,%esp
c002b972:	84 c0                	test   %al,%al
c002b974:	74 6b                	je     c002b9e1 <start_process+0x428>
    read_bytes -= page_read_bytes;
c002b976:	29 fe                	sub    %edi,%esi
    zero_bytes -= page_zero_bytes;
c002b978:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002b97c:	29 7c 24 0c          	sub    %edi,0xc(%esp)
    upage += PGSIZE;
c002b980:	81 44 24 18 00 10 00 	addl   $0x1000,0x18(%esp)
c002b987:	00 
c002b988:	e9 6b ff ff ff       	jmp    c002b8f8 <start_process+0x33f>
            zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
c002b98d:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax
c002b994:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002b999:	89 44 24 0c          	mov    %eax,0xc(%esp)
            read_bytes = 0;
c002b99d:	be 00 00 00 00       	mov    $0x0,%esi
c002b9a2:	e9 22 ff ff ff       	jmp    c002b8c9 <start_process+0x310>
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002b9a7:	83 ec 0c             	sub    $0xc,%esp
c002b9aa:	8d 83 d8 6d ff ff    	lea    -0x9228(%ebx),%eax
c002b9b0:	50                   	push   %eax
c002b9b1:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002b9b7:	50                   	push   %eax
c002b9b8:	8d 83 08 4b ff ff    	lea    -0xb4f8(%ebx),%eax
c002b9be:	50                   	push   %eax
c002b9bf:	68 fc 01 00 00       	push   $0x1fc
c002b9c4:	8d 83 99 6d ff ff    	lea    -0x9267(%ebx),%eax
c002b9ca:	50                   	push   %eax
c002b9cb:	e8 b7 d8 ff ff       	call   c0029287 <debug_panic>
      palloc_free_page (kpage);
c002b9d0:	83 ec 0c             	sub    $0xc,%esp
c002b9d3:	55                   	push   %ebp
c002b9d4:	e8 a7 82 ff ff       	call   c0023c80 <palloc_free_page>
c002b9d9:	83 c4 10             	add    $0x10,%esp
c002b9dc:	e9 f0 fc ff ff       	jmp    c002b6d1 <start_process+0x118>
      palloc_free_page (kpage);
c002b9e1:	83 ec 0c             	sub    $0xc,%esp
c002b9e4:	55                   	push   %ebp
c002b9e5:	e8 96 82 ff ff       	call   c0023c80 <palloc_free_page>
c002b9ea:	83 c4 10             	add    $0x10,%esp
c002b9ed:	e9 df fc ff ff       	jmp    c002b6d1 <start_process+0x118>
c002b9f2:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002b9f6:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c002b9fa:	8b 7c 24 14          	mov    0x14(%esp),%edi
  kpage = palloc_get_page (PAL_USER | PAL_ZERO);
c002b9fe:	83 ec 0c             	sub    $0xc,%esp
c002ba01:	6a 06                	push   $0x6
c002ba03:	e8 0a 81 ff ff       	call   c0023b12 <palloc_get_page>
c002ba08:	89 c2                	mov    %eax,%edx
c002ba0a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  if (kpage != NULL)
c002ba0e:	83 c4 10             	add    $0x10,%esp
c002ba11:	85 c0                	test   %eax,%eax
c002ba13:	0f 84 b8 fc ff ff    	je     c002b6d1 <start_process+0x118>
      success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
c002ba19:	b9 01 00 00 00       	mov    $0x1,%ecx
c002ba1e:	b8 00 f0 ff bf       	mov    $0xbffff000,%eax
c002ba23:	e8 cb f8 ff ff       	call   c002b2f3 <install_page>
      if (success)
c002ba28:	84 c0                	test   %al,%al
c002ba2a:	0f 84 3c 01 00 00    	je     c002bb6c <start_process+0x5b3>
        *esp = PHYS_BASE;
c002ba30:	c7 84 24 28 01 00 00 	movl   $0xc0000000,0x128(%esp)
c002ba37:	00 00 00 c0 
  *eip = (void (*) (void)) ehdr.e_entry;
c002ba3b:	8b 44 24 74          	mov    0x74(%esp),%eax
c002ba3f:	89 84 24 1c 01 00 00 	mov    %eax,0x11c(%esp)
    t->exec_file = file;
c002ba46:	89 be a4 00 00 00    	mov    %edi,0xa4(%esi)
    file_deny_write(file);
c002ba4c:	83 ec 0c             	sub    $0xc,%esp
c002ba4f:	57                   	push   %edi
c002ba50:	e8 40 1b 00 00       	call   c002d595 <file_deny_write>
    char *esp = if_.esp;
c002ba55:	8b b4 24 38 01 00 00 	mov    0x138(%esp),%esi
    for (arg = name_tmp; arg != NULL; arg = strtok_r (NULL, " ", &saveptr))
c002ba5c:	83 c4 10             	add    $0x10,%esp
c002ba5f:	85 ed                	test   %ebp,%ebp
c002ba61:	74 50                	je     c002bab3 <start_process+0x4fa>
c002ba63:	89 ea                	mov    %ebp,%edx
c002ba65:	8b 6c 24 08          	mov    0x8(%esp),%ebp
      int l = strlen (arg);
c002ba69:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002ba6e:	89 d7                	mov    %edx,%edi
c002ba70:	b8 00 00 00 00       	mov    $0x0,%eax
c002ba75:	f2 ae                	repnz scas %es:(%edi),%al
c002ba77:	f7 d1                	not    %ecx
      esp -= l + 1;
c002ba79:	29 ce                	sub    %ecx,%esi
      strlcpy (esp, arg, l + 1);
c002ba7b:	83 ec 04             	sub    $0x4,%esp
c002ba7e:	51                   	push   %ecx
c002ba7f:	52                   	push   %edx
c002ba80:	56                   	push   %esi
c002ba81:	e8 56 ce ff ff       	call   c00288dc <strlcpy>
      args[argc++] = esp;
c002ba86:	83 c5 01             	add    $0x1,%ebp
c002ba89:	89 74 ac 68          	mov    %esi,0x68(%esp,%ebp,4)
    for (arg = name_tmp; arg != NULL; arg = strtok_r (NULL, " ", &saveptr))
c002ba8d:	83 c4 0c             	add    $0xc,%esp
c002ba90:	8d 84 24 e0 00 00 00 	lea    0xe0(%esp),%eax
c002ba97:	50                   	push   %eax
c002ba98:	8d 83 da 67 ff ff    	lea    -0x9826(%ebx),%eax
c002ba9e:	50                   	push   %eax
c002ba9f:	6a 00                	push   $0x0
c002baa1:	e8 2c cc ff ff       	call   c00286d2 <strtok_r>
c002baa6:	89 c2                	mov    %eax,%edx
c002baa8:	83 c4 10             	add    $0x10,%esp
c002baab:	85 c0                	test   %eax,%eax
c002baad:	75 ba                	jne    c002ba69 <start_process+0x4b0>
c002baaf:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    while (((char *) if_.esp - esp) & 3) esp--;
c002bab3:	8b 84 24 28 01 00 00 	mov    0x128(%esp),%eax
c002baba:	89 c2                	mov    %eax,%edx
c002babc:	29 f2                	sub    %esi,%edx
c002babe:	f6 c2 03             	test   $0x3,%dl
c002bac1:	74 14                	je     c002bad7 <start_process+0x51e>
c002bac3:	8d 56 ff             	lea    -0x1(%esi),%edx
c002bac6:	29 d0                	sub    %edx,%eax
c002bac8:	83 ee 01             	sub    $0x1,%esi
c002bacb:	89 c2                	mov    %eax,%edx
c002bacd:	83 e2 03             	and    $0x3,%edx
c002bad0:	83 c0 01             	add    $0x1,%eax
c002bad3:	85 d2                	test   %edx,%edx
c002bad5:	75 f1                	jne    c002bac8 <start_process+0x50f>
    esp -= 4;
c002bad7:	8d 56 fc             	lea    -0x4(%esi),%edx
    *((int *) esp) = 0;//align
c002bada:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
    while (top > 0)
c002bae1:	8b 44 24 08          	mov    0x8(%esp),%eax
c002bae5:	85 c0                	test   %eax,%eax
c002bae7:	7e 16                	jle    c002baff <start_process+0x546>
c002bae9:	6b c8 fc             	imul   $0xfffffffc,%eax,%ecx
c002baec:	01 ce                	add    %ecx,%esi
      *((int *) esp) = (int *) args[--top];
c002baee:	83 e8 01             	sub    $0x1,%eax
c002baf1:	8b 7c 84 5c          	mov    0x5c(%esp,%eax,4),%edi
c002baf5:	89 7c 86 fc          	mov    %edi,-0x4(%esi,%eax,4)
    while (top > 0)
c002baf9:	85 c0                	test   %eax,%eax
c002bafb:	75 f1                	jne    c002baee <start_process+0x535>
c002bafd:	01 ca                	add    %ecx,%edx
    *((int *) esp) = (int *) argv;
c002baff:	89 52 fc             	mov    %edx,-0x4(%edx)
    *((int *) esp) = argc;
c002bb02:	8b 44 24 08          	mov    0x8(%esp),%eax
c002bb06:	89 42 f8             	mov    %eax,-0x8(%edx)
    *((int *) esp) = 0;
c002bb09:	c7 42 f4 00 00 00 00 	movl   $0x0,-0xc(%edx)
    esp -= 4;
c002bb10:	83 ea 0c             	sub    $0xc,%edx
c002bb13:	89 94 24 28 01 00 00 	mov    %edx,0x128(%esp)
  palloc_free_page (file_name);
c002bb1a:	83 ec 0c             	sub    $0xc,%esp
c002bb1d:	ff b4 24 5c 01 00 00 	pushl  0x15c(%esp)
c002bb24:	e8 57 81 ff ff       	call   c0023c80 <palloc_free_page>
  sema_up (thread_current ()->message_to_grandpa->sema_started);
c002bb29:	e8 26 52 ff ff       	call   c0020d54 <thread_current>
c002bb2e:	83 c4 04             	add    $0x4,%esp
c002bb31:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
c002bb37:	ff 70 14             	pushl  0x14(%eax)
c002bb3a:	e8 e1 75 ff ff       	call   c0023120 <sema_up>
  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
c002bb3f:	8d 84 24 f0 00 00 00 	lea    0xf0(%esp),%eax
c002bb46:	89 c4                	mov    %eax,%esp
c002bb48:	e9 86 68 ff ff       	jmp    c00223d3 <intr_exit>
  NOT_REACHED ();
c002bb4d:	8d 83 54 55 ff ff    	lea    -0xaaac(%ebx),%eax
c002bb53:	50                   	push   %eax
c002bb54:	8d 83 18 4b ff ff    	lea    -0xb4e8(%ebx),%eax
c002bb5a:	50                   	push   %eax
c002bb5b:	68 8a 00 00 00       	push   $0x8a
c002bb60:	8d 83 99 6d ff ff    	lea    -0x9267(%ebx),%eax
c002bb66:	50                   	push   %eax
c002bb67:	e8 1b d7 ff ff       	call   c0029287 <debug_panic>
        palloc_free_page (kpage);
c002bb6c:	83 ec 0c             	sub    $0xc,%esp
c002bb6f:	ff 74 24 18          	pushl  0x18(%esp)
c002bb73:	e8 08 81 ff ff       	call   c0023c80 <palloc_free_page>
c002bb78:	83 c4 10             	add    $0x10,%esp
c002bb7b:	e9 51 fb ff ff       	jmp    c002b6d1 <start_process+0x118>

c002bb80 <lookup_page>:
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page (uint32_t *pd, const void *vaddr, bool create)
{
c002bb80:	57                   	push   %edi
c002bb81:	56                   	push   %esi
c002bb82:	53                   	push   %ebx
c002bb83:	e8 fd 2e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002bb88:	81 c3 2c f3 00 00    	add    $0xf32c,%ebx
  uint32_t *pt, *pde;

  ASSERT (pd != NULL);
c002bb8e:	85 c0                	test   %eax,%eax
c002bb90:	0f 84 88 00 00 00    	je     c002bc1e <lookup_page+0x9e>
c002bb96:	89 d6                	mov    %edx,%esi

  /* Shouldn't create new kernel virtual mappings. */
  ASSERT (!create || is_user_vaddr (vaddr));
c002bb98:	80 f9 01             	cmp    $0x1,%cl
c002bb9b:	75 0c                	jne    c002bba9 <lookup_page+0x29>
c002bb9d:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002bba3:	0f 87 9b 00 00 00    	ja     c002bc44 <lookup_page+0xc4>
  return (uintptr_t) va >> PDSHIFT;
c002bba9:	89 f2                	mov    %esi,%edx
c002bbab:	c1 ea 16             	shr    $0x16,%edx

  /* Check for a page table for VADDR.
     If one is missing, create one if requested. */
  pde = pd + pd_no (vaddr);
c002bbae:	8d 3c 90             	lea    (%eax,%edx,4),%edi
  if (*pde == 0) 
c002bbb1:	83 3f 00             	cmpl   $0x0,(%edi)
c002bbb4:	75 3a                	jne    c002bbf0 <lookup_page+0x70>
    {
      if (create)
c002bbb6:	84 c9                	test   %cl,%cl
c002bbb8:	0f 84 44 01 00 00    	je     c002bd02 <lookup_page+0x182>
        {
          pt = palloc_get_page (PAL_ZERO);
c002bbbe:	83 ec 0c             	sub    $0xc,%esp
c002bbc1:	6a 02                	push   $0x2
c002bbc3:	e8 4a 7f ff ff       	call   c0023b12 <palloc_get_page>
          if (pt == NULL) 
c002bbc8:	83 c4 10             	add    $0x10,%esp
c002bbcb:	85 c0                	test   %eax,%eax
c002bbcd:	74 4b                	je     c002bc1a <lookup_page+0x9a>
  ASSERT (pg_ofs (pt) == 0);
c002bbcf:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002bbd4:	0f 85 90 00 00 00    	jne    c002bc6a <lookup_page+0xea>
  ASSERT (is_kernel_vaddr (vaddr));
c002bbda:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bbdf:	0f 86 ab 00 00 00    	jbe    c002bc90 <lookup_page+0x110>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002bbe5:	8d 80 00 00 00 40    	lea    0x40000000(%eax),%eax
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002bbeb:	83 c8 07             	or     $0x7,%eax
c002bbee:	89 07                	mov    %eax,(%edi)
      else
        return NULL;
    }

  /* Return the page table entry. */
  pt = pde_get_pt (*pde);
c002bbf0:	8b 07                	mov    (%edi),%eax
  ASSERT (pde & PTE_P);
c002bbf2:	a8 01                	test   $0x1,%al
c002bbf4:	0f 84 bc 00 00 00    	je     c002bcb6 <lookup_page+0x136>
  return ptov (pde & PTE_ADDR);
c002bbfa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002bbff:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002bc04:	0f 87 d2 00 00 00    	ja     c002bcdc <lookup_page+0x15c>
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002bc0a:	c1 ee 0a             	shr    $0xa,%esi
  return &pt[pt_no (vaddr)];
c002bc0d:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
c002bc13:	8d 84 30 00 00 00 c0 	lea    -0x40000000(%eax,%esi,1),%eax
}
c002bc1a:	5b                   	pop    %ebx
c002bc1b:	5e                   	pop    %esi
c002bc1c:	5f                   	pop    %edi
c002bc1d:	c3                   	ret    
  ASSERT (pd != NULL);
c002bc1e:	83 ec 0c             	sub    $0xc,%esp
c002bc21:	8d 83 00 6e ff ff    	lea    -0x9200(%ebx),%eax
c002bc27:	50                   	push   %eax
c002bc28:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bc2e:	50                   	push   %eax
c002bc2f:	8d 83 5c 4b ff ff    	lea    -0xb4a4(%ebx),%eax
c002bc35:	50                   	push   %eax
c002bc36:	6a 44                	push   $0x44
c002bc38:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002bc3e:	50                   	push   %eax
c002bc3f:	e8 43 d6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (!create || is_user_vaddr (vaddr));
c002bc44:	83 ec 0c             	sub    $0xc,%esp
c002bc47:	8d 83 bc 6e ff ff    	lea    -0x9144(%ebx),%eax
c002bc4d:	50                   	push   %eax
c002bc4e:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bc54:	50                   	push   %eax
c002bc55:	8d 83 5c 4b ff ff    	lea    -0xb4a4(%ebx),%eax
c002bc5b:	50                   	push   %eax
c002bc5c:	6a 47                	push   $0x47
c002bc5e:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002bc64:	50                   	push   %eax
c002bc65:	e8 1d d6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (pg_ofs (pt) == 0);
c002bc6a:	83 ec 0c             	sub    $0xc,%esp
c002bc6d:	8d 83 34 4e ff ff    	lea    -0xb1cc(%ebx),%eax
c002bc73:	50                   	push   %eax
c002bc74:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bc7a:	50                   	push   %eax
c002bc7b:	8d 83 50 4b ff ff    	lea    -0xb4b0(%ebx),%eax
c002bc81:	50                   	push   %eax
c002bc82:	6a 48                	push   $0x48
c002bc84:	8d 83 5c 4e ff ff    	lea    -0xb1a4(%ebx),%eax
c002bc8a:	50                   	push   %eax
c002bc8b:	e8 f7 d5 ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c002bc90:	83 ec 0c             	sub    $0xc,%esp
c002bc93:	8d 83 70 4e ff ff    	lea    -0xb190(%ebx),%eax
c002bc99:	50                   	push   %eax
c002bc9a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bca0:	50                   	push   %eax
c002bca1:	8d 83 68 4b ff ff    	lea    -0xb498(%ebx),%eax
c002bca7:	50                   	push   %eax
c002bca8:	6a 54                	push   $0x54
c002bcaa:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002bcb0:	50                   	push   %eax
c002bcb1:	e8 d1 d5 ff ff       	call   c0029287 <debug_panic>
  ASSERT (pde & PTE_P);
c002bcb6:	83 ec 0c             	sub    $0xc,%esp
c002bcb9:	8d 83 24 6e ff ff    	lea    -0x91dc(%ebx),%eax
c002bcbf:	50                   	push   %eax
c002bcc0:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bcc6:	50                   	push   %eax
c002bcc7:	8d 83 8c 4b ff ff    	lea    -0xb474(%ebx),%eax
c002bccd:	50                   	push   %eax
c002bcce:	6a 4f                	push   $0x4f
c002bcd0:	8d 83 5c 4e ff ff    	lea    -0xb1a4(%ebx),%eax
c002bcd6:	50                   	push   %eax
c002bcd7:	e8 ab d5 ff ff       	call   c0029287 <debug_panic>
  ASSERT ((void *) paddr < PHYS_BASE);
c002bcdc:	83 ec 0c             	sub    $0xc,%esp
c002bcdf:	8d 83 53 5a ff ff    	lea    -0xa5ad(%ebx),%eax
c002bce5:	50                   	push   %eax
c002bce6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bcec:	50                   	push   %eax
c002bced:	8d 83 84 4b ff ff    	lea    -0xb47c(%ebx),%eax
c002bcf3:	50                   	push   %eax
c002bcf4:	6a 4a                	push   $0x4a
c002bcf6:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002bcfc:	50                   	push   %eax
c002bcfd:	e8 85 d5 ff ff       	call   c0029287 <debug_panic>
        return NULL;
c002bd02:	b8 00 00 00 00       	mov    $0x0,%eax
c002bd07:	e9 0e ff ff ff       	jmp    c002bc1a <lookup_page+0x9a>

c002bd0c <pagedir_create>:
{
c002bd0c:	57                   	push   %edi
c002bd0d:	56                   	push   %esi
c002bd0e:	53                   	push   %ebx
c002bd0f:	e8 71 2d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002bd14:	81 c3 a0 f1 00 00    	add    $0xf1a0,%ebx
  uint32_t *pd = palloc_get_page (0);
c002bd1a:	83 ec 0c             	sub    $0xc,%esp
c002bd1d:	6a 00                	push   $0x0
c002bd1f:	e8 ee 7d ff ff       	call   c0023b12 <palloc_get_page>
  if (pd != NULL)
c002bd24:	83 c4 10             	add    $0x10,%esp
c002bd27:	85 c0                	test   %eax,%eax
c002bd29:	74 2f                	je     c002bd5a <pagedir_create+0x4e>
    memcpy (pd, init_page_dir, PGSIZE);
c002bd2b:	c7 c2 38 d4 03 c0    	mov    $0xc003d438,%edx
c002bd31:	8b 32                	mov    (%edx),%esi
c002bd33:	8b 16                	mov    (%esi),%edx
c002bd35:	89 10                	mov    %edx,(%eax)
c002bd37:	8b 96 fc 0f 00 00    	mov    0xffc(%esi),%edx
c002bd3d:	89 90 fc 0f 00 00    	mov    %edx,0xffc(%eax)
c002bd43:	8d 78 04             	lea    0x4(%eax),%edi
c002bd46:	83 e7 fc             	and    $0xfffffffc,%edi
c002bd49:	89 c1                	mov    %eax,%ecx
c002bd4b:	29 f9                	sub    %edi,%ecx
c002bd4d:	29 ce                	sub    %ecx,%esi
c002bd4f:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c002bd55:	c1 e9 02             	shr    $0x2,%ecx
c002bd58:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
c002bd5a:	5b                   	pop    %ebx
c002bd5b:	5e                   	pop    %esi
c002bd5c:	5f                   	pop    %edi
c002bd5d:	c3                   	ret    

c002bd5e <pagedir_destroy>:
{
c002bd5e:	55                   	push   %ebp
c002bd5f:	57                   	push   %edi
c002bd60:	56                   	push   %esi
c002bd61:	53                   	push   %ebx
c002bd62:	83 ec 1c             	sub    $0x1c,%esp
c002bd65:	e8 1b 2d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002bd6a:	81 c3 4a f1 00 00    	add    $0xf14a,%ebx
  if (pd == NULL)
c002bd70:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002bd75:	0f 84 24 01 00 00    	je     c002be9f <pagedir_destroy+0x141>
  ASSERT (pd != init_page_dir);
c002bd7b:	c7 c0 38 d4 03 c0    	mov    $0xc003d438,%eax
c002bd81:	8b 54 24 30          	mov    0x30(%esp),%edx
c002bd85:	39 10                	cmp    %edx,(%eax)
c002bd87:	74 1c                	je     c002bda5 <pagedir_destroy+0x47>
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002bd89:	89 d0                	mov    %edx,%eax
c002bd8b:	05 00 0c 00 00       	add    $0xc00,%eax
c002bd90:	89 44 24 08          	mov    %eax,0x8(%esp)
c002bd94:	39 c2                	cmp    %eax,%edx
c002bd96:	0f 83 f4 00 00 00    	jae    c002be90 <pagedir_destroy+0x132>
c002bd9c:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c002bda0:	e9 b6 00 00 00       	jmp    c002be5b <pagedir_destroy+0xfd>
  ASSERT (pd != init_page_dir);
c002bda5:	83 ec 0c             	sub    $0xc,%esp
c002bda8:	8d 83 30 6e ff ff    	lea    -0x91d0(%ebx),%eax
c002bdae:	50                   	push   %eax
c002bdaf:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bdb5:	50                   	push   %eax
c002bdb6:	8d 83 98 4b ff ff    	lea    -0xb468(%ebx),%eax
c002bdbc:	50                   	push   %eax
c002bdbd:	6a 29                	push   $0x29
c002bdbf:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002bdc5:	50                   	push   %eax
c002bdc6:	e8 bc d4 ff ff       	call   c0029287 <debug_panic>
c002bdcb:	83 ec 0c             	sub    $0xc,%esp
c002bdce:	8d 83 53 5a ff ff    	lea    -0xa5ad(%ebx),%eax
c002bdd4:	50                   	push   %eax
c002bdd5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bddb:	50                   	push   %eax
c002bddc:	8d 83 84 4b ff ff    	lea    -0xb47c(%ebx),%eax
c002bde2:	50                   	push   %eax
c002bde3:	6a 4a                	push   $0x4a
c002bde5:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002bdeb:	50                   	push   %eax
c002bdec:	e8 96 d4 ff ff       	call   c0029287 <debug_panic>
c002bdf1:	83 ec 0c             	sub    $0xc,%esp
c002bdf4:	8d 83 53 5a ff ff    	lea    -0xa5ad(%ebx),%eax
c002bdfa:	50                   	push   %eax
c002bdfb:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002be01:	50                   	push   %eax
c002be02:	8d 83 84 4b ff ff    	lea    -0xb47c(%ebx),%eax
c002be08:	50                   	push   %eax
c002be09:	6a 4a                	push   $0x4a
c002be0b:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002be11:	50                   	push   %eax
c002be12:	e8 70 d4 ff ff       	call   c0029287 <debug_panic>
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002be17:	83 c6 04             	add    $0x4,%esi
c002be1a:	39 fe                	cmp    %edi,%esi
c002be1c:	74 25                	je     c002be43 <pagedir_destroy+0xe5>
          if (*pte & PTE_P)
c002be1e:	8b 06                	mov    (%esi),%eax
c002be20:	a8 01                	test   $0x1,%al
c002be22:	74 f3                	je     c002be17 <pagedir_destroy+0xb9>
}

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page (uint32_t pte) {
  return ptov (pte & PTE_ADDR);
c002be24:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002be29:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002be2e:	77 c1                	ja     c002bdf1 <pagedir_destroy+0x93>
            palloc_free_page (pte_get_page (*pte));
c002be30:	83 ec 0c             	sub    $0xc,%esp
  return (void *) (paddr + PHYS_BASE);
c002be33:	2d 00 00 00 40       	sub    $0x40000000,%eax
c002be38:	50                   	push   %eax
c002be39:	e8 42 7e ff ff       	call   c0023c80 <palloc_free_page>
c002be3e:	83 c4 10             	add    $0x10,%esp
c002be41:	eb d4                	jmp    c002be17 <pagedir_destroy+0xb9>
        palloc_free_page (pt);
c002be43:	83 ec 0c             	sub    $0xc,%esp
c002be46:	ff 74 24 18          	pushl  0x18(%esp)
c002be4a:	e8 31 7e ff ff       	call   c0023c80 <palloc_free_page>
c002be4f:	83 c4 10             	add    $0x10,%esp
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002be52:	83 c5 04             	add    $0x4,%ebp
c002be55:	3b 6c 24 08          	cmp    0x8(%esp),%ebp
c002be59:	74 35                	je     c002be90 <pagedir_destroy+0x132>
    if (*pde & PTE_P)
c002be5b:	8b 7d 00             	mov    0x0(%ebp),%edi
c002be5e:	f7 c7 01 00 00 00    	test   $0x1,%edi
c002be64:	74 ec                	je     c002be52 <pagedir_destroy+0xf4>
  return ptov (pde & PTE_ADDR);
c002be66:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
  ASSERT ((void *) paddr < PHYS_BASE);
c002be6c:	81 ff ff ff ff bf    	cmp    $0xbfffffff,%edi
c002be72:	0f 87 53 ff ff ff    	ja     c002bdcb <pagedir_destroy+0x6d>
  return (void *) (paddr + PHYS_BASE);
c002be78:	8d 87 00 00 00 c0    	lea    -0x40000000(%edi),%eax
c002be7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002be82:	81 ef 00 f0 ff 3f    	sub    $0x3ffff000,%edi
c002be88:	39 f8                	cmp    %edi,%eax
c002be8a:	73 b7                	jae    c002be43 <pagedir_destroy+0xe5>
c002be8c:	89 c6                	mov    %eax,%esi
c002be8e:	eb 8e                	jmp    c002be1e <pagedir_destroy+0xc0>
  palloc_free_page (pd);
c002be90:	83 ec 0c             	sub    $0xc,%esp
c002be93:	ff 74 24 3c          	pushl  0x3c(%esp)
c002be97:	e8 e4 7d ff ff       	call   c0023c80 <palloc_free_page>
c002be9c:	83 c4 10             	add    $0x10,%esp
}
c002be9f:	83 c4 1c             	add    $0x1c,%esp
c002bea2:	5b                   	pop    %ebx
c002bea3:	5e                   	pop    %esi
c002bea4:	5f                   	pop    %edi
c002bea5:	5d                   	pop    %ebp
c002bea6:	c3                   	ret    

c002bea7 <pagedir_set_page>:
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page (uint32_t *pd, void *upage, void *kpage, bool writable)
{
c002bea7:	55                   	push   %ebp
c002bea8:	57                   	push   %edi
c002bea9:	56                   	push   %esi
c002beaa:	53                   	push   %ebx
c002beab:	83 ec 0c             	sub    $0xc,%esp
c002beae:	e8 d2 2b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002beb3:	81 c3 01 f0 00 00    	add    $0xf001,%ebx
c002beb9:	8b 44 24 20          	mov    0x20(%esp),%eax
c002bebd:	8b 54 24 24          	mov    0x24(%esp),%edx
c002bec1:	8b 74 24 28          	mov    0x28(%esp),%esi
c002bec5:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  uint32_t *pte;
//  static cnt = 0;
//  printf("--%d ,%x, %x\n", cnt++, upage, kpage);
  ASSERT (pg_ofs (upage) == 0);
c002bec9:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002becf:	0f 85 86 00 00 00    	jne    c002bf5b <pagedir_set_page+0xb4>
  ASSERT (pg_ofs (kpage) == 0);
c002bed5:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002bedb:	0f 85 a0 00 00 00    	jne    c002bf81 <pagedir_set_page+0xda>
  ASSERT (is_user_vaddr (upage));
c002bee1:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002bee7:	0f 87 ba 00 00 00    	ja     c002bfa7 <pagedir_set_page+0x100>
  ASSERT (is_kernel_vaddr (vaddr));
c002beed:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002bef3:	0f 86 d4 00 00 00    	jbe    c002bfcd <pagedir_set_page+0x126>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002bef9:	81 c6 00 00 00 40    	add    $0x40000000,%esi
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002beff:	89 f5                	mov    %esi,%ebp
c002bf01:	c1 ed 0c             	shr    $0xc,%ebp
c002bf04:	c7 c1 7e 01 02 c0    	mov    $0xc002017e,%ecx
c002bf0a:	3b 29                	cmp    (%ecx),%ebp
c002bf0c:	0f 83 e1 00 00 00    	jae    c002bff3 <pagedir_set_page+0x14c>
  ASSERT (pd != init_page_dir);
c002bf12:	c7 c1 38 d4 03 c0    	mov    $0xc003d438,%ecx
c002bf18:	39 01                	cmp    %eax,(%ecx)
c002bf1a:	0f 84 f9 00 00 00    	je     c002c019 <pagedir_set_page+0x172>

  pte = lookup_page (pd, upage, true);
c002bf20:	b9 01 00 00 00       	mov    $0x1,%ecx
c002bf25:	e8 56 fc ff ff       	call   c002bb80 <lookup_page>

  if (pte != NULL) 
c002bf2a:	85 c0                	test   %eax,%eax
c002bf2c:	0f 84 33 01 00 00    	je     c002c065 <pagedir_set_page+0x1be>
    {
      ASSERT ((*pte & PTE_P) == 0);
c002bf32:	f6 00 01             	testb  $0x1,(%eax)
c002bf35:	0f 85 04 01 00 00    	jne    c002c03f <pagedir_set_page+0x198>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002bf3b:	89 fb                	mov    %edi,%ebx
c002bf3d:	84 db                	test   %bl,%bl
c002bf3f:	0f 95 c2             	setne  %dl
c002bf42:	0f b6 d2             	movzbl %dl,%edx
c002bf45:	01 d2                	add    %edx,%edx
  return pte_create_kernel (page, writable) | PTE_U;
c002bf47:	83 ce 05             	or     $0x5,%esi
c002bf4a:	09 d6                	or     %edx,%esi
c002bf4c:	89 30                	mov    %esi,(%eax)
      *pte = pte_create_user (kpage, writable);
      return true;
c002bf4e:	b8 01 00 00 00       	mov    $0x1,%eax
    }
  else
    return false;
}
c002bf53:	83 c4 0c             	add    $0xc,%esp
c002bf56:	5b                   	pop    %ebx
c002bf57:	5e                   	pop    %esi
c002bf58:	5f                   	pop    %edi
c002bf59:	5d                   	pop    %ebp
c002bf5a:	c3                   	ret    
  ASSERT (pg_ofs (upage) == 0);
c002bf5b:	83 ec 0c             	sub    $0xc,%esp
c002bf5e:	8d 83 44 6e ff ff    	lea    -0x91bc(%ebx),%eax
c002bf64:	50                   	push   %eax
c002bf65:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bf6b:	50                   	push   %eax
c002bf6c:	8d 83 70 4b ff ff    	lea    -0xb490(%ebx),%eax
c002bf72:	50                   	push   %eax
c002bf73:	6a 6f                	push   $0x6f
c002bf75:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002bf7b:	50                   	push   %eax
c002bf7c:	e8 06 d3 ff ff       	call   c0029287 <debug_panic>
  ASSERT (pg_ofs (kpage) == 0);
c002bf81:	83 ec 0c             	sub    $0xc,%esp
c002bf84:	8d 83 58 6e ff ff    	lea    -0x91a8(%ebx),%eax
c002bf8a:	50                   	push   %eax
c002bf8b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bf91:	50                   	push   %eax
c002bf92:	8d 83 70 4b ff ff    	lea    -0xb490(%ebx),%eax
c002bf98:	50                   	push   %eax
c002bf99:	6a 70                	push   $0x70
c002bf9b:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002bfa1:	50                   	push   %eax
c002bfa2:	e8 e0 d2 ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002bfa7:	83 ec 0c             	sub    $0xc,%esp
c002bfaa:	8d 83 6c 6e ff ff    	lea    -0x9194(%ebx),%eax
c002bfb0:	50                   	push   %eax
c002bfb1:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bfb7:	50                   	push   %eax
c002bfb8:	8d 83 70 4b ff ff    	lea    -0xb490(%ebx),%eax
c002bfbe:	50                   	push   %eax
c002bfbf:	6a 71                	push   $0x71
c002bfc1:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002bfc7:	50                   	push   %eax
c002bfc8:	e8 ba d2 ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_kernel_vaddr (vaddr));
c002bfcd:	83 ec 0c             	sub    $0xc,%esp
c002bfd0:	8d 83 70 4e ff ff    	lea    -0xb190(%ebx),%eax
c002bfd6:	50                   	push   %eax
c002bfd7:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002bfdd:	50                   	push   %eax
c002bfde:	8d 83 68 4b ff ff    	lea    -0xb498(%ebx),%eax
c002bfe4:	50                   	push   %eax
c002bfe5:	6a 54                	push   $0x54
c002bfe7:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002bfed:	50                   	push   %eax
c002bfee:	e8 94 d2 ff ff       	call   c0029287 <debug_panic>
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002bff3:	83 ec 0c             	sub    $0xc,%esp
c002bff6:	8d 83 e0 6e ff ff    	lea    -0x9120(%ebx),%eax
c002bffc:	50                   	push   %eax
c002bffd:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c003:	50                   	push   %eax
c002c004:	8d 83 70 4b ff ff    	lea    -0xb490(%ebx),%eax
c002c00a:	50                   	push   %eax
c002c00b:	6a 72                	push   $0x72
c002c00d:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002c013:	50                   	push   %eax
c002c014:	e8 6e d2 ff ff       	call   c0029287 <debug_panic>
  ASSERT (pd != init_page_dir);
c002c019:	83 ec 0c             	sub    $0xc,%esp
c002c01c:	8d 83 30 6e ff ff    	lea    -0x91d0(%ebx),%eax
c002c022:	50                   	push   %eax
c002c023:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c029:	50                   	push   %eax
c002c02a:	8d 83 70 4b ff ff    	lea    -0xb490(%ebx),%eax
c002c030:	50                   	push   %eax
c002c031:	6a 73                	push   $0x73
c002c033:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002c039:	50                   	push   %eax
c002c03a:	e8 48 d2 ff ff       	call   c0029287 <debug_panic>
      ASSERT ((*pte & PTE_P) == 0);
c002c03f:	83 ec 0c             	sub    $0xc,%esp
c002c042:	8d 83 82 6e ff ff    	lea    -0x917e(%ebx),%eax
c002c048:	50                   	push   %eax
c002c049:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c04f:	50                   	push   %eax
c002c050:	8d 83 70 4b ff ff    	lea    -0xb490(%ebx),%eax
c002c056:	50                   	push   %eax
c002c057:	6a 79                	push   $0x79
c002c059:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002c05f:	50                   	push   %eax
c002c060:	e8 22 d2 ff ff       	call   c0029287 <debug_panic>
    return false;
c002c065:	b8 00 00 00 00       	mov    $0x0,%eax
c002c06a:	e9 e4 fe ff ff       	jmp    c002bf53 <pagedir_set_page+0xac>

c002c06f <pagedir_get_page>:
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page (uint32_t *pd, const void *uaddr) 
{
c002c06f:	56                   	push   %esi
c002c070:	53                   	push   %ebx
c002c071:	83 ec 04             	sub    $0x4,%esp
c002c074:	e8 0c 2a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c079:	81 c3 3b ee 00 00    	add    $0xee3b,%ebx
c002c07f:	8b 74 24 14          	mov    0x14(%esp),%esi
  uint32_t *pte;

  ASSERT (is_user_vaddr (uaddr));
c002c083:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c089:	77 46                	ja     c002c0d1 <pagedir_get_page+0x62>
  ASSERT (uaddr != NULL);
c002c08b:	85 f6                	test   %esi,%esi
c002c08d:	74 6b                	je     c002c0fa <pagedir_get_page+0x8b>
  
  pte = lookup_page (pd, uaddr, false);
c002c08f:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c094:	89 f2                	mov    %esi,%edx
c002c096:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c09a:	e8 e1 fa ff ff       	call   c002bb80 <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002c09f:	85 c0                	test   %eax,%eax
c002c0a1:	0f 84 a2 00 00 00    	je     c002c149 <pagedir_get_page+0xda>
c002c0a7:	8b 00                	mov    (%eax),%eax
c002c0a9:	a8 01                	test   $0x1,%al
c002c0ab:	0f 84 a2 00 00 00    	je     c002c153 <pagedir_get_page+0xe4>
  return ptov (pte & PTE_ADDR);
c002c0b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c002c0b6:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c0bb:	77 66                	ja     c002c123 <pagedir_get_page+0xb4>
  return (uintptr_t) va & PGMASK;
c002c0bd:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
    return pte_get_page (*pte) + pg_ofs (uaddr);
c002c0c3:	09 c6                	or     %eax,%esi
c002c0c5:	8d 86 00 00 00 c0    	lea    -0x40000000(%esi),%eax
  else
    return NULL;
}
c002c0cb:	83 c4 04             	add    $0x4,%esp
c002c0ce:	5b                   	pop    %ebx
c002c0cf:	5e                   	pop    %esi
c002c0d0:	c3                   	ret    
  ASSERT (is_user_vaddr (uaddr));
c002c0d1:	83 ec 0c             	sub    $0xc,%esp
c002c0d4:	8d 83 96 6e ff ff    	lea    -0x916a(%ebx),%eax
c002c0da:	50                   	push   %eax
c002c0db:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c0e1:	50                   	push   %eax
c002c0e2:	8d 83 3c 4b ff ff    	lea    -0xb4c4(%ebx),%eax
c002c0e8:	50                   	push   %eax
c002c0e9:	68 8a 00 00 00       	push   $0x8a
c002c0ee:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002c0f4:	50                   	push   %eax
c002c0f5:	e8 8d d1 ff ff       	call   c0029287 <debug_panic>
  ASSERT (uaddr != NULL);
c002c0fa:	83 ec 0c             	sub    $0xc,%esp
c002c0fd:	8d 83 ac 6e ff ff    	lea    -0x9154(%ebx),%eax
c002c103:	50                   	push   %eax
c002c104:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c10a:	50                   	push   %eax
c002c10b:	8d 83 3c 4b ff ff    	lea    -0xb4c4(%ebx),%eax
c002c111:	50                   	push   %eax
c002c112:	68 8b 00 00 00       	push   $0x8b
c002c117:	8d 83 0b 6e ff ff    	lea    -0x91f5(%ebx),%eax
c002c11d:	50                   	push   %eax
c002c11e:	e8 64 d1 ff ff       	call   c0029287 <debug_panic>
  ASSERT ((void *) paddr < PHYS_BASE);
c002c123:	83 ec 0c             	sub    $0xc,%esp
c002c126:	8d 83 53 5a ff ff    	lea    -0xa5ad(%ebx),%eax
c002c12c:	50                   	push   %eax
c002c12d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c133:	50                   	push   %eax
c002c134:	8d 83 84 4b ff ff    	lea    -0xb47c(%ebx),%eax
c002c13a:	50                   	push   %eax
c002c13b:	6a 4a                	push   $0x4a
c002c13d:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002c143:	50                   	push   %eax
c002c144:	e8 3e d1 ff ff       	call   c0029287 <debug_panic>
    return NULL;
c002c149:	b8 00 00 00 00       	mov    $0x0,%eax
c002c14e:	e9 78 ff ff ff       	jmp    c002c0cb <pagedir_get_page+0x5c>
c002c153:	b8 00 00 00 00       	mov    $0x0,%eax
c002c158:	e9 6e ff ff ff       	jmp    c002c0cb <pagedir_get_page+0x5c>

c002c15d <pagedir_is_dirty>:
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty (uint32_t *pd, const void *vpage) 
{
c002c15d:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002c160:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c165:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c169:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c16d:	e8 0e fa ff ff       	call   c002bb80 <lookup_page>
  return pte != NULL && (*pte & PTE_D) != 0;
c002c172:	ba 00 00 00 00       	mov    $0x0,%edx
c002c177:	85 c0                	test   %eax,%eax
c002c179:	74 08                	je     c002c183 <pagedir_is_dirty+0x26>
c002c17b:	8b 10                	mov    (%eax),%edx
c002c17d:	c1 ea 06             	shr    $0x6,%edx
c002c180:	83 e2 01             	and    $0x1,%edx
c002c183:	89 d0                	mov    %edx,%eax
c002c185:	83 e0 01             	and    $0x1,%eax
}
c002c188:	83 c4 0c             	add    $0xc,%esp
c002c18b:	c3                   	ret    

c002c18c <pagedir_is_accessed>:
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed (uint32_t *pd, const void *vpage) 
{
c002c18c:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002c18f:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c194:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c198:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c19c:	e8 df f9 ff ff       	call   c002bb80 <lookup_page>
  return pte != NULL && (*pte & PTE_A) != 0;
c002c1a1:	ba 00 00 00 00       	mov    $0x0,%edx
c002c1a6:	85 c0                	test   %eax,%eax
c002c1a8:	74 08                	je     c002c1b2 <pagedir_is_accessed+0x26>
c002c1aa:	8b 10                	mov    (%eax),%edx
c002c1ac:	c1 ea 05             	shr    $0x5,%edx
c002c1af:	83 e2 01             	and    $0x1,%edx
c002c1b2:	89 d0                	mov    %edx,%eax
c002c1b4:	83 e0 01             	and    $0x1,%eax
}
c002c1b7:	83 c4 0c             	add    $0xc,%esp
c002c1ba:	c3                   	ret    

c002c1bb <pagedir_activate>:

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate (uint32_t *pd) 
{
c002c1bb:	53                   	push   %ebx
c002c1bc:	83 ec 08             	sub    $0x8,%esp
c002c1bf:	e8 c1 28 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c1c4:	81 c3 f0 ec 00 00    	add    $0xecf0,%ebx
c002c1ca:	8b 44 24 10          	mov    0x10(%esp),%eax
  if (pd == NULL)
c002c1ce:	85 c0                	test   %eax,%eax
c002c1d0:	74 14                	je     c002c1e6 <pagedir_activate+0x2b>
  ASSERT (is_kernel_vaddr (vaddr));
c002c1d2:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c1d7:	76 17                	jbe    c002c1f0 <pagedir_activate+0x35>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002c1d9:	05 00 00 00 40       	add    $0x40000000,%eax
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
     Address of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (pd)) : "memory");
c002c1de:	0f 22 d8             	mov    %eax,%cr3
}
c002c1e1:	83 c4 08             	add    $0x8,%esp
c002c1e4:	5b                   	pop    %ebx
c002c1e5:	c3                   	ret    
    pd = init_page_dir;
c002c1e6:	c7 c0 38 d4 03 c0    	mov    $0xc003d438,%eax
c002c1ec:	8b 00                	mov    (%eax),%eax
c002c1ee:	eb e2                	jmp    c002c1d2 <pagedir_activate+0x17>
  ASSERT (is_kernel_vaddr (vaddr));
c002c1f0:	83 ec 0c             	sub    $0xc,%esp
c002c1f3:	8d 83 70 4e ff ff    	lea    -0xb190(%ebx),%eax
c002c1f9:	50                   	push   %eax
c002c1fa:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c200:	50                   	push   %eax
c002c201:	8d 83 68 4b ff ff    	lea    -0xb498(%ebx),%eax
c002c207:	50                   	push   %eax
c002c208:	6a 54                	push   $0x54
c002c20a:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002c210:	50                   	push   %eax
c002c211:	e8 71 d0 ff ff       	call   c0029287 <debug_panic>

c002c216 <invalidate_pagedir>:
   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir (uint32_t *pd) 
{
c002c216:	53                   	push   %ebx
c002c217:	83 ec 08             	sub    $0x8,%esp
c002c21a:	e8 66 28 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c21f:	81 c3 95 ec 00 00    	add    $0xec95,%ebx
  asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002c225:	0f 20 da             	mov    %cr3,%edx
  ASSERT ((void *) paddr < PHYS_BASE);
c002c228:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c22e:	77 0f                	ja     c002c23f <invalidate_pagedir+0x29>
  return (void *) (paddr + PHYS_BASE);
c002c230:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
  if (active_pd () == pd) 
c002c236:	39 d0                	cmp    %edx,%eax
c002c238:	74 2b                	je     c002c265 <invalidate_pagedir+0x4f>
    {
      /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
         "Translation Lookaside Buffers (TLBs)". */
      pagedir_activate (pd);
    } 
}
c002c23a:	83 c4 08             	add    $0x8,%esp
c002c23d:	5b                   	pop    %ebx
c002c23e:	c3                   	ret    
  ASSERT ((void *) paddr < PHYS_BASE);
c002c23f:	83 ec 0c             	sub    $0xc,%esp
c002c242:	8d 83 53 5a ff ff    	lea    -0xa5ad(%ebx),%eax
c002c248:	50                   	push   %eax
c002c249:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002c24f:	50                   	push   %eax
c002c250:	8d 83 84 4b ff ff    	lea    -0xb47c(%ebx),%eax
c002c256:	50                   	push   %eax
c002c257:	6a 4a                	push   $0x4a
c002c259:	8d 83 88 4e ff ff    	lea    -0xb178(%ebx),%eax
c002c25f:	50                   	push   %eax
c002c260:	e8 22 d0 ff ff       	call   c0029287 <debug_panic>
      pagedir_activate (pd);
c002c265:	83 ec 0c             	sub    $0xc,%esp
c002c268:	50                   	push   %eax
c002c269:	e8 4d ff ff ff       	call   c002c1bb <pagedir_activate>
c002c26e:	83 c4 10             	add    $0x10,%esp
}
c002c271:	eb c7                	jmp    c002c23a <invalidate_pagedir+0x24>

c002c273 <pagedir_clear_page>:
{
c002c273:	53                   	push   %ebx
c002c274:	83 ec 08             	sub    $0x8,%esp
c002c277:	e8 09 28 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c27c:	81 c3 38 ec 00 00    	add    $0xec38,%ebx
c002c282:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (pg_ofs (upage) == 0);
c002c286:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002c28c:	75 26                	jne    c002c2b4 <pagedir_clear_page+0x41>
  ASSERT (is_user_vaddr (upage));
c002c28e:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c294:	77 47                	ja     c002c2dd <pagedir_clear_page+0x6a>
  pte = lookup_page (pd, upage, false);
c002c296:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c29b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c29f:	e8 dc f8 ff ff       	call   c002bb80 <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002c2a4:	85 c0                	test   %eax,%eax
c002c2a6:	74 07                	je     c002c2af <pagedir_clear_page+0x3c>
c002c2a8:	8b 10                	mov    (%eax),%edx
c002c2aa:	f6 c2 01             	test   $0x1,%dl
c002c2ad:	75 57                	jne    c002c306 <pagedir_clear_page+0x93>
}
c002c2af:	83 c4 08             	add    $0x8,%esp
c002c2b2:	5b                   	pop    %ebx
c002c2b3:	c3                   	ret    
  ASSERT (pg_ofs (upage) == 0);
c002c2b4:	83 ec 0c             	sub    $0xc,%esp
c002c2b7:	8d 93 44 6e ff ff    	lea    -0x91bc(%ebx),%edx
c002c2bd:	52                   	push   %edx
c002c2be:	8d 93 45 4e ff ff    	lea    -0xb1bb(%ebx),%edx
c002c2c4:	52                   	push   %edx
c002c2c5:	8d 93 28 4b ff ff    	lea    -0xb4d8(%ebx),%edx
c002c2cb:	52                   	push   %edx
c002c2cc:	68 9d 00 00 00       	push   $0x9d
c002c2d1:	8d 93 0b 6e ff ff    	lea    -0x91f5(%ebx),%edx
c002c2d7:	52                   	push   %edx
c002c2d8:	e8 aa cf ff ff       	call   c0029287 <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002c2dd:	83 ec 0c             	sub    $0xc,%esp
c002c2e0:	8d 93 6c 6e ff ff    	lea    -0x9194(%ebx),%edx
c002c2e6:	52                   	push   %edx
c002c2e7:	8d 93 45 4e ff ff    	lea    -0xb1bb(%ebx),%edx
c002c2ed:	52                   	push   %edx
c002c2ee:	8d 93 28 4b ff ff    	lea    -0xb4d8(%ebx),%edx
c002c2f4:	52                   	push   %edx
c002c2f5:	68 9e 00 00 00       	push   $0x9e
c002c2fa:	8d 93 0b 6e ff ff    	lea    -0x91f5(%ebx),%edx
c002c300:	52                   	push   %edx
c002c301:	e8 81 cf ff ff       	call   c0029287 <debug_panic>
      *pte &= ~PTE_P;
c002c306:	83 e2 fe             	and    $0xfffffffe,%edx
c002c309:	89 10                	mov    %edx,(%eax)
      invalidate_pagedir (pd);
c002c30b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c30f:	e8 02 ff ff ff       	call   c002c216 <invalidate_pagedir>
}
c002c314:	eb 99                	jmp    c002c2af <pagedir_clear_page+0x3c>

c002c316 <pagedir_set_dirty>:
{
c002c316:	53                   	push   %ebx
c002c317:	83 ec 08             	sub    $0x8,%esp
c002c31a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page (pd, vpage, false);
c002c31e:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c323:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c327:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c32b:	e8 50 f8 ff ff       	call   c002bb80 <lookup_page>
  if (pte != NULL) 
c002c330:	85 c0                	test   %eax,%eax
c002c332:	74 07                	je     c002c33b <pagedir_set_dirty+0x25>
      if (dirty)
c002c334:	84 db                	test   %bl,%bl
c002c336:	74 08                	je     c002c340 <pagedir_set_dirty+0x2a>
        *pte |= PTE_D;
c002c338:	83 08 40             	orl    $0x40,(%eax)
}
c002c33b:	83 c4 08             	add    $0x8,%esp
c002c33e:	5b                   	pop    %ebx
c002c33f:	c3                   	ret    
          *pte &= ~(uint32_t) PTE_D;
c002c340:	83 20 bf             	andl   $0xffffffbf,(%eax)
          invalidate_pagedir (pd);
c002c343:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c347:	e8 ca fe ff ff       	call   c002c216 <invalidate_pagedir>
}
c002c34c:	eb ed                	jmp    c002c33b <pagedir_set_dirty+0x25>

c002c34e <pagedir_set_accessed>:
{
c002c34e:	53                   	push   %ebx
c002c34f:	83 ec 08             	sub    $0x8,%esp
c002c352:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page (pd, vpage, false);
c002c356:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c35b:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c35f:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c363:	e8 18 f8 ff ff       	call   c002bb80 <lookup_page>
  if (pte != NULL) 
c002c368:	85 c0                	test   %eax,%eax
c002c36a:	74 07                	je     c002c373 <pagedir_set_accessed+0x25>
      if (accessed)
c002c36c:	84 db                	test   %bl,%bl
c002c36e:	74 08                	je     c002c378 <pagedir_set_accessed+0x2a>
        *pte |= PTE_A;
c002c370:	83 08 20             	orl    $0x20,(%eax)
}
c002c373:	83 c4 08             	add    $0x8,%esp
c002c376:	5b                   	pop    %ebx
c002c377:	c3                   	ret    
          *pte &= ~(uint32_t) PTE_A; 
c002c378:	83 20 df             	andl   $0xffffffdf,(%eax)
          invalidate_pagedir (pd);
c002c37b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c37f:	e8 92 fe ff ff       	call   c002c216 <invalidate_pagedir>
}
c002c384:	eb ed                	jmp    c002c373 <pagedir_set_accessed+0x25>

c002c386 <kill>:
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill (struct intr_frame *f) 
{
c002c386:	55                   	push   %ebp
c002c387:	57                   	push   %edi
c002c388:	56                   	push   %esi
c002c389:	53                   	push   %ebx
c002c38a:	83 ec 0c             	sub    $0xc,%esp
c002c38d:	e8 f3 26 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c392:	81 c3 22 eb 00 00    	add    $0xeb22,%ebx
c002c398:	8b 74 24 20          	mov    0x20(%esp),%esi
     exceptions back to the process via signals, but we don't
     implement them. */
     
  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
c002c39c:	0f b7 7e 40          	movzwl 0x40(%esi),%edi
c002c3a0:	66 83 ff 08          	cmp    $0x8,%di
c002c3a4:	74 3a                	je     c002c3e0 <kill+0x5a>
c002c3a6:	66 83 ff 1b          	cmp    $0x1b,%di
c002c3aa:	75 59                	jne    c002c405 <kill+0x7f>
    {
    case SEL_UCSEG:
      /* User's code segment, so it's a user exception, as we
         expected.  Kill the user process.  */
      printf ("%s: dying due to interrupt %#04x (%s).\n",
c002c3ac:	83 ec 0c             	sub    $0xc,%esp
c002c3af:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002c3b3:	50                   	push   %eax
c002c3b4:	e8 e5 5f ff ff       	call   c002239e <intr_name>
c002c3b9:	89 c5                	mov    %eax,%ebp
c002c3bb:	8b 7e 30             	mov    0x30(%esi),%edi
c002c3be:	e8 82 4a ff ff       	call   c0020e45 <thread_name>
c002c3c3:	55                   	push   %ebp
c002c3c4:	57                   	push   %edi
c002c3c5:	50                   	push   %eax
c002c3c6:	8d 83 0c 6f ff ff    	lea    -0x90f4(%ebx),%eax
c002c3cc:	50                   	push   %eax
c002c3cd:	e8 1e b1 ff ff       	call   c00274f0 <printf>
              thread_name (), f->vec_no, intr_name (f->vec_no));
      intr_dump_frame (f);
c002c3d2:	83 c4 14             	add    $0x14,%esp
c002c3d5:	56                   	push   %esi
c002c3d6:	e8 22 5f ff ff       	call   c00222fd <intr_dump_frame>
      thread_exit (); 
c002c3db:	e8 01 4e ff ff       	call   c00211e1 <thread_exit>
    case SEL_KCSEG:
      /* Kernel's code segment, which indicates a kernel bug.
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.)  Panic the kernel to make the point.  */
      intr_dump_frame (f);
c002c3e0:	83 ec 0c             	sub    $0xc,%esp
c002c3e3:	56                   	push   %esi
c002c3e4:	e8 14 5f ff ff       	call   c00222fd <intr_dump_frame>
      PANIC ("Kernel bug - unexpected interrupt in kernel"); 
c002c3e9:	8d 83 34 6f ff ff    	lea    -0x90cc(%ebx),%eax
c002c3ef:	50                   	push   %eax
c002c3f0:	8d 83 a8 4b ff ff    	lea    -0xb458(%ebx),%eax
c002c3f6:	50                   	push   %eax
c002c3f7:	6a 6a                	push   $0x6a
c002c3f9:	8d 83 c3 6f ff ff    	lea    -0x903d(%ebx),%eax
c002c3ff:	50                   	push   %eax
c002c400:	e8 82 ce ff ff       	call   c0029287 <debug_panic>

    default:
      /* Some other code segment?  Shouldn't happen.  Panic the
         kernel. */
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002c405:	83 ec 0c             	sub    $0xc,%esp
c002c408:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002c40c:	50                   	push   %eax
c002c40d:	e8 8c 5f ff ff       	call   c002239e <intr_name>
  switch (f->cs)
c002c412:	0f b7 ff             	movzwl %di,%edi
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002c415:	57                   	push   %edi
c002c416:	50                   	push   %eax
c002c417:	ff 76 30             	pushl  0x30(%esi)
c002c41a:	8d 83 60 6f ff ff    	lea    -0x90a0(%ebx),%eax
c002c420:	50                   	push   %eax
c002c421:	e8 ca b0 ff ff       	call   c00274f0 <printf>
             f->vec_no, intr_name (f->vec_no), f->cs);
      thread_exit ();
c002c426:	83 c4 20             	add    $0x20,%esp
c002c429:	e8 b3 4d ff ff       	call   c00211e1 <thread_exit>

c002c42e <page_fault>:
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault (struct intr_frame *f) 
{
c002c42e:	55                   	push   %ebp
c002c42f:	57                   	push   %edi
c002c430:	56                   	push   %esi
c002c431:	53                   	push   %ebx
c002c432:	83 ec 14             	sub    $0x14,%esp
c002c435:	e8 4b 26 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c43a:	81 c3 7a ea 00 00    	add    $0xea7a,%ebx
c002c440:	8b 74 24 28          	mov    0x28(%esp),%esi
     data.  It is not necessarily the address of the instruction
     that caused the fault (that's f->eip).
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002c444:	0f 20 d7             	mov    %cr2,%edi

//  print("pagefault at %d\n", falt_addr);
  if (!syscall_translate_vaddr(fault_addr, false))
c002c447:	6a 00                	push   $0x0
c002c449:	57                   	push   %edi
c002c44a:	e8 9a 02 00 00       	call   c002c6e9 <syscall_translate_vaddr>
c002c44f:	83 c4 10             	add    $0x10,%esp
c002c452:	84 c0                	test   %al,%al
c002c454:	74 6c                	je     c002c4c2 <page_fault+0x94>
    thread_exit_with_return_value(f, -1);

  /* Turn interrupts back on (they were only off so that we could
     be assured of reading CR2 before it changed). */
  intr_enable ();
c002c456:	e8 8b 59 ff ff       	call   c0021de6 <intr_enable>

  /* Count page faults. */
  page_fault_cnt++;
c002c45b:	83 83 d4 22 00 00 01 	addl   $0x1,0x22d4(%ebx)
c002c462:	83 93 d8 22 00 00 00 	adcl   $0x0,0x22d8(%ebx)
  

  /* Determine cause. */
  not_present = (f->error_code & PF_P) == 0;
c002c469:	8b 46 34             	mov    0x34(%esi),%eax
#endif

    /* To implement virtual memory, delete the rest of the function
     body, and replace it with code that brings in the page to
     which fault_addr refers. */
	printf ("Page fault at %p: %s error %s page in %s context.\n",
c002c46c:	89 c2                	mov    %eax,%edx
c002c46e:	83 e2 04             	and    $0x4,%edx
c002c471:	8d 8b de 6f ff ff    	lea    -0x9022(%ebx),%ecx
c002c477:	8d 93 ac 5f ff ff    	lea    -0xa054(%ebx),%edx
c002c47d:	0f 44 ca             	cmove  %edx,%ecx
c002c480:	89 c2                	mov    %eax,%edx
c002c482:	83 e2 02             	and    $0x2,%edx
c002c485:	8d ab e3 6f ff ff    	lea    -0x901d(%ebx),%ebp
c002c48b:	8d 93 eb 6f ff ff    	lea    -0x9015(%ebx),%edx
c002c491:	0f 45 d5             	cmovne %ebp,%edx
c002c494:	83 e0 01             	and    $0x1,%eax
c002c497:	8d 83 f3 6f ff ff    	lea    -0x900d(%ebx),%eax
c002c49d:	8d ab ff 6f ff ff    	lea    -0x9001(%ebx),%ebp
c002c4a3:	0f 45 c5             	cmovne %ebp,%eax
c002c4a6:	83 ec 0c             	sub    $0xc,%esp
c002c4a9:	51                   	push   %ecx
c002c4aa:	52                   	push   %edx
c002c4ab:	50                   	push   %eax
c002c4ac:	57                   	push   %edi
c002c4ad:	8d 83 90 6f ff ff    	lea    -0x9070(%ebx),%eax
c002c4b3:	50                   	push   %eax
c002c4b4:	e8 37 b0 ff ff       	call   c00274f0 <printf>
		  fault_addr,
		  not_present ? "not present" : "rights violation",
		  write ? "writing" : "reading",
		  user ? "user" : "kernel");
	kill (f);
c002c4b9:	83 c4 14             	add    $0x14,%esp
c002c4bc:	56                   	push   %esi
c002c4bd:	e8 c4 fe ff ff       	call   c002c386 <kill>
    thread_exit_with_return_value(f, -1);
c002c4c2:	83 ec 08             	sub    $0x8,%esp
c002c4c5:	6a ff                	push   $0xffffffff
c002c4c7:	56                   	push   %esi
c002c4c8:	e8 98 56 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c4cd:	83 c4 10             	add    $0x10,%esp
c002c4d0:	eb 84                	jmp    c002c456 <page_fault+0x28>

c002c4d2 <exception_init>:
{
c002c4d2:	56                   	push   %esi
c002c4d3:	53                   	push   %ebx
c002c4d4:	83 ec 10             	sub    $0x10,%esp
c002c4d7:	e8 a9 25 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c4dc:	81 c3 d8 e9 00 00    	add    $0xe9d8,%ebx
  intr_register_int (3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002c4e2:	8d 83 16 56 ff ff    	lea    -0xa9ea(%ebx),%eax
c002c4e8:	50                   	push   %eax
c002c4e9:	8d b3 d2 14 ff ff    	lea    -0xeb2e(%ebx),%esi
c002c4ef:	56                   	push   %esi
c002c4f0:	6a 01                	push   $0x1
c002c4f2:	6a 03                	push   $0x3
c002c4f4:	6a 03                	push   $0x3
c002c4f6:	e8 74 5b ff ff       	call   c002206f <intr_register_int>
  intr_register_int (4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002c4fb:	83 c4 14             	add    $0x14,%esp
c002c4fe:	8d 83 2f 56 ff ff    	lea    -0xa9d1(%ebx),%eax
c002c504:	50                   	push   %eax
c002c505:	56                   	push   %esi
c002c506:	6a 01                	push   $0x1
c002c508:	6a 03                	push   $0x3
c002c50a:	6a 04                	push   $0x4
c002c50c:	e8 5e 5b ff ff       	call   c002206f <intr_register_int>
  intr_register_int (5, 3, INTR_ON, kill,
c002c511:	83 c4 14             	add    $0x14,%esp
c002c514:	8d 83 6c 57 ff ff    	lea    -0xa894(%ebx),%eax
c002c51a:	50                   	push   %eax
c002c51b:	56                   	push   %esi
c002c51c:	6a 01                	push   $0x1
c002c51e:	6a 03                	push   $0x3
c002c520:	6a 05                	push   $0x5
c002c522:	e8 48 5b ff ff       	call   c002206f <intr_register_int>
  intr_register_int (0, 0, INTR_ON, kill, "#DE Divide Error");
c002c527:	83 c4 14             	add    $0x14,%esp
c002c52a:	8d 83 e3 55 ff ff    	lea    -0xaa1d(%ebx),%eax
c002c530:	50                   	push   %eax
c002c531:	56                   	push   %esi
c002c532:	6a 01                	push   $0x1
c002c534:	6a 00                	push   $0x0
c002c536:	6a 00                	push   $0x0
c002c538:	e8 32 5b ff ff       	call   c002206f <intr_register_int>
  intr_register_int (1, 0, INTR_ON, kill, "#DB Debug Exception");
c002c53d:	83 c4 14             	add    $0x14,%esp
c002c540:	8d 83 f4 55 ff ff    	lea    -0xaa0c(%ebx),%eax
c002c546:	50                   	push   %eax
c002c547:	56                   	push   %esi
c002c548:	6a 01                	push   $0x1
c002c54a:	6a 00                	push   $0x0
c002c54c:	6a 01                	push   $0x1
c002c54e:	e8 1c 5b ff ff       	call   c002206f <intr_register_int>
  intr_register_int (6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002c553:	83 c4 14             	add    $0x14,%esp
c002c556:	8d 83 46 56 ff ff    	lea    -0xa9ba(%ebx),%eax
c002c55c:	50                   	push   %eax
c002c55d:	56                   	push   %esi
c002c55e:	6a 01                	push   $0x1
c002c560:	6a 00                	push   $0x0
c002c562:	6a 06                	push   $0x6
c002c564:	e8 06 5b ff ff       	call   c002206f <intr_register_int>
  intr_register_int (7, 0, INTR_ON, kill,
c002c569:	83 c4 14             	add    $0x14,%esp
c002c56c:	8d 83 90 57 ff ff    	lea    -0xa870(%ebx),%eax
c002c572:	50                   	push   %eax
c002c573:	56                   	push   %esi
c002c574:	6a 01                	push   $0x1
c002c576:	6a 00                	push   $0x0
c002c578:	6a 07                	push   $0x7
c002c57a:	e8 f0 5a ff ff       	call   c002206f <intr_register_int>
  intr_register_int (11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002c57f:	83 c4 14             	add    $0x14,%esp
c002c582:	8d 83 b4 56 ff ff    	lea    -0xa94c(%ebx),%eax
c002c588:	50                   	push   %eax
c002c589:	56                   	push   %esi
c002c58a:	6a 01                	push   $0x1
c002c58c:	6a 00                	push   $0x0
c002c58e:	6a 0b                	push   $0xb
c002c590:	e8 da 5a ff ff       	call   c002206f <intr_register_int>
  intr_register_int (12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002c595:	83 c4 14             	add    $0x14,%esp
c002c598:	8d 83 cc 56 ff ff    	lea    -0xa934(%ebx),%eax
c002c59e:	50                   	push   %eax
c002c59f:	56                   	push   %esi
c002c5a0:	6a 01                	push   $0x1
c002c5a2:	6a 00                	push   $0x0
c002c5a4:	6a 0c                	push   $0xc
c002c5a6:	e8 c4 5a ff ff       	call   c002206f <intr_register_int>
  intr_register_int (13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002c5ab:	83 c4 14             	add    $0x14,%esp
c002c5ae:	8d 83 b4 57 ff ff    	lea    -0xa84c(%ebx),%eax
c002c5b4:	50                   	push   %eax
c002c5b5:	56                   	push   %esi
c002c5b6:	6a 01                	push   $0x1
c002c5b8:	6a 00                	push   $0x0
c002c5ba:	6a 0d                	push   $0xd
c002c5bc:	e8 ae 5a ff ff       	call   c002206f <intr_register_int>
  intr_register_int (16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002c5c1:	83 c4 14             	add    $0x14,%esp
c002c5c4:	8d 83 d8 57 ff ff    	lea    -0xa828(%ebx),%eax
c002c5ca:	50                   	push   %eax
c002c5cb:	56                   	push   %esi
c002c5cc:	6a 01                	push   $0x1
c002c5ce:	6a 00                	push   $0x0
c002c5d0:	6a 10                	push   $0x10
c002c5d2:	e8 98 5a ff ff       	call   c002206f <intr_register_int>
  intr_register_int (19, 0, INTR_ON, kill,
c002c5d7:	83 c4 14             	add    $0x14,%esp
c002c5da:	8d 83 fc 57 ff ff    	lea    -0xa804(%ebx),%eax
c002c5e0:	50                   	push   %eax
c002c5e1:	56                   	push   %esi
c002c5e2:	6a 01                	push   $0x1
c002c5e4:	6a 00                	push   $0x0
c002c5e6:	6a 13                	push   $0x13
c002c5e8:	e8 82 5a ff ff       	call   c002206f <intr_register_int>
  intr_register_int (14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002c5ed:	83 c4 14             	add    $0x14,%esp
c002c5f0:	8d 83 e6 56 ff ff    	lea    -0xa91a(%ebx),%eax
c002c5f6:	50                   	push   %eax
c002c5f7:	8d 83 7a 15 ff ff    	lea    -0xea86(%ebx),%eax
c002c5fd:	50                   	push   %eax
c002c5fe:	6a 00                	push   $0x0
c002c600:	6a 00                	push   $0x0
c002c602:	6a 0e                	push   $0xe
c002c604:	e8 66 5a ff ff       	call   c002206f <intr_register_int>
}
c002c609:	83 c4 24             	add    $0x24,%esp
c002c60c:	5b                   	pop    %ebx
c002c60d:	5e                   	pop    %esi
c002c60e:	c3                   	ret    

c002c60f <exception_print_stats>:
{
c002c60f:	53                   	push   %ebx
c002c610:	83 ec 0c             	sub    $0xc,%esp
c002c613:	e8 6d 24 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c618:	81 c3 9c e8 00 00    	add    $0xe89c,%ebx
  printf ("Exception: %lld page faults\n", page_fault_cnt);
c002c61e:	ff b3 d8 22 00 00    	pushl  0x22d8(%ebx)
c002c624:	ff b3 d4 22 00 00    	pushl  0x22d4(%ebx)
c002c62a:	8d 83 10 70 ff ff    	lea    -0x8ff0(%ebx),%eax
c002c630:	50                   	push   %eax
c002c631:	e8 ba ae ff ff       	call   c00274f0 <printf>
}
c002c636:	83 c4 18             	add    $0x18,%esp
c002c639:	5b                   	pop    %ebx
c002c63a:	c3                   	ret    

c002c63b <syscall_init>:


//system call init 
void
syscall_init (void)
{
c002c63b:	53                   	push   %ebx
c002c63c:	83 ec 14             	sub    $0x14,%esp
c002c63f:	e8 41 24 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c644:	81 c3 70 e8 00 00    	add    $0xe870,%ebx
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
c002c64a:	8d 83 2d 70 ff ff    	lea    -0x8fd3(%ebx),%eax
c002c650:	50                   	push   %eax
c002c651:	8d 83 42 19 ff ff    	lea    -0xe6be(%ebx),%eax
c002c657:	50                   	push   %eax
c002c658:	6a 01                	push   $0x1
c002c65a:	6a 03                	push   $0x3
c002c65c:	6a 30                	push   $0x30
c002c65e:	e8 0c 5a ff ff       	call   c002206f <intr_register_int>
  lock_init(&filesys_lock);
c002c663:	83 c4 14             	add    $0x14,%esp
c002c666:	8d 83 ec 22 00 00    	lea    0x22ec(%ebx),%eax
c002c66c:	50                   	push   %eax
c002c66d:	e8 08 6c ff ff       	call   c002327a <lock_init>
}
c002c672:	83 c4 18             	add    $0x18,%esp
c002c675:	5b                   	pop    %ebx
c002c676:	c3                   	ret    

c002c677 <syscall_file_close>:
//```````````````````````````````````````````````````````````````````````````````
//```````````````````````````````````````````````````````````````````````````````
//```````````````````````````````````````````````````````````````````````````````

//外部接口，供threads.c使用
void syscall_file_close(struct file* file){
c002c677:	56                   	push   %esi
c002c678:	53                   	push   %ebx
c002c679:	83 ec 10             	sub    $0x10,%esp
c002c67c:	e8 04 24 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c681:	81 c3 33 e8 00 00    	add    $0xe833,%ebx
  lock_acquire(&filesys_lock);
c002c687:	8d b3 ec 22 00 00    	lea    0x22ec(%ebx),%esi
c002c68d:	56                   	push   %esi
c002c68e:	e8 93 6c ff ff       	call   c0023326 <lock_acquire>
  file_close(file);
c002c693:	83 c4 04             	add    $0x4,%esp
c002c696:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c69a:	e8 af 0f 00 00       	call   c002d64e <file_close>
  lock_release(&filesys_lock);
c002c69f:	89 34 24             	mov    %esi,(%esp)
c002c6a2:	e8 77 6e ff ff       	call   c002351e <lock_release>
}
c002c6a7:	83 c4 14             	add    $0x14,%esp
c002c6aa:	5b                   	pop    %ebx
c002c6ab:	5e                   	pop    %esi
c002c6ac:	c3                   	ret    

c002c6ad <syscall_file_open>:

struct file* syscall_file_open(const char * name){
c002c6ad:	57                   	push   %edi
c002c6ae:	56                   	push   %esi
c002c6af:	53                   	push   %ebx
c002c6b0:	e8 d0 23 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c6b5:	81 c3 ff e7 00 00    	add    $0xe7ff,%ebx
  lock_acquire(&filesys_lock);
c002c6bb:	83 ec 0c             	sub    $0xc,%esp
c002c6be:	8d b3 ec 22 00 00    	lea    0x22ec(%ebx),%esi
c002c6c4:	56                   	push   %esi
c002c6c5:	e8 5c 6c ff ff       	call   c0023326 <lock_acquire>
  struct file* File = filesys_open(name);
c002c6ca:	83 c4 04             	add    $0x4,%esp
c002c6cd:	ff 74 24 1c          	pushl  0x1c(%esp)
c002c6d1:	e8 35 0a 00 00       	call   c002d10b <filesys_open>
c002c6d6:	89 c7                	mov    %eax,%edi
  lock_release(&filesys_lock);
c002c6d8:	89 34 24             	mov    %esi,(%esp)
c002c6db:	e8 3e 6e ff ff       	call   c002351e <lock_release>
  return File;
c002c6e0:	83 c4 10             	add    $0x10,%esp
}
c002c6e3:	89 f8                	mov    %edi,%eax
c002c6e5:	5b                   	pop    %ebx
c002c6e6:	5e                   	pop    %esi
c002c6e7:	5f                   	pop    %edi
c002c6e8:	c3                   	ret    

c002c6e9 <syscall_translate_vaddr>:
}


/* user Vaddr to kernel vaddr */
bool
syscall_translate_vaddr(const void *vaddr, bool write){
c002c6e9:	56                   	push   %esi
c002c6ea:	53                   	push   %ebx
c002c6eb:	83 ec 04             	sub    $0x4,%esp
c002c6ee:	e8 92 23 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c6f3:	81 c3 c1 e7 00 00    	add    $0xe7c1,%ebx
c002c6f9:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (vaddr == NULL || !is_user_vaddr(vaddr))
c002c6fd:	8d 56 ff             	lea    -0x1(%esi),%edx
    return false;
c002c700:	b8 00 00 00 00       	mov    $0x0,%eax
  if (vaddr == NULL || !is_user_vaddr(vaddr))
c002c705:	81 fa fe ff ff bf    	cmp    $0xbffffffe,%edx
c002c70b:	76 06                	jbe    c002c713 <syscall_translate_vaddr+0x2a>
  else return !(write && !(base->writable));
#else
  ASSERT(vaddr != NULL);
  return pagedir_get_page(thread_current()->pagedir, vaddr) != NULL;
#endif
}
c002c70d:	83 c4 04             	add    $0x4,%esp
c002c710:	5b                   	pop    %ebx
c002c711:	5e                   	pop    %esi
c002c712:	c3                   	ret    
  return pagedir_get_page(thread_current()->pagedir, vaddr) != NULL;
c002c713:	e8 3c 46 ff ff       	call   c0020d54 <thread_current>
c002c718:	83 ec 08             	sub    $0x8,%esp
c002c71b:	56                   	push   %esi
c002c71c:	ff b0 a0 00 00 00    	pushl  0xa0(%eax)
c002c722:	e8 48 f9 ff ff       	call   c002c06f <pagedir_get_page>
c002c727:	83 c4 10             	add    $0x10,%esp
c002c72a:	85 c0                	test   %eax,%eax
c002c72c:	0f 95 c0             	setne  %al
c002c72f:	eb dc                	jmp    c002c70d <syscall_translate_vaddr+0x24>

c002c731 <syscall_check_user_string>:
syscall_check_user_string(const char *ustr){
c002c731:	55                   	push   %ebp
c002c732:	57                   	push   %edi
c002c733:	56                   	push   %esi
c002c734:	53                   	push   %ebx
c002c735:	83 ec 14             	sub    $0x14,%esp
c002c738:	e8 60 23 00 00       	call   c002ea9d <__x86.get_pc_thunk.bp>
c002c73d:	81 c5 77 e7 00 00    	add    $0xe777,%ebp
c002c743:	8b 74 24 28          	mov    0x28(%esp),%esi
  if (!syscall_translate_vaddr(ustr, false))
c002c747:	6a 00                	push   $0x0
c002c749:	56                   	push   %esi
c002c74a:	e8 9a ff ff ff       	call   c002c6e9 <syscall_translate_vaddr>
c002c74f:	89 c3                	mov    %eax,%ebx
c002c751:	83 c4 10             	add    $0x10,%esp
c002c754:	8d be ff 0f 00 00    	lea    0xfff(%esi),%edi
c002c75a:	84 c0                	test   %al,%al
c002c75c:	74 28                	je     c002c786 <syscall_check_user_string+0x55>
  while(*ustr != '\0'){
c002c75e:	80 3e 00             	cmpb   $0x0,(%esi)
c002c761:	74 23                	je     c002c786 <syscall_check_user_string+0x55>
    if(cnt == 4095){
c002c763:	39 fe                	cmp    %edi,%esi
c002c765:	74 29                	je     c002c790 <syscall_check_user_string+0x5f>
    ustr++;
c002c767:	83 c6 01             	add    $0x1,%esi
    if (((int)ustr & PGMASK) == 0){
c002c76a:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002c770:	75 ec                	jne    c002c75e <syscall_check_user_string+0x2d>
      if (!syscall_translate_vaddr(ustr, false))
c002c772:	83 ec 08             	sub    $0x8,%esp
c002c775:	6a 00                	push   $0x0
c002c777:	56                   	push   %esi
c002c778:	e8 6c ff ff ff       	call   c002c6e9 <syscall_translate_vaddr>
c002c77d:	83 c4 10             	add    $0x10,%esp
c002c780:	84 c0                	test   %al,%al
c002c782:	75 da                	jne    c002c75e <syscall_check_user_string+0x2d>
        return false;
c002c784:	89 c3                	mov    %eax,%ebx
}
c002c786:	89 d8                	mov    %ebx,%eax
c002c788:	83 c4 0c             	add    $0xc,%esp
c002c78b:	5b                   	pop    %ebx
c002c78c:	5e                   	pop    %esi
c002c78d:	5f                   	pop    %edi
c002c78e:	5d                   	pop    %ebp
c002c78f:	c3                   	ret    
      puts("String is so long, it should be no longer than 4096 Bytes!\n");
c002c790:	83 ec 0c             	sub    $0xc,%esp
c002c793:	8d 85 38 70 ff ff    	lea    -0x8fc8(%ebp),%eax
c002c799:	50                   	push   %eax
c002c79a:	89 eb                	mov    %ebp,%ebx
c002c79c:	e8 bf ea ff ff       	call   c002b260 <puts>
      return false;
c002c7a1:	83 c4 10             	add    $0x10,%esp
c002c7a4:	bb 00 00 00 00       	mov    $0x0,%ebx
c002c7a9:	eb db                	jmp    c002c786 <syscall_check_user_string+0x55>

c002c7ab <syscall_check_user_buffer>:
syscall_check_user_buffer(const char* ustr, int size, bool write){
c002c7ab:	57                   	push   %edi
c002c7ac:	56                   	push   %esi
c002c7ad:	53                   	push   %ebx
c002c7ae:	8b 74 24 10          	mov    0x10(%esp),%esi
c002c7b2:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  if (!syscall_translate_vaddr(ustr+size-1, write))
c002c7b6:	0f b6 7c 24 18       	movzbl 0x18(%esp),%edi
c002c7bb:	83 ec 08             	sub    $0x8,%esp
c002c7be:	57                   	push   %edi
c002c7bf:	8d 44 1e ff          	lea    -0x1(%esi,%ebx,1),%eax
c002c7c3:	50                   	push   %eax
c002c7c4:	e8 20 ff ff ff       	call   c002c6e9 <syscall_translate_vaddr>
c002c7c9:	83 c4 10             	add    $0x10,%esp
c002c7cc:	84 c0                	test   %al,%al
c002c7ce:	74 22                	je     c002c7f2 <syscall_check_user_buffer+0x47>
  size>>=12;
c002c7d0:	c1 fb 0c             	sar    $0xc,%ebx
    if (!syscall_translate_vaddr(ustr, write))
c002c7d3:	83 ec 08             	sub    $0x8,%esp
c002c7d6:	57                   	push   %edi
c002c7d7:	56                   	push   %esi
c002c7d8:	e8 0c ff ff ff       	call   c002c6e9 <syscall_translate_vaddr>
c002c7dd:	83 c4 10             	add    $0x10,%esp
c002c7e0:	84 c0                	test   %al,%al
c002c7e2:	74 0e                	je     c002c7f2 <syscall_check_user_buffer+0x47>
    ustr+=1<<12;
c002c7e4:	81 c6 00 10 00 00    	add    $0x1000,%esi
  }while(size--);
c002c7ea:	83 eb 01             	sub    $0x1,%ebx
c002c7ed:	83 fb ff             	cmp    $0xffffffff,%ebx
c002c7f0:	75 e1                	jne    c002c7d3 <syscall_check_user_buffer+0x28>
}
c002c7f2:	5b                   	pop    %ebx
c002c7f3:	5e                   	pop    %esi
c002c7f4:	5f                   	pop    %edi
c002c7f5:	c3                   	ret    

c002c7f6 <syscall_handler>:
static void syscall_handler (struct intr_frame *f){
c002c7f6:	55                   	push   %ebp
c002c7f7:	57                   	push   %edi
c002c7f8:	56                   	push   %esi
c002c7f9:	53                   	push   %ebx
c002c7fa:	83 ec 20             	sub    $0x20,%esp
c002c7fd:	e8 83 22 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002c802:	81 c3 b2 e6 00 00    	add    $0xe6b2,%ebx
c002c808:	8b 74 24 34          	mov    0x34(%esp),%esi
  if (!syscall_check_user_buffer(f->esp,4,false))
c002c80c:	6a 00                	push   $0x0
c002c80e:	6a 04                	push   $0x4
c002c810:	ff 76 48             	pushl  0x48(%esi)
c002c813:	e8 93 ff ff ff       	call   c002c7ab <syscall_check_user_buffer>
c002c818:	83 c4 10             	add    $0x10,%esp
c002c81b:	84 c0                	test   %al,%al
c002c81d:	74 18                	je     c002c837 <syscall_handler+0x41>
  int call_num=*((int *)f->esp);
c002c81f:	8b 7e 48             	mov    0x48(%esi),%edi
c002c822:	8b 2f                	mov    (%edi),%ebp
  void *arg1 = f->esp + 4, *arg2 = f->esp + 8, *arg3 = f->esp + 12;
c002c824:	8d 47 04             	lea    0x4(%edi),%eax
  switch (call_num){
c002c827:	83 fd 0c             	cmp    $0xc,%ebp
c002c82a:	77 2f                	ja     c002c85b <.L28>
c002c82c:	89 da                	mov    %ebx,%edx
c002c82e:	03 94 ab b0 4b ff ff 	add    -0xb450(%ebx,%ebp,4),%edx
c002c835:	ff e2                	jmp    *%edx
    thread_exit_with_return_value(f,-1);
c002c837:	83 ec 08             	sub    $0x8,%esp
c002c83a:	6a ff                	push   $0xffffffff
c002c83c:	56                   	push   %esi
c002c83d:	e8 23 53 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c842:	83 c4 10             	add    $0x10,%esp
c002c845:	eb d8                	jmp    c002c81f <syscall_handler+0x29>

c002c847 <.L29>:
      if (!syscall_check_user_buffer(arg1, 4, false))
c002c847:	83 ec 04             	sub    $0x4,%esp
c002c84a:	6a 00                	push   $0x0
c002c84c:	6a 04                	push   $0x4
c002c84e:	50                   	push   %eax
c002c84f:	e8 57 ff ff ff       	call   c002c7ab <syscall_check_user_buffer>
c002c854:	83 c4 10             	add    $0x10,%esp
c002c857:	84 c0                	test   %al,%al
c002c859:	74 14                	je     c002c86f <.L28+0x14>

c002c85b <.L28>:
  switch (call_num)
c002c85b:	83 fd 0c             	cmp    $0xc,%ebp
c002c85e:	0f 87 7b 05 00 00    	ja     c002cddf <.L44+0xbb>
c002c864:	89 d8                	mov    %ebx,%eax
c002c866:	03 84 ab e4 4b ff ff 	add    -0xb41c(%ebx,%ebp,4),%eax
c002c86d:	ff e0                	jmp    *%eax
        thread_exit_with_return_value(f, -1);
c002c86f:	83 ec 08             	sub    $0x8,%esp
c002c872:	6a ff                	push   $0xffffffff
c002c874:	56                   	push   %esi
c002c875:	e8 eb 52 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c87a:	83 c4 10             	add    $0x10,%esp
c002c87d:	eb dc                	jmp    c002c85b <.L28>

c002c87f <.L31>:
      if (!syscall_check_user_buffer(arg1, 8, false))
c002c87f:	83 ec 04             	sub    $0x4,%esp
c002c882:	6a 00                	push   $0x0
c002c884:	6a 08                	push   $0x8
c002c886:	50                   	push   %eax
c002c887:	e8 1f ff ff ff       	call   c002c7ab <syscall_check_user_buffer>
c002c88c:	83 c4 10             	add    $0x10,%esp
c002c88f:	84 c0                	test   %al,%al
c002c891:	75 c8                	jne    c002c85b <.L28>
        thread_exit_with_return_value(f, -1);
c002c893:	83 ec 08             	sub    $0x8,%esp
c002c896:	6a ff                	push   $0xffffffff
c002c898:	56                   	push   %esi
c002c899:	e8 c7 52 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c89e:	83 c4 10             	add    $0x10,%esp
c002c8a1:	eb b8                	jmp    c002c85b <.L28>

c002c8a3 <.L32>:
      if (!syscall_check_user_buffer(arg1, 12, false))
c002c8a3:	83 ec 04             	sub    $0x4,%esp
c002c8a6:	6a 00                	push   $0x0
c002c8a8:	6a 0c                	push   $0xc
c002c8aa:	50                   	push   %eax
c002c8ab:	e8 fb fe ff ff       	call   c002c7ab <syscall_check_user_buffer>
c002c8b0:	83 c4 10             	add    $0x10,%esp
c002c8b3:	84 c0                	test   %al,%al
c002c8b5:	75 a4                	jne    c002c85b <.L28>
        thread_exit_with_return_value(f, -1);
c002c8b7:	83 ec 08             	sub    $0x8,%esp
c002c8ba:	6a ff                	push   $0xffffffff
c002c8bc:	56                   	push   %esi
c002c8bd:	e8 a3 52 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c8c2:	83 c4 10             	add    $0x10,%esp
c002c8c5:	eb 94                	jmp    c002c85b <.L28>

c002c8c7 <.L34>:
  shutdown_power_off();
c002c8c7:	e8 79 a4 ff ff       	call   c0026d45 <shutdown_power_off>

c002c8cc <.L36>:
      syscall_exit(f,*((int *)arg1));
c002c8cc:	8b 7f 04             	mov    0x4(%edi),%edi
  struct thread *cur = thread_current ();
c002c8cf:	e8 80 44 ff ff       	call   c0020d54 <thread_current>
  if (!cur->grandpa_died)
c002c8d4:	80 b8 98 00 00 00 00 	cmpb   $0x0,0x98(%eax)
c002c8db:	75 13                	jne    c002c8f0 <.L36+0x24>
    cur->message_to_grandpa->exited = true;
c002c8dd:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
c002c8e3:	c6 42 08 01          	movb   $0x1,0x8(%edx)
    cur->message_to_grandpa->return_value = return_value;
c002c8e7:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
c002c8ed:	89 78 0c             	mov    %edi,0xc(%eax)
  thread_exit_with_return_value(f, return_value);
c002c8f0:	83 ec 08             	sub    $0x8,%esp
c002c8f3:	57                   	push   %edi
c002c8f4:	56                   	push   %esi
c002c8f5:	e8 6b 52 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c8fa:	83 c4 10             	add    $0x10,%esp
}
c002c8fd:	83 c4 1c             	add    $0x1c,%esp
c002c900:	5b                   	pop    %ebx
c002c901:	5e                   	pop    %esi
c002c902:	5f                   	pop    %edi
c002c903:	5d                   	pop    %ebp
c002c904:	c3                   	ret    

c002c905 <.L37>:
      syscall_exec(f,*((void **)arg1));
c002c905:	8b 6f 04             	mov    0x4(%edi),%ebp
  if (!syscall_check_user_string(cmd_line))
c002c908:	83 ec 0c             	sub    $0xc,%esp
c002c90b:	55                   	push   %ebp
c002c90c:	e8 20 fe ff ff       	call   c002c731 <syscall_check_user_string>
c002c911:	83 c4 10             	add    $0x10,%esp
c002c914:	84 c0                	test   %al,%al
c002c916:	74 5f                	je     c002c977 <.L37+0x72>
  lock_acquire(&filesys_lock);
c002c918:	83 ec 0c             	sub    $0xc,%esp
c002c91b:	8d bb ec 22 00 00    	lea    0x22ec(%ebx),%edi
c002c921:	57                   	push   %edi
c002c922:	e8 ff 69 ff ff       	call   c0023326 <lock_acquire>
  f->eax = (uint32_t)process_execute (cmd_line);
c002c927:	89 2c 24             	mov    %ebp,(%esp)
c002c92a:	e8 26 ea ff ff       	call   c002b355 <process_execute>
c002c92f:	89 46 1c             	mov    %eax,0x1c(%esi)
  lock_release(&filesys_lock);
c002c932:	89 3c 24             	mov    %edi,(%esp)
c002c935:	e8 e4 6b ff ff       	call   c002351e <lock_release>
  struct thread *cur = thread_current ();
c002c93a:	e8 15 44 ff ff       	call   c0020d54 <thread_current>
  for (e=list_begin (&cur->child_list); e != list_end (&cur->child_list); e = list_next (e))
c002c93f:	8d 68 60             	lea    0x60(%eax),%ebp
c002c942:	89 2c 24             	mov    %ebp,(%esp)
c002c945:	e8 62 ca ff ff       	call   c00293ac <list_begin>
c002c94a:	89 c7                	mov    %eax,%edi
c002c94c:	83 c4 10             	add    $0x10,%esp
c002c94f:	83 ec 0c             	sub    $0xc,%esp
c002c952:	55                   	push   %ebp
c002c953:	e8 f6 ca ff ff       	call   c002944e <list_end>
c002c958:	83 c4 10             	add    $0x10,%esp
c002c95b:	39 c7                	cmp    %eax,%edi
c002c95d:	74 9e                	je     c002c8fd <.L36+0x31>
    if(l->tid==f->eax)
c002c95f:	8b 46 1c             	mov    0x1c(%esi),%eax
c002c962:	39 47 ec             	cmp    %eax,-0x14(%edi)
c002c965:	74 20                	je     c002c987 <.L37+0x82>
  for (e=list_begin (&cur->child_list); e != list_end (&cur->child_list); e = list_next (e))
c002c967:	83 ec 0c             	sub    $0xc,%esp
c002c96a:	57                   	push   %edi
c002c96b:	e8 81 ca ff ff       	call   c00293f1 <list_next>
c002c970:	89 c7                	mov    %eax,%edi
c002c972:	83 c4 10             	add    $0x10,%esp
c002c975:	eb d8                	jmp    c002c94f <.L37+0x4a>
    thread_exit_with_return_value(f, -1);
c002c977:	83 ec 08             	sub    $0x8,%esp
c002c97a:	6a ff                	push   $0xffffffff
c002c97c:	56                   	push   %esi
c002c97d:	e8 e3 51 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002c982:	83 c4 10             	add    $0x10,%esp
c002c985:	eb 91                	jmp    c002c918 <.L37+0x13>
      sema_down (l->sema_started);
c002c987:	83 ec 0c             	sub    $0xc,%esp
c002c98a:	ff 77 fc             	pushl  -0x4(%edi)
c002c98d:	e8 66 66 ff ff       	call   c0022ff8 <sema_down>
      if (l->load_failed)
c002c992:	83 c4 10             	add    $0x10,%esp
c002c995:	80 7f f2 00          	cmpb   $0x0,-0xe(%edi)
c002c999:	0f 84 5e ff ff ff    	je     c002c8fd <.L36+0x31>
        f->eax = (uint32_t)-1;
c002c99f:	c7 46 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%esi)
c002c9a6:	e9 52 ff ff ff       	jmp    c002c8fd <.L36+0x31>

c002c9ab <.L38>:
  f->eax=(uint32_t)process_wait(pid);
c002c9ab:	83 ec 0c             	sub    $0xc,%esp
c002c9ae:	ff 77 04             	pushl  0x4(%edi)
c002c9b1:	e8 6d ea ff ff       	call   c002b423 <process_wait>
c002c9b6:	89 46 1c             	mov    %eax,0x1c(%esi)
c002c9b9:	83 c4 10             	add    $0x10,%esp
c002c9bc:	e9 3c ff ff ff       	jmp    c002c8fd <.L36+0x31>

c002c9c1 <.L46>:
  struct file_handle* t = syscall_get_file_handle(fd);
c002c9c1:	83 ec 0c             	sub    $0xc,%esp
c002c9c4:	ff 77 04             	pushl  0x4(%edi)
c002c9c7:	e8 dd 51 ff ff       	call   c0021ba9 <syscall_get_file_handle>
c002c9cc:	89 c7                	mov    %eax,%edi
  if (t != NULL){
c002c9ce:	83 c4 10             	add    $0x10,%esp
c002c9d1:	85 c0                	test   %eax,%eax
c002c9d3:	74 2d                	je     c002ca02 <.L46+0x41>
    lock_acquire(&filesys_lock);
c002c9d5:	83 ec 0c             	sub    $0xc,%esp
c002c9d8:	8d ab ec 22 00 00    	lea    0x22ec(%ebx),%ebp
c002c9de:	55                   	push   %ebp
c002c9df:	e8 42 69 ff ff       	call   c0023326 <lock_acquire>
    f->eax = (uint32_t)file_tell(t->opened_file);
c002c9e4:	83 c4 04             	add    $0x4,%esp
c002c9e7:	ff 77 04             	pushl  0x4(%edi)
c002c9ea:	e8 63 0d 00 00       	call   c002d752 <file_tell>
c002c9ef:	89 46 1c             	mov    %eax,0x1c(%esi)
    lock_release(&filesys_lock);
c002c9f2:	89 2c 24             	mov    %ebp,(%esp)
c002c9f5:	e8 24 6b ff ff       	call   c002351e <lock_release>
c002c9fa:	83 c4 10             	add    $0x10,%esp
c002c9fd:	e9 fb fe ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002ca02:	83 ec 08             	sub    $0x8,%esp
c002ca05:	6a ff                	push   $0xffffffff
c002ca07:	56                   	push   %esi
c002ca08:	e8 58 51 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002ca0d:	83 c4 10             	add    $0x10,%esp
c002ca10:	e9 e8 fe ff ff       	jmp    c002c8fd <.L36+0x31>

c002ca15 <.L47>:
  struct file_handle* t = syscall_get_file_handle(fd);
c002ca15:	83 ec 0c             	sub    $0xc,%esp
c002ca18:	ff 77 04             	pushl  0x4(%edi)
c002ca1b:	e8 89 51 ff ff       	call   c0021ba9 <syscall_get_file_handle>
c002ca20:	89 c7                	mov    %eax,%edi
  if(t != NULL){
c002ca22:	83 c4 10             	add    $0x10,%esp
c002ca25:	85 c0                	test   %eax,%eax
c002ca27:	74 3d                	je     c002ca66 <.L47+0x51>
    lock_acquire(&filesys_lock);
c002ca29:	83 ec 0c             	sub    $0xc,%esp
c002ca2c:	8d b3 ec 22 00 00    	lea    0x22ec(%ebx),%esi
c002ca32:	56                   	push   %esi
c002ca33:	e8 ee 68 ff ff       	call   c0023326 <lock_acquire>
    file_close(t->opened_file);
c002ca38:	83 c4 04             	add    $0x4,%esp
c002ca3b:	ff 77 04             	pushl  0x4(%edi)
c002ca3e:	e8 0b 0c 00 00       	call   c002d64e <file_close>
    lock_release(&filesys_lock);
c002ca43:	89 34 24             	mov    %esi,(%esp)
c002ca46:	e8 d3 6a ff ff       	call   c002351e <lock_release>
    list_remove(&t->elem);
c002ca4b:	8d 47 0c             	lea    0xc(%edi),%eax
c002ca4e:	89 04 24             	mov    %eax,(%esp)
c002ca51:	e8 01 cf ff ff       	call   c0029957 <list_remove>
    free(t);
c002ca56:	89 3c 24             	mov    %edi,(%esp)
c002ca59:	e8 7f 76 ff ff       	call   c00240dd <free>
c002ca5e:	83 c4 10             	add    $0x10,%esp
c002ca61:	e9 97 fe ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002ca66:	83 ec 08             	sub    $0x8,%esp
c002ca69:	6a ff                	push   $0xffffffff
c002ca6b:	56                   	push   %esi
c002ca6c:	e8 f4 50 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002ca71:	83 c4 10             	add    $0x10,%esp
c002ca74:	e9 84 fe ff ff       	jmp    c002c8fd <.L36+0x31>

c002ca79 <.L40>:
      syscall_remove(f,*((void **)arg1));
c002ca79:	8b 6f 04             	mov    0x4(%edi),%ebp
  if (!syscall_check_user_string(name))
c002ca7c:	83 ec 0c             	sub    $0xc,%esp
c002ca7f:	55                   	push   %ebp
c002ca80:	e8 ac fc ff ff       	call   c002c731 <syscall_check_user_string>
c002ca85:	83 c4 10             	add    $0x10,%esp
c002ca88:	84 c0                	test   %al,%al
c002ca8a:	74 2a                	je     c002cab6 <.L40+0x3d>
  lock_acquire(&filesys_lock);
c002ca8c:	83 ec 0c             	sub    $0xc,%esp
c002ca8f:	8d bb ec 22 00 00    	lea    0x22ec(%ebx),%edi
c002ca95:	57                   	push   %edi
c002ca96:	e8 8b 68 ff ff       	call   c0023326 <lock_acquire>
  f->eax=(uint32_t)filesys_remove(name);
c002ca9b:	89 2c 24             	mov    %ebp,(%esp)
c002ca9e:	e8 bb 06 00 00       	call   c002d15e <filesys_remove>
c002caa3:	89 46 1c             	mov    %eax,0x1c(%esi)
  lock_release(&filesys_lock);
c002caa6:	89 3c 24             	mov    %edi,(%esp)
c002caa9:	e8 70 6a ff ff       	call   c002351e <lock_release>
c002caae:	83 c4 10             	add    $0x10,%esp
c002cab1:	e9 47 fe ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cab6:	83 ec 08             	sub    $0x8,%esp
c002cab9:	6a ff                	push   $0xffffffff
c002cabb:	56                   	push   %esi
c002cabc:	e8 a4 50 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cac1:	83 c4 10             	add    $0x10,%esp
c002cac4:	eb c6                	jmp    c002ca8c <.L40+0x13>

c002cac6 <.L41>:
      syscall_open(f,*((void **)arg1));
c002cac6:	8b 6f 04             	mov    0x4(%edi),%ebp
  if (!syscall_check_user_string(name))
c002cac9:	83 ec 0c             	sub    $0xc,%esp
c002cacc:	55                   	push   %ebp
c002cacd:	e8 5f fc ff ff       	call   c002c731 <syscall_check_user_string>
c002cad2:	83 c4 10             	add    $0x10,%esp
c002cad5:	84 c0                	test   %al,%al
c002cad7:	74 34                	je     c002cb0d <.L41+0x47>
  lock_acquire(&filesys_lock);
c002cad9:	83 ec 0c             	sub    $0xc,%esp
c002cadc:	8d bb ec 22 00 00    	lea    0x22ec(%ebx),%edi
c002cae2:	57                   	push   %edi
c002cae3:	e8 3e 68 ff ff       	call   c0023326 <lock_acquire>
  struct file* tmp_file = filesys_open(name);
c002cae8:	89 2c 24             	mov    %ebp,(%esp)
c002caeb:	e8 1b 06 00 00       	call   c002d10b <filesys_open>
c002caf0:	89 c5                	mov    %eax,%ebp
  lock_release(&filesys_lock);
c002caf2:	89 3c 24             	mov    %edi,(%esp)
c002caf5:	e8 24 6a ff ff       	call   c002351e <lock_release>
  if (tmp_file == NULL){
c002cafa:	83 c4 10             	add    $0x10,%esp
c002cafd:	85 ed                	test   %ebp,%ebp
c002caff:	75 1c                	jne    c002cb1d <.L41+0x57>
    f->eax = (uint32_t)-1;
c002cb01:	c7 46 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%esi)
c002cb08:	e9 f0 fd ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cb0d:	83 ec 08             	sub    $0x8,%esp
c002cb10:	6a ff                	push   $0xffffffff
c002cb12:	56                   	push   %esi
c002cb13:	e8 4d 50 ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cb18:	83 c4 10             	add    $0x10,%esp
c002cb1b:	eb bc                	jmp    c002cad9 <.L41+0x13>
  struct file_handle* handle = malloc(sizeof(struct file_handle));
c002cb1d:	83 ec 0c             	sub    $0xc,%esp
c002cb20:	6a 18                	push   $0x18
c002cb22:	e8 00 74 ff ff       	call   c0023f27 <malloc>
c002cb27:	89 c7                	mov    %eax,%edi
  handle->opened_file = tmp_file;
c002cb29:	89 68 04             	mov    %ebp,0x4(%eax)
  handle->owned_thread = thread_current();
c002cb2c:	e8 23 42 ff ff       	call   c0020d54 <thread_current>
c002cb31:	89 47 08             	mov    %eax,0x8(%edi)
  handle->fd = fd_next++;
c002cb34:	8b 83 ec ff ff ff    	mov    -0x14(%ebx),%eax
c002cb3a:	8d 50 01             	lea    0x1(%eax),%edx
c002cb3d:	89 93 ec ff ff ff    	mov    %edx,-0x14(%ebx)
c002cb43:	89 07                	mov    %eax,(%edi)
  thread_file_list_inster(handle);
c002cb45:	89 3c 24             	mov    %edi,(%esp)
c002cb48:	e8 34 50 ff ff       	call   c0021b81 <thread_file_list_inster>
  f->eax = (uint32_t)handle->fd;
c002cb4d:	8b 07                	mov    (%edi),%eax
c002cb4f:	89 46 1c             	mov    %eax,0x1c(%esi)
c002cb52:	83 c4 10             	add    $0x10,%esp
c002cb55:	e9 a3 fd ff ff       	jmp    c002c8fd <.L36+0x31>

c002cb5a <.L42>:
  struct file_handle* t=syscall_get_file_handle(fd);
c002cb5a:	83 ec 0c             	sub    $0xc,%esp
c002cb5d:	ff 77 04             	pushl  0x4(%edi)
c002cb60:	e8 44 50 ff ff       	call   c0021ba9 <syscall_get_file_handle>
c002cb65:	89 c7                	mov    %eax,%edi
  if(t != NULL){
c002cb67:	83 c4 10             	add    $0x10,%esp
c002cb6a:	85 c0                	test   %eax,%eax
c002cb6c:	74 2d                	je     c002cb9b <.L42+0x41>
    lock_acquire(&filesys_lock);
c002cb6e:	83 ec 0c             	sub    $0xc,%esp
c002cb71:	8d ab ec 22 00 00    	lea    0x22ec(%ebx),%ebp
c002cb77:	55                   	push   %ebp
c002cb78:	e8 a9 67 ff ff       	call   c0023326 <lock_acquire>
    f->eax = (uint32_t)file_length(t->opened_file);
c002cb7d:	83 c4 04             	add    $0x4,%esp
c002cb80:	ff 77 04             	pushl  0x4(%edi)
c002cb83:	e8 02 0b 00 00       	call   c002d68a <file_length>
c002cb88:	89 46 1c             	mov    %eax,0x1c(%esi)
    lock_release(&filesys_lock);
c002cb8b:	89 2c 24             	mov    %ebp,(%esp)
c002cb8e:	e8 8b 69 ff ff       	call   c002351e <lock_release>
c002cb93:	83 c4 10             	add    $0x10,%esp
c002cb96:	e9 62 fd ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cb9b:	83 ec 08             	sub    $0x8,%esp
c002cb9e:	6a ff                	push   $0xffffffff
c002cba0:	56                   	push   %esi
c002cba1:	e8 bf 4f ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cba6:	83 c4 10             	add    $0x10,%esp
c002cba9:	e9 4f fd ff ff       	jmp    c002c8fd <.L36+0x31>

c002cbae <.L39>:
      syscall_create(f,*((void **) arg1),*((unsigned *)arg2));
c002cbae:	8b 47 08             	mov    0x8(%edi),%eax
c002cbb1:	89 44 24 08          	mov    %eax,0x8(%esp)
c002cbb5:	8b 6f 04             	mov    0x4(%edi),%ebp
  if (!syscall_check_user_string(name))
c002cbb8:	83 ec 0c             	sub    $0xc,%esp
c002cbbb:	55                   	push   %ebp
c002cbbc:	e8 70 fb ff ff       	call   c002c731 <syscall_check_user_string>
c002cbc1:	83 c4 10             	add    $0x10,%esp
c002cbc4:	84 c0                	test   %al,%al
c002cbc6:	74 2f                	je     c002cbf7 <.L39+0x49>
  lock_acquire(&filesys_lock);
c002cbc8:	83 ec 0c             	sub    $0xc,%esp
c002cbcb:	8d bb ec 22 00 00    	lea    0x22ec(%ebx),%edi
c002cbd1:	57                   	push   %edi
c002cbd2:	e8 4f 67 ff ff       	call   c0023326 <lock_acquire>
  f->eax=(uint32_t)filesys_create(name, initial_size);
c002cbd7:	83 c4 08             	add    $0x8,%esp
c002cbda:	ff 74 24 10          	pushl  0x10(%esp)
c002cbde:	55                   	push   %ebp
c002cbdf:	e8 8b 04 00 00       	call   c002d06f <filesys_create>
c002cbe4:	89 46 1c             	mov    %eax,0x1c(%esi)
  lock_release(&filesys_lock);
c002cbe7:	89 3c 24             	mov    %edi,(%esp)
c002cbea:	e8 2f 69 ff ff       	call   c002351e <lock_release>
c002cbef:	83 c4 10             	add    $0x10,%esp
c002cbf2:	e9 06 fd ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cbf7:	83 ec 08             	sub    $0x8,%esp
c002cbfa:	6a ff                	push   $0xffffffff
c002cbfc:	56                   	push   %esi
c002cbfd:	e8 63 4f ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cc02:	83 c4 10             	add    $0x10,%esp
c002cc05:	eb c1                	jmp    c002cbc8 <.L39+0x1a>

c002cc07 <.L45>:
      syscall_seek(f,*((int *)arg1),*((unsigned *)arg2));
c002cc07:	8b 6f 08             	mov    0x8(%edi),%ebp
  struct file_handle* t = syscall_get_file_handle(fd);
c002cc0a:	83 ec 0c             	sub    $0xc,%esp
c002cc0d:	ff 77 04             	pushl  0x4(%edi)
c002cc10:	e8 94 4f ff ff       	call   c0021ba9 <syscall_get_file_handle>
c002cc15:	89 c7                	mov    %eax,%edi
  if (t != NULL){
c002cc17:	83 c4 10             	add    $0x10,%esp
c002cc1a:	85 c0                	test   %eax,%eax
c002cc1c:	74 2b                	je     c002cc49 <.L45+0x42>
    lock_acquire(&filesys_lock);
c002cc1e:	83 ec 0c             	sub    $0xc,%esp
c002cc21:	8d b3 ec 22 00 00    	lea    0x22ec(%ebx),%esi
c002cc27:	56                   	push   %esi
c002cc28:	e8 f9 66 ff ff       	call   c0023326 <lock_acquire>
    file_seek(t->opened_file, position);
c002cc2d:	83 c4 08             	add    $0x8,%esp
c002cc30:	55                   	push   %ebp
c002cc31:	ff 77 04             	pushl  0x4(%edi)
c002cc34:	e8 a0 0a 00 00       	call   c002d6d9 <file_seek>
    lock_release(&filesys_lock);
c002cc39:	89 34 24             	mov    %esi,(%esp)
c002cc3c:	e8 dd 68 ff ff       	call   c002351e <lock_release>
c002cc41:	83 c4 10             	add    $0x10,%esp
c002cc44:	e9 b4 fc ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cc49:	83 ec 08             	sub    $0x8,%esp
c002cc4c:	6a ff                	push   $0xffffffff
c002cc4e:	56                   	push   %esi
c002cc4f:	e8 11 4f ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cc54:	83 c4 10             	add    $0x10,%esp
c002cc57:	e9 a1 fc ff ff       	jmp    c002c8fd <.L36+0x31>

c002cc5c <.L43>:
      syscall_read(f,*((int *)arg1),*((void **)arg2),*((unsigned *)arg3));
c002cc5c:	8b 47 0c             	mov    0xc(%edi),%eax
c002cc5f:	89 44 24 08          	mov    %eax,0x8(%esp)
c002cc63:	8b 6f 08             	mov    0x8(%edi),%ebp
c002cc66:	8b 7f 04             	mov    0x4(%edi),%edi
  if (!syscall_check_user_buffer(buffer, size, true))
c002cc69:	83 ec 04             	sub    $0x4,%esp
c002cc6c:	6a 01                	push   $0x1
c002cc6e:	50                   	push   %eax
c002cc6f:	55                   	push   %ebp
c002cc70:	e8 36 fb ff ff       	call   c002c7ab <syscall_check_user_buffer>
c002cc75:	83 c4 10             	add    $0x10,%esp
c002cc78:	84 c0                	test   %al,%al
c002cc7a:	74 2d                	je     c002cca9 <.L43+0x4d>
  if (fd == STDOUT_FILENO)
c002cc7c:	83 ff 01             	cmp    $0x1,%edi
c002cc7f:	74 38                	je     c002ccb9 <.L43+0x5d>
  if (fd == STDIN_FILENO){
c002cc81:	85 ff                	test   %edi,%edi
c002cc83:	75 42                	jne    c002ccc7 <.L43+0x6b>
    while(size-- != 0)
c002cc85:	8b 44 24 08          	mov    0x8(%esp),%eax
c002cc89:	85 c0                	test   %eax,%eax
c002cc8b:	0f 84 6c fc ff ff    	je     c002c8fd <.L36+0x31>
c002cc91:	01 e8                	add    %ebp,%eax
c002cc93:	89 c6                	mov    %eax,%esi
      *(char *)str++ = input_getc();
c002cc95:	e8 f6 99 ff ff       	call   c0026690 <input_getc>
c002cc9a:	83 c5 01             	add    $0x1,%ebp
c002cc9d:	88 45 ff             	mov    %al,-0x1(%ebp)
    while(size-- != 0)
c002cca0:	39 ee                	cmp    %ebp,%esi
c002cca2:	75 f1                	jne    c002cc95 <.L43+0x39>
c002cca4:	e9 54 fc ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cca9:	83 ec 08             	sub    $0x8,%esp
c002ccac:	6a ff                	push   $0xffffffff
c002ccae:	56                   	push   %esi
c002ccaf:	e8 b1 4e ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002ccb4:	83 c4 10             	add    $0x10,%esp
c002ccb7:	eb c3                	jmp    c002cc7c <.L43+0x20>
    thread_exit_with_return_value(f, -1);
c002ccb9:	83 ec 08             	sub    $0x8,%esp
c002ccbc:	6a ff                	push   $0xffffffff
c002ccbe:	56                   	push   %esi
c002ccbf:	e8 a1 4e ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002ccc4:	83 c4 10             	add    $0x10,%esp
    struct file_handle* t = syscall_get_file_handle(fd);
c002ccc7:	83 ec 0c             	sub    $0xc,%esp
c002ccca:	57                   	push   %edi
c002cccb:	e8 d9 4e ff ff       	call   c0021ba9 <syscall_get_file_handle>
    if (t != NULL){
c002ccd0:	83 c4 10             	add    $0x10,%esp
c002ccd3:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002ccd7:	85 c0                	test   %eax,%eax
c002ccd9:	74 36                	je     c002cd11 <.L43+0xb5>
      lock_acquire(&filesys_lock);
c002ccdb:	83 ec 0c             	sub    $0xc,%esp
c002ccde:	8d bb ec 22 00 00    	lea    0x22ec(%ebx),%edi
c002cce4:	57                   	push   %edi
c002cce5:	e8 3c 66 ff ff       	call   c0023326 <lock_acquire>
      f->eax=(uint32_t)file_read(t->opened_file, (void*)buffer, size);
c002ccea:	83 c4 0c             	add    $0xc,%esp
c002cced:	ff 74 24 0c          	pushl  0xc(%esp)
c002ccf1:	55                   	push   %ebp
c002ccf2:	8b 44 24 18          	mov    0x18(%esp),%eax
c002ccf6:	ff 70 04             	pushl  0x4(%eax)
c002ccf9:	e8 e3 07 00 00       	call   c002d4e1 <file_read>
c002ccfe:	89 46 1c             	mov    %eax,0x1c(%esi)
      lock_release(&filesys_lock);
c002cd01:	89 3c 24             	mov    %edi,(%esp)
c002cd04:	e8 15 68 ff ff       	call   c002351e <lock_release>
c002cd09:	83 c4 10             	add    $0x10,%esp
c002cd0c:	e9 ec fb ff ff       	jmp    c002c8fd <.L36+0x31>
      thread_exit_with_return_value(f, -1);
c002cd11:	83 ec 08             	sub    $0x8,%esp
c002cd14:	6a ff                	push   $0xffffffff
c002cd16:	56                   	push   %esi
c002cd17:	e8 49 4e ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cd1c:	83 c4 10             	add    $0x10,%esp
c002cd1f:	e9 d9 fb ff ff       	jmp    c002c8fd <.L36+0x31>

c002cd24 <.L44>:
      syscall_write(f,*((int *) arg1),*((void **) arg2),*((unsigned *) arg3));
c002cd24:	8b 6f 0c             	mov    0xc(%edi),%ebp
c002cd27:	8b 47 08             	mov    0x8(%edi),%eax
c002cd2a:	89 44 24 08          	mov    %eax,0x8(%esp)
c002cd2e:	8b 7f 04             	mov    0x4(%edi),%edi
  if (!syscall_check_user_buffer(buffer, size, false))
c002cd31:	83 ec 04             	sub    $0x4,%esp
c002cd34:	6a 00                	push   $0x0
c002cd36:	55                   	push   %ebp
c002cd37:	50                   	push   %eax
c002cd38:	e8 6e fa ff ff       	call   c002c7ab <syscall_check_user_buffer>
c002cd3d:	83 c4 10             	add    $0x10,%esp
c002cd40:	84 c0                	test   %al,%al
c002cd42:	74 53                	je     c002cd97 <.L44+0x73>
  if (fd == STDIN_FILENO)
c002cd44:	85 ff                	test   %edi,%edi
c002cd46:	74 5f                	je     c002cda7 <.L44+0x83>
  if (fd == STDOUT_FILENO)
c002cd48:	83 ff 01             	cmp    $0x1,%edi
c002cd4b:	74 6a                	je     c002cdb7 <.L44+0x93>
    struct file_handle* t = syscall_get_file_handle(fd);
c002cd4d:	83 ec 0c             	sub    $0xc,%esp
c002cd50:	57                   	push   %edi
c002cd51:	e8 53 4e ff ff       	call   c0021ba9 <syscall_get_file_handle>
    if (t != NULL){
c002cd56:	83 c4 10             	add    $0x10,%esp
c002cd59:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002cd5d:	85 c0                	test   %eax,%eax
c002cd5f:	74 6b                	je     c002cdcc <.L44+0xa8>
      lock_acquire(&filesys_lock);
c002cd61:	83 ec 0c             	sub    $0xc,%esp
c002cd64:	8d bb ec 22 00 00    	lea    0x22ec(%ebx),%edi
c002cd6a:	57                   	push   %edi
c002cd6b:	e8 b6 65 ff ff       	call   c0023326 <lock_acquire>
      f->eax = (uint32_t)file_write(t->opened_file, (void*)buffer, size);
c002cd70:	83 c4 0c             	add    $0xc,%esp
c002cd73:	55                   	push   %ebp
c002cd74:	ff 74 24 10          	pushl  0x10(%esp)
c002cd78:	8b 44 24 18          	mov    0x18(%esp),%eax
c002cd7c:	ff 70 04             	pushl  0x4(%eax)
c002cd7f:	e8 b7 07 00 00       	call   c002d53b <file_write>
c002cd84:	89 46 1c             	mov    %eax,0x1c(%esi)
      lock_release(&filesys_lock);
c002cd87:	89 3c 24             	mov    %edi,(%esp)
c002cd8a:	e8 8f 67 ff ff       	call   c002351e <lock_release>
c002cd8f:	83 c4 10             	add    $0x10,%esp
c002cd92:	e9 66 fb ff ff       	jmp    c002c8fd <.L36+0x31>
    thread_exit_with_return_value(f, -1);
c002cd97:	83 ec 08             	sub    $0x8,%esp
c002cd9a:	6a ff                	push   $0xffffffff
c002cd9c:	56                   	push   %esi
c002cd9d:	e8 c3 4d ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cda2:	83 c4 10             	add    $0x10,%esp
c002cda5:	eb 9d                	jmp    c002cd44 <.L44+0x20>
    thread_exit_with_return_value(f, -1);
c002cda7:	83 ec 08             	sub    $0x8,%esp
c002cdaa:	6a ff                	push   $0xffffffff
c002cdac:	56                   	push   %esi
c002cdad:	e8 b3 4d ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cdb2:	83 c4 10             	add    $0x10,%esp
c002cdb5:	eb 96                	jmp    c002cd4d <.L44+0x29>
    putbuf(buffer, size);
c002cdb7:	83 ec 08             	sub    $0x8,%esp
c002cdba:	55                   	push   %ebp
c002cdbb:	ff 74 24 14          	pushl  0x14(%esp)
c002cdbf:	e8 db e4 ff ff       	call   c002b29f <putbuf>
c002cdc4:	83 c4 10             	add    $0x10,%esp
c002cdc7:	e9 31 fb ff ff       	jmp    c002c8fd <.L36+0x31>
      thread_exit_with_return_value(f, -1);
c002cdcc:	83 ec 08             	sub    $0x8,%esp
c002cdcf:	6a ff                	push   $0xffffffff
c002cdd1:	56                   	push   %esi
c002cdd2:	e8 8e 4d ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cdd7:	83 c4 10             	add    $0x10,%esp
c002cdda:	e9 1e fb ff ff       	jmp    c002c8fd <.L36+0x31>
      thread_exit_with_return_value(f, -1);
c002cddf:	83 ec 08             	sub    $0x8,%esp
c002cde2:	6a ff                	push   $0xffffffff
c002cde4:	56                   	push   %esi
c002cde5:	e8 7b 4d ff ff       	call   c0021b65 <thread_exit_with_return_value>
c002cdea:	83 c4 10             	add    $0x10,%esp
}
c002cded:	e9 0b fb ff ff       	jmp    c002c8fd <.L36+0x31>

c002cdf2 <mmap_check_mmap_vaddr>:
    if (!page_available_upage(cur->page_table, vaddr + i * PGSIZE))
      res = false;
  }
  return res;
#endif
}
c002cdf2:	f3 c3                	repz ret 

c002cdf4 <mmap_install_page>:
        res = false;
    }
  }
  return res;
#endif
}
c002cdf4:	f3 c3                	repz ret 

c002cdf6 <mmap_read_file>:
    }
    else
      file_read_at(mh->mmap_file, kpage, PGSIZE, upage - mh->mmap_addr + mh->file_ofs);
  }
#endif
}
c002cdf6:	f3 c3                	repz ret 

c002cdf8 <mmap_write_file>:
      else
        file_write_at(mh->mmap_file, kpage, PGSIZE, upage - mh->mmap_addr + mh->file_ofs);
    }
  }
#endif
}
c002cdf8:	f3 c3                	repz ret 

c002cdfa <mmap_load_segment>:
  list_push_back(&(cur->mmap_file_list), &(mh->elem));
  if(!mmap_install_page(cur, mh))
    return false;
  return true;
#endif
}
c002cdfa:	f3 c3                	repz ret 

c002cdfc <gdt_init>:

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init (void)
{
c002cdfc:	53                   	push   %ebx
c002cdfd:	83 ec 18             	sub    $0x18,%esp
c002ce00:	e8 80 1c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ce05:	81 c3 af e0 00 00    	add    $0xe0af,%ebx
  uint64_t gdtr_operand;

  /* Initialize GDT. */
  gdt[SEL_NULL / sizeof *gdt] = 0;
c002ce0b:	c7 83 2c 23 00 00 00 	movl   $0x0,0x232c(%ebx)
c002ce12:	00 00 00 
c002ce15:	c7 83 30 23 00 00 00 	movl   $0x0,0x2330(%ebx)
c002ce1c:	00 00 00 
  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc (0);
c002ce1f:	c7 83 34 23 00 00 ff 	movl   $0xffff,0x2334(%ebx)
c002ce26:	ff 00 00 
c002ce29:	c7 83 38 23 00 00 00 	movl   $0xcf9a00,0x2338(%ebx)
c002ce30:	9a cf 00 
  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc (0);
c002ce33:	c7 83 3c 23 00 00 ff 	movl   $0xffff,0x233c(%ebx)
c002ce3a:	ff 00 00 
c002ce3d:	c7 83 40 23 00 00 00 	movl   $0xcf9200,0x2340(%ebx)
c002ce44:	92 cf 00 
  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc (3);
c002ce47:	c7 83 44 23 00 00 ff 	movl   $0xffff,0x2344(%ebx)
c002ce4e:	ff 00 00 
c002ce51:	c7 83 48 23 00 00 00 	movl   $0xcffa00,0x2348(%ebx)
c002ce58:	fa cf 00 
  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc (3);
c002ce5b:	c7 83 4c 23 00 00 ff 	movl   $0xffff,0x234c(%ebx)
c002ce62:	ff 00 00 
c002ce65:	c7 83 50 23 00 00 00 	movl   $0xcff200,0x2350(%ebx)
c002ce6c:	f2 cf 00 
  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc (tss_get ());
c002ce6f:	e8 59 00 00 00       	call   c002cecd <tss_get>
  ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);

  e0 = ((limit & 0xffff)             /* Limit 15:0. */
        | (base << 16));             /* Base 15:0. */

  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002ce74:	89 c2                	mov    %eax,%edx
c002ce76:	c1 ea 10             	shr    $0x10,%edx
c002ce79:	0f b6 d2             	movzbl %dl,%edx
        | (dpl << 13)                /* Descriptor privilege. */
        | (1 << 15)                  /* Present. */
        | (limit & 0xf0000)          /* Limit 16:19. */
        | (1 << 22)                  /* 32-bit segment. */
        | (granularity << 23)        /* Byte/page granularity. */
        | (base & 0xff000000));      /* Base 31:24. */
c002ce7c:	89 c1                	mov    %eax,%ecx
c002ce7e:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002ce84:	81 c9 00 89 40 00    	or     $0x408900,%ecx
c002ce8a:	09 ca                	or     %ecx,%edx
        | (base << 16));             /* Base 15:0. */
c002ce8c:	c1 e0 10             	shl    $0x10,%eax
  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002ce8f:	83 c8 67             	or     $0x67,%eax

  return e0 | ((uint64_t) e1 << 32);
c002ce92:	89 83 54 23 00 00    	mov    %eax,0x2354(%ebx)
c002ce98:	89 93 58 23 00 00    	mov    %edx,0x2358(%ebx)
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand (uint16_t limit, void *base)
{
  return limit | ((uint64_t) (uint32_t) base << 16);
c002ce9e:	8d 83 2c 23 00 00    	lea    0x232c(%ebx),%eax
c002cea4:	ba 00 00 00 00       	mov    $0x0,%edx
c002cea9:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002cead:	c1 e0 10             	shl    $0x10,%eax
c002ceb0:	83 c8 2f             	or     $0x2f,%eax
c002ceb3:	89 44 24 08          	mov    %eax,0x8(%esp)
c002ceb7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002cebb:	0f 01 54 24 08       	lgdtl  0x8(%esp)
  asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002cec0:	b8 28 00 00 00       	mov    $0x28,%eax
c002cec5:	0f 00 d8             	ltr    %ax
}
c002cec8:	83 c4 18             	add    $0x18,%esp
c002cecb:	5b                   	pop    %ebx
c002cecc:	c3                   	ret    

c002cecd <tss_get>:
}

/* Returns the kernel TSS. */
struct tss *
tss_get (void) 
{
c002cecd:	53                   	push   %ebx
c002cece:	83 ec 08             	sub    $0x8,%esp
c002ced1:	e8 af 1b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002ced6:	81 c3 de df 00 00    	add    $0xdfde,%ebx
  ASSERT (tss != NULL);
c002cedc:	8b 83 5c 23 00 00    	mov    0x235c(%ebx),%eax
c002cee2:	85 c0                	test   %eax,%eax
c002cee4:	74 05                	je     c002ceeb <tss_get+0x1e>
  return tss;
}
c002cee6:	83 c4 08             	add    $0x8,%esp
c002cee9:	5b                   	pop    %ebx
c002ceea:	c3                   	ret    
  ASSERT (tss != NULL);
c002ceeb:	83 ec 0c             	sub    $0xc,%esp
c002ceee:	8d 83 74 70 ff ff    	lea    -0x8f8c(%ebx),%eax
c002cef4:	50                   	push   %eax
c002cef5:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002cefb:	50                   	push   %eax
c002cefc:	8d 83 24 4c ff ff    	lea    -0xb3dc(%ebx),%eax
c002cf02:	50                   	push   %eax
c002cf03:	6a 5f                	push   $0x5f
c002cf05:	8d 83 80 70 ff ff    	lea    -0x8f80(%ebx),%eax
c002cf0b:	50                   	push   %eax
c002cf0c:	e8 76 c3 ff ff       	call   c0029287 <debug_panic>

c002cf11 <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update (void) 
{
c002cf11:	53                   	push   %ebx
c002cf12:	83 ec 08             	sub    $0x8,%esp
c002cf15:	e8 6b 1b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002cf1a:	81 c3 9a df 00 00    	add    $0xdf9a,%ebx
  ASSERT (tss != NULL);
c002cf20:	83 bb 5c 23 00 00 00 	cmpl   $0x0,0x235c(%ebx)
c002cf27:	74 18                	je     c002cf41 <tss_update+0x30>
  tss->esp0 = (uint8_t *) thread_current () + PGSIZE;
c002cf29:	e8 26 3e ff ff       	call   c0020d54 <thread_current>
c002cf2e:	8b 93 5c 23 00 00    	mov    0x235c(%ebx),%edx
c002cf34:	05 00 10 00 00       	add    $0x1000,%eax
c002cf39:	89 42 04             	mov    %eax,0x4(%edx)
}
c002cf3c:	83 c4 08             	add    $0x8,%esp
c002cf3f:	5b                   	pop    %ebx
c002cf40:	c3                   	ret    
  ASSERT (tss != NULL);
c002cf41:	83 ec 0c             	sub    $0xc,%esp
c002cf44:	8d 83 74 70 ff ff    	lea    -0x8f8c(%ebx),%eax
c002cf4a:	50                   	push   %eax
c002cf4b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002cf51:	50                   	push   %eax
c002cf52:	8d 83 18 4c ff ff    	lea    -0xb3e8(%ebx),%eax
c002cf58:	50                   	push   %eax
c002cf59:	6a 68                	push   $0x68
c002cf5b:	8d 83 80 70 ff ff    	lea    -0x8f80(%ebx),%eax
c002cf61:	50                   	push   %eax
c002cf62:	e8 20 c3 ff ff       	call   c0029287 <debug_panic>

c002cf67 <tss_init>:
{
c002cf67:	53                   	push   %ebx
c002cf68:	83 ec 14             	sub    $0x14,%esp
c002cf6b:	e8 15 1b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002cf70:	81 c3 44 df 00 00    	add    $0xdf44,%ebx
  tss = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002cf76:	6a 03                	push   $0x3
c002cf78:	e8 95 6b ff ff       	call   c0023b12 <palloc_get_page>
c002cf7d:	89 83 5c 23 00 00    	mov    %eax,0x235c(%ebx)
  tss->ss0 = SEL_KDSEG;
c002cf83:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
  tss->bitmap = 0xdfff;
c002cf89:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
  tss_update ();
c002cf8f:	e8 7d ff ff ff       	call   c002cf11 <tss_update>
}
c002cf94:	83 c4 18             	add    $0x18,%esp
c002cf97:	5b                   	pop    %ebx
c002cf98:	c3                   	ret    

c002cf99 <filesys_init>:

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init (bool format) 
{
c002cf99:	56                   	push   %esi
c002cf9a:	53                   	push   %ebx
c002cf9b:	83 ec 10             	sub    $0x10,%esp
c002cf9e:	e8 e2 1a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002cfa3:	81 c3 11 df 00 00    	add    $0xdf11,%ebx
c002cfa9:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  fs_device = block_get_role (BLOCK_FILESYS);
c002cfad:	6a 01                	push   $0x1
c002cfaf:	e8 f4 81 ff ff       	call   c00251a8 <block_get_role>
c002cfb4:	c7 c2 3c d4 03 c0    	mov    $0xc003d43c,%edx
c002cfba:	89 02                	mov    %eax,(%edx)
  if (fs_device == NULL)
c002cfbc:	83 c4 10             	add    $0x10,%esp
c002cfbf:	85 c0                	test   %eax,%eax
c002cfc1:	74 1b                	je     c002cfde <filesys_init+0x45>
    PANIC ("No file system device found, can't initialize file system.");

  inode_init ();
c002cfc3:	e8 7b 0d 00 00       	call   c002dd43 <inode_init>
  free_map_init ();
c002cfc8:	e8 d7 01 00 00       	call   c002d1a4 <free_map_init>

  if (format) 
c002cfcd:	89 f0                	mov    %esi,%eax
c002cfcf:	84 c0                	test   %al,%al
c002cfd1:	75 27                	jne    c002cffa <filesys_init+0x61>
    do_format ();

  free_map_open ();
c002cfd3:	e8 2b 03 00 00       	call   c002d303 <free_map_open>
}
c002cfd8:	83 c4 04             	add    $0x4,%esp
c002cfdb:	5b                   	pop    %ebx
c002cfdc:	5e                   	pop    %esi
c002cfdd:	c3                   	ret    
    PANIC ("No file system device found, can't initialize file system.");
c002cfde:	8d 83 98 70 ff ff    	lea    -0x8f68(%ebx),%eax
c002cfe4:	50                   	push   %eax
c002cfe5:	8d 83 38 4c ff ff    	lea    -0xb3c8(%ebx),%eax
c002cfeb:	50                   	push   %eax
c002cfec:	6a 16                	push   $0x16
c002cfee:	8d 83 f3 70 ff ff    	lea    -0x8f0d(%ebx),%eax
c002cff4:	50                   	push   %eax
c002cff5:	e8 8d c2 ff ff       	call   c0029287 <debug_panic>

/* Formats the file system. */
static void
do_format (void)
{
  printf ("Formatting file system...");
c002cffa:	83 ec 0c             	sub    $0xc,%esp
c002cffd:	8d 83 0b 71 ff ff    	lea    -0x8ef5(%ebx),%eax
c002d003:	50                   	push   %eax
c002d004:	e8 e7 a4 ff ff       	call   c00274f0 <printf>
  free_map_create ();
c002d009:	e8 92 03 00 00       	call   c002d3a0 <free_map_create>
  if (!dir_create (ROOT_DIR_SECTOR, 16))
c002d00e:	83 c4 08             	add    $0x8,%esp
c002d011:	6a 10                	push   $0x10
c002d013:	6a 01                	push   $0x1
c002d015:	e8 94 08 00 00       	call   c002d8ae <dir_create>
c002d01a:	83 c4 10             	add    $0x10,%esp
c002d01d:	84 c0                	test   %al,%al
c002d01f:	74 19                	je     c002d03a <filesys_init+0xa1>
    PANIC ("root directory creation failed");
  free_map_close ();
c002d021:	e8 5b 03 00 00       	call   c002d381 <free_map_close>
  printf ("done.\n");
c002d026:	83 ec 0c             	sub    $0xc,%esp
c002d029:	8d 83 61 59 ff ff    	lea    -0xa69f(%ebx),%eax
c002d02f:	50                   	push   %eax
c002d030:	e8 2b e2 ff ff       	call   c002b260 <puts>
c002d035:	83 c4 10             	add    $0x10,%esp
c002d038:	eb 99                	jmp    c002cfd3 <filesys_init+0x3a>
    PANIC ("root directory creation failed");
c002d03a:	8d 83 d4 70 ff ff    	lea    -0x8f2c(%ebx),%eax
c002d040:	50                   	push   %eax
c002d041:	8d 83 2c 4c ff ff    	lea    -0xb3d4(%ebx),%eax
c002d047:	50                   	push   %eax
c002d048:	6a 64                	push   $0x64
c002d04a:	8d 83 f3 70 ff ff    	lea    -0x8f0d(%ebx),%eax
c002d050:	50                   	push   %eax
c002d051:	e8 31 c2 ff ff       	call   c0029287 <debug_panic>

c002d056 <filesys_done>:
{
c002d056:	53                   	push   %ebx
c002d057:	83 ec 08             	sub    $0x8,%esp
c002d05a:	e8 26 1a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d05f:	81 c3 55 de 00 00    	add    $0xde55,%ebx
  free_map_close ();
c002d065:	e8 17 03 00 00       	call   c002d381 <free_map_close>
}
c002d06a:	83 c4 08             	add    $0x8,%esp
c002d06d:	5b                   	pop    %ebx
c002d06e:	c3                   	ret    

c002d06f <filesys_create>:
{
c002d06f:	57                   	push   %edi
c002d070:	56                   	push   %esi
c002d071:	53                   	push   %ebx
c002d072:	83 ec 10             	sub    $0x10,%esp
c002d075:	e8 0b 1a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d07a:	81 c3 3a de 00 00    	add    $0xde3a,%ebx
  block_sector_t inode_sector = 0;
c002d080:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d087:	00 
  struct dir *dir = dir_open_root ();
c002d088:	e8 9e 08 00 00       	call   c002d92b <dir_open_root>
c002d08d:	89 c6                	mov    %eax,%esi
                  && dir_add (dir, name, inode_sector));
c002d08f:	85 c0                	test   %eax,%eax
c002d091:	74 16                	je     c002d0a9 <filesys_create+0x3a>
                  && free_map_allocate (1, &inode_sector)
c002d093:	83 ec 08             	sub    $0x8,%esp
c002d096:	8d 44 24 14          	lea    0x14(%esp),%eax
c002d09a:	50                   	push   %eax
c002d09b:	6a 01                	push   $0x1
c002d09d:	e8 6f 01 00 00       	call   c002d211 <free_map_allocate>
c002d0a2:	83 c4 10             	add    $0x10,%esp
c002d0a5:	84 c0                	test   %al,%al
c002d0a7:	75 1f                	jne    c002d0c8 <filesys_create+0x59>
  if (!success && inode_sector != 0) 
c002d0a9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d0ad:	bf 00 00 00 00       	mov    $0x0,%edi
c002d0b2:	85 c0                	test   %eax,%eax
c002d0b4:	75 45                	jne    c002d0fb <filesys_create+0x8c>
  dir_close (dir);
c002d0b6:	83 ec 0c             	sub    $0xc,%esp
c002d0b9:	56                   	push   %esi
c002d0ba:	e8 b6 08 00 00       	call   c002d975 <dir_close>
}
c002d0bf:	89 f8                	mov    %edi,%eax
c002d0c1:	83 c4 20             	add    $0x20,%esp
c002d0c4:	5b                   	pop    %ebx
c002d0c5:	5e                   	pop    %esi
c002d0c6:	5f                   	pop    %edi
c002d0c7:	c3                   	ret    
                  && inode_create (inode_sector, initial_size)
c002d0c8:	83 ec 08             	sub    $0x8,%esp
c002d0cb:	ff 74 24 2c          	pushl  0x2c(%esp)
c002d0cf:	ff 74 24 18          	pushl  0x18(%esp)
c002d0d3:	e8 8b 0c 00 00       	call   c002dd63 <inode_create>
c002d0d8:	83 c4 10             	add    $0x10,%esp
c002d0db:	84 c0                	test   %al,%al
c002d0dd:	74 ca                	je     c002d0a9 <filesys_create+0x3a>
                  && dir_add (dir, name, inode_sector));
c002d0df:	83 ec 04             	sub    $0x4,%esp
c002d0e2:	ff 74 24 10          	pushl  0x10(%esp)
c002d0e6:	ff 74 24 28          	pushl  0x28(%esp)
c002d0ea:	56                   	push   %esi
c002d0eb:	e8 69 09 00 00       	call   c002da59 <dir_add>
c002d0f0:	89 c7                	mov    %eax,%edi
  if (!success && inode_sector != 0) 
c002d0f2:	83 c4 10             	add    $0x10,%esp
c002d0f5:	84 c0                	test   %al,%al
c002d0f7:	75 bd                	jne    c002d0b6 <filesys_create+0x47>
c002d0f9:	eb ae                	jmp    c002d0a9 <filesys_create+0x3a>
    free_map_release (inode_sector, 1);
c002d0fb:	83 ec 08             	sub    $0x8,%esp
c002d0fe:	6a 01                	push   $0x1
c002d100:	50                   	push   %eax
c002d101:	e8 80 01 00 00       	call   c002d286 <free_map_release>
c002d106:	83 c4 10             	add    $0x10,%esp
c002d109:	eb ab                	jmp    c002d0b6 <filesys_create+0x47>

c002d10b <filesys_open>:
{
c002d10b:	56                   	push   %esi
c002d10c:	53                   	push   %ebx
c002d10d:	83 ec 14             	sub    $0x14,%esp
c002d110:	e8 70 19 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d115:	81 c3 9f dd 00 00    	add    $0xdd9f,%ebx
  struct dir *dir = dir_open_root ();
c002d11b:	e8 0b 08 00 00       	call   c002d92b <dir_open_root>
c002d120:	89 c6                	mov    %eax,%esi
  struct inode *inode = NULL;
c002d122:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002d129:	00 
  if (dir != NULL)
c002d12a:	85 c0                	test   %eax,%eax
c002d12c:	74 15                	je     c002d143 <filesys_open+0x38>
    dir_lookup (dir, name, &inode);
c002d12e:	83 ec 04             	sub    $0x4,%esp
c002d131:	8d 44 24 10          	lea    0x10(%esp),%eax
c002d135:	50                   	push   %eax
c002d136:	ff 74 24 28          	pushl  0x28(%esp)
c002d13a:	56                   	push   %esi
c002d13b:	e8 6f 08 00 00       	call   c002d9af <dir_lookup>
c002d140:	83 c4 10             	add    $0x10,%esp
  dir_close (dir);
c002d143:	83 ec 0c             	sub    $0xc,%esp
c002d146:	56                   	push   %esi
c002d147:	e8 29 08 00 00       	call   c002d975 <dir_close>
  return file_open (inode);
c002d14c:	83 c4 04             	add    $0x4,%esp
c002d14f:	ff 74 24 18          	pushl  0x18(%esp)
c002d153:	e8 02 03 00 00       	call   c002d45a <file_open>
}
c002d158:	83 c4 24             	add    $0x24,%esp
c002d15b:	5b                   	pop    %ebx
c002d15c:	5e                   	pop    %esi
c002d15d:	c3                   	ret    

c002d15e <filesys_remove>:
{
c002d15e:	57                   	push   %edi
c002d15f:	56                   	push   %esi
c002d160:	53                   	push   %ebx
c002d161:	e8 1f 19 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d166:	81 c3 4e dd 00 00    	add    $0xdd4e,%ebx
  struct dir *dir = dir_open_root ();
c002d16c:	e8 ba 07 00 00       	call   c002d92b <dir_open_root>
c002d171:	89 c7                	mov    %eax,%edi
  bool success = dir != NULL && dir_remove (dir, name);
c002d173:	be 00 00 00 00       	mov    $0x0,%esi
c002d178:	85 c0                	test   %eax,%eax
c002d17a:	74 13                	je     c002d18f <filesys_remove+0x31>
c002d17c:	83 ec 08             	sub    $0x8,%esp
c002d17f:	ff 74 24 18          	pushl  0x18(%esp)
c002d183:	50                   	push   %eax
c002d184:	e8 f9 09 00 00       	call   c002db82 <dir_remove>
c002d189:	0f b6 f0             	movzbl %al,%esi
c002d18c:	83 c4 10             	add    $0x10,%esp
  dir_close (dir); 
c002d18f:	83 ec 0c             	sub    $0xc,%esp
c002d192:	57                   	push   %edi
c002d193:	e8 dd 07 00 00       	call   c002d975 <dir_close>
  bool success = dir != NULL && dir_remove (dir, name);
c002d198:	89 f0                	mov    %esi,%eax
c002d19a:	83 e0 01             	and    $0x1,%eax
  return success;
c002d19d:	83 c4 10             	add    $0x10,%esp
}
c002d1a0:	5b                   	pop    %ebx
c002d1a1:	5e                   	pop    %esi
c002d1a2:	5f                   	pop    %edi
c002d1a3:	c3                   	ret    

c002d1a4 <free_map_init>:
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init (void) 
{
c002d1a4:	53                   	push   %ebx
c002d1a5:	83 ec 14             	sub    $0x14,%esp
c002d1a8:	e8 d8 18 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d1ad:	81 c3 07 dd 00 00    	add    $0xdd07,%ebx
  free_map = bitmap_create (block_size (fs_device));
c002d1b3:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002d1b9:	ff 30                	pushl  (%eax)
c002d1bb:	e8 07 82 ff ff       	call   c00253c7 <block_size>
c002d1c0:	89 04 24             	mov    %eax,(%esp)
c002d1c3:	e8 65 d2 ff ff       	call   c002a42d <bitmap_create>
c002d1c8:	89 83 60 23 00 00    	mov    %eax,0x2360(%ebx)
  if (free_map == NULL)
c002d1ce:	83 c4 10             	add    $0x10,%esp
c002d1d1:	85 c0                	test   %eax,%eax
c002d1d3:	74 20                	je     c002d1f5 <free_map_init+0x51>
    PANIC ("bitmap creation failed--file system device is too large");
  bitmap_mark (free_map, FREE_MAP_SECTOR);
c002d1d5:	83 ec 08             	sub    $0x8,%esp
c002d1d8:	6a 00                	push   $0x0
c002d1da:	50                   	push   %eax
c002d1db:	e8 9f cf ff ff       	call   c002a17f <bitmap_mark>
  bitmap_mark (free_map, ROOT_DIR_SECTOR);
c002d1e0:	83 c4 08             	add    $0x8,%esp
c002d1e3:	6a 01                	push   $0x1
c002d1e5:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d1eb:	e8 8f cf ff ff       	call   c002a17f <bitmap_mark>
}
c002d1f0:	83 c4 18             	add    $0x18,%esp
c002d1f3:	5b                   	pop    %ebx
c002d1f4:	c3                   	ret    
    PANIC ("bitmap creation failed--file system device is too large");
c002d1f5:	8d 83 28 71 ff ff    	lea    -0x8ed8(%ebx),%eax
c002d1fb:	50                   	push   %eax
c002d1fc:	8d 83 7c 4c ff ff    	lea    -0xb384(%ebx),%eax
c002d202:	50                   	push   %eax
c002d203:	6a 11                	push   $0x11
c002d205:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d20b:	50                   	push   %eax
c002d20c:	e8 76 c0 ff ff       	call   c0029287 <debug_panic>

c002d211 <free_map_allocate>:
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate (size_t cnt, block_sector_t *sectorp)
{
c002d211:	57                   	push   %edi
c002d212:	56                   	push   %esi
c002d213:	53                   	push   %ebx
c002d214:	e8 6c 18 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d219:	81 c3 9b dc 00 00    	add    $0xdc9b,%ebx
c002d21f:	8b 7c 24 10          	mov    0x10(%esp),%edi
  block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
c002d223:	6a 00                	push   $0x0
c002d225:	57                   	push   %edi
c002d226:	6a 00                	push   $0x0
c002d228:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d22e:	e8 d5 d5 ff ff       	call   c002a808 <bitmap_scan_and_flip>
c002d233:	89 c6                	mov    %eax,%esi
  if (sector != BITMAP_ERROR
c002d235:	83 c4 10             	add    $0x10,%esp
c002d238:	83 f8 ff             	cmp    $0xffffffff,%eax
c002d23b:	74 26                	je     c002d263 <free_map_allocate+0x52>
      && free_map_file != NULL
c002d23d:	8b 83 64 23 00 00    	mov    0x2364(%ebx),%eax
c002d243:	85 c0                	test   %eax,%eax
c002d245:	74 16                	je     c002d25d <free_map_allocate+0x4c>
      && !bitmap_write (free_map, free_map_file))
c002d247:	83 ec 08             	sub    $0x8,%esp
c002d24a:	50                   	push   %eax
c002d24b:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d251:	e8 76 d6 ff ff       	call   c002a8cc <bitmap_write>
c002d256:	83 c4 10             	add    $0x10,%esp
c002d259:	84 c0                	test   %al,%al
c002d25b:	74 10                	je     c002d26d <free_map_allocate+0x5c>
    {
      bitmap_set_multiple (free_map, sector, cnt, false); 
      sector = BITMAP_ERROR;
    }
  if (sector != BITMAP_ERROR)
    *sectorp = sector;
c002d25d:	8b 44 24 14          	mov    0x14(%esp),%eax
c002d261:	89 30                	mov    %esi,(%eax)
  return sector != BITMAP_ERROR;
c002d263:	83 fe ff             	cmp    $0xffffffff,%esi
c002d266:	0f 95 c0             	setne  %al
}
c002d269:	5b                   	pop    %ebx
c002d26a:	5e                   	pop    %esi
c002d26b:	5f                   	pop    %edi
c002d26c:	c3                   	ret    
      bitmap_set_multiple (free_map, sector, cnt, false); 
c002d26d:	6a 00                	push   $0x0
c002d26f:	57                   	push   %edi
c002d270:	56                   	push   %esi
c002d271:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d277:	e8 81 d0 ff ff       	call   c002a2fd <bitmap_set_multiple>
c002d27c:	83 c4 10             	add    $0x10,%esp
      sector = BITMAP_ERROR;
c002d27f:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002d284:	eb dd                	jmp    c002d263 <free_map_allocate+0x52>

c002d286 <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release (block_sector_t sector, size_t cnt)
{
c002d286:	57                   	push   %edi
c002d287:	56                   	push   %esi
c002d288:	53                   	push   %ebx
c002d289:	e8 f7 17 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d28e:	81 c3 26 dc 00 00    	add    $0xdc26,%ebx
c002d294:	8b 74 24 10          	mov    0x10(%esp),%esi
c002d298:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (bitmap_all (free_map, sector, cnt));
c002d29c:	83 ec 04             	sub    $0x4,%esp
c002d29f:	57                   	push   %edi
c002d2a0:	56                   	push   %esi
c002d2a1:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d2a7:	e8 6f d4 ff ff       	call   c002a71b <bitmap_all>
c002d2ac:	83 c4 10             	add    $0x10,%esp
c002d2af:	84 c0                	test   %al,%al
c002d2b1:	74 2a                	je     c002d2dd <free_map_release+0x57>
  bitmap_set_multiple (free_map, sector, cnt, false);
c002d2b3:	6a 00                	push   $0x0
c002d2b5:	57                   	push   %edi
c002d2b6:	56                   	push   %esi
c002d2b7:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d2bd:	e8 3b d0 ff ff       	call   c002a2fd <bitmap_set_multiple>
  bitmap_write (free_map, free_map_file);
c002d2c2:	83 c4 08             	add    $0x8,%esp
c002d2c5:	ff b3 64 23 00 00    	pushl  0x2364(%ebx)
c002d2cb:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d2d1:	e8 f6 d5 ff ff       	call   c002a8cc <bitmap_write>
}
c002d2d6:	83 c4 10             	add    $0x10,%esp
c002d2d9:	5b                   	pop    %ebx
c002d2da:	5e                   	pop    %esi
c002d2db:	5f                   	pop    %edi
c002d2dc:	c3                   	ret    
  ASSERT (bitmap_all (free_map, sector, cnt));
c002d2dd:	83 ec 0c             	sub    $0xc,%esp
c002d2e0:	8d 83 60 71 ff ff    	lea    -0x8ea0(%ebx),%eax
c002d2e6:	50                   	push   %eax
c002d2e7:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d2ed:	50                   	push   %eax
c002d2ee:	8d 83 68 4c ff ff    	lea    -0xb398(%ebx),%eax
c002d2f4:	50                   	push   %eax
c002d2f5:	6a 2f                	push   $0x2f
c002d2f7:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d2fd:	50                   	push   %eax
c002d2fe:	e8 84 bf ff ff       	call   c0029287 <debug_panic>

c002d303 <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open (void) 
{
c002d303:	53                   	push   %ebx
c002d304:	83 ec 14             	sub    $0x14,%esp
c002d307:	e8 79 17 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d30c:	81 c3 a8 db 00 00    	add    $0xdba8,%ebx
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002d312:	6a 00                	push   $0x0
c002d314:	e8 5a 0b 00 00       	call   c002de73 <inode_open>
c002d319:	89 04 24             	mov    %eax,(%esp)
c002d31c:	e8 39 01 00 00       	call   c002d45a <file_open>
c002d321:	89 83 64 23 00 00    	mov    %eax,0x2364(%ebx)
  if (free_map_file == NULL)
c002d327:	83 c4 10             	add    $0x10,%esp
c002d32a:	85 c0                	test   %eax,%eax
c002d32c:	74 1b                	je     c002d349 <free_map_open+0x46>
    PANIC ("can't open free map");
  if (!bitmap_read (free_map, free_map_file))
c002d32e:	83 ec 08             	sub    $0x8,%esp
c002d331:	50                   	push   %eax
c002d332:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d338:	e8 23 d5 ff ff       	call   c002a860 <bitmap_read>
c002d33d:	83 c4 10             	add    $0x10,%esp
c002d340:	84 c0                	test   %al,%al
c002d342:	74 21                	je     c002d365 <free_map_open+0x62>
    PANIC ("can't read free map");
}
c002d344:	83 c4 08             	add    $0x8,%esp
c002d347:	5b                   	pop    %ebx
c002d348:	c3                   	ret    
    PANIC ("can't open free map");
c002d349:	8d 83 9c 71 ff ff    	lea    -0x8e64(%ebx),%eax
c002d34f:	50                   	push   %eax
c002d350:	8d 83 58 4c ff ff    	lea    -0xb3a8(%ebx),%eax
c002d356:	50                   	push   %eax
c002d357:	6a 3a                	push   $0x3a
c002d359:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d35f:	50                   	push   %eax
c002d360:	e8 22 bf ff ff       	call   c0029287 <debug_panic>
    PANIC ("can't read free map");
c002d365:	8d 83 b0 71 ff ff    	lea    -0x8e50(%ebx),%eax
c002d36b:	50                   	push   %eax
c002d36c:	8d 83 58 4c ff ff    	lea    -0xb3a8(%ebx),%eax
c002d372:	50                   	push   %eax
c002d373:	6a 3c                	push   $0x3c
c002d375:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d37b:	50                   	push   %eax
c002d37c:	e8 06 bf ff ff       	call   c0029287 <debug_panic>

c002d381 <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close (void) 
{
c002d381:	53                   	push   %ebx
c002d382:	83 ec 14             	sub    $0x14,%esp
c002d385:	e8 fb 16 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d38a:	81 c3 2a db 00 00    	add    $0xdb2a,%ebx
  file_close (free_map_file);
c002d390:	ff b3 64 23 00 00    	pushl  0x2364(%ebx)
c002d396:	e8 b3 02 00 00       	call   c002d64e <file_close>
}
c002d39b:	83 c4 18             	add    $0x18,%esp
c002d39e:	5b                   	pop    %ebx
c002d39f:	c3                   	ret    

c002d3a0 <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create (void) 
{
c002d3a0:	53                   	push   %ebx
c002d3a1:	83 ec 14             	sub    $0x14,%esp
c002d3a4:	e8 dc 16 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d3a9:	81 c3 0b db 00 00    	add    $0xdb0b,%ebx
  /* Create inode. */
  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map)))
c002d3af:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d3b5:	e8 96 d4 ff ff       	call   c002a850 <bitmap_file_size>
c002d3ba:	83 c4 08             	add    $0x8,%esp
c002d3bd:	50                   	push   %eax
c002d3be:	6a 00                	push   $0x0
c002d3c0:	e8 9e 09 00 00       	call   c002dd63 <inode_create>
c002d3c5:	83 c4 10             	add    $0x10,%esp
c002d3c8:	84 c0                	test   %al,%al
c002d3ca:	74 3a                	je     c002d406 <free_map_create+0x66>
    PANIC ("free map creation failed");

  /* Write bitmap to file. */
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002d3cc:	83 ec 0c             	sub    $0xc,%esp
c002d3cf:	6a 00                	push   $0x0
c002d3d1:	e8 9d 0a 00 00       	call   c002de73 <inode_open>
c002d3d6:	89 04 24             	mov    %eax,(%esp)
c002d3d9:	e8 7c 00 00 00       	call   c002d45a <file_open>
c002d3de:	89 83 64 23 00 00    	mov    %eax,0x2364(%ebx)
  if (free_map_file == NULL)
c002d3e4:	83 c4 10             	add    $0x10,%esp
c002d3e7:	85 c0                	test   %eax,%eax
c002d3e9:	74 37                	je     c002d422 <free_map_create+0x82>
    PANIC ("can't open free map");
  if (!bitmap_write (free_map, free_map_file))
c002d3eb:	83 ec 08             	sub    $0x8,%esp
c002d3ee:	50                   	push   %eax
c002d3ef:	ff b3 60 23 00 00    	pushl  0x2360(%ebx)
c002d3f5:	e8 d2 d4 ff ff       	call   c002a8cc <bitmap_write>
c002d3fa:	83 c4 10             	add    $0x10,%esp
c002d3fd:	84 c0                	test   %al,%al
c002d3ff:	74 3d                	je     c002d43e <free_map_create+0x9e>
    PANIC ("can't write free map");
}
c002d401:	83 c4 08             	add    $0x8,%esp
c002d404:	5b                   	pop    %ebx
c002d405:	c3                   	ret    
    PANIC ("free map creation failed");
c002d406:	8d 83 c4 71 ff ff    	lea    -0x8e3c(%ebx),%eax
c002d40c:	50                   	push   %eax
c002d40d:	8d 83 48 4c ff ff    	lea    -0xb3b8(%ebx),%eax
c002d413:	50                   	push   %eax
c002d414:	6a 4d                	push   $0x4d
c002d416:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d41c:	50                   	push   %eax
c002d41d:	e8 65 be ff ff       	call   c0029287 <debug_panic>
    PANIC ("can't open free map");
c002d422:	8d 83 9c 71 ff ff    	lea    -0x8e64(%ebx),%eax
c002d428:	50                   	push   %eax
c002d429:	8d 83 48 4c ff ff    	lea    -0xb3b8(%ebx),%eax
c002d42f:	50                   	push   %eax
c002d430:	6a 52                	push   $0x52
c002d432:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d438:	50                   	push   %eax
c002d439:	e8 49 be ff ff       	call   c0029287 <debug_panic>
    PANIC ("can't write free map");
c002d43e:	8d 83 dd 71 ff ff    	lea    -0x8e23(%ebx),%eax
c002d444:	50                   	push   %eax
c002d445:	8d 83 48 4c ff ff    	lea    -0xb3b8(%ebx),%eax
c002d44b:	50                   	push   %eax
c002d44c:	6a 54                	push   $0x54
c002d44e:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c002d454:	50                   	push   %eax
c002d455:	e8 2d be ff ff       	call   c0029287 <debug_panic>

c002d45a <file_open>:
/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open (struct inode *inode) 
{
c002d45a:	57                   	push   %edi
c002d45b:	56                   	push   %esi
c002d45c:	53                   	push   %ebx
c002d45d:	e8 23 16 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d462:	81 c3 52 da 00 00    	add    $0xda52,%ebx
c002d468:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct file *file = calloc (1, sizeof *file);
c002d46c:	83 ec 08             	sub    $0x8,%esp
c002d46f:	6a 0c                	push   $0xc
c002d471:	6a 01                	push   $0x1
c002d473:	e8 14 6c ff ff       	call   c002408c <calloc>
c002d478:	89 c6                	mov    %eax,%esi
  if (inode != NULL && file != NULL)
c002d47a:	83 c4 10             	add    $0x10,%esp
c002d47d:	85 ff                	test   %edi,%edi
c002d47f:	74 17                	je     c002d498 <file_open+0x3e>
c002d481:	85 c0                	test   %eax,%eax
c002d483:	74 13                	je     c002d498 <file_open+0x3e>
    {
      file->inode = inode;
c002d485:	89 38                	mov    %edi,(%eax)
      file->pos = 0;
c002d487:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      file->deny_write = false;
c002d48e:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    {
      inode_close (inode);
      free (file);
      return NULL; 
    }
}
c002d492:	89 f0                	mov    %esi,%eax
c002d494:	5b                   	pop    %ebx
c002d495:	5e                   	pop    %esi
c002d496:	5f                   	pop    %edi
c002d497:	c3                   	ret    
      inode_close (inode);
c002d498:	83 ec 0c             	sub    $0xc,%esp
c002d49b:	57                   	push   %edi
c002d49c:	e8 97 0a 00 00       	call   c002df38 <inode_close>
      free (file);
c002d4a1:	89 34 24             	mov    %esi,(%esp)
c002d4a4:	e8 34 6c ff ff       	call   c00240dd <free>
      return NULL; 
c002d4a9:	83 c4 10             	add    $0x10,%esp
c002d4ac:	be 00 00 00 00       	mov    $0x0,%esi
c002d4b1:	eb df                	jmp    c002d492 <file_open+0x38>

c002d4b3 <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen (struct file *file) 
{
c002d4b3:	53                   	push   %ebx
c002d4b4:	83 ec 14             	sub    $0x14,%esp
c002d4b7:	e8 c9 15 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d4bc:	81 c3 f8 d9 00 00    	add    $0xd9f8,%ebx
  return file_open (inode_reopen (file->inode));
c002d4c2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d4c6:	ff 30                	pushl  (%eax)
c002d4c8:	e8 98 09 00 00       	call   c002de65 <inode_reopen>
c002d4cd:	89 04 24             	mov    %eax,(%esp)
c002d4d0:	e8 85 ff ff ff       	call   c002d45a <file_open>
}
c002d4d5:	83 c4 18             	add    $0x18,%esp
c002d4d8:	5b                   	pop    %ebx
c002d4d9:	c3                   	ret    

c002d4da <file_get_inode>:

/* Returns the inode encapsulated by FILE. */
struct inode *
file_get_inode (struct file *file) 
{
  return file->inode;
c002d4da:	8b 44 24 04          	mov    0x4(%esp),%eax
c002d4de:	8b 00                	mov    (%eax),%eax
}
c002d4e0:	c3                   	ret    

c002d4e1 <file_read>:
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   Advances FILE's position by the number of bytes read. */
off_t
file_read (struct file *file, void *buffer, off_t size) 
{
c002d4e1:	56                   	push   %esi
c002d4e2:	53                   	push   %ebx
c002d4e3:	83 ec 04             	sub    $0x4,%esp
c002d4e6:	e8 9a 15 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d4eb:	81 c3 c9 d9 00 00    	add    $0xd9c9,%ebx
c002d4f1:	8b 74 24 10          	mov    0x10(%esp),%esi
  off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
c002d4f5:	ff 76 04             	pushl  0x4(%esi)
c002d4f8:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d4fc:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d500:	ff 36                	pushl  (%esi)
c002d502:	e8 fa 0a 00 00       	call   c002e001 <inode_read_at>
  file->pos += bytes_read;
c002d507:	01 46 04             	add    %eax,0x4(%esi)
  return bytes_read;
}
c002d50a:	83 c4 14             	add    $0x14,%esp
c002d50d:	5b                   	pop    %ebx
c002d50e:	5e                   	pop    %esi
c002d50f:	c3                   	ret    

c002d510 <file_read_at>:
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   The file's current position is unaffected. */
off_t
file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs) 
{
c002d510:	53                   	push   %ebx
c002d511:	83 ec 08             	sub    $0x8,%esp
c002d514:	e8 6c 15 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d519:	81 c3 9b d9 00 00    	add    $0xd99b,%ebx
  return inode_read_at (file->inode, buffer, size, file_ofs);
c002d51f:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d523:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d527:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d52b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d52f:	ff 30                	pushl  (%eax)
c002d531:	e8 cb 0a 00 00       	call   c002e001 <inode_read_at>
}
c002d536:	83 c4 18             	add    $0x18,%esp
c002d539:	5b                   	pop    %ebx
c002d53a:	c3                   	ret    

c002d53b <file_write>:
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   Advances FILE's position by the number of bytes read. */
off_t
file_write (struct file *file, const void *buffer, off_t size) 
{
c002d53b:	56                   	push   %esi
c002d53c:	53                   	push   %ebx
c002d53d:	83 ec 04             	sub    $0x4,%esp
c002d540:	e8 40 15 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d545:	81 c3 6f d9 00 00    	add    $0xd96f,%ebx
c002d54b:	8b 74 24 10          	mov    0x10(%esp),%esi
  off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
c002d54f:	ff 76 04             	pushl  0x4(%esi)
c002d552:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d556:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d55a:	ff 36                	pushl  (%esi)
c002d55c:	e8 fa 0b 00 00       	call   c002e15b <inode_write_at>
  file->pos += bytes_written;
c002d561:	01 46 04             	add    %eax,0x4(%esi)
  return bytes_written;
}
c002d564:	83 c4 14             	add    $0x14,%esp
c002d567:	5b                   	pop    %ebx
c002d568:	5e                   	pop    %esi
c002d569:	c3                   	ret    

c002d56a <file_write_at>:
   not yet implemented.)
   The file's current position is unaffected. */
off_t
file_write_at (struct file *file, const void *buffer, off_t size,
               off_t file_ofs) 
{
c002d56a:	53                   	push   %ebx
c002d56b:	83 ec 08             	sub    $0x8,%esp
c002d56e:	e8 12 15 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d573:	81 c3 41 d9 00 00    	add    $0xd941,%ebx
  return inode_write_at (file->inode, buffer, size, file_ofs);
c002d579:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d57d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d581:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d585:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d589:	ff 30                	pushl  (%eax)
c002d58b:	e8 cb 0b 00 00       	call   c002e15b <inode_write_at>
}
c002d590:	83 c4 18             	add    $0x18,%esp
c002d593:	5b                   	pop    %ebx
c002d594:	c3                   	ret    

c002d595 <file_deny_write>:

/* Prevents write operations on FILE's underlying inode
   until file_allow_write() is called or FILE is closed. */
void
file_deny_write (struct file *file) 
{
c002d595:	53                   	push   %ebx
c002d596:	83 ec 08             	sub    $0x8,%esp
c002d599:	e8 e7 14 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d59e:	81 c3 16 d9 00 00    	add    $0xd916,%ebx
c002d5a4:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002d5a8:	85 c0                	test   %eax,%eax
c002d5aa:	74 0b                	je     c002d5b7 <file_deny_write+0x22>
  if (!file->deny_write) 
c002d5ac:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002d5b0:	74 2b                	je     c002d5dd <file_deny_write+0x48>
    {
      file->deny_write = true;
      inode_deny_write (file->inode);
    }
}
c002d5b2:	83 c4 08             	add    $0x8,%esp
c002d5b5:	5b                   	pop    %ebx
c002d5b6:	c3                   	ret    
  ASSERT (file != NULL);
c002d5b7:	83 ec 0c             	sub    $0xc,%esp
c002d5ba:	8d 83 f2 71 ff ff    	lea    -0x8e0e(%ebx),%eax
c002d5c0:	50                   	push   %eax
c002d5c1:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d5c7:	50                   	push   %eax
c002d5c8:	8d 83 c4 4c ff ff    	lea    -0xb33c(%ebx),%eax
c002d5ce:	50                   	push   %eax
c002d5cf:	6a 79                	push   $0x79
c002d5d1:	8d 83 ff 71 ff ff    	lea    -0x8e01(%ebx),%eax
c002d5d7:	50                   	push   %eax
c002d5d8:	e8 aa bc ff ff       	call   c0029287 <debug_panic>
      file->deny_write = true;
c002d5dd:	c6 40 08 01          	movb   $0x1,0x8(%eax)
      inode_deny_write (file->inode);
c002d5e1:	83 ec 0c             	sub    $0xc,%esp
c002d5e4:	ff 30                	pushl  (%eax)
c002d5e6:	e8 1f 0d 00 00       	call   c002e30a <inode_deny_write>
c002d5eb:	83 c4 10             	add    $0x10,%esp
}
c002d5ee:	eb c2                	jmp    c002d5b2 <file_deny_write+0x1d>

c002d5f0 <file_allow_write>:
/* Re-enables write operations on FILE's underlying inode.
   (Writes might still be denied by some other file that has the
   same inode open.) */
void
file_allow_write (struct file *file) 
{
c002d5f0:	53                   	push   %ebx
c002d5f1:	83 ec 08             	sub    $0x8,%esp
c002d5f4:	e8 8c 14 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d5f9:	81 c3 bb d8 00 00    	add    $0xd8bb,%ebx
c002d5ff:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002d603:	85 c0                	test   %eax,%eax
c002d605:	74 0b                	je     c002d612 <file_allow_write+0x22>
  if (file->deny_write) 
c002d607:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002d60b:	75 2e                	jne    c002d63b <file_allow_write+0x4b>
    {
      file->deny_write = false;
      inode_allow_write (file->inode);
    }
}
c002d60d:	83 c4 08             	add    $0x8,%esp
c002d610:	5b                   	pop    %ebx
c002d611:	c3                   	ret    
  ASSERT (file != NULL);
c002d612:	83 ec 0c             	sub    $0xc,%esp
c002d615:	8d 83 f2 71 ff ff    	lea    -0x8e0e(%ebx),%eax
c002d61b:	50                   	push   %eax
c002d61c:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d622:	50                   	push   %eax
c002d623:	8d 83 b0 4c ff ff    	lea    -0xb350(%ebx),%eax
c002d629:	50                   	push   %eax
c002d62a:	68 87 00 00 00       	push   $0x87
c002d62f:	8d 83 ff 71 ff ff    	lea    -0x8e01(%ebx),%eax
c002d635:	50                   	push   %eax
c002d636:	e8 4c bc ff ff       	call   c0029287 <debug_panic>
      file->deny_write = false;
c002d63b:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      inode_allow_write (file->inode);
c002d63f:	83 ec 0c             	sub    $0xc,%esp
c002d642:	ff 30                	pushl  (%eax)
c002d644:	e8 10 0d 00 00       	call   c002e359 <inode_allow_write>
c002d649:	83 c4 10             	add    $0x10,%esp
}
c002d64c:	eb bf                	jmp    c002d60d <file_allow_write+0x1d>

c002d64e <file_close>:
{
c002d64e:	56                   	push   %esi
c002d64f:	53                   	push   %ebx
c002d650:	83 ec 04             	sub    $0x4,%esp
c002d653:	e8 2d 14 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d658:	81 c3 5c d8 00 00    	add    $0xd85c,%ebx
c002d65e:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (file != NULL)
c002d662:	85 f6                	test   %esi,%esi
c002d664:	74 1e                	je     c002d684 <file_close+0x36>
      file_allow_write (file);
c002d666:	83 ec 0c             	sub    $0xc,%esp
c002d669:	56                   	push   %esi
c002d66a:	e8 81 ff ff ff       	call   c002d5f0 <file_allow_write>
      inode_close (file->inode);
c002d66f:	83 c4 04             	add    $0x4,%esp
c002d672:	ff 36                	pushl  (%esi)
c002d674:	e8 bf 08 00 00       	call   c002df38 <inode_close>
      free (file); 
c002d679:	89 34 24             	mov    %esi,(%esp)
c002d67c:	e8 5c 6a ff ff       	call   c00240dd <free>
c002d681:	83 c4 10             	add    $0x10,%esp
}
c002d684:	83 c4 04             	add    $0x4,%esp
c002d687:	5b                   	pop    %ebx
c002d688:	5e                   	pop    %esi
c002d689:	c3                   	ret    

c002d68a <file_length>:

/* Returns the size of FILE in bytes. */
off_t
file_length (struct file *file) 
{
c002d68a:	53                   	push   %ebx
c002d68b:	83 ec 08             	sub    $0x8,%esp
c002d68e:	e8 f2 13 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d693:	81 c3 21 d8 00 00    	add    $0xd821,%ebx
c002d699:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002d69d:	85 c0                	test   %eax,%eax
c002d69f:	74 0f                	je     c002d6b0 <file_length+0x26>
  return inode_length (file->inode);
c002d6a1:	83 ec 0c             	sub    $0xc,%esp
c002d6a4:	ff 30                	pushl  (%eax)
c002d6a6:	e8 2a 0d 00 00       	call   c002e3d5 <inode_length>
}
c002d6ab:	83 c4 18             	add    $0x18,%esp
c002d6ae:	5b                   	pop    %ebx
c002d6af:	c3                   	ret    
  ASSERT (file != NULL);
c002d6b0:	83 ec 0c             	sub    $0xc,%esp
c002d6b3:	8d 83 f2 71 ff ff    	lea    -0x8e0e(%ebx),%eax
c002d6b9:	50                   	push   %eax
c002d6ba:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d6c0:	50                   	push   %eax
c002d6c1:	8d 83 a4 4c ff ff    	lea    -0xb35c(%ebx),%eax
c002d6c7:	50                   	push   %eax
c002d6c8:	68 93 00 00 00       	push   $0x93
c002d6cd:	8d 83 ff 71 ff ff    	lea    -0x8e01(%ebx),%eax
c002d6d3:	50                   	push   %eax
c002d6d4:	e8 ae bb ff ff       	call   c0029287 <debug_panic>

c002d6d9 <file_seek>:

/* Sets the current position in FILE to NEW_POS bytes from the
   start of the file. */
void
file_seek (struct file *file, off_t new_pos)
{
c002d6d9:	53                   	push   %ebx
c002d6da:	83 ec 08             	sub    $0x8,%esp
c002d6dd:	e8 a3 13 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d6e2:	81 c3 d2 d7 00 00    	add    $0xd7d2,%ebx
c002d6e8:	8b 44 24 10          	mov    0x10(%esp),%eax
c002d6ec:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (file != NULL);
c002d6f0:	85 c0                	test   %eax,%eax
c002d6f2:	74 0c                	je     c002d700 <file_seek+0x27>
  ASSERT (new_pos >= 0);
c002d6f4:	85 d2                	test   %edx,%edx
c002d6f6:	78 31                	js     c002d729 <file_seek+0x50>
  file->pos = new_pos;
c002d6f8:	89 50 04             	mov    %edx,0x4(%eax)
}
c002d6fb:	83 c4 08             	add    $0x8,%esp
c002d6fe:	5b                   	pop    %ebx
c002d6ff:	c3                   	ret    
  ASSERT (file != NULL);
c002d700:	83 ec 0c             	sub    $0xc,%esp
c002d703:	8d 83 f2 71 ff ff    	lea    -0x8e0e(%ebx),%eax
c002d709:	50                   	push   %eax
c002d70a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d710:	50                   	push   %eax
c002d711:	8d 83 98 4c ff ff    	lea    -0xb368(%ebx),%eax
c002d717:	50                   	push   %eax
c002d718:	68 9c 00 00 00       	push   $0x9c
c002d71d:	8d 83 ff 71 ff ff    	lea    -0x8e01(%ebx),%eax
c002d723:	50                   	push   %eax
c002d724:	e8 5e bb ff ff       	call   c0029287 <debug_panic>
  ASSERT (new_pos >= 0);
c002d729:	83 ec 0c             	sub    $0xc,%esp
c002d72c:	8d 83 14 72 ff ff    	lea    -0x8dec(%ebx),%eax
c002d732:	50                   	push   %eax
c002d733:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d739:	50                   	push   %eax
c002d73a:	8d 83 98 4c ff ff    	lea    -0xb368(%ebx),%eax
c002d740:	50                   	push   %eax
c002d741:	68 9d 00 00 00       	push   $0x9d
c002d746:	8d 83 ff 71 ff ff    	lea    -0x8e01(%ebx),%eax
c002d74c:	50                   	push   %eax
c002d74d:	e8 35 bb ff ff       	call   c0029287 <debug_panic>

c002d752 <file_tell>:

/* Returns the current position in FILE as a byte offset from the
   start of the file. */
off_t
file_tell (struct file *file) 
{
c002d752:	53                   	push   %ebx
c002d753:	83 ec 08             	sub    $0x8,%esp
c002d756:	e8 2a 13 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d75b:	81 c3 59 d7 00 00    	add    $0xd759,%ebx
c002d761:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (file != NULL);
c002d765:	85 c0                	test   %eax,%eax
c002d767:	74 08                	je     c002d771 <file_tell+0x1f>
  return file->pos;
c002d769:	8b 40 04             	mov    0x4(%eax),%eax
}
c002d76c:	83 c4 08             	add    $0x8,%esp
c002d76f:	5b                   	pop    %ebx
c002d770:	c3                   	ret    
  ASSERT (file != NULL);
c002d771:	83 ec 0c             	sub    $0xc,%esp
c002d774:	8d 83 f2 71 ff ff    	lea    -0x8e0e(%ebx),%eax
c002d77a:	50                   	push   %eax
c002d77b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d781:	50                   	push   %eax
c002d782:	8d 83 8c 4c ff ff    	lea    -0xb374(%ebx),%eax
c002d788:	50                   	push   %eax
c002d789:	68 a6 00 00 00       	push   $0xa6
c002d78e:	8d 83 ff 71 ff ff    	lea    -0x8e01(%ebx),%eax
c002d794:	50                   	push   %eax
c002d795:	e8 ed ba ff ff       	call   c0029287 <debug_panic>

c002d79a <lookup>:
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup (const struct dir *dir, const char *name,
        struct dir_entry *ep, off_t *ofsp) 
{
c002d79a:	55                   	push   %ebp
c002d79b:	57                   	push   %edi
c002d79c:	56                   	push   %esi
c002d79d:	53                   	push   %ebx
c002d79e:	83 ec 4c             	sub    $0x4c,%esp
c002d7a1:	e8 df 12 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d7a6:	81 c3 0e d7 00 00    	add    $0xd70e,%ebx
c002d7ac:	89 54 24 14          	mov    %edx,0x14(%esp)
c002d7b0:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  struct dir_entry e;
  size_t ofs;
  
  ASSERT (dir != NULL);
c002d7b4:	85 c0                	test   %eax,%eax
c002d7b6:	74 1c                	je     c002d7d4 <lookup+0x3a>
c002d7b8:	89 c5                	mov    %eax,%ebp
  ASSERT (name != NULL);
c002d7ba:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002d7bf:	74 39                	je     c002d7fa <lookup+0x60>

  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002d7c1:	be 00 00 00 00       	mov    $0x0,%esi
c002d7c6:	8d 7c 24 2c          	lea    0x2c(%esp),%edi
       ofs += sizeof e) 
    if (e.in_use && !strcmp (name, e.name)) 
c002d7ca:	8d 44 24 30          	lea    0x30(%esp),%eax
c002d7ce:	89 44 24 18          	mov    %eax,0x18(%esp)
c002d7d2:	eb 4f                	jmp    c002d823 <lookup+0x89>
  ASSERT (dir != NULL);
c002d7d4:	83 ec 0c             	sub    $0xc,%esp
c002d7d7:	8d 83 21 72 ff ff    	lea    -0x8ddf(%ebx),%eax
c002d7dd:	50                   	push   %eax
c002d7de:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d7e4:	50                   	push   %eax
c002d7e5:	8d 83 e8 4c ff ff    	lea    -0xb318(%ebx),%eax
c002d7eb:	50                   	push   %eax
c002d7ec:	6a 62                	push   $0x62
c002d7ee:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002d7f4:	50                   	push   %eax
c002d7f5:	e8 8d ba ff ff       	call   c0029287 <debug_panic>
  ASSERT (name != NULL);
c002d7fa:	83 ec 0c             	sub    $0xc,%esp
c002d7fd:	8d 83 ff 53 ff ff    	lea    -0xac01(%ebx),%eax
c002d803:	50                   	push   %eax
c002d804:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002d80a:	50                   	push   %eax
c002d80b:	8d 83 e8 4c ff ff    	lea    -0xb318(%ebx),%eax
c002d811:	50                   	push   %eax
c002d812:	6a 63                	push   $0x63
c002d814:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002d81a:	50                   	push   %eax
c002d81b:	e8 67 ba ff ff       	call   c0029287 <debug_panic>
       ofs += sizeof e) 
c002d820:	83 c6 14             	add    $0x14,%esi
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002d823:	89 74 24 10          	mov    %esi,0x10(%esp)
c002d827:	56                   	push   %esi
c002d828:	6a 14                	push   $0x14
c002d82a:	57                   	push   %edi
c002d82b:	ff 75 00             	pushl  0x0(%ebp)
c002d82e:	e8 ce 07 00 00       	call   c002e001 <inode_read_at>
c002d833:	83 c4 10             	add    $0x10,%esp
c002d836:	83 f8 14             	cmp    $0x14,%eax
c002d839:	75 61                	jne    c002d89c <lookup+0x102>
    if (e.in_use && !strcmp (name, e.name)) 
c002d83b:	0f b6 44 24 3f       	movzbl 0x3f(%esp),%eax
c002d840:	88 44 24 0f          	mov    %al,0xf(%esp)
c002d844:	84 c0                	test   %al,%al
c002d846:	74 d8                	je     c002d820 <lookup+0x86>
c002d848:	83 ec 08             	sub    $0x8,%esp
c002d84b:	ff 74 24 20          	pushl  0x20(%esp)
c002d84f:	ff 74 24 20          	pushl  0x20(%esp)
c002d853:	e8 f4 ac ff ff       	call   c002854c <strcmp>
c002d858:	83 c4 10             	add    $0x10,%esp
c002d85b:	85 c0                	test   %eax,%eax
c002d85d:	75 c1                	jne    c002d820 <lookup+0x86>
      {
        if (ep != NULL)
c002d85f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002d863:	85 d2                	test   %edx,%edx
c002d865:	74 22                	je     c002d889 <lookup+0xef>
          *ep = e;
c002d867:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002d86b:	89 02                	mov    %eax,(%edx)
c002d86d:	8b 44 24 30          	mov    0x30(%esp),%eax
c002d871:	89 42 04             	mov    %eax,0x4(%edx)
c002d874:	8b 44 24 34          	mov    0x34(%esp),%eax
c002d878:	89 42 08             	mov    %eax,0x8(%edx)
c002d87b:	8b 44 24 38          	mov    0x38(%esp),%eax
c002d87f:	89 42 0c             	mov    %eax,0xc(%edx)
c002d882:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002d886:	89 42 10             	mov    %eax,0x10(%edx)
        if (ofsp != NULL)
c002d889:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
c002d88e:	74 11                	je     c002d8a1 <lookup+0x107>
          *ofsp = ofs;
c002d890:	8b 44 24 60          	mov    0x60(%esp),%eax
c002d894:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002d898:	89 08                	mov    %ecx,(%eax)
c002d89a:	eb 05                	jmp    c002d8a1 <lookup+0x107>
        return true;
      }
  return false;
c002d89c:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
}
c002d8a1:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c002d8a6:	83 c4 4c             	add    $0x4c,%esp
c002d8a9:	5b                   	pop    %ebx
c002d8aa:	5e                   	pop    %esi
c002d8ab:	5f                   	pop    %edi
c002d8ac:	5d                   	pop    %ebp
c002d8ad:	c3                   	ret    

c002d8ae <dir_create>:
{
c002d8ae:	53                   	push   %ebx
c002d8af:	83 ec 10             	sub    $0x10,%esp
c002d8b2:	e8 ce 11 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d8b7:	81 c3 fd d5 00 00    	add    $0xd5fd,%ebx
c002d8bd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  return inode_create (sector, entry_cnt * sizeof (struct dir_entry));
c002d8c1:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002d8c4:	c1 e0 02             	shl    $0x2,%eax
c002d8c7:	50                   	push   %eax
c002d8c8:	ff 74 24 1c          	pushl  0x1c(%esp)
c002d8cc:	e8 92 04 00 00       	call   c002dd63 <inode_create>
}
c002d8d1:	83 c4 18             	add    $0x18,%esp
c002d8d4:	5b                   	pop    %ebx
c002d8d5:	c3                   	ret    

c002d8d6 <dir_open>:
{
c002d8d6:	57                   	push   %edi
c002d8d7:	56                   	push   %esi
c002d8d8:	53                   	push   %ebx
c002d8d9:	e8 a7 11 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d8de:	81 c3 d6 d5 00 00    	add    $0xd5d6,%ebx
c002d8e4:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct dir *dir = calloc (1, sizeof *dir);
c002d8e8:	83 ec 08             	sub    $0x8,%esp
c002d8eb:	6a 08                	push   $0x8
c002d8ed:	6a 01                	push   $0x1
c002d8ef:	e8 98 67 ff ff       	call   c002408c <calloc>
c002d8f4:	89 c6                	mov    %eax,%esi
  if (inode != NULL && dir != NULL)
c002d8f6:	83 c4 10             	add    $0x10,%esp
c002d8f9:	85 ff                	test   %edi,%edi
c002d8fb:	74 13                	je     c002d910 <dir_open+0x3a>
c002d8fd:	85 c0                	test   %eax,%eax
c002d8ff:	74 0f                	je     c002d910 <dir_open+0x3a>
      dir->inode = inode;
c002d901:	89 38                	mov    %edi,(%eax)
      dir->pos = 0;
c002d903:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
c002d90a:	89 f0                	mov    %esi,%eax
c002d90c:	5b                   	pop    %ebx
c002d90d:	5e                   	pop    %esi
c002d90e:	5f                   	pop    %edi
c002d90f:	c3                   	ret    
      inode_close (inode);
c002d910:	83 ec 0c             	sub    $0xc,%esp
c002d913:	57                   	push   %edi
c002d914:	e8 1f 06 00 00       	call   c002df38 <inode_close>
      free (dir);
c002d919:	89 34 24             	mov    %esi,(%esp)
c002d91c:	e8 bc 67 ff ff       	call   c00240dd <free>
      return NULL; 
c002d921:	83 c4 10             	add    $0x10,%esp
c002d924:	be 00 00 00 00       	mov    $0x0,%esi
c002d929:	eb df                	jmp    c002d90a <dir_open+0x34>

c002d92b <dir_open_root>:
{
c002d92b:	53                   	push   %ebx
c002d92c:	83 ec 14             	sub    $0x14,%esp
c002d92f:	e8 51 11 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d934:	81 c3 80 d5 00 00    	add    $0xd580,%ebx
  return dir_open (inode_open (ROOT_DIR_SECTOR));
c002d93a:	6a 01                	push   $0x1
c002d93c:	e8 32 05 00 00       	call   c002de73 <inode_open>
c002d941:	89 04 24             	mov    %eax,(%esp)
c002d944:	e8 8d ff ff ff       	call   c002d8d6 <dir_open>
}
c002d949:	83 c4 18             	add    $0x18,%esp
c002d94c:	5b                   	pop    %ebx
c002d94d:	c3                   	ret    

c002d94e <dir_reopen>:
{
c002d94e:	53                   	push   %ebx
c002d94f:	83 ec 14             	sub    $0x14,%esp
c002d952:	e8 2e 11 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d957:	81 c3 5d d5 00 00    	add    $0xd55d,%ebx
  return dir_open (inode_reopen (dir->inode));
c002d95d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002d961:	ff 30                	pushl  (%eax)
c002d963:	e8 fd 04 00 00       	call   c002de65 <inode_reopen>
c002d968:	89 04 24             	mov    %eax,(%esp)
c002d96b:	e8 66 ff ff ff       	call   c002d8d6 <dir_open>
}
c002d970:	83 c4 18             	add    $0x18,%esp
c002d973:	5b                   	pop    %ebx
c002d974:	c3                   	ret    

c002d975 <dir_close>:
{
c002d975:	56                   	push   %esi
c002d976:	53                   	push   %ebx
c002d977:	83 ec 04             	sub    $0x4,%esp
c002d97a:	e8 06 11 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d97f:	81 c3 35 d5 00 00    	add    $0xd535,%ebx
c002d985:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (dir != NULL)
c002d989:	85 f6                	test   %esi,%esi
c002d98b:	74 15                	je     c002d9a2 <dir_close+0x2d>
      inode_close (dir->inode);
c002d98d:	83 ec 0c             	sub    $0xc,%esp
c002d990:	ff 36                	pushl  (%esi)
c002d992:	e8 a1 05 00 00       	call   c002df38 <inode_close>
      free (dir);
c002d997:	89 34 24             	mov    %esi,(%esp)
c002d99a:	e8 3e 67 ff ff       	call   c00240dd <free>
c002d99f:	83 c4 10             	add    $0x10,%esp
}
c002d9a2:	83 c4 04             	add    $0x4,%esp
c002d9a5:	5b                   	pop    %ebx
c002d9a6:	5e                   	pop    %esi
c002d9a7:	c3                   	ret    

c002d9a8 <dir_get_inode>:
  return dir->inode;
c002d9a8:	8b 44 24 04          	mov    0x4(%esp),%eax
c002d9ac:	8b 00                	mov    (%eax),%eax
}
c002d9ae:	c3                   	ret    

c002d9af <dir_lookup>:
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup (const struct dir *dir, const char *name,
            struct inode **inode) 
{
c002d9af:	56                   	push   %esi
c002d9b0:	53                   	push   %ebx
c002d9b1:	83 ec 24             	sub    $0x24,%esp
c002d9b4:	e8 cc 10 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002d9b9:	81 c3 fb d4 00 00    	add    $0xd4fb,%ebx
c002d9bf:	8b 44 24 30          	mov    0x30(%esp),%eax
c002d9c3:	8b 54 24 34          	mov    0x34(%esp),%edx
c002d9c7:	8b 74 24 38          	mov    0x38(%esp),%esi
  struct dir_entry e;

  ASSERT (dir != NULL);
c002d9cb:	85 c0                	test   %eax,%eax
c002d9cd:	74 2b                	je     c002d9fa <dir_lookup+0x4b>
  ASSERT (name != NULL);
c002d9cf:	85 d2                	test   %edx,%edx
c002d9d1:	74 4d                	je     c002da20 <dir_lookup+0x71>

  if (lookup (dir, name, &e, NULL))
c002d9d3:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002d9d7:	83 ec 0c             	sub    $0xc,%esp
c002d9da:	6a 00                	push   $0x0
c002d9dc:	e8 b9 fd ff ff       	call   c002d79a <lookup>
c002d9e1:	83 c4 10             	add    $0x10,%esp
c002d9e4:	84 c0                	test   %al,%al
c002d9e6:	75 5e                	jne    c002da46 <dir_lookup+0x97>
    *inode = inode_open (e.inode_sector);
  else
    *inode = NULL;
c002d9e8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

  return *inode != NULL;
c002d9ee:	83 3e 00             	cmpl   $0x0,(%esi)
c002d9f1:	0f 95 c0             	setne  %al
}
c002d9f4:	83 c4 24             	add    $0x24,%esp
c002d9f7:	5b                   	pop    %ebx
c002d9f8:	5e                   	pop    %esi
c002d9f9:	c3                   	ret    
  ASSERT (dir != NULL);
c002d9fa:	83 ec 0c             	sub    $0xc,%esp
c002d9fd:	8d 83 21 72 ff ff    	lea    -0x8ddf(%ebx),%eax
c002da03:	50                   	push   %eax
c002da04:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002da0a:	50                   	push   %eax
c002da0b:	8d 83 f0 4c ff ff    	lea    -0xb310(%ebx),%eax
c002da11:	50                   	push   %eax
c002da12:	6a 7c                	push   $0x7c
c002da14:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002da1a:	50                   	push   %eax
c002da1b:	e8 67 b8 ff ff       	call   c0029287 <debug_panic>
  ASSERT (name != NULL);
c002da20:	83 ec 0c             	sub    $0xc,%esp
c002da23:	8d 83 ff 53 ff ff    	lea    -0xac01(%ebx),%eax
c002da29:	50                   	push   %eax
c002da2a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002da30:	50                   	push   %eax
c002da31:	8d 83 f0 4c ff ff    	lea    -0xb310(%ebx),%eax
c002da37:	50                   	push   %eax
c002da38:	6a 7d                	push   $0x7d
c002da3a:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002da40:	50                   	push   %eax
c002da41:	e8 41 b8 ff ff       	call   c0029287 <debug_panic>
    *inode = inode_open (e.inode_sector);
c002da46:	83 ec 0c             	sub    $0xc,%esp
c002da49:	ff 74 24 18          	pushl  0x18(%esp)
c002da4d:	e8 21 04 00 00       	call   c002de73 <inode_open>
c002da52:	89 06                	mov    %eax,(%esi)
c002da54:	83 c4 10             	add    $0x10,%esp
c002da57:	eb 95                	jmp    c002d9ee <dir_lookup+0x3f>

c002da59 <dir_add>:
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
{
c002da59:	55                   	push   %ebp
c002da5a:	57                   	push   %edi
c002da5b:	56                   	push   %esi
c002da5c:	53                   	push   %ebx
c002da5d:	83 ec 3c             	sub    $0x3c,%esp
c002da60:	e8 20 10 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002da65:	81 c3 4f d4 00 00    	add    $0xd44f,%ebx
c002da6b:	8b 6c 24 50          	mov    0x50(%esp),%ebp
c002da6f:	8b 74 24 54          	mov    0x54(%esp),%esi
  struct dir_entry e;
  off_t ofs;
  bool success = false;

  ASSERT (dir != NULL);
c002da73:	85 ed                	test   %ebp,%ebp
c002da75:	74 2d                	je     c002daa4 <dir_add+0x4b>
  ASSERT (name != NULL);
c002da77:	85 f6                	test   %esi,%esi
c002da79:	74 52                	je     c002dacd <dir_add+0x74>

  /* Check NAME for validity. */
  if (*name == '\0' || strlen (name) > NAME_MAX)
    return false;
c002da7b:	b8 00 00 00 00       	mov    $0x0,%eax
  if (*name == '\0' || strlen (name) > NAME_MAX)
c002da80:	80 3e 00             	cmpb   $0x0,(%esi)
c002da83:	74 17                	je     c002da9c <dir_add+0x43>
c002da85:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002da8a:	89 f7                	mov    %esi,%edi
c002da8c:	f2 ae                	repnz scas %es:(%edi),%al
c002da8e:	89 ca                	mov    %ecx,%edx
c002da90:	f7 d2                	not    %edx
c002da92:	89 d1                	mov    %edx,%ecx
c002da94:	83 e9 01             	sub    $0x1,%ecx
c002da97:	83 f9 0e             	cmp    $0xe,%ecx
c002da9a:	76 5a                	jbe    c002daf6 <dir_add+0x9d>
  e.inode_sector = inode_sector;
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;

 done:
  return success;
}
c002da9c:	83 c4 3c             	add    $0x3c,%esp
c002da9f:	5b                   	pop    %ebx
c002daa0:	5e                   	pop    %esi
c002daa1:	5f                   	pop    %edi
c002daa2:	5d                   	pop    %ebp
c002daa3:	c3                   	ret    
  ASSERT (dir != NULL);
c002daa4:	83 ec 0c             	sub    $0xc,%esp
c002daa7:	8d 83 21 72 ff ff    	lea    -0x8ddf(%ebx),%eax
c002daad:	50                   	push   %eax
c002daae:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002dab4:	50                   	push   %eax
c002dab5:	8d 83 e0 4c ff ff    	lea    -0xb320(%ebx),%eax
c002dabb:	50                   	push   %eax
c002dabc:	68 94 00 00 00       	push   $0x94
c002dac1:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002dac7:	50                   	push   %eax
c002dac8:	e8 ba b7 ff ff       	call   c0029287 <debug_panic>
  ASSERT (name != NULL);
c002dacd:	83 ec 0c             	sub    $0xc,%esp
c002dad0:	8d 83 ff 53 ff ff    	lea    -0xac01(%ebx),%eax
c002dad6:	50                   	push   %eax
c002dad7:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002dadd:	50                   	push   %eax
c002dade:	8d 83 e0 4c ff ff    	lea    -0xb320(%ebx),%eax
c002dae4:	50                   	push   %eax
c002dae5:	68 95 00 00 00       	push   $0x95
c002daea:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002daf0:	50                   	push   %eax
c002daf1:	e8 91 b7 ff ff       	call   c0029287 <debug_panic>
  if (lookup (dir, name, NULL, NULL))
c002daf6:	83 ec 0c             	sub    $0xc,%esp
c002daf9:	6a 00                	push   $0x0
c002dafb:	b9 00 00 00 00       	mov    $0x0,%ecx
c002db00:	89 f2                	mov    %esi,%edx
c002db02:	89 e8                	mov    %ebp,%eax
c002db04:	e8 91 fc ff ff       	call   c002d79a <lookup>
c002db09:	89 c2                	mov    %eax,%edx
c002db0b:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002db0e:	b8 00 00 00 00       	mov    $0x0,%eax
  if (lookup (dir, name, NULL, NULL))
c002db13:	84 d2                	test   %dl,%dl
c002db15:	75 85                	jne    c002da9c <dir_add+0x43>
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002db17:	bf 00 00 00 00       	mov    $0x0,%edi
c002db1c:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002db20:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002db24:	57                   	push   %edi
c002db25:	6a 14                	push   $0x14
c002db27:	ff 74 24 14          	pushl  0x14(%esp)
c002db2b:	ff 75 00             	pushl  0x0(%ebp)
c002db2e:	e8 ce 04 00 00       	call   c002e001 <inode_read_at>
c002db33:	83 c4 10             	add    $0x10,%esp
c002db36:	83 f8 14             	cmp    $0x14,%eax
c002db39:	75 0c                	jne    c002db47 <dir_add+0xee>
    if (!e.in_use)
c002db3b:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
c002db40:	74 05                	je     c002db47 <dir_add+0xee>
c002db42:	83 c7 14             	add    $0x14,%edi
c002db45:	eb dd                	jmp    c002db24 <dir_add+0xcb>
  e.in_use = true;
c002db47:	c6 44 24 2f 01       	movb   $0x1,0x2f(%esp)
  strlcpy (e.name, name, sizeof e.name);
c002db4c:	83 ec 04             	sub    $0x4,%esp
c002db4f:	6a 0f                	push   $0xf
c002db51:	56                   	push   %esi
c002db52:	8d 74 24 28          	lea    0x28(%esp),%esi
c002db56:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002db5a:	50                   	push   %eax
c002db5b:	e8 7c ad ff ff       	call   c00288dc <strlcpy>
  e.inode_sector = inode_sector;
c002db60:	8b 44 24 68          	mov    0x68(%esp),%eax
c002db64:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002db68:	57                   	push   %edi
c002db69:	6a 14                	push   $0x14
c002db6b:	56                   	push   %esi
c002db6c:	ff 75 00             	pushl  0x0(%ebp)
c002db6f:	e8 e7 05 00 00       	call   c002e15b <inode_write_at>
c002db74:	83 c4 20             	add    $0x20,%esp
c002db77:	83 f8 14             	cmp    $0x14,%eax
c002db7a:	0f 94 c0             	sete   %al
c002db7d:	e9 1a ff ff ff       	jmp    c002da9c <dir_add+0x43>

c002db82 <dir_remove>:
/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove (struct dir *dir, const char *name) 
{
c002db82:	55                   	push   %ebp
c002db83:	57                   	push   %edi
c002db84:	56                   	push   %esi
c002db85:	53                   	push   %ebx
c002db86:	83 ec 2c             	sub    $0x2c,%esp
c002db89:	e8 f7 0e 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002db8e:	81 c3 26 d3 00 00    	add    $0xd326,%ebx
c002db94:	8b 7c 24 40          	mov    0x40(%esp),%edi
c002db98:	8b 54 24 44          	mov    0x44(%esp),%edx
  struct dir_entry e;
  struct inode *inode = NULL;
  bool success = false;
  off_t ofs;

  ASSERT (dir != NULL);
c002db9c:	85 ff                	test   %edi,%edi
c002db9e:	74 38                	je     c002dbd8 <dir_remove+0x56>
  ASSERT (name != NULL);
c002dba0:	85 d2                	test   %edx,%edx
c002dba2:	74 5d                	je     c002dc01 <dir_remove+0x7f>

  /* Find directory entry. */
  if (!lookup (dir, name, &e, &ofs))
c002dba4:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002dba8:	83 ec 0c             	sub    $0xc,%esp
c002dbab:	8d 44 24 14          	lea    0x14(%esp),%eax
c002dbaf:	50                   	push   %eax
c002dbb0:	89 f8                	mov    %edi,%eax
c002dbb2:	e8 e3 fb ff ff       	call   c002d79a <lookup>
c002dbb7:	89 c6                	mov    %eax,%esi
c002dbb9:	83 c4 10             	add    $0x10,%esp
  struct inode *inode = NULL;
c002dbbc:	bd 00 00 00 00       	mov    $0x0,%ebp
  if (!lookup (dir, name, &e, &ofs))
c002dbc1:	84 c0                	test   %al,%al
c002dbc3:	75 65                	jne    c002dc2a <dir_remove+0xa8>
  /* Remove inode. */
  inode_remove (inode);
  success = true;

 done:
  inode_close (inode);
c002dbc5:	83 ec 0c             	sub    $0xc,%esp
c002dbc8:	55                   	push   %ebp
c002dbc9:	e8 6a 03 00 00       	call   c002df38 <inode_close>
  return success;
}
c002dbce:	89 f0                	mov    %esi,%eax
c002dbd0:	83 c4 3c             	add    $0x3c,%esp
c002dbd3:	5b                   	pop    %ebx
c002dbd4:	5e                   	pop    %esi
c002dbd5:	5f                   	pop    %edi
c002dbd6:	5d                   	pop    %ebp
c002dbd7:	c3                   	ret    
  ASSERT (dir != NULL);
c002dbd8:	83 ec 0c             	sub    $0xc,%esp
c002dbdb:	8d 83 21 72 ff ff    	lea    -0x8ddf(%ebx),%eax
c002dbe1:	50                   	push   %eax
c002dbe2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002dbe8:	50                   	push   %eax
c002dbe9:	8d 83 d4 4c ff ff    	lea    -0xb32c(%ebx),%eax
c002dbef:	50                   	push   %eax
c002dbf0:	68 c0 00 00 00       	push   $0xc0
c002dbf5:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002dbfb:	50                   	push   %eax
c002dbfc:	e8 86 b6 ff ff       	call   c0029287 <debug_panic>
  ASSERT (name != NULL);
c002dc01:	83 ec 0c             	sub    $0xc,%esp
c002dc04:	8d 83 ff 53 ff ff    	lea    -0xac01(%ebx),%eax
c002dc0a:	50                   	push   %eax
c002dc0b:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002dc11:	50                   	push   %eax
c002dc12:	8d 83 d4 4c ff ff    	lea    -0xb32c(%ebx),%eax
c002dc18:	50                   	push   %eax
c002dc19:	68 c1 00 00 00       	push   $0xc1
c002dc1e:	8d 83 2d 72 ff ff    	lea    -0x8dd3(%ebx),%eax
c002dc24:	50                   	push   %eax
c002dc25:	e8 5d b6 ff ff       	call   c0029287 <debug_panic>
  inode = inode_open (e.inode_sector);
c002dc2a:	83 ec 0c             	sub    $0xc,%esp
c002dc2d:	ff 74 24 18          	pushl  0x18(%esp)
c002dc31:	e8 3d 02 00 00       	call   c002de73 <inode_open>
c002dc36:	89 c5                	mov    %eax,%ebp
  if (inode == NULL)
c002dc38:	83 c4 10             	add    $0x10,%esp
c002dc3b:	85 c0                	test   %eax,%eax
c002dc3d:	74 3a                	je     c002dc79 <dir_remove+0xf7>
  e.in_use = false;
c002dc3f:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
  if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e) 
c002dc44:	ff 74 24 08          	pushl  0x8(%esp)
c002dc48:	6a 14                	push   $0x14
c002dc4a:	8d 44 24 14          	lea    0x14(%esp),%eax
c002dc4e:	50                   	push   %eax
c002dc4f:	ff 37                	pushl  (%edi)
c002dc51:	e8 05 05 00 00       	call   c002e15b <inode_write_at>
c002dc56:	83 c4 10             	add    $0x10,%esp
c002dc59:	83 f8 14             	cmp    $0x14,%eax
c002dc5c:	74 0a                	je     c002dc68 <dir_remove+0xe6>
  bool success = false;
c002dc5e:	be 00 00 00 00       	mov    $0x0,%esi
c002dc63:	e9 5d ff ff ff       	jmp    c002dbc5 <dir_remove+0x43>
  inode_remove (inode);
c002dc68:	83 ec 0c             	sub    $0xc,%esp
c002dc6b:	55                   	push   %ebp
c002dc6c:	e8 47 03 00 00       	call   c002dfb8 <inode_remove>
c002dc71:	83 c4 10             	add    $0x10,%esp
c002dc74:	e9 4c ff ff ff       	jmp    c002dbc5 <dir_remove+0x43>
  bool success = false;
c002dc79:	be 00 00 00 00       	mov    $0x0,%esi
c002dc7e:	e9 42 ff ff ff       	jmp    c002dbc5 <dir_remove+0x43>

c002dc83 <dir_readdir>:
/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
{
c002dc83:	55                   	push   %ebp
c002dc84:	57                   	push   %edi
c002dc85:	56                   	push   %esi
c002dc86:	53                   	push   %ebx
c002dc87:	83 ec 2c             	sub    $0x2c,%esp
c002dc8a:	e8 f6 0d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002dc8f:	81 c3 25 d2 00 00    	add    $0xd225,%ebx
c002dc95:	8b 74 24 40          	mov    0x40(%esp),%esi
  struct dir_entry e;

  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002dc99:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002dc9d:	ff 76 04             	pushl  0x4(%esi)
c002dca0:	6a 14                	push   $0x14
c002dca2:	55                   	push   %ebp
c002dca3:	ff 36                	pushl  (%esi)
c002dca5:	e8 57 03 00 00       	call   c002e001 <inode_read_at>
c002dcaa:	83 c4 10             	add    $0x10,%esp
c002dcad:	83 f8 14             	cmp    $0x14,%eax
c002dcb0:	75 27                	jne    c002dcd9 <dir_readdir+0x56>
    {
      dir->pos += sizeof e;
c002dcb2:	83 46 04 14          	addl   $0x14,0x4(%esi)
      if (e.in_use)
c002dcb6:	0f b6 7c 24 1f       	movzbl 0x1f(%esp),%edi
c002dcbb:	89 f8                	mov    %edi,%eax
c002dcbd:	84 c0                	test   %al,%al
c002dcbf:	74 dc                	je     c002dc9d <dir_readdir+0x1a>
        {
          strlcpy (name, e.name, NAME_MAX + 1);
c002dcc1:	83 ec 04             	sub    $0x4,%esp
c002dcc4:	6a 0f                	push   $0xf
c002dcc6:	8d 44 24 18          	lea    0x18(%esp),%eax
c002dcca:	50                   	push   %eax
c002dccb:	ff 74 24 50          	pushl  0x50(%esp)
c002dccf:	e8 08 ac ff ff       	call   c00288dc <strlcpy>
          return true;
c002dcd4:	83 c4 10             	add    $0x10,%esp
c002dcd7:	eb 05                	jmp    c002dcde <dir_readdir+0x5b>
        } 
    }
  return false;
c002dcd9:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002dcde:	89 f8                	mov    %edi,%eax
c002dce0:	83 c4 2c             	add    $0x2c,%esp
c002dce3:	5b                   	pop    %ebx
c002dce4:	5e                   	pop    %esi
c002dce5:	5f                   	pop    %edi
c002dce6:	5d                   	pop    %ebp
c002dce7:	c3                   	ret    

c002dce8 <byte_to_sector>:
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector (const struct inode *inode, off_t pos) 
{
c002dce8:	53                   	push   %ebx
c002dce9:	83 ec 08             	sub    $0x8,%esp
c002dcec:	e8 94 0d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002dcf1:	81 c3 c3 d1 00 00    	add    $0xd1c3,%ebx
  ASSERT (inode != NULL);
c002dcf7:	85 c0                	test   %eax,%eax
c002dcf9:	74 22                	je     c002dd1d <byte_to_sector+0x35>
  if (pos < inode->data.length)
    return inode->data.start + pos / BLOCK_SECTOR_SIZE;
  else
    return -1;
c002dcfb:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  if (pos < inode->data.length)
c002dd00:	39 50 1c             	cmp    %edx,0x1c(%eax)
c002dd03:	7e 11                	jle    c002dd16 <byte_to_sector+0x2e>
    return inode->data.start + pos / BLOCK_SECTOR_SIZE;
c002dd05:	8d 8a ff 01 00 00    	lea    0x1ff(%edx),%ecx
c002dd0b:	85 d2                	test   %edx,%edx
c002dd0d:	0f 49 ca             	cmovns %edx,%ecx
c002dd10:	c1 f9 09             	sar    $0x9,%ecx
c002dd13:	03 48 18             	add    0x18(%eax),%ecx
}
c002dd16:	89 c8                	mov    %ecx,%eax
c002dd18:	83 c4 08             	add    $0x8,%esp
c002dd1b:	5b                   	pop    %ebx
c002dd1c:	c3                   	ret    
  ASSERT (inode != NULL);
c002dd1d:	83 ec 0c             	sub    $0xc,%esp
c002dd20:	8d 83 47 72 ff ff    	lea    -0x8db9(%ebx),%eax
c002dd26:	50                   	push   %eax
c002dd27:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002dd2d:	50                   	push   %eax
c002dd2e:	8d 83 24 4d ff ff    	lea    -0xb2dc(%ebx),%eax
c002dd34:	50                   	push   %eax
c002dd35:	6a 31                	push   $0x31
c002dd37:	8d 83 55 72 ff ff    	lea    -0x8dab(%ebx),%eax
c002dd3d:	50                   	push   %eax
c002dd3e:	e8 44 b5 ff ff       	call   c0029287 <debug_panic>

c002dd43 <inode_init>:
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init (void) 
{
c002dd43:	53                   	push   %ebx
c002dd44:	83 ec 14             	sub    $0x14,%esp
c002dd47:	e8 39 0d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002dd4c:	81 c3 68 d1 00 00    	add    $0xd168,%ebx
  list_init (&open_inodes);
c002dd52:	8d 83 6c 25 00 00    	lea    0x256c(%ebx),%eax
c002dd58:	50                   	push   %eax
c002dd59:	e8 f6 b5 ff ff       	call   c0029354 <list_init>
}
c002dd5e:	83 c4 18             	add    $0x18,%esp
c002dd61:	5b                   	pop    %ebx
c002dd62:	c3                   	ret    

c002dd63 <inode_create>:
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create (block_sector_t sector, off_t length)
{
c002dd63:	55                   	push   %ebp
c002dd64:	57                   	push   %edi
c002dd65:	56                   	push   %esi
c002dd66:	53                   	push   %ebx
c002dd67:	83 ec 1c             	sub    $0x1c,%esp
c002dd6a:	e8 16 0d 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002dd6f:	81 c3 45 d1 00 00    	add    $0xd145,%ebx
c002dd75:	8b 7c 24 34          	mov    0x34(%esp),%edi
  struct inode_disk *disk_inode = NULL;
  bool success = false;

  ASSERT (length >= 0);
c002dd79:	85 ff                	test   %edi,%edi
c002dd7b:	78 6c                	js     c002dde9 <inode_create+0x86>

  /* If this assertion fails, the inode structure is not exactly
     one sector in size, and you should fix that. */
  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

  disk_inode = calloc (1, sizeof *disk_inode);
c002dd7d:	83 ec 08             	sub    $0x8,%esp
c002dd80:	68 00 02 00 00       	push   $0x200
c002dd85:	6a 01                	push   $0x1
c002dd87:	e8 00 63 ff ff       	call   c002408c <calloc>
c002dd8c:	89 c6                	mov    %eax,%esi
  if (disk_inode != NULL)
c002dd8e:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002dd91:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
  if (disk_inode != NULL)
c002dd96:	85 c0                	test   %eax,%eax
c002dd98:	74 42                	je     c002dddc <inode_create+0x79>
  return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002dd9a:	8d af fe 03 00 00    	lea    0x3fe(%edi),%ebp
c002dda0:	89 f8                	mov    %edi,%eax
c002dda2:	05 ff 01 00 00       	add    $0x1ff,%eax
c002dda7:	0f 49 e8             	cmovns %eax,%ebp
c002ddaa:	c1 fd 09             	sar    $0x9,%ebp
c002ddad:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    {
      size_t sectors = bytes_to_sectors (length);
      disk_inode->length = length;
c002ddb1:	89 7e 04             	mov    %edi,0x4(%esi)
      disk_inode->magic = INODE_MAGIC;
c002ddb4:	c7 46 08 44 4f 4e 49 	movl   $0x494e4f44,0x8(%esi)
      if (free_map_allocate (sectors, &disk_inode->start)) 
c002ddbb:	83 ec 08             	sub    $0x8,%esp
c002ddbe:	56                   	push   %esi
c002ddbf:	55                   	push   %ebp
c002ddc0:	e8 4c f4 ff ff       	call   c002d211 <free_map_allocate>
c002ddc5:	88 44 24 17          	mov    %al,0x17(%esp)
c002ddc9:	83 c4 10             	add    $0x10,%esp
c002ddcc:	84 c0                	test   %al,%al
c002ddce:	75 3f                	jne    c002de0f <inode_create+0xac>
              for (i = 0; i < sectors; i++) 
                block_write (fs_device, disk_inode->start + i, zeros);
            }
          success = true; 
        } 
      free (disk_inode);
c002ddd0:	83 ec 0c             	sub    $0xc,%esp
c002ddd3:	56                   	push   %esi
c002ddd4:	e8 04 63 ff ff       	call   c00240dd <free>
c002ddd9:	83 c4 10             	add    $0x10,%esp
    }
  return success;
}
c002dddc:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c002dde1:	83 c4 1c             	add    $0x1c,%esp
c002dde4:	5b                   	pop    %ebx
c002dde5:	5e                   	pop    %esi
c002dde6:	5f                   	pop    %edi
c002dde7:	5d                   	pop    %ebp
c002dde8:	c3                   	ret    
  ASSERT (length >= 0);
c002dde9:	83 ec 0c             	sub    $0xc,%esp
c002ddec:	8d 83 6b 72 ff ff    	lea    -0x8d95(%ebx),%eax
c002ddf2:	50                   	push   %eax
c002ddf3:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002ddf9:	50                   	push   %eax
c002ddfa:	8d 83 44 4d ff ff    	lea    -0xb2bc(%ebx),%eax
c002de00:	50                   	push   %eax
c002de01:	6a 4e                	push   $0x4e
c002de03:	8d 83 55 72 ff ff    	lea    -0x8dab(%ebx),%eax
c002de09:	50                   	push   %eax
c002de0a:	e8 78 b4 ff ff       	call   c0029287 <debug_panic>
          block_write (fs_device, sector, disk_inode);
c002de0f:	83 ec 04             	sub    $0x4,%esp
c002de12:	56                   	push   %esi
c002de13:	ff 74 24 38          	pushl  0x38(%esp)
c002de17:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002de1d:	ff 30                	pushl  (%eax)
c002de1f:	e8 35 75 ff ff       	call   c0025359 <block_write>
          if (sectors > 0) 
c002de24:	83 c4 10             	add    $0x10,%esp
c002de27:	85 ed                	test   %ebp,%ebp
c002de29:	74 a5                	je     c002ddd0 <inode_create+0x6d>
              for (i = 0; i < sectors; i++) 
c002de2b:	bf 00 00 00 00       	mov    $0x0,%edi
                block_write (fs_device, disk_inode->start + i, zeros);
c002de30:	8d ab 6c 23 00 00    	lea    0x236c(%ebx),%ebp
c002de36:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002de3c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002de40:	83 ec 04             	sub    $0x4,%esp
c002de43:	55                   	push   %ebp
c002de44:	89 f8                	mov    %edi,%eax
c002de46:	03 06                	add    (%esi),%eax
c002de48:	50                   	push   %eax
c002de49:	8b 44 24 18          	mov    0x18(%esp),%eax
c002de4d:	ff 30                	pushl  (%eax)
c002de4f:	e8 05 75 ff ff       	call   c0025359 <block_write>
              for (i = 0; i < sectors; i++) 
c002de54:	83 c7 01             	add    $0x1,%edi
c002de57:	83 c4 10             	add    $0x10,%esp
c002de5a:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c002de5e:	75 e0                	jne    c002de40 <inode_create+0xdd>
c002de60:	e9 6b ff ff ff       	jmp    c002ddd0 <inode_create+0x6d>

c002de65 <inode_reopen>:
}

/* Reopens and returns INODE. */
struct inode *
inode_reopen (struct inode *inode)
{
c002de65:	8b 44 24 04          	mov    0x4(%esp),%eax
  if (inode != NULL)
c002de69:	85 c0                	test   %eax,%eax
c002de6b:	74 04                	je     c002de71 <inode_reopen+0xc>
    inode->open_cnt++;
c002de6d:	83 40 0c 01          	addl   $0x1,0xc(%eax)
  return inode;
}
c002de71:	f3 c3                	repz ret 

c002de73 <inode_open>:
{
c002de73:	55                   	push   %ebp
c002de74:	57                   	push   %edi
c002de75:	56                   	push   %esi
c002de76:	53                   	push   %ebx
c002de77:	83 ec 18             	sub    $0x18,%esp
c002de7a:	e8 06 0c 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002de7f:	81 c3 35 d0 00 00    	add    $0xd035,%ebx
c002de85:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002de89:	8d 83 6c 25 00 00    	lea    0x256c(%ebx),%eax
c002de8f:	50                   	push   %eax
c002de90:	e8 17 b5 ff ff       	call   c00293ac <list_begin>
c002de95:	89 c6                	mov    %eax,%esi
c002de97:	83 c4 10             	add    $0x10,%esp
c002de9a:	8d ab 6c 25 00 00    	lea    0x256c(%ebx),%ebp
c002dea0:	83 ec 0c             	sub    $0xc,%esp
c002dea3:	55                   	push   %ebp
c002dea4:	e8 a5 b5 ff ff       	call   c002944e <list_end>
c002dea9:	83 c4 10             	add    $0x10,%esp
c002deac:	39 f0                	cmp    %esi,%eax
c002deae:	74 2b                	je     c002dedb <inode_open+0x68>
      if (inode->sector == sector) 
c002deb0:	39 7e 08             	cmp    %edi,0x8(%esi)
c002deb3:	74 10                	je     c002dec5 <inode_open+0x52>
       e = list_next (e)) 
c002deb5:	83 ec 0c             	sub    $0xc,%esp
c002deb8:	56                   	push   %esi
c002deb9:	e8 33 b5 ff ff       	call   c00293f1 <list_next>
c002debe:	89 c6                	mov    %eax,%esi
c002dec0:	83 c4 10             	add    $0x10,%esp
c002dec3:	eb db                	jmp    c002dea0 <inode_open+0x2d>
          inode_reopen (inode);
c002dec5:	83 ec 0c             	sub    $0xc,%esp
c002dec8:	56                   	push   %esi
c002dec9:	e8 97 ff ff ff       	call   c002de65 <inode_reopen>
          return inode; 
c002dece:	83 c4 10             	add    $0x10,%esp
}
c002ded1:	89 f0                	mov    %esi,%eax
c002ded3:	83 c4 0c             	add    $0xc,%esp
c002ded6:	5b                   	pop    %ebx
c002ded7:	5e                   	pop    %esi
c002ded8:	5f                   	pop    %edi
c002ded9:	5d                   	pop    %ebp
c002deda:	c3                   	ret    
  inode = malloc (sizeof *inode);
c002dedb:	83 ec 0c             	sub    $0xc,%esp
c002dede:	68 18 02 00 00       	push   $0x218
c002dee3:	e8 3f 60 ff ff       	call   c0023f27 <malloc>
c002dee8:	89 c6                	mov    %eax,%esi
  if (inode == NULL)
c002deea:	83 c4 10             	add    $0x10,%esp
c002deed:	85 c0                	test   %eax,%eax
c002deef:	74 e0                	je     c002ded1 <inode_open+0x5e>
  list_push_front (&open_inodes, &inode->elem);
c002def1:	83 ec 08             	sub    $0x8,%esp
c002def4:	50                   	push   %eax
c002def5:	8d 83 6c 25 00 00    	lea    0x256c(%ebx),%eax
c002defb:	50                   	push   %eax
c002defc:	e8 1c ba ff ff       	call   c002991d <list_push_front>
  inode->sector = sector;
c002df01:	89 7e 08             	mov    %edi,0x8(%esi)
  inode->open_cnt = 1;
c002df04:	c7 46 0c 01 00 00 00 	movl   $0x1,0xc(%esi)
  inode->deny_write_cnt = 0;
c002df0b:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  inode->removed = false;
c002df12:	c6 46 10 00          	movb   $0x0,0x10(%esi)
  block_read (fs_device, inode->sector, &inode->data);
c002df16:	83 c4 0c             	add    $0xc,%esp
c002df19:	8d 46 18             	lea    0x18(%esi),%eax
c002df1c:	50                   	push   %eax
c002df1d:	57                   	push   %edi
c002df1e:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002df24:	ff 30                	pushl  (%eax)
c002df26:	e8 fa 73 ff ff       	call   c0025325 <block_read>
  return inode;
c002df2b:	83 c4 10             	add    $0x10,%esp
c002df2e:	eb a1                	jmp    c002ded1 <inode_open+0x5e>

c002df30 <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber (const struct inode *inode)
{
  return inode->sector;
c002df30:	8b 44 24 04          	mov    0x4(%esp),%eax
c002df34:	8b 40 08             	mov    0x8(%eax),%eax
}
c002df37:	c3                   	ret    

c002df38 <inode_close>:
/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close (struct inode *inode) 
{
c002df38:	56                   	push   %esi
c002df39:	53                   	push   %ebx
c002df3a:	83 ec 04             	sub    $0x4,%esp
c002df3d:	e8 43 0b 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002df42:	81 c3 72 cf 00 00    	add    $0xcf72,%ebx
c002df48:	8b 74 24 10          	mov    0x10(%esp),%esi
  /* Ignore null pointer. */
  if (inode == NULL)
c002df4c:	85 f6                	test   %esi,%esi
c002df4e:	74 0d                	je     c002df5d <inode_close+0x25>
    return;

  /* Release resources if this was the last opener. */
  if (--inode->open_cnt == 0)
c002df50:	8b 46 0c             	mov    0xc(%esi),%eax
c002df53:	83 e8 01             	sub    $0x1,%eax
c002df56:	89 46 0c             	mov    %eax,0xc(%esi)
c002df59:	85 c0                	test   %eax,%eax
c002df5b:	74 06                	je     c002df63 <inode_close+0x2b>
                            bytes_to_sectors (inode->data.length)); 
        }

      free (inode); 
    }
}
c002df5d:	83 c4 04             	add    $0x4,%esp
c002df60:	5b                   	pop    %ebx
c002df61:	5e                   	pop    %esi
c002df62:	c3                   	ret    
      list_remove (&inode->elem);
c002df63:	83 ec 0c             	sub    $0xc,%esp
c002df66:	56                   	push   %esi
c002df67:	e8 eb b9 ff ff       	call   c0029957 <list_remove>
      if (inode->removed) 
c002df6c:	83 c4 10             	add    $0x10,%esp
c002df6f:	80 7e 10 00          	cmpb   $0x0,0x10(%esi)
c002df73:	75 0e                	jne    c002df83 <inode_close+0x4b>
      free (inode); 
c002df75:	83 ec 0c             	sub    $0xc,%esp
c002df78:	56                   	push   %esi
c002df79:	e8 5f 61 ff ff       	call   c00240dd <free>
c002df7e:	83 c4 10             	add    $0x10,%esp
c002df81:	eb da                	jmp    c002df5d <inode_close+0x25>
          free_map_release (inode->sector, 1);
c002df83:	83 ec 08             	sub    $0x8,%esp
c002df86:	6a 01                	push   $0x1
c002df88:	ff 76 08             	pushl  0x8(%esi)
c002df8b:	e8 f6 f2 ff ff       	call   c002d286 <free_map_release>
          free_map_release (inode->data.start,
c002df90:	83 c4 08             	add    $0x8,%esp
  return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002df93:	8b 56 1c             	mov    0x1c(%esi),%edx
c002df96:	8d 8a ff 01 00 00    	lea    0x1ff(%edx),%ecx
c002df9c:	8d 82 fe 03 00 00    	lea    0x3fe(%edx),%eax
c002dfa2:	85 c9                	test   %ecx,%ecx
c002dfa4:	0f 49 c1             	cmovns %ecx,%eax
c002dfa7:	c1 f8 09             	sar    $0x9,%eax
          free_map_release (inode->data.start,
c002dfaa:	50                   	push   %eax
c002dfab:	ff 76 18             	pushl  0x18(%esi)
c002dfae:	e8 d3 f2 ff ff       	call   c002d286 <free_map_release>
c002dfb3:	83 c4 10             	add    $0x10,%esp
c002dfb6:	eb bd                	jmp    c002df75 <inode_close+0x3d>

c002dfb8 <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove (struct inode *inode) 
{
c002dfb8:	53                   	push   %ebx
c002dfb9:	83 ec 08             	sub    $0x8,%esp
c002dfbc:	e8 c4 0a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002dfc1:	81 c3 f3 ce 00 00    	add    $0xcef3,%ebx
c002dfc7:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (inode != NULL);
c002dfcb:	85 c0                	test   %eax,%eax
c002dfcd:	74 09                	je     c002dfd8 <inode_remove+0x20>
  inode->removed = true;
c002dfcf:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002dfd3:	83 c4 08             	add    $0x8,%esp
c002dfd6:	5b                   	pop    %ebx
c002dfd7:	c3                   	ret    
  ASSERT (inode != NULL);
c002dfd8:	83 ec 0c             	sub    $0xc,%esp
c002dfdb:	8d 83 47 72 ff ff    	lea    -0x8db9(%ebx),%eax
c002dfe1:	50                   	push   %eax
c002dfe2:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002dfe8:	50                   	push   %eax
c002dfe9:	8d 83 34 4d ff ff    	lea    -0xb2cc(%ebx),%eax
c002dfef:	50                   	push   %eax
c002dff0:	68 c1 00 00 00       	push   $0xc1
c002dff5:	8d 83 55 72 ff ff    	lea    -0x8dab(%ebx),%eax
c002dffb:	50                   	push   %eax
c002dffc:	e8 86 b2 ff ff       	call   c0029287 <debug_panic>

c002e001 <inode_read_at>:
/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) 
{
c002e001:	55                   	push   %ebp
c002e002:	57                   	push   %edi
c002e003:	56                   	push   %esi
c002e004:	53                   	push   %ebx
c002e005:	83 ec 2c             	sub    $0x2c,%esp
c002e008:	e8 78 0a 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e00d:	81 c3 a7 ce 00 00    	add    $0xcea7,%ebx
c002e013:	8b 6c 24 4c          	mov    0x4c(%esp),%ebp
  uint8_t *buffer = buffer_;
  off_t bytes_read = 0;
  uint8_t *bounce = NULL;

  while (size > 0) 
c002e017:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002e01c:	0f 8e 27 01 00 00    	jle    c002e149 <inode_read_at+0x148>
  uint8_t *bounce = NULL;
c002e022:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e029:	00 
  off_t bytes_read = 0;
c002e02a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e031:	00 
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
              if (bounce == NULL)
                break;
            }
          block_read (fs_device, sector_idx, bounce);
c002e032:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002e038:	89 44 24 18          	mov    %eax,0x18(%esp)
          block_read (fs_device, sector_idx, buffer + bytes_read);
c002e03c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002e040:	eb 50                	jmp    c002e092 <inode_read_at+0x91>
          if (bounce == NULL) 
c002e042:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002e047:	0f 84 c8 00 00 00    	je     c002e115 <inode_read_at+0x114>
          block_read (fs_device, sector_idx, bounce);
c002e04d:	83 ec 04             	sub    $0x4,%esp
c002e050:	ff 74 24 0c          	pushl  0xc(%esp)
c002e054:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e058:	8b 44 24 24          	mov    0x24(%esp),%eax
c002e05c:	ff 30                	pushl  (%eax)
c002e05e:	e8 c2 72 ff ff       	call   c0025325 <block_read>
          memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002e063:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e067:	03 44 24 54          	add    0x54(%esp),%eax
c002e06b:	03 7c 24 18          	add    0x18(%esp),%edi
c002e06f:	83 c4 0c             	add    $0xc,%esp
c002e072:	56                   	push   %esi
c002e073:	57                   	push   %edi
c002e074:	50                   	push   %eax
c002e075:	e8 09 a4 ff ff       	call   c0028483 <memcpy>
c002e07a:	83 c4 10             	add    $0x10,%esp
        }
      
      /* Advance. */
      size -= chunk_size;
c002e07d:	29 74 24 48          	sub    %esi,0x48(%esp)
      offset += chunk_size;
c002e081:	01 f5                	add    %esi,%ebp
      bytes_read += chunk_size;
c002e083:	01 74 24 0c          	add    %esi,0xc(%esp)
  while (size > 0) 
c002e087:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002e08c:	0f 8e 9f 00 00 00    	jle    c002e131 <inode_read_at+0x130>
      block_sector_t sector_idx = byte_to_sector (inode, offset);
c002e092:	89 ea                	mov    %ebp,%edx
c002e094:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e098:	e8 4b fc ff ff       	call   c002dce8 <byte_to_sector>
c002e09d:	89 c1                	mov    %eax,%ecx
c002e09f:	89 44 24 14          	mov    %eax,0x14(%esp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e0a3:	89 e8                	mov    %ebp,%eax
c002e0a5:	c1 f8 1f             	sar    $0x1f,%eax
c002e0a8:	c1 e8 17             	shr    $0x17,%eax
c002e0ab:	8d 7c 05 00          	lea    0x0(%ebp,%eax,1),%edi
c002e0af:	81 e7 ff 01 00 00    	and    $0x1ff,%edi
c002e0b5:	29 c7                	sub    %eax,%edi
      off_t inode_left = inode_length (inode) - offset;
c002e0b7:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e0bb:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e0be:	89 44 24 10          	mov    %eax,0x10(%esp)
c002e0c2:	89 c6                	mov    %eax,%esi
c002e0c4:	29 ee                	sub    %ebp,%esi
      int chunk_size = size < min_left ? size : min_left;
c002e0c6:	3b 74 24 48          	cmp    0x48(%esp),%esi
c002e0ca:	0f 4f 74 24 48       	cmovg  0x48(%esp),%esi
c002e0cf:	89 f0                	mov    %esi,%eax
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e0d1:	be 00 02 00 00       	mov    $0x200,%esi
c002e0d6:	29 fe                	sub    %edi,%esi
      int chunk_size = size < min_left ? size : min_left;
c002e0d8:	39 f0                	cmp    %esi,%eax
c002e0da:	0f 4e f0             	cmovle %eax,%esi
      if (chunk_size <= 0)
c002e0dd:	85 f6                	test   %esi,%esi
c002e0df:	7e 50                	jle    c002e131 <inode_read_at+0x130>
      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002e0e1:	85 ff                	test   %edi,%edi
c002e0e3:	0f 85 59 ff ff ff    	jne    c002e042 <inode_read_at+0x41>
c002e0e9:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002e0ef:	0f 85 4d ff ff ff    	jne    c002e042 <inode_read_at+0x41>
          block_read (fs_device, sector_idx, buffer + bytes_read);
c002e0f5:	83 ec 04             	sub    $0x4,%esp
c002e0f8:	8b 44 24 10          	mov    0x10(%esp),%eax
c002e0fc:	03 44 24 48          	add    0x48(%esp),%eax
c002e100:	50                   	push   %eax
c002e101:	51                   	push   %ecx
c002e102:	8b 44 24 28          	mov    0x28(%esp),%eax
c002e106:	ff 30                	pushl  (%eax)
c002e108:	e8 18 72 ff ff       	call   c0025325 <block_read>
c002e10d:	83 c4 10             	add    $0x10,%esp
c002e110:	e9 68 ff ff ff       	jmp    c002e07d <inode_read_at+0x7c>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002e115:	83 ec 0c             	sub    $0xc,%esp
c002e118:	68 00 02 00 00       	push   $0x200
c002e11d:	e8 05 5e ff ff       	call   c0023f27 <malloc>
c002e122:	89 44 24 18          	mov    %eax,0x18(%esp)
              if (bounce == NULL)
c002e126:	83 c4 10             	add    $0x10,%esp
c002e129:	85 c0                	test   %eax,%eax
c002e12b:	0f 85 1c ff ff ff    	jne    c002e04d <inode_read_at+0x4c>
    }
  free (bounce);
c002e131:	83 ec 0c             	sub    $0xc,%esp
c002e134:	ff 74 24 14          	pushl  0x14(%esp)
c002e138:	e8 a0 5f ff ff       	call   c00240dd <free>

  return bytes_read;
}
c002e13d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e141:	83 c4 3c             	add    $0x3c,%esp
c002e144:	5b                   	pop    %ebx
c002e145:	5e                   	pop    %esi
c002e146:	5f                   	pop    %edi
c002e147:	5d                   	pop    %ebp
c002e148:	c3                   	ret    
  off_t bytes_read = 0;
c002e149:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e150:	00 
  uint8_t *bounce = NULL;
c002e151:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e158:	00 
c002e159:	eb d6                	jmp    c002e131 <inode_read_at+0x130>

c002e15b <inode_write_at>:
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at (struct inode *inode, const void *buffer_, off_t size,
                off_t offset) 
{
c002e15b:	55                   	push   %ebp
c002e15c:	57                   	push   %edi
c002e15d:	56                   	push   %esi
c002e15e:	53                   	push   %ebx
c002e15f:	83 ec 2c             	sub    $0x2c,%esp
c002e162:	e8 1e 09 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e167:	81 c3 4d cd 00 00    	add    $0xcd4d,%ebx
  const uint8_t *buffer = buffer_;
  off_t bytes_written = 0;
  uint8_t *bounce = NULL;

  if (inode->deny_write_cnt)
c002e16d:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e171:	8b 40 14             	mov    0x14(%eax),%eax
c002e174:	89 44 24 08          	mov    %eax,0x8(%esp)
c002e178:	85 c0                	test   %eax,%eax
c002e17a:	0f 85 7d 01 00 00    	jne    c002e2fd <inode_write_at+0x1a2>
    return 0;

  while (size > 0) 
c002e180:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002e185:	0f 8e 65 01 00 00    	jle    c002e2f0 <inode_write_at+0x195>
  uint8_t *bounce = NULL;
c002e18b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e192:	00 
          if (sector_ofs > 0 || chunk_size < sector_left) 
            block_read (fs_device, sector_idx, bounce);
          else
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
          memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
          block_write (fs_device, sector_idx, bounce);
c002e193:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002e199:	89 44 24 18          	mov    %eax,0x18(%esp)
            block_read (fs_device, sector_idx, bounce);
c002e19d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002e1a1:	e9 b1 00 00 00       	jmp    c002e257 <inode_write_at+0xfc>
          block_write (fs_device, sector_idx, buffer + bytes_written);
c002e1a6:	83 ec 04             	sub    $0x4,%esp
c002e1a9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002e1ad:	03 44 24 48          	add    0x48(%esp),%eax
c002e1b1:	50                   	push   %eax
c002e1b2:	51                   	push   %ecx
c002e1b3:	c7 c0 3c d4 03 c0    	mov    $0xc003d43c,%eax
c002e1b9:	ff 30                	pushl  (%eax)
c002e1bb:	e8 99 71 ff ff       	call   c0025359 <block_write>
c002e1c0:	83 c4 10             	add    $0x10,%esp
c002e1c3:	eb 7f                	jmp    c002e244 <inode_write_at+0xe9>
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002e1c5:	83 ec 0c             	sub    $0xc,%esp
c002e1c8:	68 00 02 00 00       	push   $0x200
c002e1cd:	e8 55 5d ff ff       	call   c0023f27 <malloc>
c002e1d2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
              if (bounce == NULL)
c002e1d6:	83 c4 10             	add    $0x10,%esp
c002e1d9:	85 c0                	test   %eax,%eax
c002e1db:	0f 85 ea 00 00 00    	jne    c002e2cb <inode_write_at+0x170>
      /* Advance. */
      size -= chunk_size;
      offset += chunk_size;
      bytes_written += chunk_size;
    }
  free (bounce);
c002e1e1:	83 ec 0c             	sub    $0xc,%esp
c002e1e4:	ff 74 24 18          	pushl  0x18(%esp)
c002e1e8:	e8 f0 5e ff ff       	call   c00240dd <free>

  return bytes_written;
c002e1ed:	83 c4 10             	add    $0x10,%esp
}
c002e1f0:	8b 44 24 08          	mov    0x8(%esp),%eax
c002e1f4:	83 c4 2c             	add    $0x2c,%esp
c002e1f7:	5b                   	pop    %ebx
c002e1f8:	5e                   	pop    %esi
c002e1f9:	5f                   	pop    %edi
c002e1fa:	5d                   	pop    %ebp
c002e1fb:	c3                   	ret    
            block_read (fs_device, sector_idx, bounce);
c002e1fc:	83 ec 04             	sub    $0x4,%esp
c002e1ff:	ff 74 24 10          	pushl  0x10(%esp)
c002e203:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e207:	8b 44 24 28          	mov    0x28(%esp),%eax
c002e20b:	ff 30                	pushl  (%eax)
c002e20d:	e8 13 71 ff ff       	call   c0025325 <block_read>
c002e212:	83 c4 10             	add    $0x10,%esp
          memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002e215:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002e219:	01 fd                	add    %edi,%ebp
c002e21b:	8b 44 24 08          	mov    0x8(%esp),%eax
c002e21f:	03 44 24 44          	add    0x44(%esp),%eax
c002e223:	83 ec 04             	sub    $0x4,%esp
c002e226:	56                   	push   %esi
c002e227:	50                   	push   %eax
c002e228:	55                   	push   %ebp
c002e229:	e8 55 a2 ff ff       	call   c0028483 <memcpy>
          block_write (fs_device, sector_idx, bounce);
c002e22e:	83 c4 0c             	add    $0xc,%esp
c002e231:	57                   	push   %edi
c002e232:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e236:	8b 44 24 24          	mov    0x24(%esp),%eax
c002e23a:	ff 30                	pushl  (%eax)
c002e23c:	e8 18 71 ff ff       	call   c0025359 <block_write>
c002e241:	83 c4 10             	add    $0x10,%esp
      size -= chunk_size;
c002e244:	29 74 24 48          	sub    %esi,0x48(%esp)
      offset += chunk_size;
c002e248:	01 74 24 4c          	add    %esi,0x4c(%esp)
      bytes_written += chunk_size;
c002e24c:	01 74 24 08          	add    %esi,0x8(%esp)
  while (size > 0) 
c002e250:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c002e255:	7e 8a                	jle    c002e1e1 <inode_write_at+0x86>
      block_sector_t sector_idx = byte_to_sector (inode, offset);
c002e257:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c002e25b:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e25f:	e8 84 fa ff ff       	call   c002dce8 <byte_to_sector>
c002e264:	89 c1                	mov    %eax,%ecx
c002e266:	89 44 24 14          	mov    %eax,0x14(%esp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002e26a:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002e26e:	c1 f8 1f             	sar    $0x1f,%eax
c002e271:	c1 e8 17             	shr    $0x17,%eax
c002e274:	89 c5                	mov    %eax,%ebp
c002e276:	03 6c 24 4c          	add    0x4c(%esp),%ebp
c002e27a:	81 e5 ff 01 00 00    	and    $0x1ff,%ebp
c002e280:	29 c5                	sub    %eax,%ebp
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002e282:	bf 00 02 00 00       	mov    $0x200,%edi
c002e287:	29 ef                	sub    %ebp,%edi
      off_t inode_left = inode_length (inode) - offset;
c002e289:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e28d:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e290:	89 44 24 10          	mov    %eax,0x10(%esp)
c002e294:	89 c6                	mov    %eax,%esi
c002e296:	2b 74 24 4c          	sub    0x4c(%esp),%esi
      int chunk_size = size < min_left ? size : min_left;
c002e29a:	3b 74 24 48          	cmp    0x48(%esp),%esi
c002e29e:	0f 4f 74 24 48       	cmovg  0x48(%esp),%esi
c002e2a3:	39 fe                	cmp    %edi,%esi
c002e2a5:	0f 4f f7             	cmovg  %edi,%esi
      if (chunk_size <= 0)
c002e2a8:	85 f6                	test   %esi,%esi
c002e2aa:	0f 8e 31 ff ff ff    	jle    c002e1e1 <inode_write_at+0x86>
      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002e2b0:	85 ed                	test   %ebp,%ebp
c002e2b2:	75 0c                	jne    c002e2c0 <inode_write_at+0x165>
c002e2b4:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002e2ba:	0f 84 e6 fe ff ff    	je     c002e1a6 <inode_write_at+0x4b>
          if (bounce == NULL) 
c002e2c0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c002e2c5:	0f 84 fa fe ff ff    	je     c002e1c5 <inode_write_at+0x6a>
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002e2cb:	85 ed                	test   %ebp,%ebp
c002e2cd:	0f 8f 29 ff ff ff    	jg     c002e1fc <inode_write_at+0xa1>
c002e2d3:	39 f7                	cmp    %esi,%edi
c002e2d5:	0f 8f 21 ff ff ff    	jg     c002e1fc <inode_write_at+0xa1>
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
c002e2db:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e2e0:	b8 00 00 00 00       	mov    $0x0,%eax
c002e2e5:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002e2e9:	f3 ab                	rep stos %eax,%es:(%edi)
c002e2eb:	e9 25 ff ff ff       	jmp    c002e215 <inode_write_at+0xba>
  uint8_t *bounce = NULL;
c002e2f0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e2f7:	00 
c002e2f8:	e9 e4 fe ff ff       	jmp    c002e1e1 <inode_write_at+0x86>
    return 0;
c002e2fd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002e304:	00 
c002e305:	e9 e6 fe ff ff       	jmp    c002e1f0 <inode_write_at+0x95>

c002e30a <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write (struct inode *inode) 
{
c002e30a:	53                   	push   %ebx
c002e30b:	83 ec 08             	sub    $0x8,%esp
c002e30e:	e8 72 07 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e313:	81 c3 a1 cb 00 00    	add    $0xcba1,%ebx
c002e319:	8b 54 24 10          	mov    0x10(%esp),%edx
  inode->deny_write_cnt++;
c002e31d:	8b 42 14             	mov    0x14(%edx),%eax
c002e320:	83 c0 01             	add    $0x1,%eax
c002e323:	89 42 14             	mov    %eax,0x14(%edx)
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e326:	3b 42 0c             	cmp    0xc(%edx),%eax
c002e329:	7f 05                	jg     c002e330 <inode_deny_write+0x26>
}
c002e32b:	83 c4 08             	add    $0x8,%esp
c002e32e:	5b                   	pop    %ebx
c002e32f:	c3                   	ret    
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e330:	83 ec 0c             	sub    $0xc,%esp
c002e333:	8d 83 94 72 ff ff    	lea    -0x8d6c(%ebx),%eax
c002e339:	50                   	push   %eax
c002e33a:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002e340:	50                   	push   %eax
c002e341:	8d 83 10 4d ff ff    	lea    -0xb2f0(%ebx),%eax
c002e347:	50                   	push   %eax
c002e348:	68 46 01 00 00       	push   $0x146
c002e34d:	8d 83 55 72 ff ff    	lea    -0x8dab(%ebx),%eax
c002e353:	50                   	push   %eax
c002e354:	e8 2e af ff ff       	call   c0029287 <debug_panic>

c002e359 <inode_allow_write>:
/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write (struct inode *inode) 
{
c002e359:	53                   	push   %ebx
c002e35a:	83 ec 08             	sub    $0x8,%esp
c002e35d:	e8 23 07 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e362:	81 c3 52 cb 00 00    	add    $0xcb52,%ebx
c002e368:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT (inode->deny_write_cnt > 0);
c002e36c:	8b 42 14             	mov    0x14(%edx),%eax
c002e36f:	85 c0                	test   %eax,%eax
c002e371:	7e 10                	jle    c002e383 <inode_allow_write+0x2a>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e373:	3b 42 0c             	cmp    0xc(%edx),%eax
c002e376:	7f 34                	jg     c002e3ac <inode_allow_write+0x53>
  inode->deny_write_cnt--;
c002e378:	83 e8 01             	sub    $0x1,%eax
c002e37b:	89 42 14             	mov    %eax,0x14(%edx)
}
c002e37e:	83 c4 08             	add    $0x8,%esp
c002e381:	5b                   	pop    %ebx
c002e382:	c3                   	ret    
  ASSERT (inode->deny_write_cnt > 0);
c002e383:	83 ec 0c             	sub    $0xc,%esp
c002e386:	8d 83 77 72 ff ff    	lea    -0x8d89(%ebx),%eax
c002e38c:	50                   	push   %eax
c002e38d:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002e393:	50                   	push   %eax
c002e394:	8d 83 fc 4c ff ff    	lea    -0xb304(%ebx),%eax
c002e39a:	50                   	push   %eax
c002e39b:	68 4f 01 00 00       	push   $0x14f
c002e3a0:	8d 83 55 72 ff ff    	lea    -0x8dab(%ebx),%eax
c002e3a6:	50                   	push   %eax
c002e3a7:	e8 db ae ff ff       	call   c0029287 <debug_panic>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002e3ac:	83 ec 0c             	sub    $0xc,%esp
c002e3af:	8d 83 94 72 ff ff    	lea    -0x8d6c(%ebx),%eax
c002e3b5:	50                   	push   %eax
c002e3b6:	8d 83 45 4e ff ff    	lea    -0xb1bb(%ebx),%eax
c002e3bc:	50                   	push   %eax
c002e3bd:	8d 83 fc 4c ff ff    	lea    -0xb304(%ebx),%eax
c002e3c3:	50                   	push   %eax
c002e3c4:	68 50 01 00 00       	push   $0x150
c002e3c9:	8d 83 55 72 ff ff    	lea    -0x8dab(%ebx),%eax
c002e3cf:	50                   	push   %eax
c002e3d0:	e8 b2 ae ff ff       	call   c0029287 <debug_panic>

c002e3d5 <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length (const struct inode *inode)
{
  return inode->data.length;
c002e3d5:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e3d9:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002e3dc:	c3                   	ret    

c002e3dd <fsutil_ls>:
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls (char **argv UNUSED) 
{
c002e3dd:	57                   	push   %edi
c002e3de:	56                   	push   %esi
c002e3df:	53                   	push   %ebx
c002e3e0:	83 ec 1c             	sub    $0x1c,%esp
c002e3e3:	e8 9d 06 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e3e8:	81 c3 cc ca 00 00    	add    $0xcacc,%ebx
  struct dir *dir;
  char name[NAME_MAX + 1];
  
  printf ("Files in the root directory:\n");
c002e3ee:	8d 83 bd 72 ff ff    	lea    -0x8d43(%ebx),%eax
c002e3f4:	50                   	push   %eax
c002e3f5:	e8 66 ce ff ff       	call   c002b260 <puts>
  dir = dir_open_root ();
c002e3fa:	e8 2c f5 ff ff       	call   c002d92b <dir_open_root>
  if (dir == NULL)
c002e3ff:	83 c4 10             	add    $0x10,%esp
c002e402:	85 c0                	test   %eax,%eax
c002e404:	74 08                	je     c002e40e <fsutil_ls+0x31>
c002e406:	89 c7                	mov    %eax,%edi
    PANIC ("root dir open failed");
  while (dir_readdir (dir, name))
c002e408:	8d 74 24 01          	lea    0x1(%esp),%esi
c002e40c:	eb 28                	jmp    c002e436 <fsutil_ls+0x59>
    PANIC ("root dir open failed");
c002e40e:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
c002e414:	50                   	push   %eax
c002e415:	8d 83 8c 4d ff ff    	lea    -0xb274(%ebx),%eax
c002e41b:	50                   	push   %eax
c002e41c:	6a 18                	push   $0x18
c002e41e:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e424:	50                   	push   %eax
c002e425:	e8 5d ae ff ff       	call   c0029287 <debug_panic>
    printf ("%s\n", name);
c002e42a:	83 ec 0c             	sub    $0xc,%esp
c002e42d:	56                   	push   %esi
c002e42e:	e8 2d ce ff ff       	call   c002b260 <puts>
c002e433:	83 c4 10             	add    $0x10,%esp
  while (dir_readdir (dir, name))
c002e436:	83 ec 08             	sub    $0x8,%esp
c002e439:	56                   	push   %esi
c002e43a:	57                   	push   %edi
c002e43b:	e8 43 f8 ff ff       	call   c002dc83 <dir_readdir>
c002e440:	83 c4 10             	add    $0x10,%esp
c002e443:	84 c0                	test   %al,%al
c002e445:	75 e3                	jne    c002e42a <fsutil_ls+0x4d>
  dir_close (dir);
c002e447:	83 ec 0c             	sub    $0xc,%esp
c002e44a:	57                   	push   %edi
c002e44b:	e8 25 f5 ff ff       	call   c002d975 <dir_close>
  printf ("End of listing.\n");
c002e450:	8d 83 06 73 ff ff    	lea    -0x8cfa(%ebx),%eax
c002e456:	89 04 24             	mov    %eax,(%esp)
c002e459:	e8 02 ce ff ff       	call   c002b260 <puts>
}
c002e45e:	83 c4 20             	add    $0x20,%esp
c002e461:	5b                   	pop    %ebx
c002e462:	5e                   	pop    %esi
c002e463:	5f                   	pop    %edi
c002e464:	c3                   	ret    

c002e465 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat (char **argv)
{
c002e465:	55                   	push   %ebp
c002e466:	57                   	push   %edi
c002e467:	56                   	push   %esi
c002e468:	53                   	push   %ebx
c002e469:	83 ec 14             	sub    $0x14,%esp
c002e46c:	e8 14 06 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e471:	81 c3 43 ca 00 00    	add    $0xca43,%ebx
  const char *file_name = argv[1];
c002e477:	8b 44 24 28          	mov    0x28(%esp),%eax
c002e47b:	8b 78 04             	mov    0x4(%eax),%edi
  
  struct file *file;
  char *buffer;

  printf ("Printing '%s' to the console...\n", file_name);
c002e47e:	57                   	push   %edi
c002e47f:	8d 83 e0 73 ff ff    	lea    -0x8c20(%ebx),%eax
c002e485:	50                   	push   %eax
c002e486:	e8 65 90 ff ff       	call   c00274f0 <printf>
  file = filesys_open (file_name);
c002e48b:	89 3c 24             	mov    %edi,(%esp)
c002e48e:	e8 78 ec ff ff       	call   c002d10b <filesys_open>
  if (file == NULL)
c002e493:	83 c4 10             	add    $0x10,%esp
c002e496:	85 c0                	test   %eax,%eax
c002e498:	74 41                	je     c002e4db <fsutil_cat+0x76>
c002e49a:	89 c6                	mov    %eax,%esi
    PANIC ("%s: open failed", file_name);
  buffer = palloc_get_page (PAL_ASSERT);
c002e49c:	83 ec 0c             	sub    $0xc,%esp
c002e49f:	6a 01                	push   $0x1
c002e4a1:	e8 6c 56 ff ff       	call   c0023b12 <palloc_get_page>
c002e4a6:	89 c7                	mov    %eax,%edi
c002e4a8:	83 c4 10             	add    $0x10,%esp
  for (;;) 
    {
      off_t pos = file_tell (file);
c002e4ab:	83 ec 0c             	sub    $0xc,%esp
c002e4ae:	56                   	push   %esi
c002e4af:	e8 9e f2 ff ff       	call   c002d752 <file_tell>
c002e4b4:	89 c5                	mov    %eax,%ebp
      off_t n = file_read (file, buffer, PGSIZE);
c002e4b6:	83 c4 0c             	add    $0xc,%esp
c002e4b9:	68 00 10 00 00       	push   $0x1000
c002e4be:	57                   	push   %edi
c002e4bf:	56                   	push   %esi
c002e4c0:	e8 1c f0 ff ff       	call   c002d4e1 <file_read>
      if (n == 0)
c002e4c5:	83 c4 10             	add    $0x10,%esp
c002e4c8:	85 c0                	test   %eax,%eax
c002e4ca:	74 2f                	je     c002e4fb <fsutil_cat+0x96>
        break;

      hex_dump (pos, buffer, n, true); 
c002e4cc:	6a 01                	push   $0x1
c002e4ce:	50                   	push   %eax
c002e4cf:	57                   	push   %edi
c002e4d0:	55                   	push   %ebp
c002e4d1:	e8 58 99 ff ff       	call   c0027e2e <hex_dump>
    {
c002e4d6:	83 c4 10             	add    $0x10,%esp
c002e4d9:	eb d0                	jmp    c002e4ab <fsutil_cat+0x46>
    PANIC ("%s: open failed", file_name);
c002e4db:	83 ec 0c             	sub    $0xc,%esp
c002e4de:	57                   	push   %edi
c002e4df:	8d 83 16 73 ff ff    	lea    -0x8cea(%ebx),%eax
c002e4e5:	50                   	push   %eax
c002e4e6:	8d 83 80 4d ff ff    	lea    -0xb280(%ebx),%eax
c002e4ec:	50                   	push   %eax
c002e4ed:	6a 2c                	push   $0x2c
c002e4ef:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e4f5:	50                   	push   %eax
c002e4f6:	e8 8c ad ff ff       	call   c0029287 <debug_panic>
    }
  palloc_free_page (buffer);
c002e4fb:	83 ec 0c             	sub    $0xc,%esp
c002e4fe:	57                   	push   %edi
c002e4ff:	e8 7c 57 ff ff       	call   c0023c80 <palloc_free_page>
  file_close (file);
c002e504:	89 34 24             	mov    %esi,(%esp)
c002e507:	e8 42 f1 ff ff       	call   c002d64e <file_close>
}
c002e50c:	83 c4 1c             	add    $0x1c,%esp
c002e50f:	5b                   	pop    %ebx
c002e510:	5e                   	pop    %esi
c002e511:	5f                   	pop    %edi
c002e512:	5d                   	pop    %ebp
c002e513:	c3                   	ret    

c002e514 <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm (char **argv) 
{
c002e514:	56                   	push   %esi
c002e515:	53                   	push   %ebx
c002e516:	83 ec 0c             	sub    $0xc,%esp
c002e519:	e8 67 05 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e51e:	81 c3 96 c9 00 00    	add    $0xc996,%ebx
  const char *file_name = argv[1];
c002e524:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e528:	8b 70 04             	mov    0x4(%eax),%esi
  
  printf ("Deleting '%s'...\n", file_name);
c002e52b:	56                   	push   %esi
c002e52c:	8d 83 26 73 ff ff    	lea    -0x8cda(%ebx),%eax
c002e532:	50                   	push   %eax
c002e533:	e8 b8 8f ff ff       	call   c00274f0 <printf>
  if (!filesys_remove (file_name))
c002e538:	89 34 24             	mov    %esi,(%esp)
c002e53b:	e8 1e ec ff ff       	call   c002d15e <filesys_remove>
c002e540:	83 c4 10             	add    $0x10,%esp
c002e543:	84 c0                	test   %al,%al
c002e545:	74 06                	je     c002e54d <fsutil_rm+0x39>
    PANIC ("%s: delete failed\n", file_name);
}
c002e547:	83 c4 04             	add    $0x4,%esp
c002e54a:	5b                   	pop    %ebx
c002e54b:	5e                   	pop    %esi
c002e54c:	c3                   	ret    
    PANIC ("%s: delete failed\n", file_name);
c002e54d:	83 ec 0c             	sub    $0xc,%esp
c002e550:	56                   	push   %esi
c002e551:	8d 83 38 73 ff ff    	lea    -0x8cc8(%ebx),%eax
c002e557:	50                   	push   %eax
c002e558:	8d 83 74 4d ff ff    	lea    -0xb28c(%ebx),%eax
c002e55e:	50                   	push   %eax
c002e55f:	6a 43                	push   $0x43
c002e561:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e567:	50                   	push   %eax
c002e568:	e8 1a ad ff ff       	call   c0029287 <debug_panic>

c002e56d <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract (char **argv UNUSED) 
{
c002e56d:	55                   	push   %ebp
c002e56e:	57                   	push   %edi
c002e56f:	56                   	push   %esi
c002e570:	53                   	push   %ebx
c002e571:	83 ec 38             	sub    $0x38,%esp
c002e574:	e8 0c 05 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e579:	81 c3 3b c9 00 00    	add    $0xc93b,%ebx

  struct block *src;
  void *header, *data;

  /* Allocate buffers. */
  header = malloc (BLOCK_SECTOR_SIZE);
c002e57f:	68 00 02 00 00       	push   $0x200
c002e584:	e8 9e 59 ff ff       	call   c0023f27 <malloc>
c002e589:	89 c7                	mov    %eax,%edi
c002e58b:	89 44 24 14          	mov    %eax,0x14(%esp)
  data = malloc (BLOCK_SECTOR_SIZE);
c002e58f:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002e596:	e8 8c 59 ff ff       	call   c0023f27 <malloc>
c002e59b:	89 c5                	mov    %eax,%ebp
  if (header == NULL || data == NULL)
c002e59d:	83 c4 10             	add    $0x10,%esp
c002e5a0:	85 ff                	test   %edi,%edi
c002e5a2:	74 3d                	je     c002e5e1 <fsutil_extract+0x74>
c002e5a4:	85 c0                	test   %eax,%eax
c002e5a6:	74 39                	je     c002e5e1 <fsutil_extract+0x74>
    PANIC ("couldn't allocate buffers");

  /* Open source block device. */
  src = block_get_role (BLOCK_SCRATCH);
c002e5a8:	83 ec 0c             	sub    $0xc,%esp
c002e5ab:	6a 02                	push   $0x2
c002e5ad:	e8 f6 6b ff ff       	call   c00251a8 <block_get_role>
c002e5b2:	89 44 24 10          	mov    %eax,0x10(%esp)
  if (src == NULL)
c002e5b6:	83 c4 10             	add    $0x10,%esp
c002e5b9:	85 c0                	test   %eax,%eax
c002e5bb:	74 40                	je     c002e5fd <fsutil_extract+0x90>
    PANIC ("couldn't open scratch device");

  printf ("Extracting ustar archive from scratch device "
c002e5bd:	83 ec 0c             	sub    $0xc,%esp
c002e5c0:	8d 83 04 74 ff ff    	lea    -0x8bfc(%ebx),%eax
c002e5c6:	50                   	push   %eax
c002e5c7:	e8 94 cc ff ff       	call   c002b260 <puts>
c002e5cc:	83 c4 10             	add    $0x10,%esp
      enum ustar_type type;
      int size;

      /* Read and parse ustar header. */
      block_read (src, sector++, header);
      error = ustar_parse_header (header, &file_name, &type, &size);
c002e5cf:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002e5d3:	89 44 24 08          	mov    %eax,0x8(%esp)
c002e5d7:	8d 44 24 18          	lea    0x18(%esp),%eax
c002e5db:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e5df:	eb 78                	jmp    c002e659 <fsutil_extract+0xec>
    PANIC ("couldn't allocate buffers");
c002e5e1:	8d 83 4b 73 ff ff    	lea    -0x8cb5(%ebx),%eax
c002e5e7:	50                   	push   %eax
c002e5e8:	8d 83 64 4d ff ff    	lea    -0xb29c(%ebx),%eax
c002e5ee:	50                   	push   %eax
c002e5ef:	6a 54                	push   $0x54
c002e5f1:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e5f7:	50                   	push   %eax
c002e5f8:	e8 8a ac ff ff       	call   c0029287 <debug_panic>
    PANIC ("couldn't open scratch device");
c002e5fd:	8d 83 65 73 ff ff    	lea    -0x8c9b(%ebx),%eax
c002e603:	50                   	push   %eax
c002e604:	8d 83 64 4d ff ff    	lea    -0xb29c(%ebx),%eax
c002e60a:	50                   	push   %eax
c002e60b:	6a 59                	push   $0x59
c002e60d:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e613:	50                   	push   %eax
c002e614:	e8 6e ac ff ff       	call   c0029287 <debug_panic>
      if (error != NULL)
        PANIC ("bad ustar header in sector %"PRDSNu" (%s)", sector - 1, error);
c002e619:	83 ec 08             	sub    $0x8,%esp
c002e61c:	50                   	push   %eax
c002e61d:	8b 83 80 25 00 00    	mov    0x2580(%ebx),%eax
c002e623:	83 e8 01             	sub    $0x1,%eax
c002e626:	50                   	push   %eax
c002e627:	8d 83 48 74 ff ff    	lea    -0x8bb8(%ebx),%eax
c002e62d:	50                   	push   %eax
c002e62e:	8d 83 64 4d ff ff    	lea    -0xb29c(%ebx),%eax
c002e634:	50                   	push   %eax
c002e635:	6a 69                	push   $0x69
c002e637:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e63d:	50                   	push   %eax
c002e63e:	e8 44 ac ff ff       	call   c0029287 <debug_panic>
        {
          /* End of archive. */
          break;
        }
      else if (type == USTAR_DIRECTORY)
        printf ("ignoring directory %s\n", file_name);
c002e643:	83 ec 08             	sub    $0x8,%esp
c002e646:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e64a:	8d 83 82 73 ff ff    	lea    -0x8c7e(%ebx),%eax
c002e650:	50                   	push   %eax
c002e651:	e8 9a 8e ff ff       	call   c00274f0 <printf>
c002e656:	83 c4 10             	add    $0x10,%esp
      block_read (src, sector++, header);
c002e659:	8b 83 80 25 00 00    	mov    0x2580(%ebx),%eax
c002e65f:	8d 50 01             	lea    0x1(%eax),%edx
c002e662:	89 93 80 25 00 00    	mov    %edx,0x2580(%ebx)
c002e668:	83 ec 04             	sub    $0x4,%esp
c002e66b:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002e66f:	57                   	push   %edi
c002e670:	50                   	push   %eax
c002e671:	ff 74 24 0c          	pushl  0xc(%esp)
c002e675:	e8 ab 6c ff ff       	call   c0025325 <block_read>
      error = ustar_parse_header (header, &file_name, &type, &size);
c002e67a:	ff 74 24 18          	pushl  0x18(%esp)
c002e67e:	ff 74 24 20          	pushl  0x20(%esp)
c002e682:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002e686:	50                   	push   %eax
c002e687:	57                   	push   %edi
c002e688:	e8 61 a9 ff ff       	call   c0028fee <ustar_parse_header>
      if (error != NULL)
c002e68d:	83 c4 20             	add    $0x20,%esp
c002e690:	85 c0                	test   %eax,%eax
c002e692:	75 85                	jne    c002e619 <fsutil_extract+0xac>
      if (type == USTAR_EOF)
c002e694:	8b 44 24 18          	mov    0x18(%esp),%eax
c002e698:	83 f8 ff             	cmp    $0xffffffff,%eax
c002e69b:	0f 84 23 01 00 00    	je     c002e7c4 <fsutil_extract+0x257>
      else if (type == USTAR_DIRECTORY)
c002e6a1:	83 f8 35             	cmp    $0x35,%eax
c002e6a4:	74 9d                	je     c002e643 <fsutil_extract+0xd6>
      else if (type == USTAR_REGULAR)
c002e6a6:	83 f8 30             	cmp    $0x30,%eax
c002e6a9:	75 ae                	jne    c002e659 <fsutil_extract+0xec>
        {
          struct file *dst;

          printf ("Putting '%s' into the file system...\n", file_name);
c002e6ab:	83 ec 08             	sub    $0x8,%esp
c002e6ae:	ff 74 24 1c          	pushl  0x1c(%esp)
c002e6b2:	8d 83 6c 74 ff ff    	lea    -0x8b94(%ebx),%eax
c002e6b8:	50                   	push   %eax
c002e6b9:	e8 32 8e ff ff       	call   c00274f0 <printf>

          /* Create destination file. */
          if (!filesys_create (file_name, size))
c002e6be:	83 c4 08             	add    $0x8,%esp
c002e6c1:	ff 74 24 24          	pushl  0x24(%esp)
c002e6c5:	ff 74 24 20          	pushl  0x20(%esp)
c002e6c9:	e8 a1 e9 ff ff       	call   c002d06f <filesys_create>
c002e6ce:	83 c4 10             	add    $0x10,%esp
c002e6d1:	84 c0                	test   %al,%al
c002e6d3:	74 7f                	je     c002e754 <fsutil_extract+0x1e7>
            PANIC ("%s: create failed", file_name);
          dst = filesys_open (file_name);
c002e6d5:	83 ec 0c             	sub    $0xc,%esp
c002e6d8:	ff 74 24 20          	pushl  0x20(%esp)
c002e6dc:	e8 2a ea ff ff       	call   c002d10b <filesys_open>
c002e6e1:	89 c7                	mov    %eax,%edi
          if (dst == NULL)
c002e6e3:	83 c4 10             	add    $0x10,%esp
c002e6e6:	85 c0                	test   %eax,%eax
c002e6e8:	0f 84 89 00 00 00    	je     c002e777 <fsutil_extract+0x20a>
            PANIC ("%s: open failed", file_name);

          /* Do copy. */
          while (size > 0)
c002e6ee:	8b 74 24 1c          	mov    0x1c(%esp),%esi
c002e6f2:	85 f6                	test   %esi,%esi
c002e6f4:	7e 4d                	jle    c002e743 <fsutil_extract+0x1d6>
            {
              int chunk_size = (size > BLOCK_SECTOR_SIZE
c002e6f6:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c002e6fc:	b8 00 02 00 00       	mov    $0x200,%eax
c002e701:	0f 4f f0             	cmovg  %eax,%esi
                                ? BLOCK_SECTOR_SIZE
                                : size);
              block_read (src, sector++, data);
c002e704:	8b 83 80 25 00 00    	mov    0x2580(%ebx),%eax
c002e70a:	8d 50 01             	lea    0x1(%eax),%edx
c002e70d:	89 93 80 25 00 00    	mov    %edx,0x2580(%ebx)
c002e713:	83 ec 04             	sub    $0x4,%esp
c002e716:	55                   	push   %ebp
c002e717:	50                   	push   %eax
c002e718:	ff 74 24 0c          	pushl  0xc(%esp)
c002e71c:	e8 04 6c ff ff       	call   c0025325 <block_read>
              if (file_write (dst, data, chunk_size) != chunk_size)
c002e721:	83 c4 0c             	add    $0xc,%esp
c002e724:	56                   	push   %esi
c002e725:	55                   	push   %ebp
c002e726:	57                   	push   %edi
c002e727:	e8 0f ee ff ff       	call   c002d53b <file_write>
c002e72c:	83 c4 10             	add    $0x10,%esp
c002e72f:	39 f0                	cmp    %esi,%eax
c002e731:	75 67                	jne    c002e79a <fsutil_extract+0x22d>
                PANIC ("%s: write failed with %d bytes unwritten",
                       file_name, size);
              size -= chunk_size;
c002e733:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e737:	29 f0                	sub    %esi,%eax
c002e739:	89 c6                	mov    %eax,%esi
c002e73b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          while (size > 0)
c002e73f:	85 c0                	test   %eax,%eax
c002e741:	7f b3                	jg     c002e6f6 <fsutil_extract+0x189>
            }

          /* Finish up. */
          file_close (dst);
c002e743:	83 ec 0c             	sub    $0xc,%esp
c002e746:	57                   	push   %edi
c002e747:	e8 02 ef ff ff       	call   c002d64e <file_close>
c002e74c:	83 c4 10             	add    $0x10,%esp
    {
c002e74f:	e9 05 ff ff ff       	jmp    c002e659 <fsutil_extract+0xec>
            PANIC ("%s: create failed", file_name);
c002e754:	83 ec 0c             	sub    $0xc,%esp
c002e757:	ff 74 24 20          	pushl  0x20(%esp)
c002e75b:	8d 83 99 73 ff ff    	lea    -0x8c67(%ebx),%eax
c002e761:	50                   	push   %eax
c002e762:	8d 83 64 4d ff ff    	lea    -0xb29c(%ebx),%eax
c002e768:	50                   	push   %eax
c002e769:	6a 7a                	push   $0x7a
c002e76b:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e771:	50                   	push   %eax
c002e772:	e8 10 ab ff ff       	call   c0029287 <debug_panic>
            PANIC ("%s: open failed", file_name);
c002e777:	83 ec 0c             	sub    $0xc,%esp
c002e77a:	ff 74 24 20          	pushl  0x20(%esp)
c002e77e:	8d 83 16 73 ff ff    	lea    -0x8cea(%ebx),%eax
c002e784:	50                   	push   %eax
c002e785:	8d 83 64 4d ff ff    	lea    -0xb29c(%ebx),%eax
c002e78b:	50                   	push   %eax
c002e78c:	6a 7d                	push   $0x7d
c002e78e:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e794:	50                   	push   %eax
c002e795:	e8 ed aa ff ff       	call   c0029287 <debug_panic>
                PANIC ("%s: write failed with %d bytes unwritten",
c002e79a:	83 ec 08             	sub    $0x8,%esp
c002e79d:	ff 74 24 24          	pushl  0x24(%esp)
c002e7a1:	ff 74 24 20          	pushl  0x20(%esp)
c002e7a5:	8d 83 94 74 ff ff    	lea    -0x8b6c(%ebx),%eax
c002e7ab:	50                   	push   %eax
c002e7ac:	8d 83 64 4d ff ff    	lea    -0xb29c(%ebx),%eax
c002e7b2:	50                   	push   %eax
c002e7b3:	68 88 00 00 00       	push   $0x88
c002e7b8:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e7be:	50                   	push   %eax
c002e7bf:	e8 c3 aa ff ff       	call   c0029287 <debug_panic>

  /* Erase the ustar header from the start of the block device,
     so that the extraction operation is idempotent.  We erase
     two blocks because two blocks of zeros are the ustar
     end-of-archive marker. */
  printf ("Erasing ustar archive...\n");
c002e7c4:	83 ec 0c             	sub    $0xc,%esp
c002e7c7:	8d 83 ab 73 ff ff    	lea    -0x8c55(%ebx),%eax
c002e7cd:	50                   	push   %eax
c002e7ce:	e8 8d ca ff ff       	call   c002b260 <puts>
  memset (header, 0, BLOCK_SECTOR_SIZE);
c002e7d3:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e7d8:	b8 00 00 00 00       	mov    $0x0,%eax
c002e7dd:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002e7e1:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write (src, 0, header);
c002e7e3:	83 c4 0c             	add    $0xc,%esp
c002e7e6:	8b 7c 24 08          	mov    0x8(%esp),%edi
c002e7ea:	57                   	push   %edi
c002e7eb:	6a 00                	push   $0x0
c002e7ed:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002e7f1:	56                   	push   %esi
c002e7f2:	e8 62 6b ff ff       	call   c0025359 <block_write>
  block_write (src, 1, header);
c002e7f7:	83 c4 0c             	add    $0xc,%esp
c002e7fa:	57                   	push   %edi
c002e7fb:	6a 01                	push   $0x1
c002e7fd:	56                   	push   %esi
c002e7fe:	e8 56 6b ff ff       	call   c0025359 <block_write>

  free (data);
c002e803:	89 2c 24             	mov    %ebp,(%esp)
c002e806:	e8 d2 58 ff ff       	call   c00240dd <free>
  free (header);
c002e80b:	89 3c 24             	mov    %edi,(%esp)
c002e80e:	e8 ca 58 ff ff       	call   c00240dd <free>
}
c002e813:	83 c4 3c             	add    $0x3c,%esp
c002e816:	5b                   	pop    %ebx
c002e817:	5e                   	pop    %esi
c002e818:	5f                   	pop    %edi
c002e819:	5d                   	pop    %ebp
c002e81a:	c3                   	ret    

c002e81b <fsutil_append>:
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append (char **argv)
{
c002e81b:	55                   	push   %ebp
c002e81c:	57                   	push   %edi
c002e81d:	56                   	push   %esi
c002e81e:	53                   	push   %ebx
c002e81f:	83 ec 24             	sub    $0x24,%esp
c002e822:	e8 5e 02 00 00       	call   c002ea85 <__x86.get_pc_thunk.bx>
c002e827:	81 c3 8d c6 00 00    	add    $0xc68d,%ebx
  static block_sector_t sector = 0;

  const char *file_name = argv[1];
c002e82d:	8b 44 24 38          	mov    0x38(%esp),%eax
c002e831:	8b 40 04             	mov    0x4(%eax),%eax
c002e834:	89 44 24 14          	mov    %eax,0x14(%esp)
  void *buffer;
  struct file *src;
  struct block *dst;
  off_t size;

  printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002e838:	50                   	push   %eax
c002e839:	8d 83 c0 74 ff ff    	lea    -0x8b40(%ebx),%eax
c002e83f:	50                   	push   %eax
c002e840:	e8 ab 8c ff ff       	call   c00274f0 <printf>

  /* Allocate buffer. */
  buffer = malloc (BLOCK_SECTOR_SIZE);
c002e845:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c002e84c:	e8 d6 56 ff ff       	call   c0023f27 <malloc>
  if (buffer == NULL)
c002e851:	83 c4 10             	add    $0x10,%esp
c002e854:	85 c0                	test   %eax,%eax
c002e856:	0f 84 52 01 00 00    	je     c002e9ae <fsutil_append+0x193>
c002e85c:	89 c5                	mov    %eax,%ebp
    PANIC ("couldn't allocate buffer");

  /* Open source file. */
  src = filesys_open (file_name);
c002e85e:	83 ec 0c             	sub    $0xc,%esp
c002e861:	ff 74 24 18          	pushl  0x18(%esp)
c002e865:	e8 a1 e8 ff ff       	call   c002d10b <filesys_open>
c002e86a:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (src == NULL)
c002e86e:	83 c4 10             	add    $0x10,%esp
c002e871:	85 c0                	test   %eax,%eax
c002e873:	0f 84 54 01 00 00    	je     c002e9cd <fsutil_append+0x1b2>
    PANIC ("%s: open failed", file_name);
  size = file_length (src);
c002e879:	83 ec 0c             	sub    $0xc,%esp
c002e87c:	ff 74 24 14          	pushl  0x14(%esp)
c002e880:	e8 05 ee ff ff       	call   c002d68a <file_length>
c002e885:	89 c7                	mov    %eax,%edi

  /* Open target block device. */
  dst = block_get_role (BLOCK_SCRATCH);
c002e887:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c002e88e:	e8 15 69 ff ff       	call   c00251a8 <block_get_role>
c002e893:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (dst == NULL)
c002e897:	83 c4 10             	add    $0x10,%esp
c002e89a:	85 c0                	test   %eax,%eax
c002e89c:	0f 84 51 01 00 00    	je     c002e9f3 <fsutil_append+0x1d8>
    PANIC ("couldn't open scratch device");
  
  /* Write ustar header to first sector. */
  if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
c002e8a2:	55                   	push   %ebp
c002e8a3:	57                   	push   %edi
c002e8a4:	6a 30                	push   $0x30
c002e8a6:	ff 74 24 18          	pushl  0x18(%esp)
c002e8aa:	e8 4c a5 ff ff       	call   c0028dfb <ustar_make_header>
c002e8af:	83 c4 10             	add    $0x10,%esp
c002e8b2:	84 c0                	test   %al,%al
c002e8b4:	0f 84 58 01 00 00    	je     c002ea12 <fsutil_append+0x1f7>
    PANIC ("%s: name too long for ustar format", file_name);
  block_write (dst, sector++, buffer);
c002e8ba:	8b 83 7c 25 00 00    	mov    0x257c(%ebx),%eax
c002e8c0:	8d 50 01             	lea    0x1(%eax),%edx
c002e8c3:	89 93 7c 25 00 00    	mov    %edx,0x257c(%ebx)
c002e8c9:	83 ec 04             	sub    $0x4,%esp
c002e8cc:	55                   	push   %ebp
c002e8cd:	50                   	push   %eax
c002e8ce:	ff 74 24 10          	pushl  0x10(%esp)
c002e8d2:	e8 82 6a ff ff       	call   c0025359 <block_write>

  /* Do copy. */
  while (size > 0) 
c002e8d7:	83 c4 10             	add    $0x10,%esp
c002e8da:	85 ff                	test   %edi,%edi
c002e8dc:	7e 7f                	jle    c002e95d <fsutil_append+0x142>
    {
      int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002e8de:	81 ff 00 02 00 00    	cmp    $0x200,%edi
c002e8e4:	be 00 02 00 00       	mov    $0x200,%esi
c002e8e9:	0f 4e f7             	cmovle %edi,%esi
      if (sector >= block_size (dst))
c002e8ec:	83 ec 0c             	sub    $0xc,%esp
c002e8ef:	ff 74 24 10          	pushl  0x10(%esp)
c002e8f3:	e8 cf 6a ff ff       	call   c00253c7 <block_size>
c002e8f8:	83 c4 10             	add    $0x10,%esp
c002e8fb:	3b 83 7c 25 00 00    	cmp    0x257c(%ebx),%eax
c002e901:	0f 86 31 01 00 00    	jbe    c002ea38 <fsutil_append+0x21d>
        PANIC ("%s: out of space on scratch device", file_name);
      if (file_read (src, buffer, chunk_size) != chunk_size)
c002e907:	83 ec 04             	sub    $0x4,%esp
c002e90a:	56                   	push   %esi
c002e90b:	55                   	push   %ebp
c002e90c:	ff 74 24 14          	pushl  0x14(%esp)
c002e910:	e8 cc eb ff ff       	call   c002d4e1 <file_read>
c002e915:	83 c4 10             	add    $0x10,%esp
c002e918:	39 f0                	cmp    %esi,%eax
c002e91a:	0f 85 3e 01 00 00    	jne    c002ea5e <fsutil_append+0x243>
        PANIC ("%s: read failed with %"PROTd" bytes unread", file_name, size);
      memset (buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002e920:	ba 00 02 00 00       	mov    $0x200,%edx
c002e925:	29 f2                	sub    %esi,%edx
c002e927:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
c002e92b:	83 ec 04             	sub    $0x4,%esp
c002e92e:	52                   	push   %edx
c002e92f:	6a 00                	push   $0x0
c002e931:	50                   	push   %eax
c002e932:	e8 cf 9e ff ff       	call   c0028806 <memset>
      block_write (dst, sector++, buffer);
c002e937:	8b 83 7c 25 00 00    	mov    0x257c(%ebx),%eax
c002e93d:	8d 50 01             	lea    0x1(%eax),%edx
c002e940:	89 93 7c 25 00 00    	mov    %edx,0x257c(%ebx)
c002e946:	83 c4 0c             	add    $0xc,%esp
c002e949:	55                   	push   %ebp
c002e94a:	50                   	push   %eax
c002e94b:	ff 74 24 10          	pushl  0x10(%esp)
c002e94f:	e8 05 6a ff ff       	call   c0025359 <block_write>
      size -= chunk_size;
c002e954:	29 f7                	sub    %esi,%edi
  while (size > 0) 
c002e956:	83 c4 10             	add    $0x10,%esp
c002e959:	85 ff                	test   %edi,%edi
c002e95b:	7f 81                	jg     c002e8de <fsutil_append+0xc3>
    }

  /* Write ustar end-of-archive marker, which is two consecutive
     sectors full of zeros.  Don't advance our position past
     them, though, in case we have more files to append. */
  memset (buffer, 0, BLOCK_SECTOR_SIZE);
c002e95d:	b9 80 00 00 00       	mov    $0x80,%ecx
c002e962:	b8 00 00 00 00       	mov    $0x0,%eax
c002e967:	89 ef                	mov    %ebp,%edi
c002e969:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write (dst, sector, buffer);
c002e96b:	83 ec 04             	sub    $0x4,%esp
c002e96e:	55                   	push   %ebp
c002e96f:	ff b3 7c 25 00 00    	pushl  0x257c(%ebx)
c002e975:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002e979:	57                   	push   %edi
c002e97a:	e8 da 69 ff ff       	call   c0025359 <block_write>
  block_write (dst, sector, buffer + 1);
c002e97f:	83 c4 0c             	add    $0xc,%esp
c002e982:	8d 45 01             	lea    0x1(%ebp),%eax
c002e985:	50                   	push   %eax
c002e986:	ff b3 7c 25 00 00    	pushl  0x257c(%ebx)
c002e98c:	57                   	push   %edi
c002e98d:	e8 c7 69 ff ff       	call   c0025359 <block_write>

  /* Finish up. */
  file_close (src);
c002e992:	83 c4 04             	add    $0x4,%esp
c002e995:	ff 74 24 14          	pushl  0x14(%esp)
c002e999:	e8 b0 ec ff ff       	call   c002d64e <file_close>
  free (buffer);
c002e99e:	89 2c 24             	mov    %ebp,(%esp)
c002e9a1:	e8 37 57 ff ff       	call   c00240dd <free>
}
c002e9a6:	83 c4 2c             	add    $0x2c,%esp
c002e9a9:	5b                   	pop    %ebx
c002e9aa:	5e                   	pop    %esi
c002e9ab:	5f                   	pop    %edi
c002e9ac:	5d                   	pop    %ebp
c002e9ad:	c3                   	ret    
    PANIC ("couldn't allocate buffer");
c002e9ae:	8d 83 c4 73 ff ff    	lea    -0x8c3c(%ebx),%eax
c002e9b4:	50                   	push   %eax
c002e9b5:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c002e9bb:	50                   	push   %eax
c002e9bc:	68 b6 00 00 00       	push   $0xb6
c002e9c1:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e9c7:	50                   	push   %eax
c002e9c8:	e8 ba a8 ff ff       	call   c0029287 <debug_panic>
    PANIC ("%s: open failed", file_name);
c002e9cd:	83 ec 0c             	sub    $0xc,%esp
c002e9d0:	ff 74 24 18          	pushl  0x18(%esp)
c002e9d4:	8d 83 16 73 ff ff    	lea    -0x8cea(%ebx),%eax
c002e9da:	50                   	push   %eax
c002e9db:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c002e9e1:	50                   	push   %eax
c002e9e2:	68 bb 00 00 00       	push   $0xbb
c002e9e7:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002e9ed:	50                   	push   %eax
c002e9ee:	e8 94 a8 ff ff       	call   c0029287 <debug_panic>
    PANIC ("couldn't open scratch device");
c002e9f3:	8d 83 65 73 ff ff    	lea    -0x8c9b(%ebx),%eax
c002e9f9:	50                   	push   %eax
c002e9fa:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c002ea00:	50                   	push   %eax
c002ea01:	68 c1 00 00 00       	push   $0xc1
c002ea06:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002ea0c:	50                   	push   %eax
c002ea0d:	e8 75 a8 ff ff       	call   c0029287 <debug_panic>
    PANIC ("%s: name too long for ustar format", file_name);
c002ea12:	83 ec 0c             	sub    $0xc,%esp
c002ea15:	ff 74 24 18          	pushl  0x18(%esp)
c002ea19:	8d 83 f8 74 ff ff    	lea    -0x8b08(%ebx),%eax
c002ea1f:	50                   	push   %eax
c002ea20:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c002ea26:	50                   	push   %eax
c002ea27:	68 c5 00 00 00       	push   $0xc5
c002ea2c:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002ea32:	50                   	push   %eax
c002ea33:	e8 4f a8 ff ff       	call   c0029287 <debug_panic>
        PANIC ("%s: out of space on scratch device", file_name);
c002ea38:	83 ec 0c             	sub    $0xc,%esp
c002ea3b:	ff 74 24 18          	pushl  0x18(%esp)
c002ea3f:	8d 83 1c 75 ff ff    	lea    -0x8ae4(%ebx),%eax
c002ea45:	50                   	push   %eax
c002ea46:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c002ea4c:	50                   	push   %eax
c002ea4d:	68 cd 00 00 00       	push   $0xcd
c002ea52:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002ea58:	50                   	push   %eax
c002ea59:	e8 29 a8 ff ff       	call   c0029287 <debug_panic>
        PANIC ("%s: read failed with %"PROTd" bytes unread", file_name, size);
c002ea5e:	83 ec 08             	sub    $0x8,%esp
c002ea61:	57                   	push   %edi
c002ea62:	ff 74 24 18          	pushl  0x18(%esp)
c002ea66:	8d 83 40 75 ff ff    	lea    -0x8ac0(%ebx),%eax
c002ea6c:	50                   	push   %eax
c002ea6d:	8d 83 54 4d ff ff    	lea    -0xb2ac(%ebx),%eax
c002ea73:	50                   	push   %eax
c002ea74:	68 cf 00 00 00       	push   $0xcf
c002ea79:	8d 83 ef 72 ff ff    	lea    -0x8d11(%ebx),%eax
c002ea7f:	50                   	push   %eax
c002ea80:	e8 02 a8 ff ff       	call   c0029287 <debug_panic>

Disassembly of section .text.__x86.get_pc_thunk.bx:

c002ea85 <__x86.get_pc_thunk.bx>:
c002ea85:	8b 1c 24             	mov    (%esp),%ebx
c002ea88:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c002ea89 <__x86.get_pc_thunk.ax>:
c002ea89:	8b 04 24             	mov    (%esp),%eax
c002ea8c:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c002ea8d <__x86.get_pc_thunk.di>:
c002ea8d:	8b 3c 24             	mov    (%esp),%edi
c002ea90:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.si:

c002ea91 <__x86.get_pc_thunk.si>:
c002ea91:	8b 34 24             	mov    (%esp),%esi
c002ea94:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c002ea95 <__x86.get_pc_thunk.cx>:
c002ea95:	8b 0c 24             	mov    (%esp),%ecx
c002ea98:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c002ea99 <__x86.get_pc_thunk.dx>:
c002ea99:	8b 14 24             	mov    (%esp),%edx
c002ea9c:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bp:

c002ea9d <__x86.get_pc_thunk.bp>:
c002ea9d:	8b 2c 24             	mov    (%esp),%ebp
c002eaa0:	c3                   	ret    
